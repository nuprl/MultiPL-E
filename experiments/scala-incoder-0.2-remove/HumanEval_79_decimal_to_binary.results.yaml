language: scala
name: HumanEval_79_decimal_to_binary
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        binary.dropRight(binary.length-1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpprkwk47c.scala:15)\n\tat Problem.main(tmpprkwk47c.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009420
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(binary.length - db.length)\
    \ + db + binary.substring(0, binary.length - db.length)\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmp1bv2p88_.scala:13)\n\
    \tat Problem$.main(tmp1bv2p88_.scala:17)\n\tat Problem.main(tmp1bv2p88_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        binary.drop(binary.length\
    \ - 2)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdoe566in.scala:15)\n\tat Problem.main(tmpdoe566in.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        binary.substring(0,\
    \ binary.length-1)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpc1hn9wso.scala:15)\n\tat Problem.main(tmpc1hn9wso.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n   \
    \     val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        binary.dropRight(binary.length\
    \ + 2)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwtn1uir0.scala:15)\n\tat Problem.main(tmpwtn1uir0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\".toBinaryString\n        val result = binary.dropRight(binary.length\
    \ + 2)\n        result + db + result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmhin5cr5.scala:12:22 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mdb\e[0m = \e[31m\"db\"\e\
    [0m.toBinaryString\n\e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                 value toBinaryString is not a member of String\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009420
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(binary.length - db.length,\
    \ binary.length) + db\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat Problem$.decimalToBinary(tmplvfmno92.scala:13)\n\tat Problem$.main(tmplvfmno92.scala:17)\n\
    \tat Problem.main(tmplvfmno92.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n   \
    \     val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(binary.length - db.length)\
    \ + db + binary.substring(0, binary.length - db.length)\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmp1bv2p88_.scala:13)\n\
    \tat Problem$.main(tmp1bv2p88_.scala:17)\n\tat Problem.main(tmp1bv2p88_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ extraChars = binary.substring(binary.length - 2, binary.length)\n        val\
    \ extraCharsReversed = extraChars.reverse\n        val extraCharsReversedString\
    \ = extraCharsReversed.mkString\n        val extraCharsReversedStringLength =\
    \ extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmexn8xs8.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mextraCharsReversedStringLength\e\
    [0m = extraCharsReversedString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextraCharsReversedStringLength is already defined as \e[33mvalue\e\
    [0m \e[35mextraCharsReversedStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmexn8xs8.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mextraCharsReversedStringLength\e\
    [0m = extraCharsReversedString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextraCharsReversedStringLength is already defined as \e[33mvalue\e\
    [0m \e[35mextraCharsReversedStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmexn8xs8.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mextraCharsReversedStringLength\e\
    [0m = extraCharsReversedString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextraCharsReversedStringLength is already defined as \e[33mvalue\e\
    [0m \e[35mextraCharsReversedStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmexn8xs8.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mextraCharsReversedStringLength\e\
    [0m = extraCharsReversedString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextraCharsReversedStringLength is already defined as \e[33mvalue\e\
    [0m \e[35mextraCharsReversedStr"
  stdout: ''
  timestamp: 1660009421
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n   \
    \     val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        binary.substring(binary.length\
    \ - 2) + \"db\"\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpj6rhs_yh.scala:12)\n\
    \tat Problem$.main(tmpj6rhs_yh.scala:15)\n\tat Problem.main(tmpj6rhs_yh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009420
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n   \
    \     val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.dropRight(binary.length) + db + binary.drop(binary.length)\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3qkyxeo5.scala:17)\n\tat Problem.main(tmp3qkyxeo5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        binary.drop(1).dropRight(1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzhchc_qz.scala:15)\n\tat Problem.main(tmpzhchc_qz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n   \
    \     val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.dropRight(binary.length - db.length)\
    \ + db + binary.take(binary.length - db.length)\n        return result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6cikq_05.scala:17)\n\tat Problem.main(tmp6cikq_05.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(binary.length - 3)\n    \
    \    result + db + binary.substring(0, binary.length - 3)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -2, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmp_dacjrk2.scala:13)\n\
    \tat Problem$.main(tmp_dacjrk2.scala:17)\n\tat Problem.main(tmp_dacjrk2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(binary.length - 3)\n    \
    \    result + db + binary.substring(0, binary.length - 3)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -2, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmp_dacjrk2.scala:13)\n\
    \tat Problem$.main(tmp_dacjrk2.scala:17)\n\tat Problem.main(tmp_dacjrk2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(0,binary.length-1)\n    \
    \    result + db + binary.substring(binary.length-1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa06x9obf.scala:17)\n\tat Problem.main(tmpa06x9obf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ extraChars = binary.substring(binary.length - 2, binary.length)\n        val\
    \ extraCharsReversed = extraChars.reverse\n        val extraCharsReversedString\
    \ = extraCharsReversed.mkString\n        val extraCharsReversedStringLength =\
    \ extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmexn8xs8.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mextraCharsReversedStringLength\e\
    [0m = extraCharsReversedString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextraCharsReversedStringLength is already defined as \e[33mvalue\e\
    [0m \e[35mextraCharsReversedStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmexn8xs8.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mextraCharsReversedStringLength\e\
    [0m = extraCharsReversedString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextraCharsReversedStringLength is already defined as \e[33mvalue\e\
    [0m \e[35mextraCharsReversedStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmexn8xs8.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mextraCharsReversedStringLength\e\
    [0m = extraCharsReversedString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextraCharsReversedStringLength is already defined as \e[33mvalue\e\
    [0m \e[35mextraCharsReversedStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmexn8xs8.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mextraCharsReversedStringLength\e\
    [0m = extraCharsReversedString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextraCharsReversedStringLength is already defined as \e[33mvalue\e\
    [0m \e[35mextraCharsReversedStr"
  stdout: ''
  timestamp: 1660009421
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n   \
    \     val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(0,binary.length-1)\n    \
    \    result + db + binary.substring(binary.length-1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa06x9obf.scala:17)\n\tat Problem.main(tmpa06x9obf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        var binary = \"\"\n        var remainder = decimal\n\
    \        while(decimal != 0) {\n            binary += remainder % 2\n        \
    \    remainder = remainder / 2\n        }\n        binary += \"db\"\n        binary\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_y3svybq.scala:21)\n\tat Problem.main(tmp_y3svybq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009420
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpiofg6x01.scala:58:4 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpiofg6x01.scala:12:12 ---------------------------\e[0m\e[0m\n\e[31m12\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpiofg6x01.scala:13:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpiofg6x01.scala:14:12 ---------------------------\e[0m\e[0m\n\e[31m14\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpiofg6x01.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpiofg6x01.scala:16:12 ---------------------------\e[0"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        binary.dropRight(binary.length + db.length)\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpllgcqr65.scala:16)\n\tat Problem.main(tmpllgcqr65.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(binary.length - db.length)\
    \ + db\n        return result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpjrqc7pst.scala:13)\n\
    \tat Problem$.main(tmpjrqc7pst.scala:17)\n\tat Problem.main(tmpjrqc7pst.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ extraChars = if (binary == decimal.toBinaryString) \"\" else binary\n      \
    \  val extraCharsLength = extraChars.length\n        val binaryLength = binary.length\n\
    \        val binaryStringLength = binaryLength + extraCharsLength\n        val\
    \ binaryString = new Array[Char](binaryStringLength)\n        val extraCharsArray\
    \ = new Array[Char](extraCharsLength)\n        val extraCharsArrayIndex = 0\n\
    \        val binaryArrayIndex = 0\n        val binaryStringIndex = 0\n       \
    \ while (binaryArrayIndex < binaryLength) {\n            binaryString(binaryStringIndex)\
    \ = binary(binaryArrayIndex)\n            extraCharsArray(extraCharsArrayIndex)\
    \ = extraChars(extraCharsArrayIndex)\n            extraCharsArrayIndex += 1\n\
    \            binaryArrayIndex += 1\n            binaryStringIndex += 1\n     \
    \   }\n        val binaryStringBuilder = new StringBuilder\n        binaryStringBuilder.append(extraCharsArray(0))\n\
    \        binaryStringBuilder.append(binaryString(0))\n        binaryStringBuilder.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpp6932ekk.scala:24:33 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            extraCharsArrayIndex += \e[31m1\e[0m\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m value\
    \ += is not a member of Int - did you mean extraCharsArrayIndex.!=?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpp6932ekk.scala:25:29 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            binaryArrayIndex += \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     value +=\
    \ is not a member of Int - did you mean binaryArrayIndex.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpp6932ekk.scala:26:30 ------------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m            binaryStringIndex += \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value += is\
    \ not a member of Int - did you mean binaryStringIndex.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(binary.length - db.length)\
    \ + db + binary.substring(0, binary.length - db.length)\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmp1bv2p88_.scala:13)\n\
    \tat Problem$.main(tmp1bv2p88_.scala:17)\n\tat Problem.main(tmp1bv2p88_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n   \
    \     val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        var binary = \"\"\n        var remainder = decimal\n\
    \        while(decimal != 0){\n            binary += (decimal % 2).toChar\n  \
    \          remainder = decimal / 2\n        }\n        binary += remainder.toChar\n\
    \        binary += \"db\"\n        binary\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmply2cxk62.scala:22)\n\tat Problem.main(tmply2cxk62.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009420
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.replace(\"0\",\"db\")\n        val binary = binary.replace(\"\
    1\",\"0\")\n        binary.substring(2)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl1khcbzl.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.replace(\e\
    [31m\"0\"\e[0m,\e[31m\"db\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl1khcbzl.scala:13:12 ---------------------------\e[0m\e[0m\n\e\
    [31m13 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.replace(\e[31m\"\
    1\"\e[0m,\e[31m\"0\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n2 errors found\n"
  stdout: ''
  timestamp: 1660009418
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(binary.length - db.length,\
    \ binary.length) + db\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat Problem$.decimalToBinary(tmplvfmno92.scala:13)\n\tat Problem$.main(tmplvfmno92.scala:17)\n\
    \tat Problem.main(tmplvfmno92.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(binary.length - db.length)\
    \ + db + binary.substring(0, binary.length - db.length)\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmp1bv2p88_.scala:13)\n\
    \tat Problem$.main(tmp1bv2p88_.scala:17)\n\tat Problem.main(tmp1bv2p88_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.dropRight(binary.length) + db + binary.take(binary.length)\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb_4itmvo.scala:17)\n\tat Problem.main(tmpb_4itmvo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(binary.length - db.length)\
    \ + db\n        return result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpjrqc7pst.scala:13)\n\
    \tat Problem$.main(tmpjrqc7pst.scala:17)\n\tat Problem.main(tmpjrqc7pst.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.dropRight(binary.length - db.length)\
    \ + db + binary.take(binary.length - db.length)\n        return result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6cikq_05.scala:17)\n\tat Problem.main(tmp6cikq_05.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ extraChars = binary.substring(binary.length - 2)\n        val extraCharsLength\
    \ = extraChars.length\n        val extraCharsString = \"db\" + extraChars\n  \
    \      val binaryLength = binary.length\n        val binaryString = \"0\" * (binaryLength\
    \ - extraCharsLength) + binary + extraCharsString\n        binaryString.substring(0,binaryString.length\
    \ - 2)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpwgnrpq58.scala:12)\n\
    \tat Problem$.main(tmpwgnrpq58.scala:20)\n\tat Problem.main(tmpwgnrpq58.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009429
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        binary.substring(0,1)\
    \ + binary.substring(1,binary.length-1) + \"db\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin 1, end 0, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat Problem$.decimalToBinary(tmpnt_27dug.scala:12)\n\tat Problem$.main(tmpnt_27dug.scala:15)\n\
    \tat Problem.main(tmpnt_27dug.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009430
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ extraChars = if (decimal == 0) \"db\" else \"\"\n        binary.dropRight(binary.length\
    \ - extraChars.length) + extraChars\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpd_on7z8z.scala:16)\n\tat Problem.main(tmpd_on7z8z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009430
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        binary.dropRight(binary.length - db.length) + db + binary.drop(binary.length\
    \ - db.length)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpt01styv6.scala:16)\n\tat Problem.main(tmpt01styv6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009430
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(binary.length - db.length)\
    \ + db\n        return result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpjrqc7pst.scala:13)\n\
    \tat Problem$.main(tmpjrqc7pst.scala:17)\n\tat Problem.main(tmpjrqc7pst.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        binary.substring(0,binary.length-1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzb3s9grr.scala:16)\n\tat Problem.main(tmpzb3s9grr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009430
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        binary.substring(binary.length\
    \ - 2) + \"db\"\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpj6rhs_yh.scala:12)\n\
    \tat Problem$.main(tmpj6rhs_yh.scala:15)\n\tat Problem.main(tmpj6rhs_yh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009420
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(binary.length - db.length)\
    \ + db + binary.substring(0, binary.length - db.length)\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmp1bv2p88_.scala:13)\n\
    \tat Problem$.main(tmp1bv2p88_.scala:17)\n\tat Problem.main(tmp1bv2p88_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ bin = binary.substring(binary.length - 2)\n        val binary = bin.substring(0,\
    \ bin.length - 1)\n        binary.toCharArray\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpp3zsx_0l.scala:13:12 ---------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = bin.substring(\e\
    [31m0\e[0m, bin.length - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpp3zsx_0l.scala:14:8 ---------------------\e[0m\e[0m\n\
    \e[31m14 |\e[0m        binary.toCharArray\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Array[Char]\n\e[31m   |\e[0m        Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009430
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.reverse\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.reverse\n        val binary = binary.dropRight(1)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpq4emlc_k.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpq4emlc_k.scala:13:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpq4emlc_k.scala:14:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpq4emlc_k.scala:15:12 ---------------------------\e[0m\e[0m\n\e\
    [31m15 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpq4emlc_k.scala:16:12 ---------------------------\e[0m\e[0m\n\e[31m16\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded metho"
  stdout: ''
  timestamp: 1660009430
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.dropRight(binary.length - db.length)\
    \ + db + binary.drop(binary.length - db.length)\n        return result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpezs5ez4i.scala:17)\n\tat Problem.main(tmpezs5ez4i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009431
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.dropRight(binary.length - 2)\n    \
    \    result + db + binary.dropLeft(binary.length - 2)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqps6_kuo.scala:14:29 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        result + db + binary.dropLeft(binary.length -\
    \ \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      value dropLeft is not a member of String\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009430
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        binary.dropRight(binary.length + db.length)\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpllgcqr65.scala:16)\n\tat Problem.main(tmpllgcqr65.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ extraChars = if (decimal == 0) \"db\" else \"\"\n        binary.dropRight(binary.length)\
    \ + extraChars\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbz1d0pch.scala:16)\n\tat Problem.main(tmpbz1d0pch.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009430
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(binary.length - 2)\n    \
    \    result + db + binary.substring(0, binary.length - 2)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpl0wnsjlj.scala:13)\n\
    \tat Problem$.main(tmpl0wnsjlj.scala:17)\n\tat Problem.main(tmpl0wnsjlj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009430
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ bin = binary.substring(binary.length - 2)\n        val binary = bin.substring(0,\
    \ bin.length - 1)\n        val binary = binary.concat(\"db\")\n        binary.toUpperCase\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjzsigvcv.scala:13:12 ---------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = bin.substring(\e\
    [31m0\e[0m, bin.length - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpjzsigvcv.scala:14:12 ---------------------------\e[0m\e[0m\n\e\
    [31m14 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.concat(\e[31m\"\
    db\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n2 errors found\n"
  stdout: ''
  timestamp: 1660009427
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n   \
    \     val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        binary.substring(0,binary.length-1)+db+binary.substring(binary.length-1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnrgyzc1y.scala:16)\n\tat Problem.main(tmpnrgyzc1y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009430
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(binary.length - db.length,\
    \ binary.length)\n        result + db\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat Problem$.decimalToBinary(tmpn7kgvxio.scala:13)\n\tat Problem$.main(tmpn7kgvxio.scala:17)\n\
    \tat Problem.main(tmpn7kgvxio.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009430
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        binary.substring(0,binary.length-1)+db+binary.substring(binary.length-1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnrgyzc1y.scala:16)\n\tat Problem.main(tmpnrgyzc1y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009430
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        var binary = \"\"\n        var remainder = decimal\n\
    \        while(decimal != 0) {\n            binary += remainder % 2\n        \
    \    remainder = remainder / 2\n        }\n        binary += \"db\"\n        binary\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_y3svybq.scala:21)\n\tat Problem.main(tmp_y3svybq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009420
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(binary.length - db.length)\
    \ + db\n        return result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpjrqc7pst.scala:13)\n\
    \tat Problem$.main(tmpjrqc7pst.scala:17)\n\tat Problem.main(tmpjrqc7pst.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        binary.substring(0,binary.length-1)+db+binary.substring(binary.length-1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnrgyzc1y.scala:16)\n\tat Problem.main(tmpnrgyzc1y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009430
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.dropRight(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpch7roa0l.scala:50:33 ---------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.drop(\n\
    \e[31m\e[31m   |\e[0m                                 ^\e[0m\n\e[31m   |\e[0m\
    \                                 expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpch7roa0l.scala:12:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpch7roa0l.scala:13:12 ---------------------------\e[0m\e[0m\n\e[31m13\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.drop(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpch7roa0l.scala:14:12 ---------------------------\e[0m\e[0m\n\e\
    [31m14 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.drop(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpch7roa0l.scala:15:12 ---------------------------\e[0m\e[0m\n\e\
    [31m15 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.drop(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is "
  stdout: ''
  timestamp: 1660009430
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ bin = binary.substring(binary.length - 2)\n        val binary = bin.substring(0,\
    \ bin.length - 1)\n        val binary = binary.concat(\"db\")\n        binary\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp16ui0hyo.scala:13:12 ---------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = bin.substring(\e\
    [31m0\e[0m, bin.length - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp16ui0hyo.scala:14:12 ---------------------------\e[0m\e[0m\n\e\
    [31m14 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.concat(\e[31m\"\
    db\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n2 errors found\n"
  stdout: ''
  timestamp: 1660009428
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ extraChars = binary.substring(binary.length - 2, binary.length)\n        val\
    \ extraCharsReversed = extraChars.reverse\n        val extraCharsReversedString\
    \ = extraCharsReversed.mkString\n        val extraCharsReversedStringLength =\
    \ extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmexn8xs8.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mextraCharsReversedStringLength\e\
    [0m = extraCharsReversedString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextraCharsReversedStringLength is already defined as \e[33mvalue\e\
    [0m \e[35mextraCharsReversedStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmexn8xs8.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mextraCharsReversedStringLength\e\
    [0m = extraCharsReversedString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextraCharsReversedStringLength is already defined as \e[33mvalue\e\
    [0m \e[35mextraCharsReversedStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmexn8xs8.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mextraCharsReversedStringLength\e\
    [0m = extraCharsReversedString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextraCharsReversedStringLength is already defined as \e[33mvalue\e\
    [0m \e[35mextraCharsReversedStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmexn8xs8.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mextraCharsReversedStringLength\e\
    [0m = extraCharsReversedString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextraCharsReversedStringLength is already defined as \e[33mvalue\e\
    [0m \e[35mextraCharsReversedStr"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        binary.substring(0,binary.length-1)+db+binary.substring(binary.length-1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnrgyzc1y.scala:16)\n\tat Problem.main(tmpnrgyzc1y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009430
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(binary.length - db.length)\
    \ + db\n        return result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpjrqc7pst.scala:13)\n\
    \tat Problem$.main(tmpjrqc7pst.scala:17)\n\tat Problem.main(tmpjrqc7pst.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.substring(binary.length - 2)\n        val binary = binary.substring(0,\
    \ binary.length - 2)\n        val binary = binary.toCharArray\n        val binary\
    \ = binary.map(_ + \"\")\n        val binary = binary.mkString(\"db\")\n     \
    \   binary.toString\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppx444xhj.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.substring(binary.length\
    \ - \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmppx444xhj.scala:13:12 ---------------------------\e[0m\e[0m\n\e\
    [31m13 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.substring(\e[31m0\e\
    [0m, binary.length - \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmppx444xhj.scala:14:12 ---------------------------\e[0m\e[0m\n\e\
    [31m14 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.toCharArray\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppx444xhj.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.map(_ + \e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppx444xhj.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.mkString(\e[31m\"db\"\e[0m)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m"
  stdout: ''
  timestamp: 1660009428
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpiofg6x01.scala:58:4 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpiofg6x01.scala:12:12 ---------------------------\e[0m\e[0m\n\e[31m12\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpiofg6x01.scala:13:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpiofg6x01.scala:14:12 ---------------------------\e[0m\e[0m\n\e[31m14\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpiofg6x01.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpiofg6x01.scala:16:12 ---------------------------\e[0"
  stdout: ''
  timestamp: 1660009421
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n   \
    \     val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ extraChars = if (binary == \"1\") \"db\" else \"\"\n        binary.dropRight(binary.length)\
    \ + extraChars\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpm5z0iv57.scala:16)\n\tat Problem.main(tmpm5z0iv57.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009431
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ extraChars = if (binary == decimal.toBinaryString) \"\" else binary\n      \
    \  val extraCharsLen = extraChars.length\n        val binLen = binary.length\n\
    \        val result = new StringBuilder(binLen)\n        val remainder = decimal.asInstanceOf[Long]\
    \ % 2\n        val remainderChar = if (remainder == 0) \"0\" else \"1\"\n    \
    \    val remainderLen = remainderChar.length\n        result.append('b').append(remainderChar)\n\
    \        val remainderIndex = binLen - remainderLen - 1\n        val remainderCharIndex\
    \ = binLen - remainderLen - remainderIndex - 1\n        val remainderCharIndex2\
    \ = binLen - remainderLen - remainderIndex - 2\n        val remainderCharIndex3\
    \ = binLen - remainderLen - remainderIndex - 3\n        val remainderCharIndex4\
    \ = binLen - remainderLen - remainderIndex - 4\n        val remainderCharIndex5\
    \ = binLen - remainderLen - remainderIndex - 5\n        val remainderCharIndex6\
    \ = binLen - remainderLen - remainderIndex - 6\n        val remainderCharIndex7\
    \ = binLen - remainderLen - remainderIndex - 7\n        val remainderCharIndex8\
    \ = binLen - remainderLen - remainderIndex - 8\n        val remainderCharIndex9\
    \ = binLen - remainderLen - remainderIndex - 9\n        val remainderCharIndex10\
    \ = binLen - remainderLen - remainderIndex - 10\n        val remainderCharIndex11\
    \ = binLen - remainderLen - remainderIndex - 11\n        val remainderCharIndex12\
    \ = binLen - remainderLen - remainderIndex - 12\n        val remainderCharIndex13\
    \ = binLen - remainderLen - remainderIndex - 13\n        val remainderCharIndex14\
    \ = binLen - remainderLen - remainderIndex - 14\n        val remainderCharIndex15\
    \ = binLen - remainderLen - remainderIndex - 15\n        val remainderCharIndex16\
    \ = binLen - remainderLen - remainderIndex - 16\n        val remainderCharIndex17\
    \ = binLen - remainderLen - remainderIndex - 17\n        val remainderCharIndex18\
    \ = binLen - remainderLen - remainderIndex - 18\n        val remainderCharIndex19\
    \ = binLen - remainderLen - remainderIndex - 19\n        val remainderCharIndex20\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpyd5sso83.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpyd5sso83.scala:41:5 ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009431
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.dropRight(binary.length - db.length)\
    \ + db + binary.take(binary.length - db.length)\n        return result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6cikq_05.scala:17)\n\tat Problem.main(tmp6cikq_05.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        binary.substring(0,binary.length-1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzb3s9grr.scala:16)\n\tat Problem.main(tmpzb3s9grr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009430
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.substring(binary.length - 2)\n        val binary = binary.substring(0,\
    \ binary.length - 2)\n        val binary = binary.reverse\n        val binary\
    \ = binary.reverse\n        val binary = binary.reverse\n        val binary =\
    \ binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n\
    \        val binary = binary.reverse\n        val binary = binary.reverse\n  \
    \      val binary = binary.reverse\n        val binary = binary.reverse\n    \
    \    val binary = binary.reverse\n        val binary = binary.reverse\n      \
    \  val binary = binary.reverse\n        val binary = binary.reverse\n        val\
    \ binary = binary.reverse\n        val binary = binary.reverse\n        val binary\
    \ = binary.reverse\n        val binary = binary.reverse\n        val binary =\
    \ binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n\
    \        val binary = binary.reverse\n        val binary = binary.reverse\n  \
    \      val binary = binary.reverse\n        val binary = binary.reverse\n    \
    \    val binary = binary.reverse\n        val binary = binary.reverse\n      \
    \  val binary = binary.reverse\n        val binary = binary.reverse\n        val\
    \ binary = binary.reverse\n        val binary = binary.reverse\n        val binary\
    \ = binary.reverse\n        val binary = binary.reverse\n        val binary =\
    \ binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n\
    \        val binary = binary.reverse\n        val binary = binary.reverse\n  \
    \      val binary = binary.reverse\n        val binary = binary.reverse\n    \
    \    val binary = binary.reverse\n        val binary = binary.reverse\n      \
    \  val binary = binary.reverse\n        val binary = binary.reverse\n        val\
    \ binary = binary.reverse\n        val binary = binary.reverse\n        val binary\
    \ = binary.reverse\n        val binary = binary.reverse\n        val binary =\
    \ binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n\
    \        val binary = binary.reverse\n        val binary = binary.reverse\n  \
    \      val binary = binary.reverse\n        val binary = binary.reverse\n    \
    \    val binary = binary.reverse\n        val binary = binary.reverse\n      \
    \  val binary = binary.reverse\n        val binary = binary.reverse\n        val\
    \ binary = binary.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmvw2hb70.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.substring(binary.length\
    \ - \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpmvw2hb70.scala:13:12 ---------------------------\e[0m\e[0m\n\e\
    [31m13 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.substring(\e[31m0\e\
    [0m, binary.length - \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpmvw2hb70.scala:14:12 ---------------------------\e[0m\e[0m\n\e\
    [31m14 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is\
    \ already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmvw2hb70.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpmvw2hb70.scala:16:12 ---------------------------\e[0m\e[0m\n\e\
    [31m16 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is\
    \ already defined as \e[33m"
  stdout: ''
  timestamp: 1660009430
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        binary.substring(binary.length\
    \ - 2)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpl6_qmrly.scala:12)\n\
    \tat Problem$.main(tmpl6_qmrly.scala:15)\n\tat Problem.main(tmpl6_qmrly.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009431
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.substring(binary.length - 2)\n        val binary = binary.substring(0,\
    \ binary.length - 2)\n        val binary = binary.reverse\n        val binary\
    \ = binary.reverse\n        val binary = binary.reverse\n        val binary =\
    \ binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n\
    \        val binary = binary.reverse\n        val binary = binary.reverse\n  \
    \      val binary = binary.reverse\n        val binary = binary.reverse\n    \
    \    val binary = binary.reverse\n        val binary = binary.reverse\n      \
    \  val binary = binary.reverse\n        val binary = binary.reverse\n        val\
    \ binary = binary.reverse\n        val binary = binary.reverse\n        val binary\
    \ = binary.reverse\n        val binary = binary.reverse\n        val binary =\
    \ binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n\
    \        val binary = binary.reverse\n        val binary = binary.reverse\n  \
    \      val binary = binary.reverse\n        val binary = binary.reverse\n    \
    \    val binary = binary.reverse\n        val binary = binary.reverse\n      \
    \  val binary = binary.reverse\n        val binary = binary.reverse\n        val\
    \ binary = binary.reverse\n        val binary = binary.reverse\n        val binary\
    \ = binary.reverse\n        val binary = binary.reverse\n        val binary =\
    \ binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n\
    \        val binary = binary.reverse\n        val binary = binary.reverse\n  \
    \      val binary = binary.reverse\n        val binary = binary.reverse\n    \
    \    val binary = binary.reverse\n        val binary = binary.reverse\n      \
    \  val binary = binary.reverse\n        val binary = binary.reverse\n        val\
    \ binary = binary.reverse\n        val binary = binary.reverse\n        val binary\
    \ = binary.reverse\n        val binary = binary.reverse\n        val binary =\
    \ binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n\
    \        val binary = binary.reverse\n        val binary = binary.reverse\n  \
    \      val binary = binary.reverse\n        val binary = binary.reverse\n    \
    \    val binary = binary.reverse\n        val binary = binary.reverse\n      \
    \  val binary = binary.reverse\n        val binary = binary.reverse\n        val\
    \ binary = binary.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmvw2hb70.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.substring(binary.length\
    \ - \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpmvw2hb70.scala:13:12 ---------------------------\e[0m\e[0m\n\e\
    [31m13 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.substring(\e[31m0\e\
    [0m, binary.length - \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpmvw2hb70.scala:14:12 ---------------------------\e[0m\e[0m\n\e\
    [31m14 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is\
    \ already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmvw2hb70.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpmvw2hb70.scala:16:12 ---------------------------\e[0m\e[0m\n\e\
    [31m16 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is\
    \ already defined as \e[33m"
  stdout: ''
  timestamp: 1660009430
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ extraChars = binary.substring(binary.length - 2, binary.length)\n        val\
    \ extraCharsReversed = extraChars.reverse\n        val extraCharsReversedString\
    \ = extraCharsReversed.mkString\n        val extraCharsReversedStringLength =\
    \ extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmexn8xs8.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mextraCharsReversedStringLength\e\
    [0m = extraCharsReversedString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextraCharsReversedStringLength is already defined as \e[33mvalue\e\
    [0m \e[35mextraCharsReversedStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmexn8xs8.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mextraCharsReversedStringLength\e\
    [0m = extraCharsReversedString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextraCharsReversedStringLength is already defined as \e[33mvalue\e\
    [0m \e[35mextraCharsReversedStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmexn8xs8.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mextraCharsReversedStringLength\e\
    [0m = extraCharsReversedString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextraCharsReversedStringLength is already defined as \e[33mvalue\e\
    [0m \e[35mextraCharsReversedStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmexn8xs8.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mextraCharsReversedStringLength\e\
    [0m = extraCharsReversedString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextraCharsReversedStringLength is already defined as \e[33mvalue\e\
    [0m \e[35mextraCharsReversedStr"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(binary.length - db.length)\
    \ + db + binary.substring(0, binary.length - db.length)\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmp1bv2p88_.scala:13)\n\
    \tat Problem$.main(tmp1bv2p88_.scala:17)\n\tat Problem.main(tmp1bv2p88_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        binary.substring(binary.length\
    \ - 2, binary.length) + binary.substring(0, binary.length - 2)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\"\
    )));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat Problem$.decimalToBinary(tmp_ijt4r37.scala:12)\n\tat Problem$.main(tmp_ijt4r37.scala:15)\n\
    \tat Problem.main(tmp_ijt4r37.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009431
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ extraChars = if (decimal == 0) \"\" else s\"db${decimal.toBinaryString}\"\n\
    \        binary.dropRight(binary.length) + extraChars\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq5i6bcsd.scala:16)\n\tat Problem.main(tmpq5i6bcsd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009431
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(binary.length - db.length)\
    \ + db\n        return result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpjrqc7pst.scala:13)\n\
    \tat Problem$.main(tmpjrqc7pst.scala:17)\n\tat Problem.main(tmpjrqc7pst.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.dropRight(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpch7roa0l.scala:50:33 ---------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.drop(\n\
    \e[31m\e[31m   |\e[0m                                 ^\e[0m\n\e[31m   |\e[0m\
    \                                 expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpch7roa0l.scala:12:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpch7roa0l.scala:13:12 ---------------------------\e[0m\e[0m\n\e[31m13\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.drop(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpch7roa0l.scala:14:12 ---------------------------\e[0m\e[0m\n\e\
    [31m14 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.drop(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpch7roa0l.scala:15:12 ---------------------------\e[0m\e[0m\n\e\
    [31m15 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.drop(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is "
  stdout: ''
  timestamp: 1660009430
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ result = binary.reverse.dropWhile(_ == '0').dropWhile(_ == '1').mkString\n \
    \       result + \"db\"\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpeyewijsc.scala:16)\n\tat Problem.main(tmpeyewijsc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009437
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.dropRight(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpch7roa0l.scala:50:33 ---------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.drop(\n\
    \e[31m\e[31m   |\e[0m                                 ^\e[0m\n\e[31m   |\e[0m\
    \                                 expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpch7roa0l.scala:12:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpch7roa0l.scala:13:12 ---------------------------\e[0m\e[0m\n\e[31m13\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.drop(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpch7roa0l.scala:14:12 ---------------------------\e[0m\e[0m\n\e\
    [31m14 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.drop(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpch7roa0l.scala:15:12 ---------------------------\e[0m\e[0m\n\e\
    [31m15 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.drop(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is "
  stdout: ''
  timestamp: 1660009430
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.dropRight(binary.length - db.length)\
    \ + db + binary.take(binary.length - db.length)\n        return result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6cikq_05.scala:17)\n\tat Problem.main(tmp6cikq_05.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.dropRight(binary.length + 2)\n    \
    \    result + db + binary.drop(binary.length + 2)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcoiwiy1z.scala:17)\n\tat Problem.main(tmpcoiwiy1z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009439
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ extraChars = binary.substring(binary.length - 2)\n        val extraCharsReversed\
    \ = extraChars.reverse\n        val extraCharsReversedString = extraCharsReversed.mkString\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extra\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7qgzmwuj.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7qgzmwuj.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextraCharsReversedStringLength\e[0m = extraCharsReversedString.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextraCharsReversedStringLength is already defined as \e[33mvalue\e\
    [0m \e[35mextraCharsReversedStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7qgzmwuj.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mextraCharsReversedStringLength\e\
    [0m = extraCharsReversedString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextraCharsReversedStringLength is already defined as \e[33mvalue\e\
    [0m \e[35mextraCharsReversedStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7qgzmwuj.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mextraCharsReversedStringLength\e\
    [0m = extraCharsReversedString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextraCharsReversedStringLength is already defined as \e[33mvalue\e\
    [0m \e[35mextraCharsReversedStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7qgzmwuj.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mextraCharsReversedStringLength\e\
    [0m = extraCharsReversedString.length\n\e[31m\e[31m   |\e"
  stdout: ''
  timestamp: 1660009438
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.dropRight(binary.length - 2)\n    \
    \    result + db + binary.drop(binary.length - 2)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp369vl_sm.scala:17)\n\tat Problem.main(tmp369vl_sm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009439
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.dropRight(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpch7roa0l.scala:50:33 ---------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.drop(\n\
    \e[31m\e[31m   |\e[0m                                 ^\e[0m\n\e[31m   |\e[0m\
    \                                 expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpch7roa0l.scala:12:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpch7roa0l.scala:13:12 ---------------------------\e[0m\e[0m\n\e[31m13\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.drop(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpch7roa0l.scala:14:12 ---------------------------\e[0m\e[0m\n\e\
    [31m14 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.drop(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpch7roa0l.scala:15:12 ---------------------------\e[0m\e[0m\n\e\
    [31m15 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.drop(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is "
  stdout: ''
  timestamp: 1660009430
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.dropRight(binary.length - db.length)\
    \ + db + binary.takeRight(binary.length - db.length)\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgy8xid0q.scala:17)\n\tat Problem.main(tmpgy8xid0q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009440
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.dropRight(binary.length - db.length)\
    \ + db + binary.drop(binary.length - db.length)\n        return result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpezs5ez4i.scala:17)\n\tat Problem.main(tmpezs5ez4i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009431
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n   \
    \     val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e"
  stdout: ''
  timestamp: 1660009421
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n   \
    \     val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e"
  stdout: ''
  timestamp: 1660009421
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.substring(binary.length - 2)\n        val binary = binary.substring(0,\
    \ binary.length - 2)\n        val binary = binary.reverse\n        val binary\
    \ = binary.reverse\n        val binary = binary.reverse\n        val binary =\
    \ binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n\
    \        val binary = binary.reverse\n        val binary = binary.reverse\n  \
    \      val binary = binary.reverse\n        val binary = binary.reverse\n    \
    \    val binary = binary.reverse\n        val binary = binary.reverse\n      \
    \  val binary = binary.reverse\n        val binary = binary.reverse\n        val\
    \ binary = binary.reverse\n        val binary = binary.reverse\n        val binary\
    \ = binary.reverse\n        val binary = binary.reverse\n        val binary =\
    \ binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n\
    \        val binary = binary.reverse\n        val binary = binary.reverse\n  \
    \      val binary = binary.reverse\n        val binary = binary.reverse\n    \
    \    val binary = binary.reverse\n        val binary = binary.reverse\n      \
    \  val binary = binary.reverse\n        val binary = binary.reverse\n        val\
    \ binary = binary.reverse\n        val binary = binary.reverse\n        val binary\
    \ = binary.reverse\n        val binary = binary.reverse\n        val binary =\
    \ binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n\
    \        val binary = binary.reverse\n        val binary = binary.reverse\n  \
    \      val binary = binary.reverse\n        val binary = binary.reverse\n    \
    \    val binary = binary.reverse\n        val binary = binary.reverse\n      \
    \  val binary = binary.reverse\n        val binary = binary.reverse\n        val\
    \ binary = binary.reverse\n        val binary = binary.reverse\n        val binary\
    \ = binary.reverse\n        val binary = binary.reverse\n        val binary =\
    \ binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n\
    \        val binary = binary.reverse\n        val binary = binary.reverse\n  \
    \      val binary = binary.reverse\n        val binary = binary.reverse\n    \
    \    val binary = binary.reverse\n        val binary = binary.reverse\n      \
    \  val binary = binary.reverse\n        val binary = binary.reverse\n        val\
    \ binary = binary.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmvw2hb70.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.substring(binary.length\
    \ - \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpmvw2hb70.scala:13:12 ---------------------------\e[0m\e[0m\n\e\
    [31m13 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.substring(\e[31m0\e\
    [0m, binary.length - \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpmvw2hb70.scala:14:12 ---------------------------\e[0m\e[0m\n\e\
    [31m14 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is\
    \ already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmvw2hb70.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpmvw2hb70.scala:16:12 ---------------------------\e[0m\e[0m\n\e\
    [31m16 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is\
    \ already defined as \e[33m"
  stdout: ''
  timestamp: 1660009430
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(binary.length - db.length)\
    \ + db + binary.substring(0, binary.length - db.length)\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmp1bv2p88_.scala:13)\n\
    \tat Problem$.main(tmp1bv2p88_.scala:17)\n\tat Problem.main(tmp1bv2p88_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(binary.length - db.length)\
    \ + db\n        return result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpjrqc7pst.scala:13)\n\
    \tat Problem$.main(tmpjrqc7pst.scala:17)\n\tat Problem.main(tmpjrqc7pst.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\".toBinaryString\n        val result = binary.padTo(binary.length,\
    \ \"0\")\n        result + db\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmsbv7trt.scala:12:22 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mdb\e[0m = \e[31m\"db\"\e\
    [0m.toBinaryString\n\e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                 value toBinaryString is not a member of String\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmsbv7trt.scala:14:15 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        result + db\n\e[31m\e[31m   |\e[0m        ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue + is not a member of IndexedSeq[Matchable], but could\
    \ be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might make progress towards fixing the problem:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009440
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.dropRight(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpch7roa0l.scala:50:33 ---------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.drop(\n\
    \e[31m\e[31m   |\e[0m                                 ^\e[0m\n\e[31m   |\e[0m\
    \                                 expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpch7roa0l.scala:12:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpch7roa0l.scala:13:12 ---------------------------\e[0m\e[0m\n\e[31m13\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.drop(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpch7roa0l.scala:14:12 ---------------------------\e[0m\e[0m\n\e\
    [31m14 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.drop(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpch7roa0l.scala:15:12 ---------------------------\e[0m\e[0m\n\e\
    [31m15 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.drop(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is "
  stdout: ''
  timestamp: 1660009430
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(binary.length - 3)\n    \
    \    result + db\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -2, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpu_h2vutg.scala:13)\n\
    \tat Problem$.main(tmpu_h2vutg.scala:17)\n\tat Problem.main(tmpu_h2vutg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009440
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(binary.length - db.length)\
    \ + db + binary.substring(0, binary.length - db.length)\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmp1bv2p88_.scala:13)\n\
    \tat Problem$.main(tmp1bv2p88_.scala:17)\n\tat Problem.main(tmp1bv2p88_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ result = binary.substring(binary.length - 2)\n        result + \"db\"\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmp08hvo39f.scala:12)\n\
    \tat Problem$.main(tmp08hvo39f.scala:16)\n\tat Problem.main(tmp08hvo39f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009440
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(binary.length - db.length)\
    \ + db\n        return result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpjrqc7pst.scala:13)\n\
    \tat Problem$.main(tmpjrqc7pst.scala:17)\n\tat Problem.main(tmpjrqc7pst.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.substring(binary.length - 2)\n        val binary = binary.substring(0,\
    \ binary.length - 2)\n        binary.toCharArray\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa_rwnp77.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.substring(binary.length\
    \ - \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa_rwnp77.scala:13:12 ---------------------------\e[0m\e[0m\n\e\
    [31m13 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.substring(\e[31m0\e\
    [0m, binary.length - \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpa_rwnp77.scala:14:8 ---------------------\e[0m\e[0m\n\
    \e[31m14 |\e[0m        binary.toCharArray\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Array[Char]\n\e[31m   |\e[0m        Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009439
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n   \
    \     val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.dropRight(binary.length - db.length)\
    \ + db + binary.drop(binary.length - db.length)\n        return result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpezs5ez4i.scala:17)\n\tat Problem.main(tmpezs5ez4i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009431
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.dropRight(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpch7roa0l.scala:50:33 ---------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.drop(\n\
    \e[31m\e[31m   |\e[0m                                 ^\e[0m\n\e[31m   |\e[0m\
    \                                 expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpch7roa0l.scala:12:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpch7roa0l.scala:13:12 ---------------------------\e[0m\e[0m\n\e[31m13\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.drop(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpch7roa0l.scala:14:12 ---------------------------\e[0m\e[0m\n\e\
    [31m14 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.drop(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpch7roa0l.scala:15:12 ---------------------------\e[0m\e[0m\n\e\
    [31m15 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.drop(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is "
  stdout: ''
  timestamp: 1660009430
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ extraChars = if (binary == decimal.toBinaryString) \"\" else binary\n      \
    \  val extraCharsLength = extraChars.length\n        val result = binary.padToLength(binary.length\
    \ + extraCharsLength, \"0\")\n        result + extraChars\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnwqvz70z.scala:14:28 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = binary.padToLength(binary.length\
    \ + extraCharsLength, \e[31m\"0\"\e[0m)\n\e[31m\e[31m   |\e[0m               \
    \      ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     value padToLength\
    \ is not a member of String\n1 error found\n"
  stdout: ''
  timestamp: 1660009440
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        binary.substring(binary.length\
    \ - 2) +\n            binary.substring(0, binary.length - 2)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpdtpni03q.scala:12)\n\
    \tat Problem$.main(tmpdtpni03q.scala:16)\n\tat Problem.main(tmpdtpni03q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009440
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.dropRight(binary.length - db.length)\
    \ + db + binary.take(binary.length - db.length)\n        return result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6cikq_05.scala:17)\n\tat Problem.main(tmp6cikq_05.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n   \
    \     val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        var binary = \"\"\n        var remainder = decimal\n\
    \        while(decimal != 0) {\n            binary += remainder % 2\n        \
    \    remainder = remainder / 2\n        }\n        binary += \"db\"\n        binary\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_y3svybq.scala:21)\n\tat Problem.main(tmp_y3svybq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009420
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        var binary = \"\"\n        var remainder = decimal\n\
    \        while(decimal != 0){\n            binary += remainder % 2\n         \
    \   remainder = remainder / 2\n        }\n        binary += \"db\"\n        binary\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpu14t70nl.scala:21)\n\tat Problem.main(tmpu14t70nl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009440
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ result = binary.substring(binary.length - 2)\n        val extraChars = binary.substring(binary.length\
    \ - 2, binary.length)\n        val extraCharsLength = extraChars.length\n    \
    \    val extraCharsString = extraChars.substring(0, extraCharsLength)\n      \
    \  val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength\
    \ = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n\
    \        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength\
    \ = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n\
    \        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength\
    \ = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n\
    \        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength\
    \ = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n\
    \        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength\
    \ = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n\
    \        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength\
    \ = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n\
    \        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength\
    \ = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n\
    \        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength\
    \ = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n\
    \        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength\
    \ = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n\
    \        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength\
    \ = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n\
    \        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength\
    \ = extraCharsString.length\n        val extraCharsStringLength = extraCharsString.length\n\
    \        val extraCharsStringLength = extraCharsString.length\n        val extraCharsStringLength\
    \ = extra\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmptan30v5w.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mextraCharsStringLength\e\
    [0m = extraCharsString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextraCharsStringLength is already defined as \e[33mvalue\e\
    [0m \e[35mextraCharsStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmptan30v5w.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mextraCharsStringLength\e\
    [0m = extraCharsString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextraCharsStringLength is already defined as \e[33mvalue\e\
    [0m \e[35mextraCharsStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmptan30v5w.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mextraCharsStringLength\e\
    [0m = extraCharsString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextraCharsStringLength is already defined as \e[33mvalue\e\
    [0m \e[35mextraCharsStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmptan30v5w.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mextraCharsStringLength\e\
    [0m = extraCharsString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextraCharsStringLength is already defined as \e[33mvalue\e\
    [0m \e[35mextraCharsStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmptan30v5w.scala:21:"
  stdout: ''
  timestamp: 1660009440
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ extraChars = if (binary == \"11111111\") \"db\" else \"\"\n        binary.substring(1)\
    \ + extraChars\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcl719ogm.scala:16)\n\tat Problem.main(tmpcl719ogm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009440
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\".toBinaryString\n        binary.substring(binary.length - db.length)\
    \ + db + binary.substring(0, binary.length - db.length)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgy2rg7q6.scala:12:22 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mdb\e[0m = \e[31m\"db\"\e\
    [0m.toBinaryString\n\e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                 value toBinaryString is not a member of String\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009439
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        binary.substring(0,1) + db + binary.substring(binary.length-1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpps1q97c4.scala:16)\n\tat Problem.main(tmpps1q97c4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009440
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n   \
    \     val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e"
  stdout: ''
  timestamp: 1660009421
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ extraChars = binary.substring(binary.length - 2)\n        val extraCharsReversed\
    \ = extraChars.reverse\n        val extraCharsReversedString = extraCharsReversed.mkString\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extra\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7qgzmwuj.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7qgzmwuj.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextraCharsReversedStringLength\e[0m = extraCharsReversedString.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextraCharsReversedStringLength is already defined as \e[33mvalue\e\
    [0m \e[35mextraCharsReversedStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7qgzmwuj.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mextraCharsReversedStringLength\e\
    [0m = extraCharsReversedString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextraCharsReversedStringLength is already defined as \e[33mvalue\e\
    [0m \e[35mextraCharsReversedStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7qgzmwuj.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mextraCharsReversedStringLength\e\
    [0m = extraCharsReversedString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextraCharsReversedStringLength is already defined as \e[33mvalue\e\
    [0m \e[35mextraCharsReversedStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7qgzmwuj.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mextraCharsReversedStringLength\e\
    [0m = extraCharsReversedString.length\n\e[31m\e[31m   |\e"
  stdout: ''
  timestamp: 1660009438
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(binary.length - 3)\n    \
    \    result + db + binary.substring(0, binary.length - 3)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -2, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmp_dacjrk2.scala:13)\n\
    \tat Problem$.main(tmp_dacjrk2.scala:17)\n\tat Problem.main(tmp_dacjrk2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpiofg6x01.scala:58:4 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpiofg6x01.scala:12:12 ---------------------------\e[0m\e[0m\n\e[31m12\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpiofg6x01.scala:13:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpiofg6x01.scala:14:12 ---------------------------\e[0m\e[0m\n\e[31m14\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpiofg6x01.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpiofg6x01.scala:16:12 ---------------------------\e[0"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ extraChars = if (decimal == 0) \"db\" else \"\"\n        binary.dropRight(binary.length)\
    \ + extraChars\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbz1d0pch.scala:16)\n\tat Problem.main(tmpbz1d0pch.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009430
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(binary.length - 2)\n    \
    \    result + db\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmp_0mmyjdp.scala:13)\n\
    \tat Problem$.main(tmp_0mmyjdp.scala:17)\n\tat Problem.main(tmp_0mmyjdp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009440
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        binary.dropRight(binary.length-1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpprkwk47c.scala:15)\n\tat Problem.main(tmpprkwk47c.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009420
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(0,binary.length-1)\n    \
    \    val result = result + db\n        result + db\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo3si9cwq.scala:14:12 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = result + db\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mresult\
    \ is already defined as \e[33mvalue\e[0m \e[35mresult\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n1 error found\n"
  stdout: ''
  timestamp: 1660009438
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ bin = binary.substring(binary.length - 2)\n        val binary = bin.substring(0,\
    \ bin.length - 1)\n        val binary = binary.concat(\"db\")\n        binary\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp16ui0hyo.scala:13:12 ---------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = bin.substring(\e\
    [31m0\e[0m, bin.length - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp16ui0hyo.scala:14:12 ---------------------------\e[0m\e[0m\n\e\
    [31m14 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.concat(\e[31m\"\
    db\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n2 errors found\n"
  stdout: ''
  timestamp: 1660009428
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ extraChars = if (binary.length < 8) {\n            Array(binary.charAt(0), binary.charAt(binary.length\
    \ - 1))\n        } else {\n            Array(binary.charAt(0), binary.charAt(binary.length\
    \ - 1), binary.charAt(binary.length - 2))\n        }\n        extraChars.mkString(\"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpn5w_g76c.scala:20)\n\tat Problem.main(tmpn5w_g76c.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009441
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.dropRight(binary.length - 2)\n    \
    \    result + db + binary.takeRight(binary.length - 2)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpg40vga0_.scala:17)\n\tat Problem.main(tmpg40vga0_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009441
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.substring(binary.length - 2)\n        val binary = binary.substring(0,\
    \ binary.length - 2)\n        val binary = binary.toCharArray\n        val binary\
    \ = binary.map(x => if (x == '1') '0' else '1')\n        val binary = binary.mkString(\"\
    \")\n        val binary = binary.concat(\"db\")\n        binary\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\"\
    )));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv43qenv_.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.substring(binary.length\
    \ - \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv43qenv_.scala:13:12 ---------------------------\e[0m\e[0m\n\e\
    [31m13 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.substring(\e[31m0\e\
    [0m, binary.length - \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv43qenv_.scala:14:12 ---------------------------\e[0m\e[0m\n\e\
    [31m14 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.toCharArray\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv43qenv_.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.map(\e[36mx\e[0m => \e[33mif\e[0m (x == \e[31m'1'\e\
    [0m) \e[31m'0'\e[0m \e[33melse\e[0m \e[31m'1'\e[0m)\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv43qenv_.scala:16:12 ---------------------------\e[0m\e[0m\n\e[31m16\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = "
  stdout: ''
  timestamp: 1660009439
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.dropRight(binary.length - 2)\n    \
    \    result + db + binary.dropLeft(binary.length - 2)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqps6_kuo.scala:14:29 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        result + db + binary.dropLeft(binary.length -\
    \ \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      value dropLeft is not a member of String\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009430
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(binary.length - db.length)\
    \ + db + binary.substring(0, binary.length - db.length)\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmp1bv2p88_.scala:13)\n\
    \tat Problem$.main(tmp1bv2p88_.scala:17)\n\tat Problem.main(tmp1bv2p88_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\".toCharArray\n        val result = binary.dropRight(binary.length\
    \ - db.length) + db + binary.drop(binary.length - db.length)\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpx5a5bz2y.scala:17)\n\tat Problem.main(tmpx5a5bz2y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009441
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        binary.substring(binary.length\
    \ - 2) + \"db\"\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpj6rhs_yh.scala:12)\n\
    \tat Problem$.main(tmpj6rhs_yh.scala:15)\n\tat Problem.main(tmpj6rhs_yh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009420
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n   \
    \     val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e"
  stdout: ''
  timestamp: 1660009421
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n   \
    \     val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ extraChars = binary.substring(binary.length - 2)\n        val extraCharsDb =\
    \ \"db\" + extraChars\n        binary.substring(1) + extraCharsDb + extraChars\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmp3gzetacw.scala:12)\n\
    \tat Problem$.main(tmp3gzetacw.scala:17)\n\tat Problem.main(tmp3gzetacw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009441
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(binary.length - db.length,\
    \ binary.length)\n        result + db\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat Problem$.decimalToBinary(tmpn7kgvxio.scala:13)\n\tat Problem$.main(tmpn7kgvxio.scala:17)\n\
    \tat Problem.main(tmpn7kgvxio.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009430
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ extraChars = binary.substring(binary.length - 2)\n        val extraCharsReversed\
    \ = extraChars.reverse\n        val extraCharsReversedLength = extraCharsReversed.length\n\
    \        val extraCharsReversedLength = extraCharsReversedLength + 2\n       \
    \ val extraCharsReversedLength = extraCharsReversedLength + 2\n        val extraCharsReversedLength\
    \ = extraCharsReversedLength + 2\n        val extraCharsReversedLength = extraCharsReversedLength\
    \ + 2\n        val extraCharsReversedLength = extraCharsReversedLength + 2\n \
    \       val extraCharsReversedLength = extraCharsReversedLength + 2\n        val\
    \ extraCharsReversedLength = extraCharsReversedLength + 2\n        val extraCharsReversedLength\
    \ = extraCharsReversedLength + 2\n        val extraCharsReversedLength = extraCharsReversedLength\
    \ + 2\n        val extraCharsReversedLength = extraCharsReversedLength + 2\n \
    \       val extraCharsReversedLength = extraCharsReversedLength + 2\n        val\
    \ extraCharsReversedLength = extraCharsReversedLength + 2\n        val extraCharsReversedLength\
    \ = extraCharsReversedLength + 2\n        val extraCharsReversedLength = extraCharsReversedLength\
    \ + 2\n        val extraCharsReversedLength = extraCharsReversedLength + 2\n \
    \       val extraCharsReversedLength = extraCharsReversedLength + 2\n        val\
    \ extraCharsReversedLength = extraCharsReversedLength + 2\n        val extraCharsReversedLength\
    \ = extraCharsReversedLength + 2\n        val extraCharsReversedLength = extraCharsReversedLength\
    \ + 2\n        val extraCharsReversedLength = extraCharsReversedLength + 2\n \
    \       val extraCharsReversedLength = extraCharsReversedLength + 2\n        val\
    \ extraCharsReversedLength = extraCharsReversedLength + 2\n        val extraCharsReversedLength\
    \ = extraCharsReversedLength + 2\n        val extraCharsReversedLength = extraCharsReversedLength\
    \ + 2\n        val extraCharsReversedLength = extraCharsReversedLength + 2\n \
    \       val extraCharsReversedLength = extraCharsReversedLength + 2\n        val\
    \ extraCharsReversedLength = extraCharsReversedLength + 2\n        val extraChar\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpx2n5sb_5.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpx2n5sb_5.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextraCharsReversedLength\e[0m = extraCharsReversedLength + \e[31m2\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextraCharsReversedLength is already defined as \e[33mvalue\e\
    [0m \e[35mextraCharsReversedLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpx2n5sb_5.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mextraCharsReversedLength\e\
    [0m = extraCharsReversedLength + \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextraCharsReversedLength is already defined as \e[33mvalue\e\
    [0m \e[35mextraCharsReversedLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpx2n5sb_5.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mextraCharsReversedLength\e\
    [0m = extraCharsReversedLength + \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextraCharsReversedLength is already defined as \e[33mvalue\e\
    [0m \e[35mextraCharsReversedLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpx2n5sb_5.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mextraCharsReversedLength\e\
    [0m = extraCharsReversedLength + \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660009446
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(binary.length - 2)\n    \
    \    result + db + binary.substring(0, binary.length - 2)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpl0wnsjlj.scala:13)\n\
    \tat Problem$.main(tmpl0wnsjlj.scala:17)\n\tat Problem.main(tmpl0wnsjlj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009430
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.dropRight(binary.length - 2)\n    \
    \    result + db + binary.takeRight(binary.length - 2)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpg40vga0_.scala:17)\n\tat Problem.main(tmpg40vga0_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009441
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(binary.length - db.length)\
    \ + db\n        return result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpjrqc7pst.scala:13)\n\
    \tat Problem$.main(tmpjrqc7pst.scala:17)\n\tat Problem.main(tmpjrqc7pst.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n   \
    \     val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e"
  stdout: ''
  timestamp: 1660009421
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n   \
    \     val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(0,binary.length-1)\n    \
    \    result + db + binary.substring(binary.length-1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa06x9obf.scala:17)\n\tat Problem.main(tmpa06x9obf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.dropRight(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(binary.length-1)\n        val binary = binary.drop(binary.length-1)\n\
    \        val binary = binary.drop(\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpch7roa0l.scala:50:33 ---------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.drop(\n\
    \e[31m\e[31m   |\e[0m                                 ^\e[0m\n\e[31m   |\e[0m\
    \                                 expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpch7roa0l.scala:12:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpch7roa0l.scala:13:12 ---------------------------\e[0m\e[0m\n\e[31m13\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.drop(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpch7roa0l.scala:14:12 ---------------------------\e[0m\e[0m\n\e\
    [31m14 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.drop(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpch7roa0l.scala:15:12 ---------------------------\e[0m\e[0m\n\e\
    [31m15 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.drop(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is "
  stdout: ''
  timestamp: 1660009430
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ extraChars = if (binary.length < 8) \"db\" else \"\"\n        binary.padTo(8,\
    \ extraChars)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp18x6vs_m.scala:13:24\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        binary.padTo(\e[31m8\e\
    [0m, extraChars)\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                        Found:    (extraChars : String)\n\e[31m\
    \   |\e[0m                        Required: Char\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        binary.dropRight(binary.length\
    \ + 2)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwtn1uir0.scala:15)\n\tat Problem.main(tmpwtn1uir0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.dropRight(binary.length - db.length)\
    \ + db + binary.take(binary.length - db.length)\n        return result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6cikq_05.scala:17)\n\tat Problem.main(tmp6cikq_05.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n   \
    \     val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(binary.length - 2)\n    \
    \    result + db\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmp_0mmyjdp.scala:13)\n\
    \tat Problem$.main(tmp_0mmyjdp.scala:17)\n\tat Problem.main(tmp_0mmyjdp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009440
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n   \
    \     val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        binary.substring(binary.length\
    \ - 2) +\n            binary.substring(0, binary.length - 2)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpdtpni03q.scala:12)\n\
    \tat Problem$.main(tmpdtpni03q.scala:16)\n\tat Problem.main(tmpdtpni03q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009440
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.substring(binary.length - 2)\n        val binary = binary.substring(0,\
    \ binary.length - 2)\n        val binary = binary.replace(\"0\",\"db\")\n    \
    \    val binary = binary.replace(\"1\",\"db\")\n        binary\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\"\
    )));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl7a4s2b8.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.substring(binary.length\
    \ - \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl7a4s2b8.scala:13:12 ---------------------------\e[0m\e[0m\n\e\
    [31m13 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.substring(\e[31m0\e\
    [0m, binary.length - \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl7a4s2b8.scala:14:12 ---------------------------\e[0m\e[0m\n\e\
    [31m14 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.replace(\e[31m\"\
    0\"\e[0m,\e[31m\"db\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl7a4s2b8.scala:15:12 ---------------------------\e[0m\e[0m\n\e\
    [31m15 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.replace(\e[31m\"\
    1\"\e[0m,\e[31m\"db\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n4 errors found\n"
  stdout: ''
  timestamp: 1660009444
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(binary.length - 2)\n    \
    \    result + db + binary.substring(0, binary.length - 2)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpl0wnsjlj.scala:13)\n\
    \tat Problem$.main(tmpl0wnsjlj.scala:17)\n\tat Problem.main(tmpl0wnsjlj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009430
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ extraChars = binary.substring(binary.length - 2, binary.length)\n        val\
    \ extraCharsReversed = extraChars.reverse\n        val extraCharsReversedString\
    \ = extraCharsReversed.mkString\n        val extraCharsReversedStringLength =\
    \ extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n        val extraCharsReversedStringLength\
    \ = extraCharsReversedString.length\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmexn8xs8.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mextraCharsReversedStringLength\e\
    [0m = extraCharsReversedString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextraCharsReversedStringLength is already defined as \e[33mvalue\e\
    [0m \e[35mextraCharsReversedStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmexn8xs8.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mextraCharsReversedStringLength\e\
    [0m = extraCharsReversedString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextraCharsReversedStringLength is already defined as \e[33mvalue\e\
    [0m \e[35mextraCharsReversedStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmexn8xs8.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mextraCharsReversedStringLength\e\
    [0m = extraCharsReversedString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextraCharsReversedStringLength is already defined as \e[33mvalue\e\
    [0m \e[35mextraCharsReversedStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmexn8xs8.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mextraCharsReversedStringLength\e\
    [0m = extraCharsReversedString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextraCharsReversedStringLength is already defined as \e[33mvalue\e\
    [0m \e[35mextraCharsReversedStr"
  stdout: ''
  timestamp: 1660009421
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.substring(binary.length - 2)\n        val binary = binary.substring(0,\
    \ binary.length - 2)\n        val binary = binary.toCharArray\n        val binary\
    \ = binary.map(_ + 48)\n        val binary = binary.toList\n        val binary\
    \ = binary.toString.reverse\n        val binary = binary.reverse\n        val\
    \ binary = binary.reverse\n        val binary = binary.reverse\n        val binary\
    \ = binary.reverse\n        val binary = binary.reverse\n        val binary =\
    \ binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n\
    \        val binary = binary.reverse\n        val binary = binary.reverse\n  \
    \      val binary = binary.reverse\n        val binary = binary.reverse\n    \
    \    val binary = binary.reverse\n        val binary = binary.reverse\n      \
    \  val binary = binary.reverse\n        val binary = binary.reverse\n        val\
    \ binary = binary.reverse\n        val binary = binary.reverse\n        val binary\
    \ = binary.reverse\n        val binary = binary.reverse\n        val binary =\
    \ binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n\
    \        val binary = binary.reverse\n        val binary = binary.reverse\n  \
    \      val binary = binary.reverse\n        val binary = binary.reverse\n    \
    \    val binary = binary.reverse\n        val binary = binary.reverse\n      \
    \  val binary = binary.reverse\n        val binary = binary.reverse\n        val\
    \ binary = binary.reverse\n        val binary = binary.reverse\n        val binary\
    \ = binary.reverse\n        val binary = binary.reverse\n        val binary =\
    \ binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n\
    \        val binary = binary.reverse\n        val binary = binary.reverse\n  \
    \      val binary = binary.reverse\n        val binary = binary.reverse\n    \
    \    val binary = binary.reverse\n        val binary = binary.reverse\n      \
    \  val binary = binary.reverse\n        val binary = binary.reverse\n        val\
    \ binary = binary.reverse\n        val binary = binary.reverse\n        val binary\
    \ = binary.reverse\n        val binary = binary.reverse\n        val binary =\
    \ binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n\
    \        val binary = binary.reverse\n        val binary = binary.\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp06kdow51.scala:73:4 ----------------------------\e\
    [0m\e[0m\n\e[31m73 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp06kdow51.scala:12:12 ---------------------------\e[0m\e[0m\n\e[31m12\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.substring(binary.length\
    \ - \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp06kdow51.scala:13:12 ---------------------------\e[0m\e[0m\n\e\
    [31m13 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.substring(\e[31m0\e\
    [0m, binary.length - \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp06kdow51.scala:14:12 ---------------------------\e[0m\e[0m\n\e\
    [31m14 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.toCharArray\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp06kdow51.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.map(_ + \e[31m48\e[0m)\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already defined\
    \ as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp06k"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ bin = binary.substring(binary.length - 2)\n        val binary = bin.substring(0,\
    \ bin.length - 1)\n        val binary = binary.concat(\"db\")\n        binary.toUpperCase\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjzsigvcv.scala:13:12 ---------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = bin.substring(\e\
    [31m0\e[0m, bin.length - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpjzsigvcv.scala:14:12 ---------------------------\e[0m\e[0m\n\e\
    [31m14 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.concat(\e[31m\"\
    db\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n2 errors found\n"
  stdout: ''
  timestamp: 1660009427
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.replace(\"0\",\"db\")\n        val binary = binary.replace(\"\
    1\",\"0\")\n        binary\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpq_vgod8k.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.replace(\e\
    [31m\"0\"\e[0m,\e[31m\"db\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpq_vgod8k.scala:13:12 ---------------------------\e[0m\e[0m\n\e\
    [31m13 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.replace(\e[31m\"\
    1\"\e[0m,\e[31m\"0\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n2 errors found\n"
  stdout: ''
  timestamp: 1660009444
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ extraChars = if (decimal == 0) \"db\" else \"\"\n        binary.dropRight(binary.length\
    \ - extraChars.length) + extraChars\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpd_on7z8z.scala:16)\n\tat Problem.main(tmpd_on7z8z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009430
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n   \
    \     val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e"
  stdout: ''
  timestamp: 1660009421
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ extraChars = binary.substring(binary.length - 2, binary.length)\n        val\
    \ extraCharsString = extraChars.toUpperCase\n        val extraCharsStringLength\
    \ = extraCharsString.length\n        val extraCharsStringWithDb = extraCharsString\
    \ + extraCharsString.substring(0, extraCharsStringLength - 1) + extraCharsString.substring(extraCharsStringLength\
    \ - 1, extraCharsStringLength)\n        val extraCharsStringWithDbLength = extraCharsStringWithDb.length\n\
    \        val extraCharsStringWithDbWithDb = extraCharsStringWithDb + extraCharsStringWithDb.substring(0,\
    \ extraCharsStringWithDbLength - 1) + extraCharsStringWithDb.substring(extraCharsStringWithDbLength\
    \ - 1, extraCharsStringWithDbLength)\n        val extraCharsStringWithDbWithDbLength\
    \ = extraCharsStringWithDbWithDb.length\n        val extraCharsStringWithDbWithDbWithDb\
    \ = extraCharsStringWithDbWithDb + extraCharsStringWithDbWithDb.substring(0, extraCharsStringWithDbWithDbLength\
    \ - 1) + extraCharsStringWithDbWithDb.substring(extraCharsStringWithDbWithDbLength\
    \ - 1, extraCharsStringWithDbWithDbLength)\n        val extraCharsStringWithDbWithDbWithDbLength\
    \ = extraCharsStringWithDbWithDbWithDbWithDb.length\n        val extraCharsStringWithDbWithDbWithDbWithDb\
    \ = extraCharsStringWithDbWithDbWithDb + extraCharsStringWithDbWithDbWithDbWithDb.substring(0,\
    \ extraCharsStringWithDbWithDbWithDbWithDbLength - 1) + extraCharsStringWithDbWithDbWithDbWithDb.substring(extraCharsStringWithDbWithDbWithDbLength\
    \ - 1, extraCharsStringWithDbWithDbWithDbLength)\n        val extraCharsStringWithDbWithDbWithDbWithDbLength\
    \ = extraCharsStringWithDbWithDbWithDbWithDbWithDb.length\n        val extraCharsStringWithDbWithDbWithDbWithDbWithDb\
    \ = extraCharsStringWithDbWithDbWithDbWithDb + extraCharsStringWithDbWithDbWithDbWithDbWithDb.substring(0,\
    \ extraCharsStringWithDbWithDbWithDbWithDbWithDbWithDbLength - 1) + extraCharsStringWithDbWithDbWithDbWithDbWithDb.substring(extraCharsStringWith\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpkm2ksupk.scala:24:4 ----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpkm2ksupk.scala:21:92\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextraCharsStringWithDbWithDbWithDbWithDb\e[0m = extraCharsStringWithDbWithDbWithDb\
    \ + extraCharsStringWithDbWithDbWithDbWithDb.substring(\e[31m0\e[0m, extraCharsStringWithDbWithDbWithDbWithDbLength\
    \ - \e[31m1\e[0m) + extraCharsStringWithDbWithDbWithDbWithDb.substring(extraCharsStringWithDbWithDbWithDbLength\
    \ - \e[31m1\e[0m, extraCharsStringWithDbWithDbWithDbLength)\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \                  ^\e[0m\n\e[31m   |\e[0m     Recursive \e[33mvalue\e[0m \e[35mextraCharsStringWithDbWithDbWithDbWithDb\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpkm2ksupk.scala:21:200\
    \ --------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextraCharsStringWithDbWithDbWithDbWithDb\e[0m = extraCharsStringWithDbWithDbWithDb\
    \ + extraCharsStringWithDbWithDbWithDbWithDb.substring(\e[31m0\e[0m, extraCharsStringWithDbWithDbWithDbWithDbLength\
    \ - \e[31m1\e[0m) + extraCharsStringWithDbWithDbWithDbWithDb.substring(extraCharsStringWithDbWithDbWithDbLength\
    \ - \e[31m1\e[0m, extraCharsStringWithDbWithDbWithDbLength)\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \                                                                            \
    \                                                  ^\e[0m\n\e[31m   |\e[0m   \
    \  Recursive \e[33mvalue\e[0m \e[35mextraCharsStringWithDbWithDbWithDbWithDb\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpkm2ksupk.scala:23:104\
    \ --------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mext"
  stdout: ''
  timestamp: 1660009449
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\".toCharArray\n        val result = binary.dropRight(binary.length\
    \ - db.length) + db + binary.take(binary.length - db.length)\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnniqh67s.scala:17)\n\tat Problem.main(tmpnniqh67s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009450
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.dropRight(binary.length - 2)\n    \
    \    result + db + binary.dropLeft(binary.length - 2)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqps6_kuo.scala:14:29 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        result + db + binary.dropLeft(binary.length -\
    \ \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      value dropLeft is not a member of String\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009430
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        var binary = \"\"\n        var remainder = decimal\n\
    \        while(decimal != 0) {\n            decimal /= 2\n            binary +=\
    \ \"0\"\n        }\n        while(decimal != 0) {\n            decimal /= 2\n\
    \            binary += \"1\"\n        }\n        binary += \"db\"\n        while(decimal\
    \ != 0) {\n            decimal /= 2\n            binary += \"0\"\n        }\n\
    \        while(decimal != 0) {\n            decimal /= 2\n            binary +=\
    \ \"1\"\n        }\n        binary += \"db\"\n        while(decimal != 0) {\n\
    \            decimal /= 2\n            binary += \"0\"\n        }\n        while(decimal\
    \ != 0) {\n            decimal /= 2\n            binary += \"1\"\n        }\n\
    \        binary += \"db\"\n        while(decimal != 0) {\n            decimal\
    \ /= 2\n            binary += \"0\"\n        }\n        while(decimal != 0) {\n\
    \            decimal /= 2\n            binary += \"1\"\n        }\n        binary\
    \ += \"db\"\n        while(decimal != 0) {\n            decimal /= 2\n       \
    \     binary += \"0\"\n        }\n        while(decimal != 0) {\n            decimal\
    \ /= 2\n            binary += \"1\"\n        }\n        binary += \"db\"\n   \
    \     while(decimal != 0) {\n            decimal /= 2\n            binary += \"\
    0\"\n        }\n        while(decimal != 0) {\n            decimal /= 2\n    \
    \        binary += \"1\"\n        }\n        binary += \"db\"\n        while(decimal\
    \ != 0) {\n            decimal /= 2\n            binary += \"0\"\n        }\n\
    \        while(decimal != 0) {\n            decimal /= 2\n            binary +=\
    \ \"1\"\n        }\n        binary += \"db\"\n        while(decimal != 0) {\n\
    \            decimal /= 2\n            binary += \"0\"\n        }\n        while(decimal\
    \ != 0) {\n            decimal /= 2\n            binary += \"1\"\n        }\n\
    \        binary += \"db\"\n        while(decimal != 0) {\n            decimal\
    \ /= 2\n            binary += \"0\"\n        }\n        while(decimal != 0) {\n\
    \            decimal /= 2\n            binary += \"1\"\n        }\n        binary\
    \ += \"db\"\n        while(decimal != 0) {\n            decimal /= 2\n       \
    \     binary += \"0\"\n        }\n        while(decimal != 0) {\n            decimal\
    \ /= 2\n            binary += \"1\"\n        }\n        binary += \"db\"\n   \
    \     while(decimal != 0) {\n            decimal /= 2\n            binary += \"\
    0\"\n        }\n        while(decimal != 0) {\n            decimal /= 2\n    \
    \        binary += \"1\"\n        }\n        binary += \"db\"\n        while(decimal\
    \ != 0) {\n            decimal /= 2\n            binary += \"0\"\n        }\n\
    \        while(decimal != 0) {\n            decimal /= 2\n            binary +=\
    \ \"1\"\n        }\n        binary += \"db\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpw7z8jsxy.scala:120:18 ----------------------------------------\e\
    [0m\e[0m\n\e[31m120 |\e[0m        binary += \"db\n\e[31m\e[31m    |\e[0m     \
    \             ^\e[0m\n\e[31m    |\e[0m                  unclosed string literal\n\
    \e[31m\e[31m-- Error: /tmp/tmpw7z8jsxy.scala:122:34 ----------------------------------------\e\
    [0m\e[0m\n\e[31m122 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m:\
    \ \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m    |\e[0m           \
    \                       ^\e[0m\n\e[31m    |\e[0m                             \
    \  end of statement expected but '=' found\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpw7z8jsxy.scala:14:20 ------------------------\e[0m\e[0m\n\e[31m14 |\e\
    [0m            decimal /= \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value /= is not a member of Long - did you mean\
    \ decimal.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpw7z8jsxy.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m            decimal /= \e\
    [31m2\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \            value /= is not a member of Long - did you mean decimal.!=?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpw7z8jsxy.scala:23:20 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            decimal /= \e[31m2\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value /= is not a member\
    \ of Long - did you mean decimal.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpw7z8jsxy.scala:27:20\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m            decimal /= \e\
    [31m2\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \            value /= is not a member of Long - did you mean decimal.!=?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpw7z8jsxy.scala:32:20 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            decimal /= \e[31m2\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value /= is not a member\
    \ of Long - did you mean decimal.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpw7z8jsxy.scala:36:20\
    \ ------------------------\e[0m"
  stdout: ''
  timestamp: 1660009451
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ extraChars = binary.substring(binary.length - 2)\n        val extraCharsLen\
    \ = extraChars.length\n        val extraCharsStr = \"db\" + extraChars\n     \
    \   val binaryLen = binary.length\n        val binaryStr = \"db\" + binary\n \
    \       val result = extraCharsStr + binaryStr\n        result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\"\
    )));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpcmikjr09.scala:12)\n\
    \tat Problem$.main(tmpcmikjr09.scala:21)\n\tat Problem.main(tmpcmikjr09.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(binary.length - db.length)\
    \ + db\n        return result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpjrqc7pst.scala:13)\n\
    \tat Problem$.main(tmpjrqc7pst.scala:17)\n\tat Problem.main(tmpjrqc7pst.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(binary.length - 2)\n    \
    \    result + db + binary.substring(0, binary.length - 2)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpl0wnsjlj.scala:13)\n\
    \tat Problem$.main(tmpl0wnsjlj.scala:17)\n\tat Problem.main(tmpl0wnsjlj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009430
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(binary.length - 2)\n    \
    \    result + db\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmp_0mmyjdp.scala:13)\n\
    \tat Problem$.main(tmp_0mmyjdp.scala:17)\n\tat Problem.main(tmp_0mmyjdp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009440
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n   \
    \     val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        binary.dropRight(binary.length\
    \ + 2)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwtn1uir0.scala:15)\n\tat Problem.main(tmpwtn1uir0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(binary.length - db.length,\
    \ binary.length)\n        result + db\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat Problem$.decimalToBinary(tmpn7kgvxio.scala:13)\n\tat Problem$.main(tmpn7kgvxio.scala:17)\n\
    \tat Problem.main(tmpn7kgvxio.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009430
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.dropRight(binary.length - db.length)\
    \ + db + binary.drop(binary.length - db.length)\n        return result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpezs5ez4i.scala:17)\n\tat Problem.main(tmpezs5ez4i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009431
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        binary.substring(0,binary.length-1)+db+binary.substring(binary.length-1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnrgyzc1y.scala:16)\n\tat Problem.main(tmpnrgyzc1y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009430
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(binary.length - 2)\n    \
    \    val result = db + result\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9k4_2j1_.scala:14:12 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = db + result\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mresult\
    \ is already defined as \e[33mvalue\e[0m \e[35mresult\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n1 error found\n"
  stdout: ''
  timestamp: 1660009446
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ extraChars = if (binary == decimal.toBinaryString) \"\" else binary\n      \
    \  val extraCharsLen = extraChars.length\n        val extraCharsLen2 = extraCharsLen\
    \ / 2\n        val extraCharsLen3 = extraCharsLen - extraCharsLen2\n        val\
    \ extraCharsLen4 = extraCharsLen - extraCharsLen2 - extraCharsLen3\n        val\
    \ extraCharsLen5 = extraCharsLen - extraCharsLen2 - extraCharsLen3 - extraCharsLen4\n\
    \        val extraCharsLen6 = extraCharsLen - extraCharsLen2 - extraCharsLen3\
    \ - extraCharsLen4 - extraCharsLen5\n        val extraCharsLen7 = extraCharsLen\
    \ - extraCharsLen2 - extraCharsLen3 - extraCharsLen4 - extraCharsLen5 - extraCharsLen6\n\
    \        val extraCharsLen8 = extraCharsLen - extraCharsLen2 - extraCharsLen3\
    \ - extraCharsLen4 - extraCharsLen5 - extraCharsLen6 - extraCharsLen7\n      \
    \  val extraCharsLen9 = extraCharsLen - extraCharsLen2 - extraCharsLen3 - extraCharsLen4\
    \ - extraCharsLen5 - extraCharsLen6 - extraCharsLen7 - extraCharsLen8\n      \
    \  val extraCharsLen10 = extraCharsLen - extraCharsLen2 - extraCharsLen3 - extraCharsLen4\
    \ - extraCharsLen5 - extraCharsLen6 - extraCharsLen7 - extraCharsLen8 - extraCharsLen9\n\
    \        val extraCharsLen11 = extraCharsLen - extraCharsLen2 - extraCharsLen3\
    \ - extraCharsLen4 - extraCharsLen5 - extraCharsLen6 - extraCharsLen7 - extraCharsLen8\
    \ - extraCharsLen9 - extraCharsLen10\n        val extraCharsLen12 = extraCharsLen\
    \ - extraCharsLen2 - extraCharsLen3 - extraCharsLen4 - extraCharsLen5 - extraCharsLen6\
    \ - extraCharsLen7 - extraCharsLen8 - extraCharsLen9 - extraCharsLen10 - extraCharsLen11\n\
    \        val extraCharsLen13 = extraCharsLen - extraCharsLen2 - extraCharsLen3\
    \ - extraCharsLen4 - extraCharsLen5 - extra\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf11w0xy5.scala:25:114 -----------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextraCharsLen13\e[0m = extraCharsLen\
    \ - extraCharsLen2 - extraCharsLen3 - extraCharsLen4 - extraCharsLen5 - extra\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                          ^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                                        Not found: extra\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpf11w0xy5.scala:26:5\
    \ ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        binary.substring(0,1)\
    \ + binary.substring(1,binary.length-1) + binary.substring(binary.length-1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin 1, end 0, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat Problem$.decimalToBinary(tmplccgndwi.scala:12)\n\tat Problem$.main(tmplccgndwi.scala:15)\n\
    \tat Problem.main(tmplccgndwi.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009450
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.dropRight(binary.length - db.length)\
    \ + db + binary.drop(binary.length - db.length)\n        return result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpezs5ez4i.scala:17)\n\tat Problem.main(tmpezs5ez4i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009431
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n   \
    \     val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e"
  stdout: ''
  timestamp: 1660009421
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ extraChars = binary.substring(binary.length - 2)\n        val extraCharsLength\
    \ = extraChars.length\n        val extraCharsLengthInt = extraCharsLength.toInt\n\
    \        val extraCharsLengthString = extraChars.substring(extraCharsLengthInt\
    \ - 1)\n        val extraCharsLengthStringInt = extraCharsLengthString.toInt\n\
    \        val extraCharsLengthStringString = extraCharsLengthString.substring(extraCharsLengthStringInt\
    \ - 1)\n        val extraCharsLengthStringIntString = extraCharsLengthStringString.toInt\n\
    \        val extraCharsLengthStringStringString = extraCharsLengthStringString.substring(extraCharsLengthStringIntString\
    \ - 1)\n        val extraCharsLengthStringIntStringString = extraCharsLengthStringStringString.toInt\n\
    \        val extraCharsLengthStringIntStringStringString = extraCharsLengthStringIntStringStringString.toInt\n\
    \        val extraCharsLengthStringIntStringStringStringString = extraCharsLengthStringIntStringStringStringString.toInt\n\
    \        val extraCharsLengthStringIntStringStringStringStringString = extraCharsLengthStringIntStringStringStringStringString.toInt\n\
    \        val extraCharsLengthStringIntStringStringStringStringStringString = extraCharsLengthStringIntStringStringStringStringStringStringString.toInt\n\
    \        val extraCharsLengthStringIntStringStringStringStringStringStringStringString\
    \ = extraCharsLengthStringIntStringStringStringStringStringStringStringStringString.toInt\n\
    \        val extraCharsLengthStringIntStringStringStringStringStringStringStringStringStringString\
    \ = extraCharsLengthStringIntStringStringStringStringStringStringStringStringStringStringString.toInt\n\
    \        val extraCharsLengthStringIntStringStringStringStringStringStringStringStringStringStringStringStringString\
    \ = extraCharsLengthStringIntStringStringStringStringStringStringStringStringStringStringStringStringString.toInt\n\
    \        val extraCharsLengthStringIntStringStringStringStringStringStringStringStringStringStringStringStringStringStringString\
    \ = extraCharsLengthStringIntStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringString.toInt\n\
    \        val extraCharsLengthStringIntStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringString\
    \ = extraCharsLengthStringIntStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringStringString.toInt\n\
    \        val extraCharsLengthStringIntStringStringStringStringStringStringStringStringStringStringStringStringStringStringString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbe1ixzlp.scala:31:4 ----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpbe1ixzlp.scala:21:58\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextraCharsLengthStringIntStringStringString\e[0m = extraCharsLengthStringIntStringStringString.toInt\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \  ^\e[0m\n\e[31m   |\e[0m  Recursive \e[33mvalue\e[0m \e[35mextraCharsLengthStringIntStringStringString\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpbe1ixzlp.scala:22:64\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextraCharsLengthStringIntStringStringStringString\e[0m = extraCharsLengthStringIntStringStringStringString.toInt\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \        ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mextraCharsLengthStringIntStringStringStringString\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpbe1ixzlp.scala:23:70\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextraCharsLengthStringIntStringStringStringStringString\e[0m = extraCharsLengthStringIntStringStringStringStringString.toInt\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \              ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mextraCharsLengthStringIntStringStringStringStringString\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbe1ixzlp.scala:24:76\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mextraCharsLengthStringIntStringStringStringStringStringString\e[0m = extraCharsLengthStringIntStringStringStringStri"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.substring(binary.length - 2)\n        val binary = binary.substring(0,\
    \ binary.length - 2)\n        val binary = binary.toCharArray\n        val binary\
    \ = binary.map(x => if (x == '1') '0' else '1')\n        val binary = binary.mkString(\"\
    \")\n        val binary = binary.concat(\"db\")\n        val binary = binary.concat(\"\
    db\")\n        binary.toString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkh172988.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.substring(binary.length\
    \ - \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpkh172988.scala:13:12 ---------------------------\e[0m\e[0m\n\e\
    [31m13 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.substring(\e[31m0\e\
    [0m, binary.length - \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpkh172988.scala:14:12 ---------------------------\e[0m\e[0m\n\e\
    [31m14 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.toCharArray\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkh172988.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.map(\e[36mx\e[0m => \e[33mif\e[0m (x == \e[31m'1'\e\
    [0m) \e[31m'0'\e[0m \e[33melse\e[0m \e[31m'1'\e[0m)\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpkh172988.scala:16:12 ---------------------------\e[0m\e[0m\n\e[31m16\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = "
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.dropRight(binary.length - 2)\n    \
    \    result + db + binary.dropLeft(binary.length - 2)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqps6_kuo.scala:14:29 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        result + db + binary.dropLeft(binary.length -\
    \ \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      value dropLeft is not a member of String\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009430
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n   \
    \     val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp28e0p1l4.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp28e0p1l4.scala:13:12 ---------------------------\e[0m\e[0m\n\e\
    [31m13 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is\
    \ already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp28e0p1l4.scala:14:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp28e0p1l4.scala:15:12 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp28e0p1l4.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is "
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.substring(binary.length - 2)\n        val binary = binary.substring(0,\
    \ binary.length - 2)\n        val binary = binary.reverse\n        val binary\
    \ = binary.reverse\n        val binary = binary.reverse\n        val binary =\
    \ binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n\
    \        val binary = binary.reverse\n        val binary = binary.reverse\n  \
    \      val binary = binary.reverse\n        val binary = binary.reverse\n    \
    \    val binary = binary.reverse\n        val binary = binary.reverse\n      \
    \  val binary = binary.reverse\n        val binary = binary.reverse\n        val\
    \ binary = binary.reverse\n        val binary = binary.reverse\n        val binary\
    \ = binary.reverse\n        val binary = binary.reverse\n        val binary =\
    \ binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n\
    \        val binary = binary.reverse\n        val binary = binary.reverse\n  \
    \      val binary = binary.reverse\n        val binary = binary.reverse\n    \
    \    val binary = binary.reverse\n        val binary = binary.reverse\n      \
    \  val binary = binary.reverse\n        val binary = binary.reverse\n        val\
    \ binary = binary.reverse\n        val binary = binary.reverse\n        val binary\
    \ = binary.reverse\n        val binary = binary.reverse\n        val binary =\
    \ binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n\
    \        val binary = binary.reverse\n        val binary = binary.reverse\n  \
    \      val binary = binary.reverse\n        val binary = binary.reverse\n    \
    \    val binary = binary.reverse\n        val binary = binary.reverse\n      \
    \  val binary = binary.reverse\n        val binary = binary.reverse\n        val\
    \ binary = binary.reverse\n        val binary = binary.reverse\n        val binary\
    \ = binary.reverse\n        val binary = binary.reverse\n        val binary =\
    \ binary.reverse\n        val binary = binary.reverse\n        val binary = binary.reverse\n\
    \        val binary = binary.reverse\n        val binary = binary.reverse\n  \
    \      val binary = binary.reverse\n        val binary = binary.reverse\n    \
    \    val binary = binary.reverse\n        val binary = binary.reverse\n      \
    \  val binary = binary.reverse\n        val binary = binary.reverse\n        val\
    \ binary = binary.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmvw2hb70.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.substring(binary.length\
    \ - \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpmvw2hb70.scala:13:12 ---------------------------\e[0m\e[0m\n\e\
    [31m13 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.substring(\e[31m0\e\
    [0m, binary.length - \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpmvw2hb70.scala:14:12 ---------------------------\e[0m\e[0m\n\e\
    [31m14 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is\
    \ already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmvw2hb70.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpmvw2hb70.scala:16:12 ---------------------------\e[0m\e[0m\n\e\
    [31m16 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is\
    \ already defined as \e[33m"
  stdout: ''
  timestamp: 1660009430
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ result = binary.substring(binary.length - 2)\n        result + binary.substring(0,\
    \ binary.length - 2)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmp9ligp8o6.scala:12)\n\
    \tat Problem$.main(tmp9ligp8o6.scala:16)\n\tat Problem.main(tmp9ligp8o6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009450
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        binary.dropRight(binary.length\
    \ + 2)\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwtn1uir0.scala:15)\n\tat Problem.main(tmpwtn1uir0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        binary.substring(binary.length-1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcvjcs0_z.scala:15)\n\tat Problem.main(tmpcvjcs0_z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009450
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(0,binary.length-1)\n    \
    \    val dbResult = binary.substring(binary.length-1)\n        result + db + dbResult\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzs577bpf.scala:18)\n\tat Problem.main(tmpzs577bpf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009450
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ extraChars = if (binary == decimal.toBinaryString) \"\" else binary\n      \
    \  val db = \"db\" + extraChars\n        binary.dropRight(binary.length - extraChars.length)\
    \ + db + binary.takeRight(binary.length - extraChars.length)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_dohmwbd.scala:17)\n\tat Problem.main(tmp_dohmwbd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009450
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ extraChars = binary.substring(binary.length - 2)\n        val extraCharsReversed\
    \ = extraChars.reverse\n        val extraCharsReversedString = extraCharsReversed.mkString\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extra\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7qgzmwuj.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7qgzmwuj.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextraCharsReversedStringLength\e[0m = extraCharsReversedString.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextraCharsReversedStringLength is already defined as \e[33mvalue\e\
    [0m \e[35mextraCharsReversedStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7qgzmwuj.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mextraCharsReversedStringLength\e\
    [0m = extraCharsReversedString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextraCharsReversedStringLength is already defined as \e[33mvalue\e\
    [0m \e[35mextraCharsReversedStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7qgzmwuj.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mextraCharsReversedStringLength\e\
    [0m = extraCharsReversedString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextraCharsReversedStringLength is already defined as \e[33mvalue\e\
    [0m \e[35mextraCharsReversedStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7qgzmwuj.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mextraCharsReversedStringLength\e\
    [0m = extraCharsReversedString.length\n\e[31m\e[31m   |\e"
  stdout: ''
  timestamp: 1660009438
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n   \
    \     val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbb1m7gj6.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:12:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:13:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:14:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb1m7gj6.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e"
  stdout: ''
  timestamp: 1660009421
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(0,binary.length-1)\n    \
    \    val extra = binary.substring(binary.length-1)\n        result + db + extra\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwq18ir3a.scala:18)\n\tat Problem.main(tmpwq18ir3a.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009451
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(0,binary.length-1)\n    \
    \    result + db + binary.substring(binary.length-1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa06x9obf.scala:17)\n\tat Problem.main(tmpa06x9obf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009421
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ extraChars = binary.substring(binary.length - 2)\n        val extraCharsReversed\
    \ = extraChars.reverse\n        val extraCharsReversedString = extraCharsReversed.mkString\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extraCharsReversedStringLength = extraCharsReversedString.length\n\
    \        val extra\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7qgzmwuj.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7qgzmwuj.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextraCharsReversedStringLength\e[0m = extraCharsReversedString.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextraCharsReversedStringLength is already defined as \e[33mvalue\e\
    [0m \e[35mextraCharsReversedStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7qgzmwuj.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mextraCharsReversedStringLength\e\
    [0m = extraCharsReversedString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextraCharsReversedStringLength is already defined as \e[33mvalue\e\
    [0m \e[35mextraCharsReversedStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7qgzmwuj.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mextraCharsReversedStringLength\e\
    [0m = extraCharsReversedString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextraCharsReversedStringLength is already defined as \e[33mvalue\e\
    [0m \e[35mextraCharsReversedStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7qgzmwuj.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mextraCharsReversedStringLength\e\
    [0m = extraCharsReversedString.length\n\e[31m\e[31m   |\e"
  stdout: ''
  timestamp: 1660009438
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ binary = binary.substring(binary.length - 2)\n        val binary = binary.substring(0,\
    \ binary.length - 2)\n        val binary = binary.toCharArray\n        val binary\
    \ = binary.map(x => if (x == '1') '0' else '1')\n        val binary = binary.mkString(\"\
    \")\n        val binary = binary.concat(\"db\")\n        binary\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\"\
    )));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv43qenv_.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.substring(binary.length\
    \ - \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv43qenv_.scala:13:12 ---------------------------\e[0m\e[0m\n\e\
    [31m13 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.substring(\e[31m0\e\
    [0m, binary.length - \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv43qenv_.scala:14:12 ---------------------------\e[0m\e[0m\n\e\
    [31m14 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.toCharArray\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv43qenv_.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.map(\e[36mx\e[0m => \e[33mif\e[0m (x == \e[31m'1'\e\
    [0m) \e[31m'0'\e[0m \e[33melse\e[0m \e[31m'1'\e[0m)\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv43qenv_.scala:16:12 ---------------------------\e[0m\e[0m\n\e[31m16\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = "
  stdout: ''
  timestamp: 1660009439
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.dropRight(binary.length - 2)\n    \
    \    result + db + binary.takeRight(binary.length - 2)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n\
    \    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"\
    db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpg40vga0_.scala:17)\n\tat Problem.main(tmpg40vga0_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009441
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        var binary = \"\"\n        var remainder = decimal\n\
    \        var remainder2 = decimal\n        while(decimal != 0) {\n           \
    \ decimal /= 2\n            remainder2 = remainder * 2\n            binary = remainder2\
    \ + binary\n            remainder = decimal % 2\n        }\n        binary = binary\
    \ + \"db\"\n        return binary\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(decimalToBinary((0l)).equals((\"db0db\")));\n    assert(decimalToBinary((32l)).equals((\"\
    db100000db\")));\n    assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n\
    \    assert(decimalToBinary((15l)).equals((\"db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpx4zgd5uc.scala:15:20 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            decimal /= \e[31m2\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value /= is not a member\
    \ of Long - did you mean decimal.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660009450
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ bin = binary.substring(binary.length - 2)\n        val binary = bin.substring(0,\
    \ bin.length - 1)\n        val binary = binary.concat(\"db\")\n        binary\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp16ui0hyo.scala:13:12 ---------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = bin.substring(\e\
    [31m0\e[0m, bin.length - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp16ui0hyo.scala:14:12 ---------------------------\e[0m\e[0m\n\e\
    [31m14 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.concat(\e[31m\"\
    db\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n2 errors found\n"
  stdout: ''
  timestamp: 1660009428
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ db = \"db\"\n        val result = binary.substring(binary.length - db.length)\
    \ + db\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpj0kwa20o.scala:13)\n\
    \tat Problem$.main(tmpj0kwa20o.scala:17)\n\tat Problem.main(tmpj0kwa20o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009451
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ extraChars = binary.substring(binary.length - 2)\n        val extraCharsDb =\
    \ \"db\" + extraChars\n        binary.substring(0,binary.length - 2) + extraCharsDb\
    \ + extraChars\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin -1, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.decimalToBinary(tmpq4lgj71b.scala:12)\n\
    \tat Problem$.main(tmpq4lgj71b.scala:17)\n\tat Problem.main(tmpq4lgj71b.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009450
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ extraChars = if (binary.length < 8) \"db\" else \"\"\n        binary.padToLength(8)\
    \ + extraChars\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpudqmhkcz.scala:13:15 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        binary.padToLength(\e[31m8\e[0m) + extraChars\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value\
    \ padToLength is not a member of String\n1 error found\n"
  stdout: ''
  timestamp: 1660009451
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given a number in decimal form and your task is to convert\
    \ it to\n    // binary format. The function should return a string, with each\
    \ character representing a binary\n    // number. Each character in the string\
    \ will be '0' or '1'.\n    // There will be an extra couple of characters 'db'\
    \ at the beginning and at the end of the string.\n    // The extra characters\
    \ are there to help with the format.\n    // Examples:\n    def decimalToBinary(decimal\
    \ : Long) : String = {\n        val binary = decimal.toBinaryString\n        val\
    \ bin = binary.dropRight(binary.length-1)\n        val bin2 = bin.dropRight(bin.length-1)\n\
    \        val bin3 = bin2.dropRight(bin2.length-1)\n        val bin4 = bin3.dropRight(bin3.length-1)\n\
    \        val bin5 = bin4.dropRight(bin4.length-1)\n        val bin6 = bin5.dropRight(bin5.length-1)\n\
    \        val bin7 = bin6.dropRight(bin6.length-1)\n        val bin8 = bin7.dropRight(bin7.length-1)\n\
    \        val bin9 = bin8.dropRight(bin8.length-1)\n        val bin10 = bin9.dropRight(bin9.length-1)\n\
    \        val bin11 = bin10.dropRight(bin10.length-1)\n        val bin12 = bin11.dropRight(bin11.length-1)\n\
    \        val bin13 = bin12.dropRight(bin12.length-1)\n        val bin14 = bin13.dropRight(bin13.length-1)\n\
    \        val bin15 = bin14.dropRight(bin14.length-1)\n        val bin16 = bin15.dropRight(bin15.length-1)\n\
    \        val bin17 = bin16.dropRight(bin16.length-1)\n        val bin18 = bin17.dropRight(bin17.length-1)\n\
    \        val bin19 = bin18.dropRight(bin18.length-1)\n        val bin20 = bin19.dropRight(bin19.length-1)\n\
    \        val bin21 = bin20.dropRight(bin20.length-1)\n        val bin22 = bin21.dropRight(bin21.length-1)\n\
    \        val bin23 = bin22.dropRight(bin22.length-1)\n        val bin24 = bin23.dropRight(bin23.length-1)\n\
    \        val bin25 = bin24.dropRight(bin24.length-1)\n        val bin26 = bin25.dropRight(bin25.length-1)\n\
    \        val bin27 = bin26.dropRight(bin26.length-1)\n        val bin28 = bin27.dropRight(bin27.length-1)\n\
    \        val bin29 = bin28.dropRight(bin28.length-1)\n        val bin30 = bin29.dropRight(bin29.length-1)\n\
    \        val bin31 = bin30.dropRight(bin30.length-1)\n        val bin32 = bin31.dropRight(bin31.length-1)\n\
    \        val bin33 = bin32.dropRight(bin32.length-1)\n        val bin34 = bin33.dropRight(bin33.length-1)\n\
    \        val bin35 = bin\n    }\n    def main(args: Array[String]) = {\n    assert(decimalToBinary((0l)).equals((\"\
    db0db\")));\n    assert(decimalToBinary((32l)).equals((\"db100000db\")));\n  \
    \  assert(decimalToBinary((103l)).equals((\"db1100111db\")));\n    assert(decimalToBinary((15l)).equals((\"\
    db1111db\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp86yvb03_.scala:47:5\
    \ ---------------------\e[0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009451
