language: scala
name: HumanEval_116_sort_array
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        // Your code here\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl8olg31u.scala:8:51\
    \ ---------------------\e[0m\e[0m\n\e[31m 8 |\e[0m    \e[33mdef\e[0m \e[36msortArray\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m]) : \e[35mList\e[0m[\e[35mLong\e\
    [0m] = {\n\e[31m\e[31m   |\e[0m                                              \
    \     ^\e[0m\n\e[31m   |\e[0m                                                \
    \   Found:    Unit\n\e[31m   |\e[0m                                          \
    \         Required: List[Long]\n\e[31m 9 |\e[0m        \e[34m// Your code here\e\
    [0m\n\e[31m10 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660008686
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decs = arr.map(_.toString.toInt)\n\
    \        val sorted = decs.sortWith((x, y) => x < y)\n        val sorted = sorted.zipWithIndex.sortWith((x,\
    \ y) => x < y).map(_._2)\n        val sorted = sorted.map(x => if (x == ones)\
    \ x else x + ones)\n        val sorted = sorted.map(x => if (x < 0) -x + ones\
    \ else x)\n        sorted.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzi_14nql.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = sorted.zipWithIndex.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => x < y).map(_._2)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msorted is already defined as \e[33mvalue\e[0m \e[35msorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpzi_14nql.scala:13:12 ---------------------------\e[0m\e[0m\n\e\
    [31m13 |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = sorted.map(\e[36mx\e[0m\
    \ => \e[33mif\e[0m (x == ones) x \e[33melse\e[0m x + ones)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msorted is already defined as \e[33mvalue\e[0m \e[35msorted\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpzi_14nql.scala:14:12 ---------------------------\e[0m\e[0m\n\e[31m14\
    \ |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = sorted.map(\e[36mx\e[0m =>\
    \ \e[33mif\e[0m (x < \e[31m0\e[0m) -x + ones \e[33melse\e[0m x)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msorted is already defined as \e[33mvalue\e[0m \e[35msorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpzi_14nql.scala:15:15 --------------------\e[0m\e[0m\n\
    \e[31m15 |\e[0m        sorted.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e\
    [0m        Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660008688
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(_ % 2 == 0).length\n        val decimals\
    \ = arr.filter(_ % 2 == 1).length\n        val sorted = arr.sortBy(x => (ones,\
    \ decimals, x))\n        sorted.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp5gb5iqx.scala:15)\n\tat Problem.main(tmpp5gb5iqx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660008689
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val twos = arr.count(_ ==\
    \ 2)\n        val threes = arr.count(_ == 3)\n        val fours = arr.count(_\
    \ == 4)\n        val fives = arr.count(_ == 5)\n        val sixes = arr.count(_\
    \ == 6)\n        val sevens = arr.count(_ == 7)\n        val eights = arr.count(_\
    \ == 8)\n        val nines = arr.count(_ == 9)\n        val tens = arr.count(_\
    \ == 10)\n        val hundreds = arr.count(_ == 100)\n        val thousands =\
    \ arr.count(_ == 1000)\n        val millions = arr.count(_ == 1000000)\n     \
    \   val billions = arr.count(_ == 1000000000)\n        val trillions = arr.count(_\
    \ == 1000000000000)\n        val quadrillions = arr.count(_ == 1000000000000000)\n\
    \        val quintillions = arr.count(_ == 1000000000000000000)\n        val onesAndZeros\
    \ = arr.count(_ == 1 && _ == 0)\n        val onesAndOnes = arr.count(_ == 1 &&\
    \ _ == 1)\n        val onesAndTwos = arr.count(_ == 1 && _ == 2)\n        val\
    \ onesAndThrees = arr.count(_ == 1 && _ == 3)\n        val onesAndFours = arr.count(_\
    \ == 1 && _ == 4)\n        val onesAndFives = arr.count(_ == 1 && _ == 5)\n  \
    \      val onesAndSixes = arr.count(_ == 1 && _ == 6)\n        val onesAndSevens\
    \ = arr.count(_ == 1 && _ == 7)\n        val onesAndEights = arr.count(_ == 1\
    \ && _ == 8)\n        val onesAndNines = arr.count(_ == 1 && _ == 9)\n       \
    \ val onesAndTens = arr.count(_ == 1 && _ == 10)\n        val onesAndHundreds\
    \ = arr.count(_ == 1 && _ == 100)\n        val onesAndThousands = arr.count(_\
    \ == 1 && _ == 1000)\n        val onesAndMillions = arr.count(_ == 1 && _ == 1000000)\n\
    \        val onesAndBillions = arr.count(_ == 1 && _ == 1000000000)\n        val\
    \ onesAndTrillions = arr.count(_ == 1 && _ == 1000000000000)\n        val onesAndQuadrillions\
    \ = arr.count(_ == 1 && _ == 1000000000000000)\n        val onesAndQuintillions\
    \ = arr.count(_ == 1 && _ == 1000000000000000000)\n        val onesAndOnesAndZeros\
    \ = arr.count(_ == 1 && \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmppmcvho8c.scala:44:53 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36monesAndOnesAndZeros\e[0m\
    \ = arr.count(_ == \e[31m1\e[0m && \n\e[31m\e[31m   |\e[0m                   \
    \                                  ^\e[0m\n\e[31m   |\e[0m                   \
    \                    expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmppmcvho8c.scala:23:39 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mtrillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000\e[0m)\n\e[31m\e[31m   |\e[0m                        \
    \               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \             number too large\n\e[31m\e[31m-- Error: /tmp/tmppmcvho8c.scala:24:42\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m24 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.count(_ == \e[31m1000000000000000\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                          ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                          number too large\n\
    \e[31m\e[31m-- Error: /tmp/tmppmcvho8c.scala:25:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mquintillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m                  \
    \                        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                               number too large\n\e[31m\e[31m-- [E086] Syntax\
    \ Error: /tmp/tmppmcvho8c.scala:26:37 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36monesAndZeros\e[0m = arr.count(_ == \e\
    [31m1\e[0m && _ == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                      \
    \               ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \          Wrong number of parameters, expected: 1\n\e[31m\e[31m-- [E086] Syntax\
    \ Error: /tmp/tmppmcvho8c.scala:27:36 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36monesAndOnes\e[0m = arr.count(_ == \e\
    [31m1\e[0m "
  stdout: ''
  timestamp: 1660008688
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val twos = arr.count(_ ==\
    \ 2)\n        val threes = arr.count(_ == 3)\n        val fours = arr.count(_\
    \ == 4)\n        val fives = arr.count(_ == 5)\n        val sixes = arr.count(_\
    \ == 6)\n        val sevens = arr.count(_ == 7)\n        val eights = arr.count(_\
    \ == 8)\n        val nines = arr.count(_ == 9)\n        val tens = arr.count(_\
    \ == 10)\n        val hundreds = arr.count(_ == 100)\n        val thousands =\
    \ arr.count(_ == 1000)\n        val millions = arr.count(_ == 1000000)\n     \
    \   val billions = arr.count(_ == 1000000000)\n        val trillions = arr.count(_\
    \ == 1000000000000)\n        val quadrillions = arr.count(_ == 1000000000000000)\n\
    \        val quintillions = arr.count(_ == 1000000000000000000)\n        val onesAndZeros\
    \ = arr.count(_ == 1 && _ == 0)\n        val onesAndOnes = arr.count(_ == 1 &&\
    \ _ == 1)\n        val onesAndTwos = arr.count(_ == 1 && _ == 2)\n        val\
    \ onesAndThrees = arr.count(_ == 1 && _ == 3)\n        val onesAndFours = arr.count(_\
    \ == 1 && _ == 4)\n        val onesAndFives = arr.count(_ == 1 && _ == 5)\n  \
    \      val onesAndSixes = arr.count(_ == 1 && _ == 6)\n        val onesAndSevens\
    \ = arr.count(_ == 1 && _ == 7)\n        val onesAndEights = arr.count(_ == 1\
    \ && _ == 8)\n        val onesAndNines = arr.count(_ == 1 && _ == 9)\n       \
    \ val onesAndTens = arr.count(_ == 1 && _ == 10)\n        val onesAndHundreds\
    \ = arr.count(_ == 1 && _ == 100)\n        val onesAndThousands = arr.count(_\
    \ == 1 && _ == 1000)\n        val onesAndMillions = arr.count(_ == 1 && _ == 1000000)\n\
    \        val onesAndBillions = arr.count(_ == 1 && _ == 1000000000)\n        val\
    \ onesAndTrillions = arr.count(_ == 1 && _ == 1000000000000)\n        val onesAndQuadrillions\
    \ = arr.count(_ == 1 && _ == 1000000000000000)\n        val onesAndQuintillions\
    \ = arr.count(_ == 1 && _ == 1000000000000000000)\n        val onesAndOnesAndZeros\
    \ = arr.count(_ == 1 && \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmppmcvho8c.scala:44:53 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36monesAndOnesAndZeros\e[0m\
    \ = arr.count(_ == \e[31m1\e[0m && \n\e[31m\e[31m   |\e[0m                   \
    \                                  ^\e[0m\n\e[31m   |\e[0m                   \
    \                    expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmppmcvho8c.scala:23:39 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mtrillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000\e[0m)\n\e[31m\e[31m   |\e[0m                        \
    \               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \             number too large\n\e[31m\e[31m-- Error: /tmp/tmppmcvho8c.scala:24:42\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m24 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.count(_ == \e[31m1000000000000000\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                          ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                          number too large\n\
    \e[31m\e[31m-- Error: /tmp/tmppmcvho8c.scala:25:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mquintillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m                  \
    \                        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                               number too large\n\e[31m\e[31m-- [E086] Syntax\
    \ Error: /tmp/tmppmcvho8c.scala:26:37 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36monesAndZeros\e[0m = arr.count(_ == \e\
    [31m1\e[0m && _ == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                      \
    \               ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \          Wrong number of parameters, expected: 1\n\e[31m\e[31m-- [E086] Syntax\
    \ Error: /tmp/tmppmcvho8c.scala:27:36 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36monesAndOnes\e[0m = arr.count(_ == \e\
    [31m1\e[0m "
  stdout: ''
  timestamp: 1660008688
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(x => x % 2 == 0).length\n        val twos\
    \ = arr.filter(x => x % 2 == 1).length\n        val threes = arr.filter(x => x\
    \ % 3 == 0).length\n        val fours = arr.filter(x => x % 4 == 0).length\n \
    \       val fives = arr.filter(x => x % 5 == 0).length\n        val sixes = arr.filter(x\
    \ => x % 6 == 0).length\n        val sevens = arr.filter(x => x % 7 == 0).length\n\
    \        val eights = arr.filter(x => x % 8 == 0).length\n        val nines =\
    \ arr.filter(x => x % 9 == 0).length\n        val tens = arr.filter(x => x % 10\
    \ == 0).length\n        val hundreds = arr.filter(x => x % 100 == 0).length\n\
    \        val thousands = arr.filter(x => x % 1000 == 0).length\n        val millions\
    \ = arr.filter(x => x % 1000000 == 0).length\n        val billions = arr.filter(x\
    \ => x % 1000000000 == 0).length\n        val trillions = arr.filter(x => x %\
    \ 1000000000000 == 0).length\n        val quadrillions = arr.filter(x => x % 1000000000000000\
    \ == 0).length\n        val quintillions = arr.filter(x => x % 1000000000000000000\
    \ == 0).length\n        val onesAndZeros = arr.filter(x => x % 1 == 0).length\n\
    \        val onesAndOnes = arr.filter(x => x % 1 == 1).length\n        val onesAndTwos\
    \ = arr.filter(x => x % 1 == 2).length\n        val onesAndThrees = arr.filter(x\
    \ => x % 1 == 3).length\n        val onesAndFours = arr.filter(x => x % 1 == 4).length\n\
    \        val onesAndFives = arr.filter(x => x % 1 == 5).length\n        val onesAndSixes\
    \ = arr.filter(x => x % 1 == 6).length\n        val onesAndSevens = arr.filter(x\
    \ => x % 1 == 7).length\n        val onesAndEights = arr.filter(x => x % 1 ==\
    \ 8).length\n        val onesAndNines = arr.filter(x => x % 1 == 9).length\n \
    \       val onesAndTens = arr.filter(x => x % 1 == 10).length\n        val onesAndHundreds\
    \ = arr.filter(x => x % 1 == 100).length\n        val onesAndThousands = arr.filter(x\
    \ => x % 1 == 1000).length\n        val onesAndMillions = arr.filter(x \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxulg6j7g.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmpxulg6j7g.scala:23:44\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m23 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.filter(\e[36mx\e[0m => x % \e[31m1000000000000\e\
    [0m == \e[31m0\e[0m).length\n\e[31m\e[31m   |\e[0m                           \
    \                 ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \                    number too large\n\e[31m\e[31m-- Error: /tmp/tmpxulg6j7g.scala:24:47\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m24 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.filter(\e[36mx\e[0m => x % \e[31m1000000000000000\e\
    [0m == \e[31m0\e[0m).length\n\e[31m\e[31m   |\e[0m                           \
    \                    ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \                             number too large\n\e[31m\e[31m-- Error: /tmp/tmpxulg6j7g.scala:25:47\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m25 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquintillions\e[0m = arr.filter(\e[36mx\e[0m => x % \e[31m1000000000000000000\e\
    [0m == \e[31m0\e[0m).length\n\e[31m\e[31m   |\e[0m                           \
    \                    ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                                number too large\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpxulg6j7g.scala:39:41 ------------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m        \e[33mval\e[0m \e[36monesAndMillions\e[0m = arr.filter(x \n\e\
    [31m\e[31m   |\e[0m                                         ^\e[0m\n\e[31m   |\e\
    [0m                                         Not found: x\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxulg6j7g.scala:40:5 ---------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when "
  stdout: ''
  timestamp: 1660008687
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val zeros = arr.count(_ ==\
    \ 0)\n        val onesArr = arr.filter(_ == 1).sorted\n        val zerosArr =\
    \ arr.filter(_ == 0).sorted\n        val onesCount = onesArr.count(_ == 1)\n \
    \       val zerosCount = zerosArr.count(_ == 0)\n        val onesDecimal = onesArr.count(_\
    \ == 1) * 10\n        val zerosDecimal = zerosArr.count(_ == 0) * 10\n       \
    \ val onesDecimalCount = onesArr.count(_ == 1) * onesCount\n        val zerosDecimalCount\
    \ = zerosArr.count(_ == 0) * zerosCount\n        val onesDecimalCount = onesArr.count(_\
    \ == 1) * onesCount\n        val zerosDecimalCount = zerosArr.count(_ == 0) *\
    \ zerosCount\n        val onesDecimalCount = onesArr.count(_ == 1) * onesCount\n\
    \        val zerosDecimalCount = zerosArr.count(_ == 0) * zerosCount\n       \
    \ val onesDecimalCount = onesArr.count(_ == 1) * onesCount\n        val zerosDecimalCount\
    \ = zerosArr.count(_ == 0) * zerosCount\n        val onesDecimalCount = onesArr.count(_\
    \ == 1) * onesCount\n        val zerosDecimalCount = zerosArr.count(_ == 0) *\
    \ zerosCount\n        val onesDecimalCount = onesArr.count(_ == 1) * onesCount\n\
    \        val zerosDecimalCount = zerosArr.count(_ == 0) * zerosCount\n       \
    \ val onesDecimalCount = onesArr.count(_ == 1) * onesCount\n        val zerosDecimalCount\
    \ = zerosArr.count(_ == 0) * zerosCount\n        val onesDecimalCount = onesArr.count(_\
    \ == 1) * onesCount\n        val zerosDecimalCount = zerosArr.count(_ == 0) *\
    \ zerosCount\n        val onesDecimalCount = onesArr.count(_ == 1) * onesCount\n\
    \        val zerosDecimalCount = zerosArr.count(_ == 0) * zerosCount\n       \
    \ val onesDecimalCount = onesArr.count(_ == 1) * onesCount\n        val zerosDecimalCount\
    \ = zerosArr.count(_ == 0) * zerosCount\n        val onesDecimalCount = onesArr.count(_\
    \ == 1) * onesCount\n        val zerosDecimalCount = zerosArr.count(_ == 0) *\
    \ zerosCount\n        val onesDecimalCount = onesArr.count(_ == 1) * onesCount\n\
    \        val zerosDecimalCount = zerosArr.count(_ == 0) * zerosCount\n       \
    \ val \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpo4n5wn2y.scala:41:11 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpo4n5wn2y.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m =\
    \ onesArr.count(_ == \e[31m1\e[0m) * onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpo4n5wn2y.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalCount\e[0m =\
    \ zerosArr.count(_ == \e[31m0\e[0m) * zerosCount\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mzerosDecimalCount is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpo4n5wn2y.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m = onesArr.count(_\
    \ == \e[31m1\e[0m) * onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpo4n5wn2y.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalCount\e[0m =\
    \ zerosArr.count(_ == \e[31m0\e[0m) * zerosCount\n\e[31m\e[31m   |\e[0m      \
    \  ^^^"
  stdout: ''
  timestamp: 1660008687
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(_ % 2 == 0).length\n        val decimal =\
    \ arr.filter(_ % 2 == 1).length\n        val sorted = arr.sortBy(x => if (ones\
    \ == 0) x else x/10)\n        sorted.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiv61bljg.scala:15)\n\tat Problem.main(tmpiv61bljg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660008689
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(x => x % 2 == 0).length\n        val decimals\
    \ = arr.filter(x => x % 2 == 1).length\n        val result = arr.sortBy(x => if\
    \ (ones == 0) x else x / 10)\n        result.sortBy(x => if (decimals == 0) x\
    \ else x / 10).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvh_ythr0.scala:15)\n\tat Problem.main(tmpvh_ythr0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660008689
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decs = arr.map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val decs = decs.takeWhile(_ < ones)\n        val decs = decs.takeWhile(_\
    \ > 0)\n        val decs = decs.reverse\n        val decs = decs.map(_.toString.toLong)\n\
    \        val decs = decs.sortBy(_.toString.toLong)\n        val decs = decs.takeWhile(_\
    \ < ones)\n        val decs = decs.takeWhile(_ > 0)\n        val decs = decs.reverse\n\
    \        val decs = decs.map(_.toString.toLong)\n        val decs = decs.sortBy(_.toString.toLong)\n\
    \        val decs = decs.takeWhile(_ < ones)\n        val decs = decs.takeWhile(_\
    \ > 0)\n        val decs = decs.reverse\n        val decs = decs.map(_.toString.toLong)\n\
    \        val decs = decs.sortBy(_.toString.toLong)\n        val decs = decs.takeWhile(_\
    \ < ones)\n        val decs = decs.takeWhile(_ > 0)\n        val decs = decs.reverse\n\
    \        val decs = decs.map(_.toString.toLong)\n        val decs = decs.sortBy(_.toString.toLong)\n\
    \        val decs = decs.takeWhile(_ < ones)\n        val decs = decs.takeWhile(_\
    \ > 0)\n        val decs = decs.reverse\n        val decs = decs.map(_.toString.toLong)\n\
    \        val decs = decs.sortBy(_.toString.toLong)\n        val decs = decs.takeWhile(_\
    \ < ones)\n        val decs = decs.takeWhile(_ > 0)\n        val decs = decs.reverse\n\
    \        val decs = decs.map(_.toString.toLong)\n        val decs = decs.sortBy(_.toString.toLong)\n\
    \        val decs = decs.takeWhile(_ < ones)\n        val decs = decs.takeWhile(_\
    \ > 0)\n        val decs = decs.reverse\n        val decs = decs.map(_.toString.toLong)\n\
    \        val decs = decs.sortBy(_.toString.toLong)\n        val decs = decs.takeWhile(_\
    \ < ones)\n        val decs = decs.takeWhile(_ > 0)\n        val decs = decs.reverse\n\
    \        val decs = decs.map(_.toString.toLong)\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzn7ngbx8.scala:11:12 ---------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = decs.takeWhile(_\
    \ < ones)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecs is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpzn7ngbx8.scala:12:12 ---------------------------\e[0m\e[0m\n\e[31m12\
    \ |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = decs.takeWhile(_ > \e[31m0\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mdecs is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpzn7ngbx8.scala:13:12 ---------------------------\e[0m\e[0m\n\e[31m13\
    \ |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = decs.reverse\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mdecs is already defined\
    \ as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzn7ngbx8.scala:14:12 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = decs.map(_.toString.toLong)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mdecs is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpzn7ngbx8.scala:15:12 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = decs.sortBy(_.toString.toLong)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mdecs is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote th"
  stdout: ''
  timestamp: 1660008688
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val zeros = arr.count(_ ==\
    \ 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount = arr.count(_\
    \ == 0)\n        val onesDecimal = onesCount / arr.length\n        val zerosDecimal\
    \ = zerosCount / arr.length\n        val onesDecimalDecimal = onesDecimal / onesCount\n\
    \        val zerosDecimalDecimal = zerosDecimal / zerosCount\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_wjmvoel.scala:34:4 ----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_wjmvoel.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_wjmvoel.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_wjmvoel.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660008687
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decs = arr.map(_.toString.toInt)\n\
    \        val sorted = decs.sortWith(_.compare(decs(0)) == 0)\n        val result\
    \ = sorted.map(x => (ones, x))\n        result.sortWith(_.compare(_._2) == 0)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmphbc6b2rn.scala:11:35 ---------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = decs.sortWith(_.compare(decs(\e\
    [31m0\e[0m)) == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                         \
    \          ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \            Wrong number of parameters, expected: 2\n\e[31m\e[31m-- [E086] Syntax\
    \ Error: /tmp/tmphbc6b2rn.scala:13:24 ---------------------------\e[0m\e[0m\n\e\
    [31m13 |\e[0m        result.sortWith(_.compare(_._2) == \e[31m0\e[0m)\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                        Wrong number of parameters, expected: 2\n2 errors found\n"
  stdout: ''
  timestamp: 1660008681
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val zeros = arr.count(_ ==\
    \ 0)\n        val maxOnes = arr.count(_ == 1)\n        val maxZeros = arr.count(_\
    \ == 0)\n        val maxOnesDecimal = maxOnes.toDouble / ones\n        val maxZerosDecimal\
    \ = maxZeros.toDouble / zeros\n        val maxDecimal = math.max(maxOnesDecimal,\
    \ maxZerosDecimal)\n        arr.sortWith(compareByDecimal(maxDecimal))\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1rifgyq_.scala:16:21 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        arr.sortWith(compareByDecimal(maxDecimal))\n\e\
    [31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                     Not found: compareByDecimal\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660008680
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ == 0)\n        val onesDecimals = ones * decimals\n        val onesDecimalsSorted\
    \ = arr.sortBy(_ / onesDecimals)\n        onesDecimalsSorted.reverse\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArithmeticException: / by zero\n\tat Problem$.$anonfun$3(tmpsei11f01.scala:12)\n\
    \tat scala.runtime.java8.JFunction1$mcJJ$sp.apply(JFunction1$mcJJ$sp.scala:17)\n\
    \tat scala.math.Ordering$$anon$1.compare(Ordering.scala:141)\n\tat java.base/java.util.TimSort.countRunAndMakeAscending(TimSort.java:355)\n\
    \tat java.base/java.util.TimSort.sort(TimSort.java:220)\n\tat java.base/java.util.Arrays.sort(Arrays.java:1233)\n\
    \tat scala.collection.SeqOps.sorted(Seq.scala:700)\n\tat scala.collection.SeqOps.sorted$(Seq.scala:692)\n\
    \tat scala.collection.immutable.List.scala$collection$immutable$StrictOptimizedSeqOps$$super$sorted(List.scala:79)\n\
    \tat scala.collection.immutable.StrictOptimizedSeqOps.sorted(StrictOptimizedSeqOps.scala:78)\n\
    \tat scala.collection.immutable.StrictOptimizedSeqOps.sorted$(StrictOptimizedSeqOps.scala:78)\n\
    \tat scala.collection.immutable.List.sorted(List.scala:79)\n\tat scala.collection.SeqOps.sortBy(Seq.scala:754)\n\
    \tat scala.collection.SeqOps.sortBy$(Seq.scala:754)\n\tat scala.collection.AbstractSeq.sortBy(Seq.scala:1161)\n\
    \tat Problem$.sortArray(tmpsei11f01.scala:12)\n\tat Problem$.main(tmpsei11f01.scala:16)\n\
    \tat Problem.main(tmpsei11f01.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(Obje"
  stdout: ''
  timestamp: 1660008689
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(_ % 2 == 0).length\n        val twos = arr.filter(_\
    \ % 2 == 1).length\n        val decimal = arr.filter(_ % 10 == 0).length\n   \
    \     val sorted = arr.sortBy(x => (ones, twos, decimal, x))\n        sorted.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkdimcdwd.scala:16)\n\tat Problem.main(tmpkdimcdwd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660008689
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(_ % 2 == 0).size\n        val zeros = arr.filter(_\
    \ % 2 == 1).size\n        val decimals = arr.filter(_ % 10 == 0).size\n      \
    \  val decimalsDecimals = arr.filter(_ % 10 == 1).size\n        val decimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 2).size\n        val decimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 3).size\n        val decimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 4).size\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 5).size\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 6).size\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 7).size\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 8).size\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 9).size\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 0).size\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 1).size\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 2).size\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 3).size\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 4).size\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 5).size\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppjj8kome.scala:28:4 ----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmppjj8kome.scala:28:5 ---------------------\e[0m\e[0m\n\e[31m28 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660008687
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(x => x % 2 == 0).size\n        val twos =\
    \ arr.filter(x => x % 2 == 1).size\n        val threes = arr.filter(x => x % 3\
    \ == 0).size\n        val fours = arr.filter(x => x % 4 == 0).size\n        val\
    \ fives = arr.filter(x => x % 5 == 0).size\n        val sixes = arr.filter(x =>\
    \ x % 6 == 0).size\n        val sevens = arr.filter(x => x % 7 == 0).size\n  \
    \      val eights = arr.filter(x => x % 8 == 0).size\n        val nines = arr.filter(x\
    \ => x % 9 == 0).size\n        val tens = arr.filter(x => x % 10 == 0).size\n\
    \        val hundreds = arr.filter(x => x % 100 == 0).size\n        val thousands\
    \ = arr.filter(x => x % 1000 == 0).size\n        val tenThousands = arr.filter(x\
    \ => x % 10000 == 0).size\n        val oneThousands = arr.filter(x => x % 100000\
    \ == 0).size\n        val oneHundreds = arr.filter(x => x % 1000000 == 0).size\n\
    \        val oneThousandThousands = arr.filter(x => x % 10000000 == 0).size\n\
    \        val oneHundredThousands = arr.filter(x => x % 100000000 == 0).size\n\
    \        val oneHundredThousandThousands = arr.filter(x => x % 1000000000 == 0).size\n\
    \        val oneHundredThousandThousandThousands = arr.filter(x => x % 10000000000\
    \ == 0).size\n        val oneHundredThousandThousandThousandThousands = arr.filter(x\
    \ => x % 100000000000 == 0).size\n        val oneHundredThousandThousandThousandThousandThousands\
    \ = arr.filter(x => x % 1000000000000 == 0).size\n        val oneHundredThousandThousandThousandThousandThousandThousands\
    \ = arr.filter(x => x % 10000000000000 == 0).size\n        val oneHundredThousandThousandThousandThousandThousandThousands\
    \ = arr.filter(x => x % 100000000000000 == 0).size\n        val oneHundredThousandThousandThousandThousandThousandThousandThousands\
    \ = arr.filter(x => x % 100\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpupdee83x.scala:33:4 ----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpupdee83x.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36moneHundredThousandThousandThousandThousandThousandThousands\e[0m = arr.filter(\e\
    [36mx\e[0m => x % \e[31m100000000000000\e[0m == \e[31m0\e[0m).size\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moneHundredThousandThousandThousandThousandThousandThousands\
    \ is already defined as \e[33mvalue\e[0m \e[35moneHundredThousandThousandThousandThousandThousandThousands\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- Error: /tmp/tmpupdee83x.scala:27:70\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m27 |\e[0m       \
    \ \e[33mval\e[0m \e[36moneHundredThousandThousandThousands\e[0m = arr.filter(\e\
    [36mx\e[0m => x % \e[31m10000000000\e[0m == \e[31m0\e[0m).size\n\e[31m\e[31m \
    \  |\e[0m                                                                    \
    \  ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                         \
    \               number too large\n\e[31m\e[31m-- Error: /tmp/tmpupdee83x.scala:28:78\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36moneHundredThousandThousandThousandThousands\e[0m = arr.filter(\e\
    [36mx\e[0m => x % \e[31m100000000000\e[0m == \e[31m0\e[0m).size\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \           ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \                         number too large\n\e[31m\e[31m-- Error: /tmp/tmpupdee83x.scala:29:86\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m29 |\e[0m       \
    \ \e[33mval\e[0m \e[36moneHundredThousandThousandThousandThousandThousands\e[0m\
    \ = arr.filter(\e[36mx\e[0m => x % \e[31m10000000000"
  stdout: ''
  timestamp: 1660008688
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(x => x == 1).length\n        val zeros =\
    \ arr.filter(x => x == 0).length\n        val onesZeros = ones + zeros\n     \
    \   val onesZeros = onesZeros * (onesZeros - 1) / 2\n        val onesZeros = onesZeros\
    \ * (onesZeros - 1) / 2\n        val onesZeros = onesZeros * (onesZeros - 1) /\
    \ 2\n        val onesZeros = onesZeros * (onesZeros - 1) / 2\n        val onesZeros\
    \ = onesZeros * (onesZeros - 1) / 2\n        val onesZeros = onesZeros * (onesZeros\
    \ - 1) / 2\n        val onesZeros = onesZeros * (onesZeros - 1) / 2\n        val\
    \ onesZeros = onesZeros * (onesZeros - 1) / 2\n        val onesZeros = onesZeros\
    \ * (onesZeros - 1) / 2\n        val onesZeros = onesZeros * (onesZeros - 1) /\
    \ 2\n        val onesZeros = onesZeros * (onesZeros - 1) / 2\n        val onesZeros\
    \ = onesZeros * (onesZeros - 1) / 2\n        val onesZeros = onesZeros * (onesZeros\
    \ - 1) / 2\n        val onesZeros = onesZeros * (onesZeros - 1) / 2\n        val\
    \ onesZeros = onesZeros * (onesZeros - 1) / 2\n        val onesZeros = onesZeros\
    \ * (onesZeros - 1) / 2\n        val onesZeros = onesZeros * (onesZeros - 1) /\
    \ 2\n        val onesZeros = onesZeros * (onesZeros - 1) / 2\n        val onesZeros\
    \ = onesZeros * (onesZeros - 1) / 2\n        val onesZeros = onesZeros * (onesZeros\
    \ - 1) / 2\n        val onesZeros = onesZeros * (onesZeros - 1) / 2\n        val\
    \ onesZeros = onesZeros * (onesZeros - 1) / 2\n        val onesZeros = onesZeros\
    \ * (onesZeros - 1) / 2\n        val onesZeros = onesZeros * (onesZeros - 1) /\
    \ 2\n        val onesZeros = onesZeros * (onesZeros - 1) / 2\n        val onesZeros\
    \ = onesZeros * (onesZeros - 1) / 2\n        val onesZeros = onesZeros \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7mkktjiv.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36monesZeros\e[0m = onesZeros\
    \ * (onesZeros - \e[31m1\e[0m) / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeros is already defined as \e[33mvalue\e[0m \e[35monesZeros\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp7mkktjiv.scala:13:12 ---------------------------\e[0m\e[0m\n\e\
    [31m13 |\e[0m        \e[33mval\e[0m \e[36monesZeros\e[0m = onesZeros * (onesZeros\
    \ - \e[31m1\e[0m) / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeros is already defined as \e[33mvalue\e[0m \e[35monesZeros\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp7mkktjiv.scala:14:12 ---------------------------\e[0m\e[0m\n\e\
    [31m14 |\e[0m        \e[33mval\e[0m \e[36monesZeros\e[0m = onesZeros * (onesZeros\
    \ - \e[31m1\e[0m) / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeros is already defined as \e[33mvalue\e[0m \e[35monesZeros\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp7mkktjiv.scala:15:12 ---------------------------\e[0m\e[0m\n\e\
    [31m15 |\e[0m        \e[33mval\e[0m \e[36monesZeros\e[0m = onesZeros * (onesZeros\
    \ - \e[31m1\e[0m) / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeros is already defined as \e[33mvalue\e[0m \e[35monesZeros\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp7mkktjiv.scala:16:12 ---------------------------\e[0m\e[0m\n\e\
    [31m16 |\e[0m        \e[33mval\e[0m"
  stdout: ''
  timestamp: 1660008688
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ == 0)\n        val onesDecimals = ones * 10 + decimals\n        val onesDecimalsSortedArray\
    \ = arr.sortBy(_ / onesDecimals)\n        onesDecimalsSortedArray\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq3pgd1x7.scala:16)\n\tat Problem.main(tmpq3pgd1x7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660008688
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(x => x % 2 == 0).length\n        val twos\
    \ = arr.filter(x => x % 2 == 1).length\n        val threes = arr.filter(x => x\
    \ % 3 == 0).length\n        val fours = arr.filter(x => x % 4 == 0).length\n \
    \       val fives = arr.filter(x => x % 5 == 0).length\n        val sixes = arr.filter(x\
    \ => x % 6 == 0).length\n        val sevens = arr.filter(x => x % 7 == 0).length\n\
    \        val eights = arr.filter(x => x % 8 == 0).length\n        val nines =\
    \ arr.filter(x => x % 9 == 0).length\n        val tens = arr.filter(x => x % 10\
    \ == 0).length\n        val hundreds = arr.filter(x => x % 100 == 0).length\n\
    \        val thousands = arr.filter(x => x % 1000 == 0).length\n        val millions\
    \ = arr.filter(x => x % 1000000 == 0).length\n        val billions = arr.filter(x\
    \ => x % 1000000000 == 0).length\n        val trillions = arr.filter(x => x %\
    \ 1000000000000000 == 0).length\n        val quadrillions = arr.filter(x => x\
    \ % 10000000000000000 == 0).length\n        val quintillions = arr.filter(x =>\
    \ x % 1000000000000000000 == 0).length\n        val onesAndZeros = arr.filter(x\
    \ => x == 1).length\n        val onesAndOnes = arr.filter(x => x == 1).length\
    \ - onesAndZeros\n        val twosAndZeros = arr.filter(x => x == 2).length\n\
    \        val twosAndOnes = arr.filter(x => x == 2).length - twosAndZeros\n   \
    \     val threesAndZeros = arr.filter(x => x == 3).length\n        val threesAndOnes\
    \ = arr.filter(x => x == 3).length - threesAndZeros\n        val foursAndZeros\
    \ = arr.filter(x => x == 4).length\n        val foursAndOnes = arr.filter(x =>\
    \ x == 4).length - foursAndZeros\n        val fivesAndZeros = arr.filter(x =>\
    \ x == 5).length\n        val fivesAndOnes = arr.filter(x => x == 5).length -\
    \ fivesAndZeros\n        val sixesAndZeros = arr.filter(x => x == 6).length\n\
    \        val sixesAndOnes = arr.filter(x => x == 6).length - sixesAndZeros\n \
    \       val sevensAndZeros = arr.filter(x => x == 7).length\n        val sevensAndOnes\
    \ = arr.filter(x \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprdl8i0gl.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmprdl8i0gl.scala:23:44\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m23 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.filter(\e[36mx\e[0m => x % \e[31m1000000000000000\e\
    [0m == \e[31m0\e[0m).length\n\e[31m\e[31m   |\e[0m                           \
    \                 ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                       number too large\n\e[31m\e[31m-- Error: /tmp/tmprdl8i0gl.scala:24:47\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m24 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.filter(\e[36mx\e[0m => x % \e[31m10000000000000000\e\
    [0m == \e[31m0\e[0m).length\n\e[31m\e[31m   |\e[0m                           \
    \                    ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                              number too large\n\e[31m\e[31m-- Error: /tmp/tmprdl8i0gl.scala:25:47\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m25 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquintillions\e[0m = arr.filter(\e[36mx\e[0m => x % \e[31m1000000000000000000\e\
    [0m == \e[31m0\e[0m).length\n\e[31m\e[31m   |\e[0m                           \
    \                    ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                                number too large\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmprdl8i0gl.scala:39:39 ------------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m        \e[33mval\e[0m \e[36msevensAndOnes\e[0m = arr.filter(x \n\e[31m\e\
    [31m   |\e[0m                                       ^\e[0m\n\e[31m   |\e[0m  \
    \                                     Not found: x\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmprdl8i0gl.scala:40:5 ---------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available whe"
  stdout: ''
  timestamp: 1660008687
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(x => x % 2 == 0).length\n        val zeros\
    \ = arr.filter(x => x % 2 == 1).length\n        val onesArr = arr.filter(x =>\
    \ x % 2 == 0).sortBy(x => math.abs(x))\n        val zerosArr = arr.filter(x =>\
    \ x % 2 == 1).sortBy(x => math.abs(x))\n        val onesSortedArr = onesArr.take(ones)\n\
    \        val zerosSortedArr = zerosArr.take(zeros)\n        onesSortedArr.zip(zerosSortedArr).sortBy(x\
    \ => x._1 - x._2)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqqle48jy.scala:15:8\
    \ ---------------------\e[0m\e[0m\n\e[31m15 |\e[0m        onesSortedArr.zip(zerosSortedArr).sortBy(\e\
    [36mx\e[0m => x._1 - x._2)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    List[\e[1m\e[31m(\e[0mLong\e[1m\e[31m,\e\
    [0m\e[1m\e[31m \e[0m\e[1m\e[31mLong\e[0m\e[1m\e[31m)\e[0m]\n\e[31m   |\e[0m  \
    \      Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660008687
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ < 0)\n        val sorted = arr.sortBy(x => if (ones == 0) x else -x)\n     \
    \   val result = sorted.map(x => if (ones == 0) x else -x)\n        if (decimals\
    \ > 0) result.sortBy(x => x.toString.toInt)\n        else result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_pwzky2g.scala:17)\n\tat Problem.main(tmp_pwzky2g.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660008689
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(x => x == 1)\n        val decimals = arr.count(x\
    \ => x == 0)\n        val onesDecimal = ones * 10 + decimals\n        arr.sortBy(x\
    \ => onesDecimal)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk5eydlir.scala:15)\n\tat Problem.main(tmpk5eydlir.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660008689
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(x => x == 1)\n        val twos = arr.count(x\
    \ => x == 2)\n        val threes = arr.count(x => x == 3)\n        val fours =\
    \ arr.count(x => x == 4)\n        val fives = arr.count(x => x == 5)\n       \
    \ val sixes = arr.count(x => x == 6)\n        val sevens = arr.count(x => x ==\
    \ 7)\n        val eights = arr.count(x => x == 8)\n        val nines = arr.count(x\
    \ => x == 9)\n        val tens = arr.count(x => x == 10)\n        val hundreds\
    \ = arr.count(x => x == 100)\n        val thousands = arr.count(x => x == 1000)\n\
    \        val millions = arr.count(x => x == 1000000)\n        val billions = arr.count(x\
    \ => x == 1000000000)\n        val trillions = arr.count(x => x == 1000000000000)\n\
    \        val quadrillions = arr.count(x => x == 1000000000000000)\n        val\
    \ quintillions = arr.count(x => x == 1000000000000000000)\n        val onesSorted\
    \ = arr.sortBy(x => ones)\n        val twosSorted = arr.sortBy(x => twos)\n  \
    \      val threesSorted = arr.sortBy(x => threes)\n        val foursSorted = arr.sortBy(x\
    \ => fours)\n        val fivesSorted = arr.sortBy(x => fives)\n        val sixesSorted\
    \ = arr.sortBy(x => sixes)\n        val sevensSorted = arr.sortBy(x => sevens)\n\
    \        val eightsSorted = arr.sortBy(x => eights)\n        val ninesSorted =\
    \ arr.sortBy(x => nines)\n        val tensSorted = arr.sortBy(x => tens)\n   \
    \     val hundredsSorted = arr.sortBy(x => hundreds)\n        val thousandsSorted\
    \ = arr.sortBy(x => thousands)\n        val millionsSorted = arr.sortBy(x => millions)\n\
    \        val billionsSorted = arr.sortBy(x => billions)\n        val trillionsSorted\
    \ = arr.sortBy(x => trillions)\n        val quadrillionsSorted = arr.sortBy(x\
    \ => quadrillions)\n        val quintillionsSorted = arr.sortBy(x => quintillions)\n\
    \        val onesSorted\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqv77nwuw.scala:44:4 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmpqv77nwuw.scala:23:44\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m23 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.count(\e[36mx\e[0m => x == \e[31m1000000000000\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                            ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                            number too large\n\
    \e[31m\e[31m-- Error: /tmp/tmpqv77nwuw.scala:24:47 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.count(\e\
    [36mx\e[0m => x == \e[31m1000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m       \
    \                                        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                               number too large\n\e[31m\e[31m--\
    \ Error: /tmp/tmpqv77nwuw.scala:25:47 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mquintillions\e[0m = arr.count(\e\
    [36mx\e[0m => x == \e[31m1000000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m    \
    \                                           ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                                               number too large\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpqv77nwuw.scala:44:5 ---------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1660008688
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decs = arr.map(_.toString.toInt)\n\
    \        val sorted = decs.sortWith((x, y) => x < y)\n        val onesSorted =\
    \ decs.sortWith((x, y) => x < y)\n        val sortedArray = sorted.zip(onesSorted).map\
    \ {\n            case (dec, ones) => dec + (ones * ones)\n        }\n        sortedArray.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxbvvs9o5.scala:16:20\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        sortedArray.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:\
    \    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e[0m        Required: List[\e[1m\e\
    [32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660008700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ == 0)\n        val onesDecimals = ones * decimals\n        val decimalsDecimals\
    \ = decimals * ones\n        val onesDecimalsDecimals = onesDecimals * decimals\n\
    \        val decimalsDecimalsDecimals = decimalsDecimals * onesDecimals\n    \
    \    val onesDecimalsDecimalsDecimals = onesDecimalsDecimals * decimalsDecimals\n\
    \        val decimalsDecimalsDecimalsDecimals = decimalsDecimalsDecimals * onesDecimalsDecimals\n\
    \        val onesDecimalsDecimalsDecimalsDecimals = onesDecimalsDecimalsDecimals\
    \ * decimalsDecimalsDecimals\n        val decimalsDecimalsDecimalsDecimalsDecimals\
    \ = decimalsDecimalsDecimalsDecimals * onesDecimalsDecimalsDecimalsDecimals\n\
    \        val onesDecimalsDecimalsDecimalsDecimalsDecimals = onesDecimalsDecimalsDecimalsDecimals\
    \ * decimalsDecimalsDecimalsDecimalsDecimals\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = decimalsDecimalsDecimalsDecimalsDecimals * onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\n\
    \        val onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimals = onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ * decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals * onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\n\
    \        val onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals = onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ * decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\n\
    \        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals *\
    \ onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\n\
    \        val onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ * decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpixf3zony.scala:21:67 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36monesDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\e\
    [0m = onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimals * decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \           ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpixf3zony.scala:22:71\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mdecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\e[0m = decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ * onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \       ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mdecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpixf3zony.scala:25:83\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\e[0m\
    \ = onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ * decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpixf3zony.scala:24:79\
    \ ------------------------\e[0m"
  stdout: ''
  timestamp: 1660008700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(x => x == 1)\n        val decimals = arr.count(x\
    \ => x == 0)\n        val maxOnes = arr.count(x => x == 1)\n        val maxDecimals\
    \ = arr.count(x => x == 0)\n        val maxOnesDecimals = arr.count(x => x ==\
    \ 1)\n        val maxDecimalsOnes = arr.count(x => x == 0)\n        val maxDecimalsOnesDecimals\
    \ = arr.count(x => x == 1)\n        val maxDecimalsOnesDecimalsOnes = arr.count(x\
    \ => x == 0)\n        val maxDecimalsOnesDecimalsOnesOnes = arr.count(x => x ==\
    \ 1)\n        val maxDecimalsOnesDecimalsOnesOnesOnes = arr.count(x => x == 0)\n\
    \        val maxDecimalsOnesDecimalsOnesOnesOnesOnes = arr.count(x => x == 1)\n\
    \        val maxDecimalsOnesDecimalsOnesOnesOnesOnesOnes = arr.count(x => x ==\
    \ 0)\n        val maxDecimalsOnesDecimalsOnesOnesOnesOnesOnesOnes = arr.count(x\
    \ => x == 1)\n        val maxDecimalsOnesDecimalsOnesOnesOnesOnesOnesOnesOnesOnes\
    \ = arr.count(x => x == 0)\n        val maxDecimalsOnesDecimalsOnesOnesOnesOnesOnesOnesOnesOnesOnes\
    \ = arr.count(x => x == 1)\n        val maxDecimalsOnesDecimalsOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnes\
    \ = arr.count(x => x == 0)\n        val maxDecimalsOnesDecimalsOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnes\
    \ = arr.count(x => x == 1)\n        val maxDecimalsOnesDecimalsOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnes\
    \ = arr.count(x => x == 0)\n        val maxDecimalsOnesDecimalsOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnes\
    \ = arr.count(x => x == 1)\n        val maxDecimalsOnesDecimalsOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOne\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpehsy087u.scala:29:4 ----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpehsy087u.scala:29:5 ---------------------\e[0m\e[0m\n\e[31m29 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660008706
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(_ % 2 == 0).length\n        val decs = arr.filter(_\
    \ % 2 == 1).map(_.toString.toInt).sorted\n        val result = decs.zip(ones).sortBy(_._1).map(x\
    \ => x._2).reverse\n        arr.filter(_ % 2 == 0).sortBy(x => x.toString.toInt).reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpoafglhpj.scala:11:30\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e\
    [0m = decs.zip(ones).sortBy(_._1).map(\e[36mx\e[0m => x._2).reverse\n\e[31m\e\
    [31m   |\e[0m                              ^^^^\e[0m\n\e[31m   |\e[0m        \
    \                      Found:    (ones : Int)\n\e[31m   |\e[0m               \
    \               Required: IterableOnce[Any]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660008706
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val zeros = arr.count(_ ==\
    \ 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount = arr.count(_\
    \ == 0)\n        val onesDecimal = onesCount / arr.length\n        val zerosDecimal\
    \ = zerosCount / arr.length\n        val onesDecimalDecimal = onesDecimal / ones\n\
    \        val zerosDecimalDecimal = zerosDecimal / zeros\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal / ones\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDeci\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp93dbtd8r.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp93dbtd8r.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp93dbtd8r.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote"
  stdout: ''
  timestamp: 1660008706
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ == 0)\n        val onesDecimals = ones * decimals\n        val onesDecimalsSorted\
    \ = arr.sortBy(_ / onesDecimals)\n        onesDecimalsSorted.reverse\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArithmeticException: / by zero\n\tat Problem$.$anonfun$3(tmpsei11f01.scala:12)\n\
    \tat scala.runtime.java8.JFunction1$mcJJ$sp.apply(JFunction1$mcJJ$sp.scala:17)\n\
    \tat scala.math.Ordering$$anon$1.compare(Ordering.scala:141)\n\tat java.base/java.util.TimSort.countRunAndMakeAscending(TimSort.java:355)\n\
    \tat java.base/java.util.TimSort.sort(TimSort.java:220)\n\tat java.base/java.util.Arrays.sort(Arrays.java:1233)\n\
    \tat scala.collection.SeqOps.sorted(Seq.scala:700)\n\tat scala.collection.SeqOps.sorted$(Seq.scala:692)\n\
    \tat scala.collection.immutable.List.scala$collection$immutable$StrictOptimizedSeqOps$$super$sorted(List.scala:79)\n\
    \tat scala.collection.immutable.StrictOptimizedSeqOps.sorted(StrictOptimizedSeqOps.scala:78)\n\
    \tat scala.collection.immutable.StrictOptimizedSeqOps.sorted$(StrictOptimizedSeqOps.scala:78)\n\
    \tat scala.collection.immutable.List.sorted(List.scala:79)\n\tat scala.collection.SeqOps.sortBy(Seq.scala:754)\n\
    \tat scala.collection.SeqOps.sortBy$(Seq.scala:754)\n\tat scala.collection.AbstractSeq.sortBy(Seq.scala:1161)\n\
    \tat Problem$.sortArray(tmpsei11f01.scala:12)\n\tat Problem$.main(tmpsei11f01.scala:16)\n\
    \tat Problem.main(tmpsei11f01.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(Obje"
  stdout: ''
  timestamp: 1660008689
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ == 0)\n        val onesDecimal = arr.count(_ == 1) / (arr.count(_ == 1) + arr.count(_\
    \ == 0))\n        val decimalsDecimal = arr.count(_ == 0) / (arr.count(_ == 1)\
    \ + arr.count(_ == 0))\n        val onesDecimalDecimal = arr.count(_ == 1) / (arr.count(_\
    \ == 1) + arr.count(_ == 0))\n        val decimalsDecimalDecimal = arr.count(_\
    \ == 0) / (arr.count(_ == 1) + arr.count(_ == 0))\n        val onesDecimalDecimalDecimal\
    \ = arr.count(_ == 1) / (arr.count(_ == 1) + arr.count(_ == 0))\n        val decimalsDecimalDecimalDecimal\
    \ = arr.count(_ == 0) / (arr.count(_ == 1) + arr.count(_ == 0))\n        val onesDecimalDecimalDecimalDecimal\
    \ = arr.count(_ == 1) / (arr.count(_ == 1) + arr.count(_ == 0))\n        val decimalsDecimalDecimalDecimalDecimal\
    \ = arr.count(_ == 0) / (arr.count(_ == 1) + arr.count(_ == 0))\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = arr.count(_ == 1) / (arr.count(_ == 1) + arr.count(_ == 0))\n        val decimalsDecimalDecimalDecimalDecimalDecimal\
    \ = arr.count(_ == 0) / (arr.count(_ == 1) + arr.count(_ == 0))\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = arr.count(_ == 1) / (arr.count(_ == 1) + arr.count(_ == 0))\n        val decimalsDecimalDecimalDecimalDecimalDecimal\
    \ = arr.count(_ == 0) / (arr.count(_ == 1) + arr.count(_ == 0))\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = arr.count(_ == 1) / (arr.count(_ == 1) + arr.count(_ == 0))\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = arr.count(_ == 0) / (arr.count(_ == 1) + arr.count(_ == 0))\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = arr.count(_ == 1) / (arr.count(_ == 1) + arr.count(_ == 0))\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = arr.count(_ == 0) / (arr.count(_ == 1) + arr.count(_ == 0))\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = arr.count(_ == 1) / (arr.count(_ == 1) + arr.count(_ == 0))\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = arr.count(_ == 0) / (arr.count(_ == 1) + arr.count(_ == 0))\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqjox29zm.scala:30:4 ----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqjox29zm.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mdecimalsDecimalDecimalDecimalDecimalDecimal\e[0m = arr.count(_ == \e[31m0\e\
    [0m) / (arr.count(_ == \e[31m1\e[0m) + arr.count(_ == \e[31m0\e[0m))\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalsDecimalDecimalDecimalDecimalDecimal is already defined\
    \ as \e[33mvalue\e[0m \e[35mdecimalsDecimalDecimalDecimalDecimalDecimal\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpqjox29zm.scala:27:12 ---------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = arr.count(_ == \e[31m1\e[0m) / (arr.count(_ == \e[31m1\e[0m) + arr.count(_\
    \ == \e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpqjox29zm.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36mdecimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = arr.count(_ == \e[31m0\e[0m) / (arr.count(_ == \e[31m1\e[0m) + arr.count(_\
    \ == \e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660008707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decs = arr.map(_.toString.toInt)\n\
    \        val sorted = decs.sortWith(_.compare(decs(0)) == 0)\n        val sorted\
    \ = sorted.sortWith(_.compare(decs(1)) == 0)\n        val sorted = sorted.sortWith(_.compare(decs(2))\
    \ == 0)\n        val sorted = sorted.sortWith(_.compare(decs(3)) == 0)\n     \
    \   val sorted = sorted.sortWith(_.compare(decs(4)) == 0)\n        val sorted\
    \ = sorted.sortWith(_.compare(decs(5)) == 0)\n        val sorted = sorted.sortWith(_.compare(decs(6))\
    \ == 0)\n        val sorted = sorted.sortWith(_.compare(decs(7)) == 0)\n     \
    \   val sorted = sorted.sortWith(_.compare(decs(8)) == 0)\n        val sorted\
    \ = sorted.sortWith(_.compare(decs(9)) == 0)\n        val sorted = sorted.sortWith(_.compare(decs(10))\
    \ == 0)\n        val sorted = sorted.sortWith(_.compare(decs(11)) == 0)\n    \
    \    val sorted = sorted.sortWith(_.compare(decs(12)) == 0)\n        val sorted\
    \ = sorted.sortWith(_.compare(decs(13)) == 0)\n        val sorted = sorted.sortWith(_.compare(decs(14))\
    \ == 0)\n        val sorted = sorted.sortWith(_.compare(decs(15)) == 0)\n    \
    \    val sorted = sorted.sortWith(_.compare(decs(16)) == 0)\n        val sorted\
    \ = sorted.sortWith(_.compare(decs(17)) == 0)\n        val sorted = sorted.sortWith(_.compare(decs(18))\
    \ == 0)\n        val sorted = sorted.sortWith(_.compare(decs(19)) == 0)\n    \
    \    val sorted = sorted.sortWith(_.compare(decs(20)) == 0)\n        val sorted\
    \ = sorted.sortWith(_.compare(decs(21)) == 0)\n        val sorted = sorted.sortWith(_.compare(decs(22))\
    \ == 0)\n        val sorted = sorted.sortWith(_.compare(decs(23)) == 0)\n    \
    \    val sorted = sorted.sortWith(_.compare(decs(24)) == 0)\n        val sorted\
    \ = sorted.sortWith(_.compare(decs(25)) == 0)\n        val sorted = sorted.sortWith(_.compare(decs(26))\
    \ == 0)\n\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqwsuycy5.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = sorted.sortWith(_.compare(decs(\e\
    [31m1\e[0m)) == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msorted is already defined as \e[33mvalue\e[0m \e[35msorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpqwsuycy5.scala:13:12 ---------------------------\e[0m\e[0m\n\e\
    [31m13 |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = sorted.sortWith(_.compare(decs(\e\
    [31m2\e[0m)) == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msorted is already defined as \e[33mvalue\e[0m \e[35msorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpqwsuycy5.scala:14:12 ---------------------------\e[0m\e[0m\n\e\
    [31m14 |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = sorted.sortWith(_.compare(decs(\e\
    [31m3\e[0m)) == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msorted is already defined as \e[33mvalue\e[0m \e[35msorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpqwsuycy5.scala:15:12 ---------------------------\e[0m\e[0m\n\e\
    [31m15 |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = sorted.sortWith(_.compare(decs(\e\
    [31m4\e[0m)) == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msorted is already defined as \e[33mvalue\e[0m \e[35msorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpqwsuycy5.scala:16:12 ---------------------------\e[0m\e[0m\n\e\
    [31m16 |"
  stdout: ''
  timestamp: 1660008707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(_ % 2 == 0).length\n        val decimals\
    \ = arr.filter(_ % 2 == 1).length\n        arr.sortWith(compare(ones, decimals))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3sjo1ab6.scala:11:21 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        arr.sortWith(compare(ones, decimals))\n\e[31m\e\
    [31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \       Not found: compare\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660008699
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val zeros = arr.count(_ ==\
    \ 0)\n        val onesDec = arr.map(x => math.pow(2, x-1).toInt).sortBy(x => x)\n\
    \        val zerosDec = arr.map(x => math.pow(2, x-1).toInt).sortBy(x => -x)\n\
    \        val onesDec.zip(zerosDec).sortBy(x => x._1 - x._2)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0gcp7jt7.scala:13:33 ---------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m onesDec.zip(zerosDec).sortBy(x\
    \ => x._1 - x._2)\n\e[31m\e[31m   |\e[0m                                 ^\e[0m\n\
    \e[31m   |\e[0m                                 '=' expected, but '.' found\n\e\
    [31m\e[31m-- [E127] Syntax Error: /tmp/tmp0gcp7jt7.scala:13:12 ---------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m onesDec.zip(zerosDec).sortBy(x\
    \ => x._1 - x._2)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0monesDec.zip cannot be used as an extractor in a pattern because it lacks\
    \ an unapply or unapplySeq method\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp0gcp7jt7.scala:14:5 ---------------------\e[0m\e[0m\n\e[31m14\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660008707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        // Your code here\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl8olg31u.scala:8:51\
    \ ---------------------\e[0m\e[0m\n\e[31m 8 |\e[0m    \e[33mdef\e[0m \e[36msortArray\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m]) : \e[35mList\e[0m[\e[35mLong\e\
    [0m] = {\n\e[31m\e[31m   |\e[0m                                              \
    \     ^\e[0m\n\e[31m   |\e[0m                                                \
    \   Found:    Unit\n\e[31m   |\e[0m                                          \
    \         Required: List[Long]\n\e[31m 9 |\e[0m        \e[34m// Your code here\e\
    [0m\n\e[31m10 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660008686
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ == 0)\n        val onesDecimal = ones * 10\n        val decimalsDecimal = decimals\
    \ * 10\n        val onesDecimalDecimal = onesDecimal * 10\n        val decimalsDecimalDecimal\
    \ = decimalsDecimal * 10\n        val onesDecimalDecimalDecimal = onesDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimal = decimalsDecimalDecimal * 10\n\
    \        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal * 10\n\
    \        val decimalsDecimalDecimalDecimalDecimal = decimalsDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimalDecimalDecimal = decimalsDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimal = decimalsDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimal = decimalsDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimal = decimalsDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * 10\n  \
    \      val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal *\
    \ 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * 10\n\
    \        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal = decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpggk0gkm4.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mdecimalsDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = decimalsDecimalDecimalDecimalDecimalDecimalDecimal * \e[31m10\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalsDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mdecimalsDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpggk0gkm4.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal * \e[31m10\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpggk0gkm4.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36mdecimalsDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = decimalsDecimalDecimalDecimalDecimalDecimalDecimal * \e[31m10\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalsDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mdecimalsDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of tople"
  stdout: ''
  timestamp: 1660008707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val zeros = arr.count(_ ==\
    \ 0)\n        val onesArr = arr.filter(x => x == 1).sortBy(x => x.toString.toInt)\n\
    \        val zerosArr = arr.filter(x => x == 0).sortBy(x => x.toString.toInt)\n\
    \        val onesZeros = ones + zeros\n        val onesZeroArr = onesZeros.sortBy(x\
    \ => x.toString.toInt)\n        val onesZeroArr2 = onesZeros.sortBy(x => x.toString.toInt)\n\
    \        val onesZeroArr3 = onesZeros.sortBy(x => x.toString.toInt)\n        val\
    \ onesZeroArr4 = onesZeros.sortBy(x => x.toString.toInt)\n        val onesZeroArr5\
    \ = onesZeros.sortBy(x => x.toString.toInt)\n        val onesZeroArr6 = onesZeros.sortBy(x\
    \ => x.toString.toInt)\n        val onesZeroArr7 = onesZeros.sortBy(x => x.toString.toInt)\n\
    \        val onesZeroArr8 = onesZeros.sortBy(x => x.toString.toInt)\n        val\
    \ onesZeroArr9 = onesZeros.sortBy(x => x.toString.toInt)\n        val onesZeroArr10\
    \ = onesZeros.sortBy(x => x.toString.toInt)\n        val onesZeroArr11 = onesZeros.sortBy(x\
    \ => x.toString.toInt)\n        val onesZeroArr12 = onesZeros.sortBy(x => x.toString.toInt)\n\
    \        val onesZeroArr13 = onesZeros.sortBy(x => x.toString.toInt)\n       \
    \ val onesZeroArr14 = onesZeros.sortBy(x => x.toString.toInt)\n        val onesZeroArr15\
    \ = onesZeros.sortBy(x => x.toString.toInt)\n        val onesZeroArr16 = onesZeros.sortBy(x\
    \ => x.toString.toInt)\n        val onesZeroArr17 = onesZeros.sortBy(x => x.toString.toInt)\n\
    \        val onesZeroArr18 = onesZeros.sortBy(x => x.toString.toInt)\n       \
    \ val onesZeroArr19 = onesZeros.sortBy(x => \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpkkfyf9xi.scala:32:49 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr19\e[0m = onesZeros.sortBy(\e\
    [36mx\e[0m => \n\e[31m\e[31m   |\e[0m                                        \
    \         ^\e[0m\n\e[31m   |\e[0m                                       expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpkkfyf9xi.scala:14:36 ------------------------\e[0m\e[0m\n\e[31m14 |\e\
    [0m        \e[33mval\e[0m \e[36monesZeroArr\e[0m = onesZeros.sortBy(\e[36mx\e\
    [0m => x.toString.toInt)\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          value sortBy is not a member of\
    \ Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkkfyf9xi.scala:15:37 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr2\e[0m = onesZeros.sortBy(\e\
    [36mx\e[0m => x.toString.toInt)\n\e[31m\e[31m   |\e[0m                       \
    \    ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                           value sortBy\
    \ is not a member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkkfyf9xi.scala:16:37\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36monesZeroArr3\e[0m = onesZeros.sortBy(\e[36mx\e[0m => x.toString.toInt)\n\e\
    [31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                           value sortBy is not a member of Int\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpkkfyf9xi.scala:17:37 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr4\e[0m = onesZeros.sortBy(\e\
    [36mx\e[0m => x.toString.toInt)\n\e[31m\e[31m   |\e[0m                       \
    \    ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                           value sortBy\
    \ is not a member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkkfyf9xi.scala:18:37\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36monesZeroArr5\e[0m = onesZeros.sortBy(\e[36mx\e[0m => x.toString.toInt)\n\e\
    [31m\e["
  stdout: ''
  timestamp: 1660008711
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ < 0)\n        val sortedArray = arr.sortBy(x => if (ones == 0) x else -x)\n\
    \        sortedArray\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0isze2qj.scala:15)\n\tat Problem.main(tmp0isze2qj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660008710
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(x => x % 2 == 0).length\n        val twos\
    \ = arr.filter(x => x % 2 == 1).length\n        val threes = arr.filter(x => x\
    \ % 3 == 0).length\n        val fours = arr.filter(x => x % 4 == 0).length\n \
    \       val fives = arr.filter(x => x % 5 == 0).length\n        val sixes = arr.filter(x\
    \ => x % 6 == 0).length\n        val sevens = arr.filter(x => x % 7 == 0).length\n\
    \        val eights = arr.filter(x => x % 8 == 0).length\n        val nines =\
    \ arr.filter(x => x % 9 == 0).length\n        val tens = arr.filter(x => x % 10\
    \ == 0).length\n        val hundreds = arr.filter(x => x % 100 == 0).length\n\
    \        val thousands = arr.filter(x => x % 1000 == 0).length\n        val millions\
    \ = arr.filter(x => x % 1000000 == 0).length\n        val billions = arr.filter(x\
    \ => x % 1000000000 == 0).length\n        val trillions = arr.filter(x => x %\
    \ 1000000000000 == 0).length\n        val quadrillions = arr.filter(x => x % 1000000000000000\
    \ == 0).length\n        val quintillions = arr.filter(x => x % 1000000000000000000\
    \ == 0).length\n        val onesAndZeros = arr.filter(x => x % 1 == 0).length\n\
    \        val onesAndOnes = arr.filter(x => x % 1 == 1).length\n        val twosAndZeros\
    \ = arr.filter(x => x % 2 == 0).length\n        val twosAndOnes = arr.filter(x\
    \ => x % 2 == 1).length\n        val threesAndZeros = arr.filter(x => x % 3 ==\
    \ 0).length\n        val threesAndOnes = arr.filter(x => x % 3 == 1).length\n\
    \        val foursAndZeros = arr.filter(x => x % 4 == 0).length\n        val foursAndOnes\
    \ = arr.filter(x => x % 4 == 1).length\n        val fivesAndZeros = arr.filter(x\
    \ => x % 5 == 0).length\n        val fivesAndOnes = arr.filter(x => x % 5 == 1).length\n\
    \        val sixesAndZeros = arr.filter(x => x % 6 == 0).length\n        val sixesAndOnes\
    \ = arr.filter(x => x % 6 == 1).length\n        val sevensAndZeros = arr.filter(x\
    \ => x % 7 == 0).length\n        val sevensAndOnes = arr.filter(x => x % 7 ==\
    \ 1).\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmtarjeq8.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmpmtarjeq8.scala:23:44\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m23 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.filter(\e[36mx\e[0m => x % \e[31m1000000000000\e\
    [0m == \e[31m0\e[0m).length\n\e[31m\e[31m   |\e[0m                           \
    \                 ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \                    number too large\n\e[31m\e[31m-- Error: /tmp/tmpmtarjeq8.scala:24:47\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m24 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.filter(\e[36mx\e[0m => x % \e[31m1000000000000000\e\
    [0m == \e[31m0\e[0m).length\n\e[31m\e[31m   |\e[0m                           \
    \                    ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \                             number too large\n\e[31m\e[31m-- Error: /tmp/tmpmtarjeq8.scala:25:47\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m25 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquintillions\e[0m = arr.filter(\e[36mx\e[0m => x % \e[31m1000000000000000000\e\
    [0m == \e[31m0\e[0m).length\n\e[31m\e[31m   |\e[0m                           \
    \                    ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                                number too large\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpmtarjeq8.scala:40:5 ---------------------\e[0m\e[0m\n\
    \e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:\
    \    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n5 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660008708
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ > 0)\n        val onesDecimal = ones * decimals\n        val onesDecimals =\
    \ onesDecimal.map(_.toDouble)\n        val onesDecimalsSorted = onesDecimals.sortWith(_\
    \ < _)\n        val decimalsSorted = decimals.map(_.toDouble).sortWith(_ < _)\n\
    \        onesDecimalsSorted.zip(decimalsSorted).map(x => x._1 + x._2)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpj3rvfa6o.scala:12:39 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36monesDecimals\e[0m = onesDecimal.map(_.toDouble)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                           value map is not a member of Int\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpj3rvfa6o.scala:14:38 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mdecimalsSorted\e[0m = decimals.map(_.toDouble).sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                             value map is not a member of Int\n2\
    \ errors found\n"
  stdout: ''
  timestamp: 1660008708
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ == 0)\n        val onesDecimals = ones * decimals\n        val onesDecimalsArray\
    \ = Array.ofDim[Long](onesDecimals)\n        val onesDecimalsArrayCopy = onesDecimalsArray.clone()\n\
    \        val onesDecimalsArrayCopySorted = onesDecimalsArrayCopy.sorted\n    \
    \    val decimalsArray = Array.ofDim[Long](decimals)\n        val decimalsArrayCopy\
    \ = decimalsArray.clone()\n        val decimalsArrayCopySorted = decimalsArrayCopy.sorted\n\
    \        val onesDecimalsArraySortedCopy = onesDecimalsArraySorted.clone()\n \
    \       val onesDecimalsArraySortedCopySorted = onesDecimalsArraySortedCopy.sorted\n\
    \        val decimalsArraySortedCopy = decimalsArraySorted.clone()\n        val\
    \ decimalsArraySortedCopySorted = decimalsArraySortedCopy.sorted\n        val\
    \ onesDecimalsArraySortedCopySorted = onesDecimalsArraySortedCopy.sorted\n   \
    \     val onesDecimalsArraySortedCopySortedCopy = onesDecimalsArraySortedCopySorted.clone()\n\
    \        val onesDecimalsArraySortedCopySortedCopy = onesDecimalsArraySortedCopySorted.clone()\n\
    \        val onesDecimalsArraySortedCopySortedCopySorted = onesDecimalsArraySortedCopySorted.clone()\n\
    \        val onesDecimalsArraySortedCopySortedCopySorted = onesDecimalsArraySortedCopySorted.clone()\n\
    \        val onesDecimalsArraySortedCopySortedCopySorted = onesDecimalsArraySortedCopySorted.clone()\n\
    \        val onesDecimalsArraySortedCopySortedCopySorted = onesDecimalsArraySortedCopySorted.clone()\n\
    \        val onesDecimalsArraySortedCopySortedCopySorted = onesDecimalsArraySortedCopySorted.clone()\n\
    \        val onesDecimalsArraySortedCopySortedCopySortedCopy = onesDecimalsArraySortedCopySortedCopySorted.clone()\n\
    \        val onesDecimalsArraySortedCopySortedCopySortedCopy = onesDecimalsArraySortedCopySortedCopySorted.clone()\n\
    \        val onesDecimalsArraySortedCopySortedCopySortedCopy = onesDecimalsArraySortedCopySortedCopySorted.clone()\n\
    \        val onesDecimalsArraySortedCopySortedCopySortedCopy = onesDecimalsArraySortedCopySortedCopySorted.clone()\n\
    \        val onesDecimalsArraySortedCopySortedCopySortedCopy = onesDecimals\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6sxxf6b5.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36monesDecimalsArraySortedCopySorted\e\
    [0m = onesDecimalsArraySortedCopy.sorted\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalsArraySortedCopySorted is already defined as \e\
    [33mvalue\e[0m \e[35monesDecimalsArraySortedCopySorted\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6sxxf6b5.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesDecimalsArraySortedCopySortedCopy\e[0m = onesDecimalsArraySortedCopySorted.clone()\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalsArraySortedCopySortedCopy is already defined as\
    \ \e[33mvalue\e[0m \e[35monesDecimalsArraySortedCopySortedCopy\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6sxxf6b5.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesDecimalsArraySortedCopySortedCopySorted\e[0m = onesDecimalsArraySortedCopySorted.clone()\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalsArraySortedCopySortedCopySorted is already defined\
    \ as \e[33mvalue\e[0m \e[35monesDecimalsArraySortedCopySortedCopySorted\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp6sxxf6b5.scala:27:12 ---------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m        \e[33mval\e[0m \e[36monesDecimalsArraySortedCopySortedCopySorted\e\
    [0m = onesDecimalsArraySortedCopySorted.clone()\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660008708
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val twos = arr.count(_ ==\
    \ 2)\n        val threes = arr.count(_ == 3)\n        val fours = arr.count(_\
    \ == 4)\n        val fives = arr.count(_ == 5)\n        val sixes = arr.count(_\
    \ == 6)\n        val sevens = arr.count(_ == 7)\n        val eights = arr.count(_\
    \ == 8)\n        val nines = arr.count(_ == 9)\n        val tens = arr.count(_\
    \ == 10)\n        val hundreds = arr.count(_ == 100)\n        val thousands =\
    \ arr.count(_ == 1000)\n        val millions = arr.count(_ == 1000000)\n     \
    \   val billions = arr.count(_ == 1000000000)\n        val trillions = arr.count(_\
    \ == 1000000000000)\n        val quadrillions = arr.count(_ == 1000000000000000)\n\
    \        val quintillions = arr.count(_ == 1000000000000000000)\n        val onesAndZeros\
    \ = arr.count(_ == 1 && _ == 0)\n        val onesAndOnes = arr.count(_ == 1 &&\
    \ _ == 1)\n        val onesAndTwos = arr.count(_ == 1 && _ == 2)\n        val\
    \ onesAndThrees = arr.count(_ == 1 && _ == 3)\n        val onesAndFours = arr.count(_\
    \ == 1 && _ == 4)\n        val onesAndFives = arr.count(_ == 1 && _ == 5)\n  \
    \      val onesAndSixes = arr.count(_ == 1 && _ == 6)\n        val onesAndSevens\
    \ = arr.count(_ == 1 && _ == 7)\n        val onesAndEights = arr.count(_ == 1\
    \ && _ == 8)\n        val onesAndNines = arr.count(_ == 1 && _ == 9)\n       \
    \ val onesAndTens = arr.count(_ == 1 && _ == 10)\n        val onesAndHundreds\
    \ = arr.count(_ == 1 && _ == 100)\n        val onesAndThousands = arr.count(_\
    \ == 1 && _ == 1000)\n        val onesAndMillions = arr.count(_ == 1 && _ == 1000000)\n\
    \        val onesAndBillions = arr.count(_ == 1 && _ == 1000000000)\n        val\
    \ onesAndTrillions = arr.count(_ == 1 && _ == 1000000000000)\n        val onesAndQuadrillions\
    \ = arr.count(_ == 1 && _ == 1000000000000000)\n        val onesAndQuintillions\
    \ = arr.count(_ == 1 && _ == 1000000000000000000)\n        val onesAndOnesAndZeros\
    \ = arr.count(_ == 1 && \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmppmcvho8c.scala:44:53 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36monesAndOnesAndZeros\e[0m\
    \ = arr.count(_ == \e[31m1\e[0m && \n\e[31m\e[31m   |\e[0m                   \
    \                                  ^\e[0m\n\e[31m   |\e[0m                   \
    \                    expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmppmcvho8c.scala:23:39 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mtrillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000\e[0m)\n\e[31m\e[31m   |\e[0m                        \
    \               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \             number too large\n\e[31m\e[31m-- Error: /tmp/tmppmcvho8c.scala:24:42\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m24 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.count(_ == \e[31m1000000000000000\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                          ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                          number too large\n\
    \e[31m\e[31m-- Error: /tmp/tmppmcvho8c.scala:25:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mquintillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m                  \
    \                        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                               number too large\n\e[31m\e[31m-- [E086] Syntax\
    \ Error: /tmp/tmppmcvho8c.scala:26:37 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36monesAndZeros\e[0m = arr.count(_ == \e\
    [31m1\e[0m && _ == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                      \
    \               ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \          Wrong number of parameters, expected: 1\n\e[31m\e[31m-- [E086] Syntax\
    \ Error: /tmp/tmppmcvho8c.scala:27:36 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36monesAndOnes\e[0m = arr.count(_ == \e\
    [31m1\e[0m "
  stdout: ''
  timestamp: 1660008688
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(x => x % 2 == 0).length\n        val zeros\
    \ = arr.filter(x => x % 2 == 1).length\n        val decimals = arr.filter(x =>\
    \ x % 10 == 0).length\n        val decimalsDecimals = arr.filter(x => x % 10 ==\
    \ 1).length\n        val decimalsDecimalsDecimals = arr.filter(x => x % 10 ==\
    \ 2).length\n        val decimalsDecimalsDecimalsDecimals = arr.filter(x => x\
    \ % 10 == 3).length\n        val decimalsDecimalsDecimalsDecimalsDecimals = arr.filter(x\
    \ => x % 10 == 4).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(x => x % 10 == 5).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(x => x % 10 == 6).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(x => x % 10 == 7).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(x => x % 10 == 8).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(x => x % 10 == 9).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(x => x % 10 == 0).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(x => x % 10 == 1).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(x => x % 10 == 2).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(x => x % 10 == 3).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(x => x % 10 == 4).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(x => x % 10 == 5).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7_9iemiz.scala:28:4 ----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7_9iemiz.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mdecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\e\
    [0m = arr.filter(\e[36mx\e[0m => x % \e[31m10\e[0m == \e[31m1\e[0m).length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmp7_9iemiz.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mdecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\e\
    [0m = arr.filter(\e[36mx\e[0m => x % \e[31m10\e[0m == \e[31m4\e[0m).length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp7_9iemiz.scala:28:5 ---------------------\e\
    [0m\e[0m\n\e[31m28 |\e"
  stdout: ''
  timestamp: 1660008709
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(x => x == 1)\n        val zeros = arr.count(x\
    \ => x == 0)\n        val onesCount = arr.count(x => x == 1)\n        val zerosCount\
    \ = arr.count(x => x == 0)\n        val onesDecimal = onesCount / ones\n     \
    \   val zerosDecimal = zerosCount / zeros\n        val onesDecimalDecimal = onesDecimal\
    \ / onesDecimal\n        val zerosDecimalDecimal = zerosDecimal / zerosDecimal\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimal\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpw1r0ckok.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimal\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimal is already defined\
    \ as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimal\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpw1r0ckok.scala:25:12 ---------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpw1r0ckok.scala:29:145 --------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \             ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0"
  stdout: ''
  timestamp: 1660008709
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val twos = arr.count(_ ==\
    \ 2)\n        val threes = arr.count(_ == 3)\n        val fours = arr.count(_\
    \ == 4)\n        val fives = arr.count(_ == 5)\n        val sixes = arr.count(_\
    \ == 6)\n        val sevens = arr.count(_ == 7)\n        val eights = arr.count(_\
    \ == 8)\n        val nines = arr.count(_ == 9)\n        val tens = arr.count(_\
    \ == 10)\n        val hundreds = arr.count(_ == 100)\n        val thousands =\
    \ arr.count(_ == 1000)\n        val millions = arr.count(_ == 1000000)\n     \
    \   val billions = arr.count(_ == 1000000000)\n        val trillions = arr.count(_\
    \ == 1000000000000)\n        val quadrillions = arr.count(_ == 1000000000000000)\n\
    \        val quintillions = arr.count(_ == 1000000000000000000)\n        val onesAndZeros\
    \ = arr.count(_ == 1 && _ == 0)\n        val onesAndOnes = arr.count(_ == 1 &&\
    \ _ == 1)\n        val onesAndTwos = arr.count(_ == 1 && _ == 2)\n        val\
    \ onesAndThrees = arr.count(_ == 1 && _ == 3)\n        val onesAndFours = arr.count(_\
    \ == 1 && _ == 4)\n        val onesAndFives = arr.count(_ == 1 && _ == 5)\n  \
    \      val onesAndSixes = arr.count(_ == 1 && _ == 6)\n        val onesAndSevens\
    \ = arr.count(_ == 1 && _ == 7)\n        val onesAndEights = arr.count(_ == 1\
    \ && _ == 8)\n        val onesAndNines = arr.count(_ == 1 && _ == 9)\n       \
    \ val onesAndTens = arr.count(_ == 1 && _ == 10)\n        val onesAndHundreds\
    \ = arr.count(_ == 1 && _ == 100)\n        val onesAndThousands = arr.count(_\
    \ == 1 && _ == 1000)\n        val onesAndMillions = arr.count(_ == 1 && _ == 1000000)\n\
    \        val onesAndBillions = arr.count(_ == 1 && _ == 1000000000)\n        val\
    \ onesAndTrillions = arr.count(_ == 1 && _ == 1000000000000)\n        val onesAndQuadrillions\
    \ = arr.count(_ == 1 && _ == 1000000000000000)\n        val onesAndQuintillions\
    \ = arr.count(_ == 1 && _ == 1000000000000000000)\n        val twosAndZeros =\
    \ arr.count(_ == 2 && _ == \n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpq6uydraa.scala:44:51 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36mtwosAndZeros\e[0m = arr.count(_\
    \ == \e[31m2\e[0m && _ == \n\e[31m\e[31m   |\e[0m                            \
    \                       ^\e[0m\n\e[31m   |\e[0m                              \
    \         expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- Error: /tmp/tmpq6uydraa.scala:23:39 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mtrillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000\e[0m)\n\e[31m\e[31m   |\e[0m                        \
    \               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \             number too large\n\e[31m\e[31m-- Error: /tmp/tmpq6uydraa.scala:24:42\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m24 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.count(_ == \e[31m1000000000000000\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                          ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                          number too large\n\
    \e[31m\e[31m-- Error: /tmp/tmpq6uydraa.scala:25:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mquintillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m                  \
    \                        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                               number too large\n\e[31m\e[31m-- [E086] Syntax\
    \ Error: /tmp/tmpq6uydraa.scala:26:37 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36monesAndZeros\e[0m = arr.count(_ == \e\
    [31m1\e[0m && _ == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                      \
    \               ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \          Wrong number of parameters, expected: 1\n\e[31m\e[31m-- [E086] Syntax\
    \ Error: /tmp/tmpq6uydraa.scala:27:36 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36monesAndOnes\e[0m = arr.count(_ == \e\
    [31m1\e[0m && _"
  stdout: ''
  timestamp: 1660008711
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(x => x == 1)\n        val zeros = arr.count(x\
    \ => x == 0)\n        val onesDec = ones / 10\n        val zerosDec = zeros /\
    \ 10\n        val onesBin = ones % 10\n        val zerosBin = zeros % 10\n   \
    \     val onesBinStr = Integer.toBinaryString(onesBin)\n        val zerosBinStr\
    \ = Integer.toBinaryString(zerosBin)\n        val onesBinStrList = onesBinStr.split(\"\
    0\")\n        val zerosBinStrList = zerosBinStr.split(\"0\")\n        val onesBinStrListSorted\
    \ = onesBinStrList.sortWith(x => x.compareTo(x))\n        val zerosBinStrListSorted\
    \ = zerosBinStrList.sortWith(x => x.compareTo(x))\n        val onesBinStrListSortedWithDec\
    \ = (onesBinStrListSorted ++ List(onesDec)).sortWith(x => x.compareTo(x))\n  \
    \      val zerosBinStrListSortedWithDec = (zerosBinStrListSorted ++ List(zerosDec)).sortWith(x\
    \ => x.compareTo(x))\n        val onesBinStrListSortedWithDecAndZeros = (onesBinStrListSortedWithDec\
    \ ++ List(zerosBinStrListSortedWithDec)).sortWith(x => x.compareTo(x))\n     \
    \   val zerosBinStrListSortedWithDecAndZeros = (zerosBinStrListSortedWithDec ++\
    \ List(onesBinStrListSortedWithDecAndZeros)).sortWith(x => x.compareTo(x))\n \
    \       val onesBinStrListSortedWithDecAndZerosAndOnes = (onesBinStrListSortedWithDecAndZeros\
    \ ++ List(onesBinStrListSortedWithDecAndZeros)).sortWith(x => x.compareTo(x))\n\
    \        val zerosBinStrListSortedWithDecAndZerosAndOnes = (zerosBinStrListSortedWithDecAndZeros\
    \ ++ List(zerosBinStrListSortedWithDecAndZeros)).sortWith(x => x.compareTo(x))\n\
    \        val onesBinStrListSortedWithDecAndZerosAndOnesAndZeros = (onesBinStrListSortedWithDecAndZerosAndOnes\
    \ ++ List(zerosBinStrListSortedWithDecAndZerosAndOnes)).sortWith(x => x.compareTo(x))\n\
    \        val zerosBinStrListSortedWithDecAndZerosAndOnesAndZeros = (zerosBinStrListSortedWithDecAndZerosAndOnes\
    \ ++ List(\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpc_3_8yx7.scala:28:119 --------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mzerosBinStrListSortedWithDecAndZerosAndOnesAndZeros\e\
    [0m = (zerosBinStrListSortedWithDecAndZerosAndOnes ++ List(\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \                                             ^\e[0m\n\e[31m   |\e[0m        \
    \                               expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpc_3_8yx7.scala:19:61\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesBinStrListSorted\e[0m = onesBinStrList.sortWith(\e[36mx\e[0m => x.compareTo(x))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \   ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                \
    \ Wrong number of parameters, expected: 2\n\e[31m\e[31m-- [E086] Syntax Error:\
    \ /tmp/tmpc_3_8yx7.scala:20:63 ---------------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m        \e[33mval\e[0m \e[36mzerosBinStrListSorted\e[0m = zerosBinStrList.sortWith(\e\
    [36mx\e[0m => x.compareTo(x))\n\e[31m\e[31m   |\e[0m                         \
    \                                    ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                 Wrong number of parameters, expected: 2\n\e\
    [31m\e[31m-- [E086] Syntax Error: /tmp/tmpc_3_8yx7.scala:21:93 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36monesBinStrListSortedWithDec\e\
    [0m = (onesBinStrListSorted ++ List(onesDec)).sortWith(\e[36mx\e[0m => x.compareTo(x))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                   ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                 Wrong number of parameters, expected: 2\n\e\
    [31m\e[31m-- [E086] Syntax Error: /tmp/tmpc_3_8yx7.scala:22:96 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mzerosBinStrListSortedWithDec\e\
    [0m = (zerosBinStrL"
  stdout: ''
  timestamp: 1660008711
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(x => x == 1).size\n        val zeros = arr.filter(x\
    \ => x == 0).size\n        val decimal = arr.map(x => math.abs(math.log2(x)))\n\
    \        val decimalSorted = decimal.sortWith(x => x < y)\n        val decimalSortedSortedWithOnes\
    \ = decimalSorted.sortWith(x => x == ones)\n        val decimalSortedSortedWithZeros\
    \ = decimalSortedSortedWithOnes.sortWith(x => x == zeros)\n        decimalSortedSortedWithZeros.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqeblucel.scala:11:49 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mdecimal\e[0m = arr.map(\e\
    [36mx\e[0m => math.abs(math.log2(x)))\n\e[31m\e[31m   |\e[0m                 \
    \                           ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \                    value log2 is not a member of math\n\e[31m\e[31m-- [E086]\
    \ Syntax Error: /tmp/tmpqeblucel.scala:12:47 ---------------------------\e[0m\e\
    [0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mdecimalSorted\e[0m = decimal.sortWith(\e\
    [36mx\e[0m => x < y)\n\e[31m\e[31m   |\e[0m                                  \
    \           ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                 Wrong\
    \ number of parameters, expected: 2\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpqeblucel.scala:13:67\
    \ ---------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m\
    \ \e[36mdecimalSortedSortedWithOnes\e[0m = decimalSorted.sortWith(\e[36mx\e[0m\
    \ => x == ones)\n\e[31m\e[31m   |\e[0m                                       \
    \                          ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \                   Wrong number of parameters, expected: 2\n\e[31m\e[31m-- [E086]\
    \ Syntax Error: /tmp/tmpqeblucel.scala:14:82 ---------------------------\e[0m\e\
    [0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mdecimalSortedSortedWithZeros\e\
    [0m = decimalSortedSortedWithOnes.sortWith(\e[36mx\e[0m => x == zeros)\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \          Wrong number of parameters, expected: 2\n4 errors found\n"
  stdout: ''
  timestamp: 1660008710
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val zeros = arr.count(_ ==\
    \ 0)\n        val onesArr = arr.filter(_ == 1).sortBy(x => math.abs(x).toInt)\n\
    \        val zerosArr = arr.filter(_ == 0).sortBy(x => math.abs(x).toInt)\n  \
    \      val onesArr2 = onesArr.zip(zerosArr).sortBy(x => x._1 - x._2)\n       \
    \ onesArr2.map(x => x._1).reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmps3vm792k.scala:17)\n\tat Problem.main(tmps3vm792k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660008713
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ == 0)\n        val onesDecimal = ones * 10\n        val decimalsDecimal = decimals\
    \ * 10\n        val onesDecimalDecimal = onesDecimal * 10\n        val decimalsDecimalDecimal\
    \ = decimalsDecimal * 10\n        val onesDecimalDecimalDecimal = onesDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimal = decimalsDecimalDecimal * 10\n\
    \        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal * 10\n\
    \        val decimalsDecimalDecimalDecimalDecimal = decimalsDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimalDecimalDecimal = decimalsDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimal = decimalsDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimal = decimalsDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimal = decimalsDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * 10\n  \
    \      val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * 10\n  \
    \      val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * 10\n  \
    \      val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal *\
    \ 10\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpkzt8djq0.scala:35:11 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpkzt8djq0.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mdecimalsDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = decimalsDecimalDecimalDecimalDecimalDecimalDecimal * \e[31m10\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalsDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mdecimalsDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpkzt8djq0.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal * \e[31m10\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpkzt8djq0.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36mdecimalsDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = decimalsDecimalDecimalDecimalDecimalDecimalDecimal * \e[31m10\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660008711
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        // Your code here\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl8olg31u.scala:8:51\
    \ ---------------------\e[0m\e[0m\n\e[31m 8 |\e[0m    \e[33mdef\e[0m \e[36msortArray\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m]) : \e[35mList\e[0m[\e[35mLong\e\
    [0m] = {\n\e[31m\e[31m   |\e[0m                                              \
    \     ^\e[0m\n\e[31m   |\e[0m                                                \
    \   Found:    Unit\n\e[31m   |\e[0m                                          \
    \         Required: List[Long]\n\e[31m 9 |\e[0m        \e[34m// Your code here\e\
    [0m\n\e[31m10 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660008686
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(_ % 2 == 0).length\n        val decimals\
    \ = arr.filter(_ % 2 == 1).length\n        val result = arr.sortWith(x => if (ones\
    \ < decimals) x else x.toInt)\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmprszqha6l.scala:11:36 ---------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = arr.sortWith(\e\
    [36mx\e[0m => \e[33mif\e[0m (ones < decimals) x \e[33melse\e[0m x.toInt)\n\e[31m\e\
    [31m   |\e[0m                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Wrong number of parameters,\
    \ expected: 2\n1 error found\n"
  stdout: ''
  timestamp: 1660008706
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val zeros = arr.count(_ ==\
    \ 0)\n        val onesDec = ones / arr.length\n        val zerosDec = zeros /\
    \ arr.length\n        arr.sortWith((a, b) => if (a == 0) b else a)\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpph9ue4to.scala:13:43\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        arr.sortWith((\e[36ma\e\
    [0m, \e[36mb\e[0m) => \e[33mif\e[0m (a == \e[31m0\e[0m) b \e[33melse\e[0m a)\n\
    \e[31m\e[31m   |\e[0m                                           ^\e[0m\n\e[31m\
    \   |\e[0m                                           Found:    (b : Long)\n\e\
    [31m   |\e[0m                                           Required: Boolean\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpph9ue4to.scala:13:50\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        arr.sortWith((\e[36ma\e\
    [0m, \e[36mb\e[0m) => \e[33mif\e[0m (a == \e[31m0\e[0m) b \e[33melse\e[0m a)\n\
    \e[31m\e[31m   |\e[0m                                                  ^\e[0m\n\
    \e[31m   |\e[0m                                                  Found:    (a\
    \ : Long)\n\e[31m   |\e[0m                                                  Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660008723
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ > 0)\n        val result = arr.sortBy(x => if (ones == 1) x else math.abs(x\
    \ - math.pow(2,arr.count(_ == 0)-1)))\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpmggwlsi2.scala:11:105 ----------------------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = arr.sortBy(\e\
    [36mx\e[0m => \e[33mif\e[0m (ones == \e[31m1\e[0m) x \e[33melse\e[0m math.abs(x\
    \ - math.pow(\e[31m2\e[0m,arr.count(_ == \e[31m0\e[0m)-\e[31m1\e[0m)))\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                         ^\e[0m\n\e[31m   |\e[0mNo implicit Ordering\
    \ defined for AnyVal..\n\e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m    scala.math.Ordering.ordered[\e[35mAnyVal\e[0m](\n\e[31m   |\e[0m      /*\
    \ missing */summon[scala.math.Ordering.AsComparable[AnyVal]]\n\e[31m   |\e[0m\
    \    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were found that\
    \ match type scala.math.Ordering.AsComparable[AnyVal].\n1 error found\n"
  stdout: ''
  timestamp: 1660008722
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val twos = arr.count(_ ==\
    \ 2)\n        val threes = arr.count(_ == 3)\n        val fours = arr.count(_\
    \ == 4)\n        val fives = arr.count(_ == 5)\n        val sixes = arr.count(_\
    \ == 6)\n        val sevens = arr.count(_ == 7)\n        val eights = arr.count(_\
    \ == 8)\n        val nines = arr.count(_ == 9)\n        val tens = arr.count(_\
    \ == 10)\n        val hundreds = arr.count(_ == 100)\n        val thousands =\
    \ arr.count(_ == 1000)\n        val millions = arr.count(_ == 1000000)\n     \
    \   val billions = arr.count(_ == 1000000000)\n        val trillions = arr.count(_\
    \ == 1000000000000)\n        val quadrillions = arr.count(_ == 1000000000000000)\n\
    \        val quintillions = arr.count(_ == 1000000000000000000)\n        val onesAndZeros\
    \ = arr.count(_ == 1 && _ == 0)\n        val onesAndOnes = arr.count(_ == 1 &&\
    \ _ == 1)\n        val onesAndTwos = arr.count(_ == 1 && _ == 2)\n        val\
    \ onesAndThrees = arr.count(_ == 1 && _ == 3)\n        val onesAndFours = arr.count(_\
    \ == 1 && _ == 4)\n        val onesAndFives = arr.count(_ == 1 && _ == 5)\n  \
    \      val onesAndSixes = arr.count(_ == 1 && _ == 6)\n        val onesAndSevens\
    \ = arr.count(_ == 1 && _ == 7)\n        val onesAndEights = arr.count(_ == 1\
    \ && _ == 8)\n        val onesAndNines = arr.count(_ == 1 && _ == 9)\n       \
    \ val onesAndTens = arr.count(_ == 1 && _ == 10)\n        val onesAndHundreds\
    \ = arr.count(_ == 1 && _ == 100)\n        val onesAndThousands = arr.count(_\
    \ == 1 && _ == 1000)\n        val onesAndMillions = arr.count(_ == 1 && _ == 1000000)\n\
    \        val onesAndBillions = arr.count(_ == 1 && _ == 1000000000)\n        val\
    \ onesAndTrillions = arr.count(_ == 1 && _ == 1000000000000)\n        val onesAndQuadrillions\
    \ = arr.count(_ == 1 && _ == 1000000000000000)\n        val onesAndQuintillions\
    \ = arr.count(_ == 1 && _ == 1000000000000000000)\n        val onesAndOnesAndZeros\
    \ = arr.count(_ == 1 && \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmppmcvho8c.scala:44:53 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36monesAndOnesAndZeros\e[0m\
    \ = arr.count(_ == \e[31m1\e[0m && \n\e[31m\e[31m   |\e[0m                   \
    \                                  ^\e[0m\n\e[31m   |\e[0m                   \
    \                    expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmppmcvho8c.scala:23:39 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mtrillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000\e[0m)\n\e[31m\e[31m   |\e[0m                        \
    \               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \             number too large\n\e[31m\e[31m-- Error: /tmp/tmppmcvho8c.scala:24:42\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m24 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.count(_ == \e[31m1000000000000000\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                          ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                          number too large\n\
    \e[31m\e[31m-- Error: /tmp/tmppmcvho8c.scala:25:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mquintillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m                  \
    \                        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                               number too large\n\e[31m\e[31m-- [E086] Syntax\
    \ Error: /tmp/tmppmcvho8c.scala:26:37 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36monesAndZeros\e[0m = arr.count(_ == \e\
    [31m1\e[0m && _ == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                      \
    \               ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \          Wrong number of parameters, expected: 1\n\e[31m\e[31m-- [E086] Syntax\
    \ Error: /tmp/tmppmcvho8c.scala:27:36 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36monesAndOnes\e[0m = arr.count(_ == \e\
    [31m1\e[0m "
  stdout: ''
  timestamp: 1660008688
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ == 0)\n        val onesDecimals = ones * decimals\n        val onesDecimalsSortedList\
    \ = arr.sortBy(_ / onesDecimals)\n        val onesDecimalsSortedListReversed =\
    \ onesDecimalsSortedList.reverse\n        onesDecimalsSortedListReversed.sortBy(_\
    \ % onesDecimals)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArithmeticException: / by zero\n\tat Problem$.$anonfun$3(tmp05jk3ejq.scala:12)\n\
    \tat scala.runtime.java8.JFunction1$mcJJ$sp.apply(JFunction1$mcJJ$sp.scala:17)\n\
    \tat scala.math.Ordering$$anon$1.compare(Ordering.scala:141)\n\tat java.base/java.util.TimSort.countRunAndMakeAscending(TimSort.java:355)\n\
    \tat java.base/java.util.TimSort.sort(TimSort.java:220)\n\tat java.base/java.util.Arrays.sort(Arrays.java:1233)\n\
    \tat scala.collection.SeqOps.sorted(Seq.scala:700)\n\tat scala.collection.SeqOps.sorted$(Seq.scala:692)\n\
    \tat scala.collection.immutable.List.scala$collection$immutable$StrictOptimizedSeqOps$$super$sorted(List.scala:79)\n\
    \tat scala.collection.immutable.StrictOptimizedSeqOps.sorted(StrictOptimizedSeqOps.scala:78)\n\
    \tat scala.collection.immutable.StrictOptimizedSeqOps.sorted$(StrictOptimizedSeqOps.scala:78)\n\
    \tat scala.collection.immutable.List.sorted(List.scala:79)\n\tat scala.collection.SeqOps.sortBy(Seq.scala:754)\n\
    \tat scala.collection.SeqOps.sortBy$(Seq.scala:754)\n\tat scala.collection.AbstractSeq.sortBy(Seq.scala:1161)\n\
    \tat Problem$.sortArray(tmp05jk3ejq.scala:12)\n\tat Problem$.main(tmp05jk3ejq.scala:17)\n\
    \tat Problem.main(tmp05jk3ejq.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(Obje"
  stdout: ''
  timestamp: 1660008727
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(x => x % 2 == 0).length\n        val zeros\
    \ = arr.filter(x => x % 2 == 1).length\n        val onesZeros = ones + zeros\n\
    \        val onesZerosList = onesZeros :: arr.filterNot(x => x % 2 == 0).sortBy(x\
    \ => x.toString.toInt)\n        val zerosList = arr.filterNot(x => x % 2 == 1).sortBy(x\
    \ => x.toString.toInt)\n        val onesZerosListLength = onesZerosList.length\n\
    \        val zerosListLength = zerosList.length\n        val onesZerosListLengthMinusOne\
    \ = onesZerosListLength - 1\n        val zerosListLengthMinusOne = zerosListLength\
    \ - 1\n        val onesZerosListLengthMinusOneMinusOne = onesZerosListLengthMinusOne\
    \ - 1\n        val zerosListLengthMinusOneMinusOne = zerosListLengthMinusOne -\
    \ 1\n        val onesZerosListLengthMinusOneMinusOneMinusOne = onesZerosListLengthMinusOneMinusOne\
    \ - 1\n        val zerosListLengthMinusOneMinusOneMinusOne = zerosListLengthMinusOneMinusOne\
    \ - 1\n        val onesZerosListLengthMinusOneMinusOneMinusOneMinusOne = onesZerosListLengthMinusOneMinusOneMinusOne\
    \ - 1\n        val zerosListLengthMinusOneMinusOneMinusOneMinusOne = zerosListLengthMinusOneMinusOneMinusOne\
    \ - 1\n        val onesZerosListLengthMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = onesZerosListLengthMinusOneMinusOneMinusOneMinusOne - 1\n        val zerosListLengthMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = zerosListLengthMinusOneMinusOneMinusOneMinusOne - 1\n        val onesZerosListLengthMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = onesZerosListLengthMinusOneMinusOneMinusOneMinusOneMinusOne - 1\n        val\
    \ zerosListLengthMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne = zerosListLengthMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val onesZerosListLengthMinusOneMinusOneMinusOne\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4z9t83wy.scala:29:4 ----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4z9t83wy.scala:27:86\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mzerosListLengthMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e\
    [0m = zerosListLengthMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne - \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                                                   \
    \                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: zerosListLengthMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4z9t83wy.scala:29:5\
    \ ---------------------\e[0m\e[0m\n\e[31m29 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660008727
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ == 0)\n        val onesDecimal = ones * 10\n        val decimalsDecimal = decimals\
    \ * 10\n        arr.sortWith((x, y) => if (x == onesDecimal) y else x)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9au6wr3a.scala:13:53\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        arr.sortWith((\e[36mx\e\
    [0m, \e[36my\e[0m) => \e[33mif\e[0m (x == onesDecimal) y \e[33melse\e[0m x)\n\e\
    [31m\e[31m   |\e[0m                                                     ^\e[0m\n\
    \e[31m   |\e[0m                                                    Found:    (y\
    \ : Long)\n\e[31m   |\e[0m                                                   \
    \ Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9au6wr3a.scala:13:60\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        arr.sortWith((\e[36mx\e\
    [0m, \e[36my\e[0m) => \e[33mif\e[0m (x == onesDecimal) y \e[33melse\e[0m x)\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \  ^\e[0m\n\e[31m   |\e[0m                                                   \
    \ Found:    (x : Long)\n\e[31m   |\e[0m                                      \
    \              Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(x => x == 1)\n        val decimals = arr.count(x\
    \ => x == 0)\n        val sortedArray = arr.sortBy(x => if (x == 1) ones else\
    \ decimals)\n        sortedArray\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp89yris4j.scala:15)\n\tat Problem.main(tmp89yris4j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660008730
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decs = arr.map(_.toString.toInt)\n\
    \        val sorted = decs.sortWith((x, y) => x < y)\n        val sorted = sorted.zipWithIndex.sortWith((x,\
    \ y) => x < y).map { case (v, i) => if (v == ones) i else v }\n        sorted.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp17w7ke6x.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = sorted.zipWithIndex.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => x < y).map { \e[33mcase\e[0m (v, i) => \e[33mif\e\
    [0m (v == ones) i \e[33melse\e[0m v }\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msorted is already defined as \e[33mvalue\e[0m \e[35msorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp17w7ke6x.scala:13:15 --------------------\e[0m\e[0m\n\
    \e[31m13 |\e[0m        sorted.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e\
    [0m        Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(x => x % 2 == 0).length\n        val decimals\
    \ = arr.filter(x => x % 2 == 1).length\n        val sortedArray = arr.sortBy(x\
    \ => if (x % 2 == 0) ones else decimals)\n        sortedArray\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprzu12_y9.scala:15)\n\tat Problem.main(tmprzu12_y9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660008731
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decs = arr.map(_.toString.toInt)\n\
    \        val sortedArr = decs.sortWith(compareDecs)\n        val sortedArr = sortedArr.sortWith(compareOnes)\n\
    \        sortedArr\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpn7_dqu8k.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.sortWith(compareOnes)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msortedArr is already defined as \e[33mvalue\e[0m \e[35msortedArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpn7_dqu8k.scala:11:38 ------------------------\e[0m\e[0m\n\
    \e[31m11 |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = decs.sortWith(compareDecs)\n\
    \e[31m\e[31m   |\e[0m                                      ^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                      Not found: compareDecs\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn7_dqu8k.scala:13:8\
    \ ---------------------\e[0m\e[0m\n\e[31m13 |\e[0m        sortedArr\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (sortedArr\
    \ : List[Int])\n\e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ == 0)\n        val onesDecimals = ones * decimals\n        val onesDecimalsSorted\
    \ = arr.sortBy(_ / onesDecimals)\n        onesDecimalsSorted.reverse\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArithmeticException: / by zero\n\tat Problem$.$anonfun$3(tmpsei11f01.scala:12)\n\
    \tat scala.runtime.java8.JFunction1$mcJJ$sp.apply(JFunction1$mcJJ$sp.scala:17)\n\
    \tat scala.math.Ordering$$anon$1.compare(Ordering.scala:141)\n\tat java.base/java.util.TimSort.countRunAndMakeAscending(TimSort.java:355)\n\
    \tat java.base/java.util.TimSort.sort(TimSort.java:220)\n\tat java.base/java.util.Arrays.sort(Arrays.java:1233)\n\
    \tat scala.collection.SeqOps.sorted(Seq.scala:700)\n\tat scala.collection.SeqOps.sorted$(Seq.scala:692)\n\
    \tat scala.collection.immutable.List.scala$collection$immutable$StrictOptimizedSeqOps$$super$sorted(List.scala:79)\n\
    \tat scala.collection.immutable.StrictOptimizedSeqOps.sorted(StrictOptimizedSeqOps.scala:78)\n\
    \tat scala.collection.immutable.StrictOptimizedSeqOps.sorted$(StrictOptimizedSeqOps.scala:78)\n\
    \tat scala.collection.immutable.List.sorted(List.scala:79)\n\tat scala.collection.SeqOps.sortBy(Seq.scala:754)\n\
    \tat scala.collection.SeqOps.sortBy$(Seq.scala:754)\n\tat scala.collection.AbstractSeq.sortBy(Seq.scala:1161)\n\
    \tat Problem$.sortArray(tmpsei11f01.scala:12)\n\tat Problem$.main(tmpsei11f01.scala:16)\n\
    \tat Problem.main(tmpsei11f01.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(Obje"
  stdout: ''
  timestamp: 1660008689
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ % 2 == 0)\n        val result = arr.sortBy(x => (ones - decimals).abs)\n   \
    \     result\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8lsxeef7.scala:15)\n\tat Problem.main(tmp8lsxeef7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660008731
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ % 2 == 0)\n        val onesDecimals = ones * decimals\n        val onesDecimalsSortedList\
    \ = arr.sortBy(_ / onesDecimals)\n        val onesDecimalsSortedListReversed =\
    \ onesDecimalsSortedList.reverse\n        onesDecimalsSortedListReversed.take(onesDecimalsSortedListReversed.size\
    \ - onesDecimals)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfl7wuwxi.scala:17)\n\tat Problem.main(tmpfl7wuwxi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660008732
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(x => x == 1).length\n        val zeros =\
    \ arr.filter(x => x == 0).length\n        val onesCount = arr.filter(x => x ==\
    \ 1).length\n        val zerosCount = arr.filter(x => x == 0).length\n       \
    \ val onesDecimal = onesCount / ones\n        val zerosDecimal = zerosCount /\
    \ zeros\n        val onesDecimalDecimal = onesDecimal / onesDecimal\n        val\
    \ zerosDecimalDecimal = zerosDecimal / zerosDecimal\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal / onesDecimalDecimal\n        val zerosDecimalDecimalDecimal\
    \ = zerosDecimalDecimal / zerosDecimalDecimal\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimal / onesDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / zerosDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimal\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = ones\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpu40mnw87.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimal is already defined\
    \ as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimal\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpu40mnw87.scala:25:12 ---------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpu40mnw87.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is al"
  stdout: ''
  timestamp: 1660008728
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(x => x % 2 == 0).length\n        val decimals\
    \ = arr.filter(x => x % 2 == 1).length\n        val sorted = arr.sortBy(x => (ones\
    \ - x.toBinaryString.length))\n        sorted.sortBy(x => (decimals - x.toString.length))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7206ubnf.scala:15)\n\tat Problem.main(tmp7206ubnf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660008732
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        // Your code here\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl8olg31u.scala:8:51\
    \ ---------------------\e[0m\e[0m\n\e[31m 8 |\e[0m    \e[33mdef\e[0m \e[36msortArray\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m]) : \e[35mList\e[0m[\e[35mLong\e\
    [0m] = {\n\e[31m\e[31m   |\e[0m                                              \
    \     ^\e[0m\n\e[31m   |\e[0m                                                \
    \   Found:    Unit\n\e[31m   |\e[0m                                          \
    \         Required: List[Long]\n\e[31m 9 |\e[0m        \e[34m// Your code here\e\
    [0m\n\e[31m10 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660008686
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val zeros = arr.count(_ ==\
    \ 0)\n        val onesDec = arr.map(x => (x >>> 0).toInt).sortBy(x => x)\n   \
    \     val zerosDec = arr.map(x => (x >>> 0).toInt).sortBy(x => -x)\n        val\
    \ onesDecSorted = onesDec.take(ones)\n        val zerosDecSorted = zerosDec.take(zeros)\n\
    \        val sortedArray = onesDecSorted.zip(zerosDecSorted).sortBy(x => x._1\
    \ - x._2)\n        sortedArray.map(x => x._1 + x._2)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpppcr48uo.scala:19)\n\tat Problem.main(tmpppcr48uo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660008732
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val zeros = arr.count(_ ==\
    \ 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount = arr.count(_\
    \ == 0)\n        val onesDecimal = onesCount / arr.size\n        val zerosDecimal\
    \ = zerosCount / arr.size\n        val onesDecimalDecimal = onesDecimal / ones\n\
    \        val zerosDecimalDecimal = zerosDecimal / zeros\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal / ones\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDeci\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzn6g1j9a.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpzn6g1j9a.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpzn6g1j9a.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote"
  stdout: ''
  timestamp: 1660008728
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val twos = arr.count(_ ==\
    \ 2)\n        val threes = arr.count(_ == 3)\n        val fours = arr.count(_\
    \ == 4)\n        val fives = arr.count(_ == 5)\n        val sixes = arr.count(_\
    \ == 6)\n        val sevens = arr.count(_ == 7)\n        val eights = arr.count(_\
    \ == 8)\n        val nines = arr.count(_ == 9)\n        val tens = arr.count(_\
    \ == 10)\n        val hundreds = arr.count(_ == 100)\n        val thousands =\
    \ arr.count(_ == 1000)\n        val millions = arr.count(_ == 1000000)\n     \
    \   val billions = arr.count(_ == 1000000000)\n        val trillions = arr.count(_\
    \ == 1000000000000)\n        val quadrillions = arr.count(_ == 1000000000000000)\n\
    \        val quintillions = arr.count(_ == 1000000000000000000)\n        val onesAndZeros\
    \ = arr.count(_ == 1 && _ == 0)\n        val onesAndOnes = arr.count(_ == 1 &&\
    \ _ == 1)\n        val onesAndTwos = arr.count(_ == 1 && _ == 2)\n        val\
    \ onesAndThrees = arr.count(_ == 1 && _ == 3)\n        val onesAndFours = arr.count(_\
    \ == 1 && _ == 4)\n        val onesAndFives = arr.count(_ == 1 && _ == 5)\n  \
    \      val onesAndSixes = arr.count(_ == 1 && _ == 6)\n        val onesAndSevens\
    \ = arr.count(_ == 1 && _ == 7)\n        val onesAndEights = arr.count(_ == 1\
    \ && _ == 8)\n        val onesAndNines = arr.count(_ == 1 && _ == 9)\n       \
    \ val onesAndTens = arr.count(_ == 1 && _ == 10)\n        val onesAndHundreds\
    \ = arr.count(_ == 1 && _ == 100)\n        val onesAndThousands = arr.count(_\
    \ == 1 && _ == 1000)\n        val onesAndMillions = arr.count(_ == 1 && _ == 1000000)\n\
    \        val onesAndBillions = arr.count(_ == 1 && _ == 1000000000)\n        val\
    \ onesAndTrillions = arr.count(_ == 1 && _ == 1000000000000)\n        val onesAndQuadrillions\
    \ = arr.count(_ == 1 && _ == 1000000000000000)\n        val onesAndQuintillions\
    \ = arr.count(_ == 1 && _ == 1000000000000000000)\n        val twosAndZeros =\
    \ arr.count(_ == 2 && _ == \n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpq6uydraa.scala:44:51 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36mtwosAndZeros\e[0m = arr.count(_\
    \ == \e[31m2\e[0m && _ == \n\e[31m\e[31m   |\e[0m                            \
    \                       ^\e[0m\n\e[31m   |\e[0m                              \
    \         expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- Error: /tmp/tmpq6uydraa.scala:23:39 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mtrillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000\e[0m)\n\e[31m\e[31m   |\e[0m                        \
    \               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \             number too large\n\e[31m\e[31m-- Error: /tmp/tmpq6uydraa.scala:24:42\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m24 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.count(_ == \e[31m1000000000000000\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                          ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                          number too large\n\
    \e[31m\e[31m-- Error: /tmp/tmpq6uydraa.scala:25:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mquintillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m                  \
    \                        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                               number too large\n\e[31m\e[31m-- [E086] Syntax\
    \ Error: /tmp/tmpq6uydraa.scala:26:37 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36monesAndZeros\e[0m = arr.count(_ == \e\
    [31m1\e[0m && _ == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                      \
    \               ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \          Wrong number of parameters, expected: 1\n\e[31m\e[31m-- [E086] Syntax\
    \ Error: /tmp/tmpq6uydraa.scala:27:36 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36monesAndOnes\e[0m = arr.count(_ == \e\
    [31m1\e[0m && _"
  stdout: ''
  timestamp: 1660008711
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(_ % 2 == 0).length\n        val twos = arr.filter(_\
    \ % 2 == 1).length\n        val decimals = arr.filter(_ % 10 == 0).length\n  \
    \      val result = arr.sortWith(compare(ones, twos, decimals))\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0c7yt6lr.scala:12:34 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = arr.sortWith(compare(ones,\
    \ twos, decimals))\n\e[31m\e[31m   |\e[0m                                  ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Not found: compare\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660008724
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decs = arr.map(_.toString.toInt)\n\
    \        val sorted = decs.sortWith((x, y) => x < y)\n        val sorted = sorted.map(x\
    \ => if (x == 0) ones else x)\n        val sorted = sorted.sortWith((x, y) =>\
    \ x < y)\n        val sorted = sorted.map(x => if (x == 0) ones else x)\n    \
    \    val sorted = sorted.sortWith((x, y) => x < y)\n        val sorted = sorted.map(x\
    \ => if (x == 0) ones else x)\n        val sorted = sorted.sortWith((x, y) =>\
    \ x < y)\n        val sorted = sorted.map(x => if (x == 0) ones else x)\n    \
    \    val sorted = sorted.sortWith((x, y) => x < y)\n        val sorted = sorted.map(x\
    \ => if (x == 0) ones else x)\n        val sorted = sorted.sortWith((x, y) =>\
    \ x < y)\n        val sorted = sorted.map(x => if (x == 0) ones else x)\n    \
    \    val sorted = sorted.sortWith((x, y) => x < y)\n        val sorted = sorted.map(x\
    \ => if (x == 0) ones else x)\n        val sorted = sorted.sortWith((x, y) =>\
    \ x < y)\n        val sorted = sorted.map(x => if (x == 0) ones else x)\n    \
    \    val sorted = sorted.sortWith((x, y) => x < y)\n        val sorted = sorted.map(x\
    \ => if (x == 0) ones else x)\n        val sorted = sorted.sortWith((x, y) =>\
    \ x < y)\n        val sorted = sorted.map(x => if (x == 0) ones else x)\n    \
    \    val sorted = sorted.sortWith((x, y) => x < y)\n        val sorted = sorted.map(x\
    \ => if (x == 0) ones else x)\n        val sorted = sorted.sortWith((x, y) =>\
    \ x < y)\n        val sorted = sorted.map(x => if (x == 0) ones else x)\n    \
    \    val sorted = sorted.sortWith((x, y) => x < y)\n        val sorted = sorted.map(x\
    \ => if (x == 0) ones else x)\n        val sorted = sorted.sortWith((x, y) =>\
    \ x < y)\n        val sorted = sorted.map(x => if (x == 0) ones else x)\n    \
    \    val sorted = sorted.sortWith((x, y) => x < y)\n        val sorted = sorted.map(x\
    \ => if (x == 0) ones else x)\n        val sorted = sorted.sortWith((x, y) =>\
    \ x < y)\n        val sorted = sorted.map(x => if (x == 0) ones else x)\n    \
    \    val sorted = sorted.sortWith((\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp6yqecw7h.scala:43:38 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = sorted.sortWith((\n\
    \e[31m\e[31m   |\e[0m                                      ^\e[0m\n\e[31m   |\e\
    [0m                                      expression expected but \e[31m'}'\e[0m\
    \ found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6yqecw7h.scala:12:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36msorted\e[0m = sorted.map(\e[36mx\e[0m => \e[33mif\e[0m (x == \e[31m0\e\
    [0m) ones \e[33melse\e[0m x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msorted is already defined as \e[33mvalue\e[0m \e[35msorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp6yqecw7h.scala:13:12 ---------------------------\e[0m\e[0m\n\e\
    [31m13 |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = sorted.sortWith((\e[36mx\e\
    [0m, \e[36my\e[0m) => x < y)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msorted is already defined as \e[33mvalue\e[0m \e[35msorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp6yqecw7h.scala:14:12 ---------------------------\e[0m\e[0m\n\e\
    [31m14 |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = sorted.map(\e[36mx\e[0m\
    \ => \e[33mif\e[0m (x == \e[31m0\e[0m) ones \e[33melse\e[0m x)\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0msorted is already defined as \e[33mvalue\e[0m \e[35msorted\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp6yqecw7h.scala:15:12 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = sorted.so"
  stdout: ''
  timestamp: 1660008732
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val zeros = arr.count(_ ==\
    \ 0)\n        val onesArray = arr.map(x => (x % 2 == 0 ? x : -x))\n        val\
    \ zerosArray = arr.map(x => (x % 2 == 0 ? x : -x))\n        val onesArraySorted\
    \ = onesArray.sortBy(x => x)\n        val zerosArraySorted = zerosArray.sortBy(x\
    \ => x)\n        val onesArraySortedSorted: Array[Long] = onesArraySorted.take(ones)\n\
    \        val zerosArraySortedSorted: Array[Long] = zerosArraySorted.take(zeros)\n\
    \        val onesArraySortedSortedSorted: Array[Long] = onesArraySortedSorted.take(ones)\n\
    \        val zerosArraySortedSortedSorted: Array[Long] = zerosArraySortedSorted.take(zeros)\n\
    \        val onesArraySortedSortedSortedSorted: Array[Long] = onesArraySortedSortedSorted.take(ones)\n\
    \        val zerosArraySortedSortedSortedSorted: Array[Long] = zerosArraySortedSortedSorted.take(zeros)\n\
    \        val onesArraySortedSortedSortedSortedSorted: Array[Long] = onesArraySortedSortedSortedSorted.take(ones)\n\
    \        val zerosArraySortedSortedSortedSorted: Array[Long] = zerosArraySortedSortedSorted.take(zeros)\n\
    \        val onesArraySortedSortedSortedSortedSorted: Array[Long] = onesArraySortedSortedSortedSorted.take(ones)\n\
    \        val zerosArraySortedSortedSortedSortedSorted: Array[Long] = zerosArraySortedSortedSortedSorted.take(zeros)\n\
    \        val onesArraySortedSortedSortedSortedSortedSorted: Array[Long] = onesArraySortedSortedSortedSortedSorted.take(ones)\n\
    \        val zerosArraySortedSortedSortedSortedSorted: Array[Long] = zerosArraySortedSortedSortedSorted.take(zeros)\n\
    \        val onesArraySortedSortedSortedSortedSortedSorted: Array[Long] = onesArraySortedSortedSortedSortedSorted.take(ones)\n\
    \        val zerosArraySortedSortedSortedSortedSortedSorted: Array[Long] = zerosArraySortedSortedSortedSortedSorted.take(zeros)\n\
    \        val onesArraySortedSortedSortedSortedSortedSortedSorted: Array[Long]\
    \ = onesArraySortedSortedSortedSortedSortedSorted.take(ones)\n        val zerosArraySortedSortedSortedSortedSortedSorted:\
    \ Array[Long] = zerosArraySortedSortedSortedSortedSorted.take(zeros)\n       \
    \ val onesArraySortedSortedSortedSorted\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpyqb79mk0.scala:11:57 ---------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36monesArray\e[0m = arr.map(\e\
    [36mx\e[0m => (x % \e[31m2\e[0m == \e[31m0\e[0m ? x : \e[35m-x\e[0m))\n\e[31m\e\
    [31m   |\e[0m                                                         ^\e[0m\n\
    \e[31m   |\e[0m                                   an identifier expected, but\
    \ ')' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpyqb79mk0.scala:12:58\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosArray\e[0m = arr.map(\e[36mx\e[0m => (x % \e[31m2\e[0m == \e[31m0\e\
    [0m ? x : \e[35m-x\e[0m))\n\e[31m\e[31m   |\e[0m                             \
    \                             ^\e[0m\n\e[31m   |\e[0m                        \
    \           an identifier expected, but ')' found\n\e[31m\e[31m-- [E040] Syntax\
    \ Error: /tmp/tmpyqb79mk0.scala:32:4 ----------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e[0m    '=' expected,\
    \ but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyqb79mk0.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosArraySortedSortedSortedSorted\e[0m: \e[35mArray\e[0m[\e[35mLong\e\
    [0m] = zerosArraySortedSortedSorted.take(zeros)\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosArraySortedSortedSortedSorted is already defined as \e\
    [33mvalue\e[0m \e[35mzerosArraySortedSortedSortedSorted\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyqb79mk0.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesArraySortedSortedSortedSortedSorted\e[0m: \e[35mArray\e[0m[\e[35mLong\e\
    [0m] = onesArraySortedSortedSortedSorted.take(ones)\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesArraySortedSortedSortedSortedSorted"
  stdout: ''
  timestamp: 1660008733
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(_ % 2 == 0).length\n        val decimals\
    \ = arr.filter(_ % 2 == 1).length\n        val maxOnes = arr.max\n        val\
    \ maxDecimals = arr.max\n        val maxDecimal = maxDecimals.toDouble\n     \
    \   val maxOne = maxOnes.toDouble\n        val maxOnes = arr.filter(_ % 2 == 1).length\n\
    \        val maxOne = maxOnes.toDouble\n        val maxOnes = arr.filter(_ % 2\
    \ == 1).length\n        val maxOne = maxOnes.toDouble\n        val maxOnes = arr.filter(_\
    \ % 2 == 1).length\n        val maxOne = maxOnes.toDouble\n        val maxOnes\
    \ = arr.filter(_ % 2 == 1).length\n        val maxOne = maxOnes.toDouble\n   \
    \     val maxOnes = arr.filter(_ % 2 == 1).length\n        val maxOne = maxOnes.toDouble\n\
    \        val maxOnes = arr.filter(_ % 2 == 1).length\n        val maxOne = maxOnes.toDouble\n\
    \        val maxOnes = arr.filter(_ % 2 == 1).length\n        val maxOne = maxOnes.toDouble\n\
    \        val maxOnes = arr.filter(_ % 2 == 1).length\n        val maxOne = maxOnes.toDouble\n\
    \        val maxOnes = arr.filter(_ % 2 == 1).length\n        val maxOne = maxOnes.toDouble\n\
    \        val maxOnes = arr.filter(_ % 2 == 1).length\n        val maxOne = maxOnes.toDouble\n\
    \        val maxOnes = arr.filter(_ % 2 == 1).length\n        val maxOne = maxOnes.toDouble\n\
    \        val maxOnes = arr.filter(_ % 2 == 1).length\n        val maxOne = maxOnes.toDouble\n\
    \        val maxOnes = arr.filter(_ % 2 == 1).length\n        val maxOne = maxOnes.toDouble\n\
    \        val maxOnes = arr.filter(_ % 2 == 1).length\n        val maxOne = maxOnes.toDouble\n\
    \        val maxOnes = arr.filter(_ % 2 == 1).length\n        val maxOne = maxOnes.toDouble\n\
    \        val maxOnes = arr.filter(_ % 2 == 1).length\n        val maxOne = maxOnes.toDouble\n\
    \        val maxOnes = arr.filter(_ % 2 == 1).length\n        val maxOne = maxOnes.toDouble\n\
    \        val maxOnes = arr.filter(_ % 2 == 1).length\n        val maxOne = maxOnes.toDouble\n\
    \        val maxOnes = arr.filter(_ % 2 == 1).length\n        val maxOne = \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpt6v3e0pl.scala:52:20 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m        \e[33mval\e[0m \e[36mmaxOne\e[0m = \n\e[31m\e\
    [31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m                    expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpt6v3e0pl.scala:15:12 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36mmaxOnes\e[0m = arr.filter(_ % \e[31m2\e[0m\
    \ == \e[31m1\e[0m).length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxOnes is already defined as \e[33mvalue\e[0m \e[35mmaxOnes\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpt6v3e0pl.scala:16:12 ---------------------------\e[0m\e[0m\n\e\
    [31m16 |\e[0m        \e[33mval\e[0m \e[36mmaxOne\e[0m = maxOnes.toDouble\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxOne\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxOne\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpt6v3e0pl.scala:17:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxOnes\e[0m = arr.filter(_ % \e[31m2\e[0m == \e[31m1\e[0m).length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mmaxOnes is already defined as \e[33mvalue\e[0m \e[35mmaxOnes\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpt6v3e0pl.scala:18:12 ---------------------------\e[0m\e[0m\n\e[31m18\
    \ |\e[0m        \e[33mval\e[0m \e[36mmaxOne\e[0m = maxOnes.toDouble\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxOne\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxOne\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote th"
  stdout: ''
  timestamp: 1660008732
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ == 0)\n        val onesDecimals = ones * 10 + decimals\n        val onesDecimalsSorted\
    \ = arr.sortBy(_ / onesDecimals)\n        onesDecimalsSorted.reverse\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa3_0f34g.scala:16)\n\tat Problem.main(tmpa3_0f34g.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660008734
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val zeros = arr.count(_ ==\
    \ 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount = arr.count(_\
    \ == 0)\n        val onesDecimal = onesCount / ones\n        val zerosDecimal\
    \ = zerosCount / zeros\n        val onesDecimalDecimal = onesDecimal / onesDecimal\n\
    \        val zerosDecimalDecimal = zerosDecimal / zerosDecimal\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal / onesDecimalDecimal\n        val zerosDecimalDecimalDecimal\
    \ = zerosDecimalDecimal / zerosDecimalDecimal\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimal / onesDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / zerosDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimal\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimal\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgjly2moq.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpgjly2moq.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpgjly2moq.scala:23:61 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimal"
  stdout: ''
  timestamp: 1660008731
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val twos = arr.count(_ ==\
    \ 2)\n        val threes = arr.count(_ == 3)\n        val fours = arr.count(_\
    \ == 4)\n        val fives = arr.count(_ == 5)\n        val sixes = arr.count(_\
    \ == 6)\n        val sevens = arr.count(_ == 7)\n        val eights = arr.count(_\
    \ == 8)\n        val nines = arr.count(_ == 9)\n        val tens = arr.count(_\
    \ == 10)\n        val hundreds = arr.count(_ == 100)\n        val thousands =\
    \ arr.count(_ == 1000)\n        val millions = arr.count(_ == 1000000)\n     \
    \   val billions = arr.count(_ == 1000000000)\n        val trillions = arr.count(_\
    \ == 1000000000000)\n        val quadrillions = arr.count(_ == 1000000000000000)\n\
    \        val quintillions = arr.count(_ == 1000000000000000000)\n        val onesAndZeros\
    \ = arr.count(_ == 1 && _ == 0)\n        val onesAndOnes = arr.count(_ == 1 &&\
    \ _ == 1)\n        val onesAndTwos = arr.count(_ == 1 && _ == 2)\n        val\
    \ onesAndThrees = arr.count(_ == 1 && _ == 3)\n        val onesAndFours = arr.count(_\
    \ == 1 && _ == 4)\n        val onesAndFives = arr.count(_ == 1 && _ == 5)\n  \
    \      val onesAndSixes = arr.count(_ == 1 && _ == 6)\n        val onesAndSevens\
    \ = arr.count(_ == 1 && _ == 7)\n        val onesAndEights = arr.count(_ == 1\
    \ && _ == 8)\n        val onesAndNines = arr.count(_ == 1 && _ == 9)\n       \
    \ val onesAndTens = arr.count(_ == 1 && _ == 10)\n        val onesAndHundreds\
    \ = arr.count(_ == 1 && _ == 100)\n        val onesAndThousands = arr.count(_\
    \ == 1 && _ == 1000)\n        val onesAndMillions = arr.count(_ == 1 && _ == 1000000)\n\
    \        val onesAndBillions = arr.count(_ == 1 && _ == 1000000000)\n        val\
    \ onesAndTrillions = arr.count(_ == 1 && _ == 1000000000000)\n        val onesAndQuadrillions\
    \ = arr.count(_ == 1 && _ == 1000000000000000)\n        val onesAndQuintillions\
    \ = arr.count(_ == 1 && _ == 1000000000000000000)\n        val twosAndZeros =\
    \ arr.count(_ == 2 && _ == \n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpq6uydraa.scala:44:51 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36mtwosAndZeros\e[0m = arr.count(_\
    \ == \e[31m2\e[0m && _ == \n\e[31m\e[31m   |\e[0m                            \
    \                       ^\e[0m\n\e[31m   |\e[0m                              \
    \         expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- Error: /tmp/tmpq6uydraa.scala:23:39 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mtrillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000\e[0m)\n\e[31m\e[31m   |\e[0m                        \
    \               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \             number too large\n\e[31m\e[31m-- Error: /tmp/tmpq6uydraa.scala:24:42\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m24 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.count(_ == \e[31m1000000000000000\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                          ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                          number too large\n\
    \e[31m\e[31m-- Error: /tmp/tmpq6uydraa.scala:25:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mquintillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m                  \
    \                        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                               number too large\n\e[31m\e[31m-- [E086] Syntax\
    \ Error: /tmp/tmpq6uydraa.scala:26:37 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36monesAndZeros\e[0m = arr.count(_ == \e\
    [31m1\e[0m && _ == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                      \
    \               ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \          Wrong number of parameters, expected: 1\n\e[31m\e[31m-- [E086] Syntax\
    \ Error: /tmp/tmpq6uydraa.scala:27:36 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36monesAndOnes\e[0m = arr.count(_ == \e\
    [31m1\e[0m && _"
  stdout: ''
  timestamp: 1660008711
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(x => x % 2 == 0).size\n        val twos =\
    \ arr.filter(x => x % 2 == 1).size\n        val threes = arr.filter(x => x % 3\
    \ == 0).size\n        val fours = arr.filter(x => x % 4 == 0).size\n        val\
    \ fives = arr.filter(x => x % 5 == 0).size\n        val sixes = arr.filter(x =>\
    \ x % 6 == 0).size\n        val sevens = arr.filter(x => x % 7 == 0).size\n  \
    \      val eights = arr.filter(x => x % 8 == 0).size\n        val nines = arr.filter(x\
    \ => x % 9 == 0).size\n        val tens = arr.filter(x => x % 10 == 0).size\n\
    \        val hundreds = arr.filter(x => x % 100 == 0).size\n        val thousands\
    \ = arr.filter(x => x % 1000 == 0).size\n        val tenThousands = arr.filter(x\
    \ => x % 10000 == 0).size\n        val oneThousands = arr.filter(x => x % 100000\
    \ == 0).size\n        val oneMillions = arr.filter(x => x % 1000000 == 0).size\n\
    \        val oneBillions = arr.filter(x => x % 10000000 == 0).size\n        val\
    \ oneTrillions = arr.filter(x => x % 100000000 == 0).size\n        val oneQuadrillions\
    \ = arr.filter(x => x % 1000000000 == 0).size\n        val oneQuintillions = arr.filter(x\
    \ => x % 10000000000 == 0).size\n        val oneBillionsAndOneTrillions = arr.filter(x\
    \ => x % 1000000000000 == 0).size\n        val oneTrillionsAndOneQuadrillions\
    \ = arr.filter(x => x % 10000000000000 == 0).size\n        val oneQuintillionsAndOneBillion\
    \ = arr.filter(x => x % 100000000000000 == 0).size\n        val oneBillionsAndOneTrillion\
    \ = arr.filter(x => x % 1000000000000000 == 0).size\n        val oneTrillionsAndOneQuadrillion\
    \ = arr.filter(x => x % 10000000000000000 == 0).size\n        val oneQuintillionsAndOneBillion\
    \ = arr.filter(x => x % 100000000000000000 == 0).size\n        val oneBillionsAndOneTrillion\
    \ = arr.filter(x => x % 1000000000000000000 == 0).size\n        val oneTrillionsAndOneQuadrillion\
    \ = arr.filter(x => x % 10000000000000000000 == 0).\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5bomtviv.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp5bomtviv.scala:33:12 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m        \e[33mval\e[0m \e[36moneQuintillionsAndOneBillion\e[0m = arr.filter(\e\
    [36mx\e[0m => x % \e[31m100000000000000000\e[0m == \e[31m0\e[0m).size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moneQuintillionsAndOneBillion is already defined as \e[33mvalue\e\
    [0m \e[35moneQuintillionsAndOneBillion\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5bomtviv.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36moneBillionsAndOneTrillion\e\
    [0m = arr.filter(\e[36mx\e[0m => x % \e[31m1000000000000000000\e[0m == \e[31m0\e\
    [0m).size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moneBillionsAndOneTrillion is already defined as \e[33mvalue\e\
    [0m \e[35moneBillionsAndOneTrillion\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5bomtviv.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36moneTrillionsAndOneQuadrillion\e\
    [0m = arr.filter(\e[36mx\e[0m => x % \e[31m10000000000000000000\e[0m == \e[31m0\e\
    [0m).\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moneTrillionsAndOneQuadrillion is already defined as \e[33mvalue\e\
    [0m \e[35moneTrillionsAndOneQuadrillion\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- Error: /tmp/tmp5bomtviv.scala:27:50 --------"
  stdout: ''
  timestamp: 1660008732
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ == 0)\n        val onesDecimals = ones * decimals\n        val onesDecimalsSorted\
    \ = arr.sortBy(x => math.abs(x - onesDecimals))\n        onesDecimalsSorted.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpeb9nvpi7.scala:16)\n\tat Problem.main(tmpeb9nvpi7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660008737
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(_ % 2 == 0).length\n        val twos = arr.filter(_\
    \ % 2 == 1).length\n        val threes = arr.filter(_ % 3 == 0).length\n     \
    \   val fours = arr.filter(_ % 4 == 0).length\n        val fives = arr.filter(_\
    \ % 5 == 0).length\n        val sixes = arr.filter(_ % 6 == 0).length\n      \
    \  val sevens = arr.filter(_ % 7 == 0).length\n        val eights = arr.filter(_\
    \ % 8 == 0).length\n        val nines = arr.filter(_ % 9 == 0).length\n      \
    \  val tens = arr.filter(_ % 10 == 0).length\n        val hundreds = arr.filter(_\
    \ % 100 == 0).length\n        val thousands = arr.filter(_ % 1000 == 0).length\n\
    \        val onesAndTwelves = arr.filter(_ % 12 == 0).length\n        val onesAndTwentyFours\
    \ = arr.filter(_ % 24 == 0).length\n        val onesAndTwentyFives = arr.filter(_\
    \ % 25 == 0).length\n        val onesAndTwentySixes = arr.filter(_ % 36 == 0).length\n\
    \        val onesAndTwentySevens = arr.filter(_ % 37 == 0).length\n        val\
    \ onesAndTwentyEights = arr.filter(_ % 38 == 0).length\n        val onesAndTwentyNines\
    \ = arr.filter(_ % 39 == 0).length\n        val onesAndTwentyTens = arr.filter(_\
    \ % 40 == 0).length\n        val onesAndTwentyElevens = arr.filter(_ % 41 == 0).length\n\
    \        val onesAndTwentyTwelves = arr.filter(_ % 42 == 0).length\n        val\
    \ onesAndTwentyFourteens = arr.filter(_ % 44 == 0).length\n        val onesAndTwentyFifteens\
    \ = arr.filter(_ % 45 == 0).length\n        val onesAndTwentySixteens = arr.filter(_\
    \ % 46 == 0).length\n        val onesAndTwentySeventeens = arr.filter(_ % 47 ==\
    \ 0).length\n        val onesAndTwentyEighteens = arr.filter(_ % 48 == 0).length\n\
    \        val onesAndTwentyNineteens = arr.filter(_ % 49 == 0).length\n       \
    \ val onesAndTwentyTwentyOnes = arr.filter(_ % 50 == 0).length\n        val onesAndTwentyTwentyTwos\
    \ = arr.filter(_ % 51 == 0).length\n        val onesAndTw\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2_83odg0.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp2_83odg0.scala:40:5 ---------------------\e[0m\e[0m\n\e[31m40 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660008742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(x => x == 1).length\n        val zeros =\
    \ arr.filter(x => x == 0).length\n        val onesDecimal = ones * 10\n      \
    \  val zerosDecimal = zeros * 10\n        val onesDecimalString = onesDecimal.toString\n\
    \        val zerosDecimalString = zerosDecimal.toString\n        val onesDecimalString\
    \ = onesDecimalString.reverse\n        val zerosDecimalString = zerosDecimalString.reverse\n\
    \        val onesDecimalStringList = onesDecimalString.toList\n        val zerosDecimalStringList\
    \ = zerosDecimalString.toList\n        val onesDecimalStringListSorted = onesDecimalStringList.sortBy(x\
    \ => x.toInt)\n        val zerosDecimalStringListSorted = zerosDecimalStringList.sortBy(x\
    \ => x.toInt)\n        val onesDecimalStringListSortedReversed = onesDecimalStringListSorted.reverse\n\
    \        val zerosDecimalStringListSortedReversed = zerosDecimalStringListSorted.reverse\n\
    \        val onesDecimalStringListSortedReversedSorted = onesDecimalStringListSortedReversed.sortBy(x\
    \ => x.toInt)\n        val zerosDecimalStringListSortedReversedSorted = zerosDecimalStringListSortedReversed.sortBy(x\
    \ => x.toInt)\n        val onesDecimalStringListSortedReversedSortedSorted = onesDecimalStringListSortedReversedSorted.reverse\n\
    \        val zerosDecimalStringListSortedReversedSortedSorted = zerosDecimalStringListSortedReversedSorted.reverse\n\
    \        val onesDecimalStringListSortedReversedSortedSortedSorted = onesDecimalStringListSortedReversedSortedSorted.sortBy(x\
    \ => x.toInt)\n        val zerosDecimalStringListSortedReversedSortedSortedSorted\
    \ = zerosDecimalStringListSortedReversedSortedSorted.sortBy(x => x.toInt)\n  \
    \      val onesDecimalStringListSortedReversedSortedSortedSorted = onesDecimalStringListSortedReversedSortedSortedSorted.reverse\n\
    \        val zerosDecimalStringListSortedReversedSortedSortedSorted = zerosDecimalStringListSortedReversedSortedSortedSorted.reverse\n\
    \        val onesDecimalStringListSortedReversedSortedSortedSorted = onesDecimalStringListSortedReversedSortedSortedSorted.sortBy(x\
    \ => x.toInt)\n        val zerosDecimalStringListSortedReversedSortedSortedSorted\
    \ = zerosDecimalStringListSortedReversedSortedSortedSorted.sortBy(x => x.toInt)\n\
    \        val onesDecimalStringListSortedReversedSortedSortedSorted = onesDecimalStringListSortedReversedSortedSortedSorted.reverse\n\
    \        \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbnpaxwqt.scala:15:12 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36monesDecimalString\e[0m =\
    \ onesDecimalString.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalString is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalString\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpbnpaxwqt.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalString\e[0m\
    \ = zerosDecimalString.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalString is already defined as \e[33mvalue\e[0m\
    \ \e[35mzerosDecimalString\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpbnpaxwqt.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36monesDecimalStringListSortedReversedSortedSortedSorted\e\
    [0m = onesDecimalStringListSortedReversedSortedSortedSorted.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalStringListSortedReversedSortedSortedSorted is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalStringListSortedReversedSortedSortedSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpbnpaxwqt.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalStringListSortedReversedSortedSortedSorted\e\
    [0m = zerosDecimalStringListSortedReversedSortedSortedSorted.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660008743
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val twos = arr.count(_ ==\
    \ 2)\n        val threes = arr.count(_ == 3)\n        val fours = arr.count(_\
    \ == 4)\n        val fives = arr.count(_ == 5)\n        val sixes = arr.count(_\
    \ == 6)\n        val sevens = arr.count(_ == 7)\n        val eights = arr.count(_\
    \ == 8)\n        val nines = arr.count(_ == 9)\n        val tens = arr.count(_\
    \ == 10)\n        val hundreds = arr.count(_ == 100)\n        val thousands =\
    \ arr.count(_ == 1000)\n        val millions = arr.count(_ == 1000000)\n     \
    \   val billions = arr.count(_ == 1000000000)\n        val trillions = arr.count(_\
    \ == 1000000000000)\n        val quadrillions = arr.count(_ == 1000000000000000)\n\
    \        val quintillions = arr.count(_ == 1000000000000000000)\n        val onesAndZeros\
    \ = arr.count(_ == 1 && _ == 0)\n        val onesAndOnes = arr.count(_ == 1 &&\
    \ _ == 1)\n        val onesAndTwos = arr.count(_ == 1 && _ == 2)\n        val\
    \ onesAndThrees = arr.count(_ == 1 && _ == 3)\n        val onesAndFours = arr.count(_\
    \ == 1 && _ == 4)\n        val onesAndFives = arr.count(_ == 1 && _ == 5)\n  \
    \      val onesAndSixes = arr.count(_ == 1 && _ == 6)\n        val onesAndSevens\
    \ = arr.count(_ == 1 && _ == 7)\n        val onesAndEights = arr.count(_ == 1\
    \ && _ == 8)\n        val onesAndNines = arr.count(_ == 1 && _ == 9)\n       \
    \ val onesAndTens = arr.count(_ == 1 && _ == 10)\n        val onesAndHundreds\
    \ = arr.count(_ == 1 && _ == 100)\n        val onesAndThousands = arr.count(_\
    \ == 1 && _ == 1000)\n        val onesAndMillions = arr.count(_ == 1 && _ == 1000000)\n\
    \        val onesAndBillions = arr.count(_ == 1 && _ == 1000000000)\n        val\
    \ onesAndTrillions = arr.count(_ == 1 && _ == 1000000000000)\n        val onesAndQuadrillions\
    \ = arr.count(_ == 1 && _ == 1000000000000000)\n        val onesAndQuintillions\
    \ = arr.count(_ == 1 && _ == 1000000000000000000)\n        val onesAndOnesAndZeros\
    \ = arr.count(_ == 1 && \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmppmcvho8c.scala:44:53 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36monesAndOnesAndZeros\e[0m\
    \ = arr.count(_ == \e[31m1\e[0m && \n\e[31m\e[31m   |\e[0m                   \
    \                                  ^\e[0m\n\e[31m   |\e[0m                   \
    \                    expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmppmcvho8c.scala:23:39 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mtrillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000\e[0m)\n\e[31m\e[31m   |\e[0m                        \
    \               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \             number too large\n\e[31m\e[31m-- Error: /tmp/tmppmcvho8c.scala:24:42\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m24 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.count(_ == \e[31m1000000000000000\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                          ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                          number too large\n\
    \e[31m\e[31m-- Error: /tmp/tmppmcvho8c.scala:25:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mquintillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m                  \
    \                        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                               number too large\n\e[31m\e[31m-- [E086] Syntax\
    \ Error: /tmp/tmppmcvho8c.scala:26:37 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36monesAndZeros\e[0m = arr.count(_ == \e\
    [31m1\e[0m && _ == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                      \
    \               ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \          Wrong number of parameters, expected: 1\n\e[31m\e[31m-- [E086] Syntax\
    \ Error: /tmp/tmppmcvho8c.scala:27:36 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36monesAndOnes\e[0m = arr.count(_ == \e\
    [31m1\e[0m "
  stdout: ''
  timestamp: 1660008688
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ == 0)\n        val onesDecimals = ones * decimals\n        val onesDecimalsSorted\
    \ = arr.sortBy(x => onesDecimals.toDouble(x))\n        onesDecimalsSorted.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmpagf_6qc5.scala:12:62 -----------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36monesDecimalsSorted\e[0m\
    \ = arr.sortBy(\e[36mx\e[0m => onesDecimals.toDouble(x))\n\e[31m\e[31m   |\e[0m\
    \                                                 ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                   \e[33mmethod\e[0m \e[35mtoDouble\e[0m in \e\
    [33mclass\e[0m \e[35mInt\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- Error: /tmp/tmpagf_6qc5.scala:12:74 -----------------------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36monesDecimalsSorted\e[0m\
    \ = arr.sortBy(\e[36mx\e[0m => onesDecimals.toDouble(x))\n\e[31m\e[31m   |\e[0m\
    \                                                                          ^\e\
    [0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mChar\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mShort\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660008739
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(x => x % 2 == 1).length\n        val twos\
    \ = arr.filter(x => x % 2 == 0).length\n        val decimal = arr.map(x => math.pow(2,x)).sum\n\
    \        val onesDecimal = math.pow(2,ones)\n        val twosDecimal = math.pow(2,twos)\n\
    \        val decimalDecimal = math.pow(2,decimal)\n        val onesDecimalDecimal\
    \ = math.pow(2,onesDecimal)\n        val twosDecimalDecimal = math.pow(2,twosDecimal)\n\
    \        val decimalDecimalDecimal = math.pow(2,decimalDecimal)\n        val onesDecimalDecimalDecimal\
    \ = math.pow(2,onesDecimalDecimal)\n        val twosDecimalDecimalDecimal = math.pow(2,twosDecimalDecimal)\n\
    \        val decimalDecimalDecimalDecimal = math.pow(2,decimalDecimalDecimal)\n\
    \        val onesDecimalDecimalDecimalDecimal = math.pow(2,onesDecimalDecimalDecimal)\n\
    \        val twosDecimalDecimalDecimalDecimal = math.pow(2,twosDecimalDecimalDecimal)\n\
    \        val decimalDecimalDecimalDecimalDecimal = math.pow(2,decimalDecimalDecimalDecimal)\n\
    \        val onesDecimalDecimalDecimalDecimalDecimal = math.pow(2,onesDecimalDecimalDecimalDecimal)\n\
    \        val twosDecimalDecimalDecimalDecimalDecimal = math.pow(2,twosDecimalDecimalDecimalDecimalDecimal)\n\
    \        val decimalDecimalDecimalDecimalDecimalDecimal = math.pow(2,decimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = math.pow(2,onesDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val twosDecimalDecimalDecimalDecimalDecimalDecimal = math.pow(2,twosDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val decimalDecimalDecimalDecimalDecimalDecimalDecimal = math.pow(2,decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = math.pow(2,onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val twosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = math.pow(2,twosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val decimalDecimalDecimalDecimalDecimalDecimalDecimal = math.pow(2,decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = math.pow(2,onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val twosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = math.pow(2,twosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = math.pow(2,decimalDecimalDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7dbxza2v.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7dbxza2v.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mdecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = math.pow(\e[31m2\e\
    [0m,decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mdecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp7dbxza2v.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = math.pow(\e[31m2\e[0m,onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp7dbxza2v.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mtwosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = math.pow(\e[31m2\e[0m,twosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660008745
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decs = arr.map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val decs = decs.map(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.map(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.map(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.map(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.map(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.map(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.map(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.map(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.map(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.map(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.map(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.map(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.map(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.map(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.map(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.map(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.map(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = de\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmptnet2a_e.scala:11:12 ---------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = decs.map(_.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mdecs is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmptnet2a_e.scala:12:12 ---------------------------\e[0m\e[0m\n\e[31m12\
    \ |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = decs.map(_.toString.toInt)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mdecs is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmptnet2a_e.scala:13:12 ---------------------------\e[0m\e[0m\n\e[31m13\
    \ |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = decs.map(_.toString.toInt)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mdecs is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmptnet2a_e.scala:14:12 ---------------------------\e[0m\e[0m\n\e[31m14\
    \ |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = decs.map(_.toString.toInt)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mdecs is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmptnet2a_e.scala:15:12 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = decs.map(_.toString.toInt)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mdecs is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\e[31m\
    \   |\e["
  stdout: ''
  timestamp: 1660008748
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val zeros = arr.count(_ ==\
    \ 0)\n        val maxOnes = arr.maxBy(_ == 1).getOrElse(0)\n        val maxZeros\
    \ = arr.maxBy(_ == 0).getOrElse(0)\n        val maxOnesDec = maxOnes.toString.toInt\n\
    \        val maxZerosDec = maxZeros.toString.toInt\n        val maxOnesBin = maxOnes.toString.toBinaryString\n\
    \        val maxZerosBin = maxZeros.toString.toBinaryString\n        val maxOnesBinDec\
    \ = maxOnesBin.toString.toInt\n        val maxZerosBinDec = maxZerosBin.toString.toInt\n\
    \        val maxOnesBinBin = maxOnesBin.toString.toBinaryString\n        val maxZerosBinBin\
    \ = maxZerosBin.toString.toBinaryString\n        val maxOnesBinBinDec = maxOnesBinBin.toString.toInt\n\
    \        val maxZerosBinBinDec = maxZerosBinBin.toString.toInt\n        val maxOnesBinBinBin\
    \ = maxOnesBinBin.toString.toBinaryString\n        val maxZerosBinBinBin = maxZerosBinBin.toString.toBinaryString\n\
    \        val maxOnesBinBinBinDec = maxOnesBinBinDec.toString.toInt\n        val\
    \ maxZerosBinBinDec = maxZerosBinBinDec.toString.toInt\n        val maxOnesBinBinBin\
    \ = maxOnesBinBin.toString.toBinaryString\n        val maxZerosBinBinBin = maxZerosBinBin.toString.toBinaryString\n\
    \        val maxOnesBinBinBinDec = maxOnesBinBinDec.toString.toInt\n        val\
    \ maxZerosBinBinDec = maxZerosBinBinDec.toString.toInt\n        val maxOnesBinBinBin\
    \ = maxOnesBinBin.toString.toBinaryString\n        val maxZerosBinBinBin = maxZerosBinBin.toString.toBinaryString\n\
    \        val maxOnesBinBinBinDec = maxOnesBinBinDec.toString.toInt\n        val\
    \ maxZerosBinBinDec = maxZerosBinBinDec.toString.toInt\n        val maxOnesBinBinBin\
    \ = maxOnesBinBin.toString.toBinaryString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4irmevrn.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmaxZerosBinBinDec\e[0m =\
    \ maxZerosBinBinDec.toString.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxZerosBinBinDec is already defined as \e[33mvalue\e[0m \e\
    [35mmaxZerosBinBinDec\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp4irmevrn.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mmaxOnesBinBinBin\e[0m =\
    \ maxOnesBinBin.toString.toBinaryString\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxOnesBinBinBin is already defined as \e[33mvalue\e[0m \e\
    [35mmaxOnesBinBinBin\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp4irmevrn.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mmaxZerosBinBinBin\e[0m =\
    \ maxZerosBinBin.toString.toBinaryString\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxZerosBinBinBin is already defined as \e[33mvalue\e[0m \e\
    [35mmaxZerosBinBinBin\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp4irmevrn.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mmaxOnesBinBinBinDec\e[0m\
    \ = maxOnesBinBinDec.toString.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxOnesBinBinBinDec is already defined as \e[33mvalue\e[0m\
    \ \e[35mmaxOnesBinBinBinDec\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp4i"
  stdout: ''
  timestamp: 1660008749
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val zeros = arr.count(_ ==\
    \ 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount = arr.count(_\
    \ == 0)\n        val onesDecimal = ones / onesCount\n        val zerosDecimal\
    \ = zeros / zerosCount\n        val onesDecimalDecimal = onesDecimal / onesCount\n\
    \        val zerosDecimalDecimal = zerosDecimal / zerosCount\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpggq1nse9.scala:34:4 ----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpggq1nse9.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpggq1nse9.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpggq1nse9.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660008750
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ == 0)\n        val onesDecimal = ones * 10\n        val decimalsDecimal = decimals\
    \ * 10\n        val onesDecimalDecimal = onesDecimal * 10\n        val decimalsDecimalDecimal\
    \ = decimalsDecimal * 10\n        val onesDecimalDecimalDecimal = onesDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimal = decimalsDecimalDecimal * 10\n\
    \        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal * 10\n\
    \        val decimalsDecimalDecimalDecimalDecimal = decimalsDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimalDecimalDecimal = decimalsDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimal = decimalsDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimal = decimalsDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimal = decimalsDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * 10\n  \
    \      val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * 10\n  \
    \      val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * 10\n  \
    \      val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * 10\n  \
    \      val ones\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmph4r2hxvs.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmph4r2hxvs.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mdecimalsDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = decimalsDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalsDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mdecimalsDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmph4r2hxvs.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal * \e[31m10\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmph4r2hxvs.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36mdecimalsDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = decimalsDecimalDecimalDecimalDecimalDecimalDecimal * \e[31m10\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalsDecimalDecimalDecimalDecimalDecimalDecimal is alrea"
  stdout: ''
  timestamp: 1660008746
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ == 0)\n        val sortedArray = arr.sortBy(x => (ones - x) / ones)\n      \
    \  sortedArray.sortBy(x => (decimals - x) / decimals)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArithmeticException: / by zero\n\tat Problem$.sortArray$$anonfun$1(tmpsjnraj0_.scala:12)\n\
    \tat scala.runtime.java8.JFunction1$mcJJ$sp.apply(JFunction1$mcJJ$sp.scala:17)\n\
    \tat scala.math.Ordering$$anon$1.compare(Ordering.scala:141)\n\tat java.base/java.util.TimSort.countRunAndMakeAscending(TimSort.java:355)\n\
    \tat java.base/java.util.TimSort.sort(TimSort.java:220)\n\tat java.base/java.util.Arrays.sort(Arrays.java:1233)\n\
    \tat scala.collection.SeqOps.sorted(Seq.scala:700)\n\tat scala.collection.SeqOps.sorted$(Seq.scala:692)\n\
    \tat scala.collection.immutable.List.scala$collection$immutable$StrictOptimizedSeqOps$$super$sorted(List.scala:79)\n\
    \tat scala.collection.immutable.StrictOptimizedSeqOps.sorted(StrictOptimizedSeqOps.scala:78)\n\
    \tat scala.collection.immutable.StrictOptimizedSeqOps.sorted$(StrictOptimizedSeqOps.scala:78)\n\
    \tat scala.collection.immutable.List.sorted(List.scala:79)\n\tat scala.collection.SeqOps.sortBy(Seq.scala:754)\n\
    \tat scala.collection.SeqOps.sortBy$(Seq.scala:754)\n\tat scala.collection.AbstractSeq.sortBy(Seq.scala:1161)\n\
    \tat Problem$.sortArray(tmpsjnraj0_.scala:12)\n\tat Problem$.main(tmpsjnraj0_.scala:15)\n\
    \tat Problem.main(tmpsjnraj0_.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner"
  stdout: ''
  timestamp: 1660008751
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ > 0)\n        val onesDecimal = ones * 10\n        val decimalsDecimal = decimals\
    \ * 10\n        arr.sortWith(\n            (a, b) => onesDecimal - decimalsDecimal\
    \ + a.toLong - b.toLong\n        )\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmu1vxp0x.scala:14:22\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m            (\e[36ma\e[0m, \e\
    [36mb\e[0m) => onesDecimal - decimalsDecimal + a.toLong - b.toLong\n\e[31m\e[31m\
    \   |\e[0m                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      Found:    Long\n\e[31m   |\e[0m    \
    \                  Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660008748
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(x => x == 1)\n        val zeros = arr.count(x\
    \ => x == 0)\n        val onesArr = arr.filter(x => x == 1).map(x => x.toBinaryString).sorted\n\
    \        val zerosArr = arr.filter(x => x == 0).map(x => x.toBinaryString).sorted\n\
    \        val onesCount = onesArr.length\n        val zerosCount = zerosArr.length\n\
    \        val onesDecimal = onesArr.map(x => x.toInt).sum\n        val zerosDecimal\
    \ = zerosArr.map(x => x.toInt).sum\n        val onesDecimalCount = onesArr.map(x\
    \ => x.toInt).count\n        val zerosDecimalCount = zerosArr.map(x => x.toInt).count\n\
    \        val onesDecimalCount = onesArr.map(x => x.toInt).count\n        val zerosDecimalCount\
    \ = zerosArr.map(x => x.toInt).count\n        val onesDecimalCount = onesArr.map(x\
    \ => x.toInt).count\n        val zerosDecimalCount = zerosArr.map(x => x.toInt).count\n\
    \        val onesDecimalCount = onesArr.map(x => x.toInt).count\n        val zerosDecimalCount\
    \ = zerosArr.map(x => x.toInt).count\n        val onesDecimalCount = onesArr.map(x\
    \ => x.toInt).count\n        val zerosDecimalCount = zerosArr.map(x => x.toInt).count\n\
    \        val onesDecimalCount = onesArr.map(x => x.toInt).count\n        val zerosDecimalCount\
    \ = zerosArr.map(x => x.toInt).count\n        val onesDecimalCount = onesArr.map(x\
    \ => x.toInt).count\n        val zerosDecimalCount = zerosArr.map(x => x.toInt).count\n\
    \        val onesDecimalCount = onesArr.map(x => x.toInt).count\n        val zerosDecimalCount\
    \ = zerosArr.map(x => x.toInt).count\n        val onesDecimalCount = onesArr.map(x\
    \ => x.toInt).count\n        val zerosDecimalCount = zerosArr.map(x => x.toInt).count\n\
    \        val onesDecimalCount = onesArr.map(x => x.toInt).count\n        val zerosDecimalCount\
    \ = zerosArr.map(x => x.toInt).count\n        val onesDecimalCount = onesArr.map(x\
    \ => x.toInt).count\n        val zerosDecimalCount = zerosArr.map(x => x.\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpyridl3h0.scala:39:4 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpyridl3h0.scala:19:12 ---------------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m = onesArr.map(\e[36mx\e\
    [0m => x.toInt).count\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpyridl3h0.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalCount\e[0m =\
    \ zerosArr.map(\e[36mx\e[0m => x.toInt).count\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35mzerosDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpyridl3h0.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m =\
    \ onesArr.map(\e[36mx\e[0m => x.toInt).count\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpyridl3h0.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalCount\e[0m =\
    \ zerosArr.map(\e[36mx\e[0m => x.toInt).count\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalCount is already defined as \e[3"
  stdout: ''
  timestamp: 1660008752
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(_ % 2 == 0).length\n        val decimals\
    \ = arr.filter(_ % 2 == 1).length\n        val onesDecimals = ones * decimals\n\
    \        arr.sortBy(x => (onesDecimals - x.toString.toLong))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp91glmt5.scala:15)\n\tat Problem.main(tmpp91glmt5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660008755
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decs = arr.map(x => math.log10(x))\n\
    \        val decs = decs.sortBy(x => math.abs(x))\n        val decs = decs.sortBy(x\
    \ => math.signum(x))\n        val decs = decs.sortBy(x => math.abs(x))\n     \
    \   val decs = decs.sortBy(x => math.signum(x))\n        val decs = decs.sortBy(x\
    \ => math.abs(x))\n        val decs = decs.sortBy(x => math.signum(x))\n     \
    \   val decs = decs.sortBy(x => math.abs(x))\n        val decs = decs.sortBy(x\
    \ => math.signum(x))\n        val decs = decs.sortBy(x => math.abs(x))\n     \
    \   val decs = decs.sortBy(x => math.signum(x))\n        val decs = decs.sortBy(x\
    \ => math.abs(x))\n        val decs = decs.sortBy(x => math.signum(x))\n     \
    \   val decs = decs.sortBy(x => math.abs(x))\n        val decs = decs.sortBy(x\
    \ => math.signum(x))\n        val decs = decs.sortBy(x => math.abs(x))\n     \
    \   val decs = decs.sortBy(x => math.signum(x))\n        val decs = decs.sortBy(x\
    \ => math.abs(x))\n        val decs = decs.sortBy(x => math.signum(x))\n     \
    \   val decs = decs.sortBy(x => math.abs(x))\n        val decs = decs.sortBy(x\
    \ => math.signum(x))\n        val decs = decs.sortBy(x => math.abs(x))\n     \
    \   val decs = decs.sortBy(x => math.signum(x))\n        val decs = decs.sortBy(x\
    \ => math.abs(x))\n        val decs = decs.sortBy(x => math.signum(x))\n     \
    \   val decs = decs.sortBy(x => math.abs(x))\n        val decs = decs.sortBy(x\
    \ => math.signum(x))\n        val decs = decs.sortBy(x => math.abs(x))\n     \
    \   val decs = decs.sortBy(x => math.signum(x))\n        val decs = decs.sortBy(x\
    \ => math.abs(x))\n        val decs = decs.sortBy(x => math.signum(x))\n     \
    \   val decs = decs.sortBy(x => math.abs(x))\n        val decs = decs.sortBy(x\
    \ => math.signum(x))\n        val decs = decs.sortBy(x => math.abs(x))\n     \
    \   val decs = decs.sortBy(x => math.sig\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp029os9cv.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp029os9cv.scala:11:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m\
    \ \e[36mdecs\e[0m = decs.sortBy(\e[36mx\e[0m => math.abs(x))\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mdecs\
    \ is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp029os9cv.scala:12:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36mdecs\e[0m = decs.sortBy(\e[36mx\e[0m => math.signum(x))\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mdecs is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp029os9cv.scala:13:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m\
    \ \e[36mdecs\e[0m = decs.sortBy(\e[36mx\e[0m => math.abs(x))\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mdecs\
    \ is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp029os9cv.scala:14:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m\
    \ \e[36mdecs\e[0m = decs.sortBy(\e[36mx\e[0m => math.signum(x))\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mdecs is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp029os9cv.scala:15:1"
  stdout: ''
  timestamp: 1660008753
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(_ % 2 == 0).length\n        val decimals\
    \ = arr.filter(_ % 2 == 1).length\n        val onesDecimals = arr.filter(_ % 2\
    \ == 0).map(_ / 2).length\n        val decimalsDecimals = arr.filter(_ % 2 ==\
    \ 1).map(_ / 2).length\n        val onesDecimalsDecimals = arr.filter(_ % 2 ==\
    \ 0).map(_ / 2).map(_ / 2).length\n        val decimalsDecimalsDecimals = arr.filter(_\
    \ % 2 == 1).map(_ / 2).map(_ / 2).map(_ / 2).length\n        val onesDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 2 == 0).map(_ / 2).map(_ / 2).map(_ / 2).map(_ / 2).length\n\
    \        val decimalsDecimalsDecimalsDecimals = arr.filter(_ % 2 == 1).map(_ /\
    \ 2).map(_ / 2).map(_ / 2).map(_ / 2).map(_ / 2).length\n        val onesDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 2 == 0).map(_ / 2).map(_ / 2).map(_ / 2).map(_ / 2).map(_ /\
    \ 2).map(_ / 2).length\n        val decimalsDecimalsDecimalsDecimalsDecimals =\
    \ arr.filter(_ % 2 == 1).map(_ / 2).map(_ / 2).map(_ / 2).map(_ / 2).map(_ / 2).map(_\
    \ / 2).map(_ / 2).length\n        val onesDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 2 == 0).map(_ / 2).map(_ / 2).map(_ / 2).map(_ / 2).map(_ /\
    \ 2).map(_ / 2).map(_ / 2).map(_ / 2).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 2 == 1).map(_ / 2).map(_ / 2).map(_ / 2).map(_ / 2).map(_ /\
    \ 2).map(_ / 2).map(_ / 2).map(_ / 2).map(_ / 2).length\n        val onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 2 == 0).map(_ / 2).map(_ / 2).map(_ / 2).map(_ / 2).map(_ /\
    \ 2).map(_ / 2).map(_ / 2).map(_ / 2).map(_ / 2).map(_ / 2).map(_ / 2).length\n\
    \        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals = arr.filter(_\
    \ % 2 == 1).map(_ / 2).map(_ / 2).map(_ / 2).map(_ / 2).map(_ / 2).map(_ / 2).map(_\
    \ / 2).map(_ / 2).map(_\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp34efopz2.scala:23:4 ----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp34efopz2.scala:23:5 ---------------------\e[0m\e[0m\n\e[31m23 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660008754
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val twos = arr.count(_ ==\
    \ 2)\n        val threes = arr.count(_ == 3)\n        val fours = arr.count(_\
    \ == 4)\n        val fives = arr.count(_ == 5)\n        val sixes = arr.count(_\
    \ == 6)\n        val sevens = arr.count(_ == 7)\n        val eights = arr.count(_\
    \ == 8)\n        val nines = arr.count(_ == 9)\n        val tens = arr.count(_\
    \ == 10)\n        val hundreds = arr.count(_ == 100)\n        val thousands =\
    \ arr.count(_ == 1000)\n        val millions = arr.count(_ == 1000000)\n     \
    \   val billions = arr.count(_ == 1000000000)\n        val trillions = arr.count(_\
    \ == 1000000000000)\n        val quadrillions = arr.count(_ == 1000000000000000)\n\
    \        val quintillions = arr.count(_ == 1000000000000000000)\n        val onesAndZeros\
    \ = arr.count(_ == 1 && _ == 0)\n        val onesAndOnes = arr.count(_ == 1 &&\
    \ _ == 1)\n        val onesAndTwos = arr.count(_ == 1 && _ == 2)\n        val\
    \ onesAndThrees = arr.count(_ == 1 && _ == 3)\n        val onesAndFours = arr.count(_\
    \ == 1 && _ == 4)\n        val onesAndFives = arr.count(_ == 1 && _ == 5)\n  \
    \      val onesAndSixes = arr.count(_ == 1 && _ == 6)\n        val onesAndSevens\
    \ = arr.count(_ == 1 && _ == 7)\n        val onesAndEights = arr.count(_ == 1\
    \ && _ == 8)\n        val onesAndNines = arr.count(_ == 1 && _ == 9)\n       \
    \ val onesAndTens = arr.count(_ == 1 && _ == 10)\n        val onesAndHundreds\
    \ = arr.count(_ == 1 && _ == 100)\n        val onesAndThousands = arr.count(_\
    \ == 1 && _ == 1000)\n        val onesAndMillions = arr.count(_ == 1 && _ == 1000000)\n\
    \        val onesAndBillions = arr.count(_ == 1 && _ == 1000000000)\n        val\
    \ onesAndTrillions = arr.count(_ == 1 && _ == 1000000000000)\n        val onesAndQuadrillions\
    \ = arr.count(_ == 1 && _ == 1000000000000000)\n        val onesAndQuintillions\
    \ = arr.count(_ == 1 && _ == 1000000000000000000)\n        val twosAndZeros =\
    \ arr.count(_ == 2 && _ == \n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpq6uydraa.scala:44:51 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36mtwosAndZeros\e[0m = arr.count(_\
    \ == \e[31m2\e[0m && _ == \n\e[31m\e[31m   |\e[0m                            \
    \                       ^\e[0m\n\e[31m   |\e[0m                              \
    \         expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- Error: /tmp/tmpq6uydraa.scala:23:39 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mtrillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000\e[0m)\n\e[31m\e[31m   |\e[0m                        \
    \               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \             number too large\n\e[31m\e[31m-- Error: /tmp/tmpq6uydraa.scala:24:42\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m24 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.count(_ == \e[31m1000000000000000\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                          ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                          number too large\n\
    \e[31m\e[31m-- Error: /tmp/tmpq6uydraa.scala:25:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mquintillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m                  \
    \                        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                               number too large\n\e[31m\e[31m-- [E086] Syntax\
    \ Error: /tmp/tmpq6uydraa.scala:26:37 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36monesAndZeros\e[0m = arr.count(_ == \e\
    [31m1\e[0m && _ == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                      \
    \               ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \          Wrong number of parameters, expected: 1\n\e[31m\e[31m-- [E086] Syntax\
    \ Error: /tmp/tmpq6uydraa.scala:27:36 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36monesAndOnes\e[0m = arr.count(_ == \e\
    [31m1\e[0m && _"
  stdout: ''
  timestamp: 1660008711
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(x => x == 1).length\n        val decimals\
    \ = arr.filter(x => x == 0).length\n        val maxOnes = arr.max\n        val\
    \ maxDecimals = arr.max\n        val onesDecimals = ones * maxDecimals\n     \
    \   val decimalsOnes = decimals * maxOnes\n        val onesDecimalsOnes = onesDecimals\
    \ * maxOnes\n        val onesDecimalsOnesDecimals = onesDecimalsOnes * maxDecimals\n\
    \        val onesDecimalsOnesDecimalsOnes = onesDecimalsOnesDecimals * maxOnes\n\
    \        val onesDecimalsOnesDecimalsOnesDecimals = onesDecimalsOnesDecimalsOnes\
    \ * maxDecimals\n        val onesDecimalsOnesDecimalsOnesDecimalsOnes = onesDecimalsOnesDecimalsOnesDecimals\
    \ * maxOnes\n        val onesDecimalsOnesDecimalsOnesDecimalsOnesDecimals = onesDecimalsOnesDecimalsOnesDecimalsOnes\
    \ * maxDecimals\n        val onesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnes\
    \ = onesDecimalsOnesDecimalsOnesDecimalsOnesDecimals * maxOnes\n        val onesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnesDecimals\
    \ = onesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnes * maxDecimals\n     \
    \   val onesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnes = onesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnesDecimals\
    \ * maxOnes\n        val onesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnesDecimals\
    \ = onesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnes * maxDecimals\n\
    \        val onesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnes\
    \ = onesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnesDecimals *\
    \ maxOnes\n        val onesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnes\
    \ = onesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnesDecimals\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxsiolfiz.scala:27:5\
    \ ---------------------\e[0m\e[0m\n\e[31m27 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660008751
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(_ % 2 == 0).length\n        val twos = arr.filter(_\
    \ % 2 == 1).length\n        val threes = arr.filter(_ % 3 == 0).length\n     \
    \   val fours = arr.filter(_ % 4 == 0).length\n        val fives = arr.filter(_\
    \ % 5 == 0).length\n        val sixes = arr.filter(_ % 6 == 0).length\n      \
    \  val sevens = arr.filter(_ % 7 == 0).length\n        val eights = arr.filter(_\
    \ % 8 == 0).length\n        val nines = arr.filter(_ % 9 == 0).length\n      \
    \  val tens = arr.filter(_ % 10 == 0).length\n        val hundreds = arr.filter(_\
    \ % 100 == 0).length\n        val thousands = arr.filter(_ % 1000 == 0).length\n\
    \        val tenThousands = arr.filter(_ % 10000 == 0).length\n        val oneThousands\
    \ = arr.filter(_ % 100000 == 0).length\n        val oneMillion = arr.filter(_\
    \ % 1000000 == 0).length\n        val oneBillion = arr.filter(_ % 10000000 ==\
    \ 0).length\n        val oneTrillion = arr.filter(_ % 100000000 == 0).length\n\
    \        val oneQuadrillion = arr.filter(_ % 1000000000 == 0).length\n       \
    \ val oneQuintillion = arr.filter(_ % 10000000000 == 0).length\n        val oneGigantic\
    \ = arr.filter(_ % 1000000000000 == 0).length\n        val oneTerabillion = arr.filter(_\
    \ % 1000000000000000 == 0).length\n        val onePentabillion = arr.filter(_\
    \ % 10000000000000000 == 0).length\n        val oneExabillion = arr.filter(_ %\
    \ 100000000000000000 == 0).length\n        val oneQuintillion = arr.filter(_ %\
    \ 1000000000000000000 == 0).length\n        val oneGigantic = arr.filter(_ % 100000000000000000000\
    \ == 0).length\n        val oneTerabillion = arr.filter(_ % 100000000000000000000000\
    \ == 0).length\n        val onePentabillion = arr.filter(_ % 1000000000000000000000000\
    \ == 0).length\n        val oneExabillion = arr.filter(_ % 10000000000000000000000000\
    \ == 0).length\n        val oneQuintillion = arr.filter(_ % 100000000000000000000000000\
    \ == 0).length\n        val oneGigantic = arr.filter(_ % 10000000000000000000000000000\
    \ == 0).length\n        val oneTerabillion = arr.filter(_ % 10000000000000000000000000000000\
    \ == 0).length\n        val onePentabillion = arr.filter(_ % 100000000000000000000000000000000\
    \ == 0).length\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9xuqa4mo.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36moneQuintillion\e[0m = arr.filter(_\
    \ % \e[31m1000000000000000000\e[0m == \e[31m0\e[0m).length\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moneQuintillion is already defined as \e[33mvalue\e[0m \e[35moneQuintillion\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp9xuqa4mo.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36moneGigantic\e[0m = arr.filter(_ % \e\
    [31m100000000000000000000\e[0m == \e[31m0\e[0m).length\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moneGigantic is already defined as \e[33mvalue\e[0m \e[35moneGigantic\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp9xuqa4mo.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36moneTerabillion\e[0m = arr.filter(_ %\
    \ \e[31m100000000000000000000000\e[0m == \e[31m0\e[0m).length\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moneTerabillion is already defined as \e[33mvalue\e[0m \e[35moneTerabillion\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp9xuqa4mo.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36monePentabillion\e[0m = arr.filter(_\
    \ % \e[31m1000000000000000000000000\e[0m == \e[31m0\e[0m).length\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monePentabillion is already defined as \e[33mvalue\e[0m \e\
    [35monePentabillion\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e"
  stdout: ''
  timestamp: 1660008753
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ == 0)\n        val onesDecimal = ones * 10\n        val decimalsDecimal = decimals\
    \ * 10\n        val onesDecimals = onesDecimal.toInt\n        val decimalsDecimals\
    \ = decimalsDecimal.toInt\n        val onesDecimalsDecimals = onesDecimals * decimalsDecimals\n\
    \        val decimalsDecimalsDecimals = decimalsDecimals * decimalsDecimals\n\
    \        val onesDecimalsDecimalsDecimals = onesDecimalsDecimals * decimalsDecimalsDecimals\n\
    \        val decimalsDecimalsDecimalsDecimals = decimalsDecimalsDecimals * decimalsDecimalsDecimals\n\
    \        val onesDecimalsDecimalsDecimalsDecimals = onesDecimalsDecimalsDecimals\
    \ * decimalsDecimalsDecimalsDecimals\n        val decimalsDecimalsDecimalsDecimalsDecimals\
    \ = decimalsDecimalsDecimals * decimalsDecimalsDecimalsDecimals\n        val onesDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = onesDecimalsDecimalsDecimals * decimalsDecimalsDecimalsDecimalsDecimals\n\
    \        val decimalsDecimalsDecimalsDecimalsDecimalsDecimals = decimalsDecimalsDecimals\
    \ * decimalsDecimalsDecimalsDecimalsDecimalsDecimals\n        val onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = onesDecimalsDecimalsDecimals * decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\n\
    \        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals = decimalsDecimalsDecimals\
    \ * decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\n       \
    \ val onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals = onesDecimalsDecimalsDecimals\
    \ * decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\n\
    \        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = decimalsDecimalsDecimals * decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\n\
    \        val onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = onesDecimalsDecimalsDecimals * decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\n\
    \        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = decimalsDecimalsDecimal\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpakida3iw.scala:22:90 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mdecimalsDecimalsDecimalsDecimalsDecimalsDecimals\e\
    [0m = decimalsDecimalsDecimals * decimalsDecimalsDecimalsDecimalsDecimalsDecimals\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                  ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35mdecimalsDecimalsDecimalsDecimalsDecimalsDecimals\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpakida3iw.scala:28:95\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mdecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\e\
    [0m = decimalsDecimalsDecimal\n\e[31m\e[31m   |\e[0m                         \
    \                                                                      ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                      Not found: decimalsDecimalsDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpakida3iw.scala:25:106\
    \ -----------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\e[0m = onesDecimalsDecimalsDecimals\
    \ * decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpakida3iw.scala:27:114\
    \ -----------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\e[0m "
  stdout: ''
  timestamp: 1660008754
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val zeros = arr.count(_ ==\
    \ 0)\n        val maxOnes = arr.count(_ == 1)\n        val maxZeros = arr.count(_\
    \ == 0)\n        val maxOnesZeros = arr.count(_ == 1 && _ == 0)\n        val maxOnesOnes\
    \ = arr.count(_ == 1 && _ == 1)\n        val maxOnesTwos = arr.count(_ == 1 &&\
    \ _ == 2)\n        val maxOnesThrees = arr.count(_ == 1 && _ == 3)\n        val\
    \ maxOnesFours = arr.count(_ == 1 && _ == 4)\n        val maxOnesFives = arr.count(_\
    \ == 1 && _ == 5)\n        val maxOnesSixes = arr.count(_ == 1 && _ == 6)\n  \
    \      val maxOnesSevens = arr.count(_ == 1 && _ == 7)\n        val maxOnesEights\
    \ = arr.count(_ == 1 && _ == 8)\n        val maxOnesNines = arr.count(_ == 1 &&\
    \ _ == 9)\n        val maxOnesTens = arr.count(_ == 1 && _ == 10)\n        val\
    \ maxOnesElevens = arr.count(_ == 1 && _ == 11)\n        val maxOnesTwelves =\
    \ arr.count(_ == 1 && _ == 12)\n        val maxOnesThirteens = arr.count(_ ==\
    \ 1 && _ == 13)\n        val maxOnesFourteens = arr.count(_ == 1 && _ == 14)\n\
    \        val maxOnesFifteens = arr.count(_ == 1 && _ == 15)\n        val maxOnesSixteens\
    \ = arr.count(_ == 1 && _ == 16)\n        val maxOnesSeventeens = arr.count(_\
    \ == 1 && _ == 17)\n        val maxOnesEighteens = arr.count(_ == 1 && _ == 18)\n\
    \        val maxOnesNineteens = arr.count(_ == 1 && _ == 19)\n        val maxOnesTwentys\
    \ = arr.count(_ == 1 && _ == 20)\n        val maxOnesTwentyFours = arr.count(_\
    \ == 1 && _ == 24)\n        val maxOnesTwentyFives = arr.count(_ == 1 && _ ==\
    \ 25)\n        val maxOnesTwentySixes = arr.count(_ == 1 && _ == 26)\n       \
    \ val maxOnesTwentySevens = arr.count(_ == 1 && _ == 27)\n        val maxOnesTwentyEights\
    \ = arr.count(_ == 1 && _ == 28)\n        val maxOnesTwentyN\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4x2praq4.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp4x2praq4.scala:13:37\
    \ ---------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxOnesZeros\e[0m = arr.count(_ == \e[31m1\e[0m && _ == \e[31m0\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                     ^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                 Wrong number of parameters, expected:\
    \ 1\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp4x2praq4.scala:14:36 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mmaxOnesOnes\e[0m = arr.count(_\
    \ == \e[31m1\e[0m && _ == \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m               \
    \                     ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                Wrong number of parameters, expected: 1\n\e[31m\e[31m-- [E086]\
    \ Syntax Error: /tmp/tmp4x2praq4.scala:15:36 ---------------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mmaxOnesTwos\e[0m = arr.count(_\
    \ == \e[31m1\e[0m && _ == \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m               \
    \                     ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                Wrong number of parameters, expected: 1\n\e[31m\e[31m-- [E086]\
    \ Syntax Error: /tmp/tmp4x2praq4.scala:16:38 ---------------------------\e[0m\e\
    [0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mmaxOnesThrees\e[0m = arr.count(_\
    \ == \e[31m1\e[0m && _ == \e[31m3\e[0m)\n\e[31m\e[31m   |\e[0m               \
    \                       ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                  Wrong number of parameters, expected: 1\n\e[31m\e[31m-- [E086]\
    \ Syntax Error: /tmp/tmp4x2praq4.scala:17:37 ---------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxOnesFours\e[0m = arr.count(_\
    \ == \e[31m1\e[0m && _ == \e[31m4\e[0m)\n\e[31m\e[31m   |\e[0m               \
    \                      ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \                 Wrong number of parameters, expected: 1\n\e[31m\e[31m-- [E086]\
    \ Syntax Error: "
  stdout: ''
  timestamp: 1660008753
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ == 0)\n        val onesDecimals = ones * decimals\n        val onesDecimalsSorted\
    \ = arr.sortBy(x => math.abs(math.log2(x)))\n        val onesDecimalsSortedWithOnes\
    \ = onesDecimalsSorted.take(onesDecimals)\n        val onesDecimalsSortedWithOnesSorted\
    \ = onesDecimalsSortedWithOnes.sortBy(x => math.abs(math.log2(x)))\n        onesDecimalsSortedWithOnesSorted\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7sem6qh_.scala:12:63 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36monesDecimalsSorted\e[0m\
    \ = arr.sortBy(\e[36mx\e[0m => math.abs(math.log2(x)))\n\e[31m\e[31m   |\e[0m\
    \                                                          ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                      value log2 is not a member\
    \ of math\n\e[31m\e[31m-- Error: /tmp/tmp7sem6qh_.scala:12:72 -----------------------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36monesDecimalsSorted\e[0m\
    \ = arr.sortBy(\e[36mx\e[0m => math.abs(math.log2(x)))\n\e[31m\e[31m   |\e[0m\
    \                                                                        ^\e[0m\n\
    \e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mByte\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mBigInt\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660008753
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ % 2 == 0)\n        val onesDecimals = ones * decimals\n        val onesDecimalsSorted\
    \ = arr.sortBy(x => onesDecimals.toDouble(x))\n        onesDecimalsSorted.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmprjsb6iut.scala:12:62 -----------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36monesDecimalsSorted\e[0m\
    \ = arr.sortBy(\e[36mx\e[0m => onesDecimals.toDouble(x))\n\e[31m\e[31m   |\e[0m\
    \                                                 ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                   \e[33mmethod\e[0m \e[35mtoDouble\e[0m in \e\
    [33mclass\e[0m \e[35mInt\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- Error: /tmp/tmprjsb6iut.scala:12:74 -----------------------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36monesDecimalsSorted\e[0m\
    \ = arr.sortBy(\e[36mx\e[0m => onesDecimals.toDouble(x))\n\e[31m\e[31m   |\e[0m\
    \                                                                          ^\e\
    [0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mChar\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mShort\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660008750
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(x => x == 1).length\n        val twos = arr.filter(x\
    \ => x == 2).length\n        val threes = arr.filter(x => x == 3).length\n   \
    \     val fours = arr.filter(x => x == 4).length\n        val fives = arr.filter(x\
    \ => x == 5).length\n        val sixes = arr.filter(x => x == 6).length\n    \
    \    val sevens = arr.filter(x => x == 7).length\n        val eights = arr.filter(x\
    \ => x == 8).length\n        val nines = arr.filter(x => x == 9).length\n    \
    \    val tens = arr.filter(x => x == 10).length\n        val hundreds = arr.filter(x\
    \ => x == 11).length\n        val thousands = arr.filter(x => x == 100).length\n\
    \        val tenThousands = arr.filter(x => x == 1000).length\n        val oneThousands\
    \ = arr.filter(x => x == 10000).length\n        val oneMillion = arr.filter(x\
    \ => x == 100000).length\n        val oneBillion = arr.filter(x => x == 1000000).length\n\
    \        val oneTrillion = arr.filter(x => x == 10000000).length\n        val\
    \ oneQuadrillion = arr.filter(x => x == 100000000).length\n        val oneQuintillion\
    \ = arr.filter(x => x == 1000000000).length\n        val oneGigantic = arr.filter(x\
    \ => x == 10000000000).length\n        val oneTerrillion = arr.filter(x => x ==\
    \ 100000000000).length\n        val onePentaMillion = arr.filter(x => x == 1000000000000).length\n\
    \        val oneExabillion = arr.filter(x => x == 10000000000000).length\n   \
    \     val oneQuintillion = arr.filter(x => x == 100000000000000).length\n    \
    \    val oneGigantic = arr.filter(x => x == 1000000000000000).length\n       \
    \ val oneTerrillion = arr.filter(x => x == 10000000000000000).length\n       \
    \ val onePentaMillion = arr.filter(x => x == 100000000000000000).length\n    \
    \    val oneExabillion = arr.filter(x => x == 1000000000000000000).length\n  \
    \      val oneQuintillion = arr.filter(x => x == 10000000000000000000).length\n\
    \        val oneGigantic = arr.filter(x => x == 100000000000000000000).length\n\
    \        val oneTerrillion = arr.filter(x => x == 1000000000000000000000).length\n\
    \        val onePentaMillion = arr.filter(x => x == 10000000000000000000000).length\n\
    \        val oneExabilli\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpk1i8_hc7.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpk1i8_hc7.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36moneQuintillion\e[0m = arr.filter(\e[36mx\e[0m => x == \e[31m100000000000000\e\
    [0m).length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moneQuintillion is already defined as \e[33mvalue\e[0m \e[35moneQuintillion\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpk1i8_hc7.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36moneGigantic\e[0m = arr.filter(\e[36mx\e\
    [0m => x == \e[31m1000000000000000\e[0m).length\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0moneGigantic is already defined as \e[33mvalue\e[0m \e[35moneGigantic\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpk1i8_hc7.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36moneTerrillion\e[0m = arr.filter(\e[36mx\e\
    [0m => x == \e[31m10000000000000000\e[0m).length\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0moneTerrillion is already defined as \e[33mvalue\e[0m \e[35moneTerrillion\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpk1i8_hc7.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36monePentaMillion\e[0m = arr.filter(\e\
    [36mx\e[0m => x == \e[31m100000000000000000\e[0m).length\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660008755
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val zeros = arr.count(_ ==\
    \ 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount = arr.count(_\
    \ == 0)\n        val onesDecimal = onesCount / arr.size\n        val zerosDecimal\
    \ = zerosCount / arr.size\n        val onesDecimalDecimal = onesDecimal + zerosDecimal\n\
    \        val zerosDecimalDecimal = zerosDecimal + onesDecimal\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal * 10\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * 10\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * 10\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * 10\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsev8ar4w.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal * \e[31m10\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpsev8ar4w.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * \e[31m10\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpsev8ar4w.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal * \e[31m10\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel defi"
  stdout: ''
  timestamp: 1660008755
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(x => x == 1)\n        val decimals = arr.count(x\
    \ => x == 0)\n        val sortedArray = arr.sortBy(x => if (x == 1) ones else\
    \ decimals)\n        sortedArray\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp89yris4j.scala:15)\n\tat Problem.main(tmp89yris4j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660008730
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(x => x == 1)\n        val decimals = arr.count(x\
    \ => x == 0)\n        val maxOnes = arr.count(x => x == 1)\n        val maxDecimals\
    \ = arr.count(x => x == 0)\n        val maxOnesDecimals = arr.count(x => x ==\
    \ 1)\n        val maxDecimalsOnes = arr.count(x => x == 0)\n        val maxOnesDecimalsOnes\
    \ = arr.count(x => x == 1)\n        val maxDecimalsOnesOnes = arr.count(x => x\
    \ == 0)\n        val maxOnesDecimalsOnesOnes = arr.count(x => x == 1)\n      \
    \  val maxDecimalsOnesOnesOnes = arr.count(x => x == 0)\n        val maxOnesDecimalsOnesOnesOnes\
    \ = arr.count(x => x == 1)\n        val maxDecimalsOnesOnesOnesOnesOnes = arr.count(x\
    \ => x == 0)\n        val maxOnesDecimalsOnesOnesOnesOnesOnes = arr.count(x =>\
    \ x == 1)\n        val maxDecimalsOnesOnesOnesOnesOnesOnesOnes = arr.count(x =>\
    \ x == 0)\n        val maxOnesDecimalsOnesOnesOnesOnesOnesOnesOnes = arr.count(x\
    \ => x == 1)\n        val maxDecimalsOnesOnesOnesOnesOnesOnesOnesOnesOnes = arr.count(x\
    \ => x == 0)\n        val maxOnesDecimalsOnesOnesOnesOnesOnesOnesOnesOnesOnes\
    \ = arr.count(x => x == 1)\n        val maxDecimalsOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnes\
    \ = arr.count(x => x == 0)\n        val maxOnesDecimalsOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnes\
    \ = arr.count(x => x == 1)\n        val maxDecimalsOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnes\
    \ = arr.count(x => x == 0)\n        val maxOnesDecimalsOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnes\
    \ = arr.count(x => x == 1)\n        val maxDecimalsOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOne\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmf0_7rcc.scala:31:4 ----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpmf0_7rcc.scala:31:5 ---------------------\e[0m\e[0m\n\e[31m31 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660008757
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val zeros = arr.count(_ ==\
    \ 0)\n        val onesArr = arr.filter(_ == 1).sortBy(_.toString.toInt)\n    \
    \    val zerosArr = arr.filter(_ == 0).sortBy(_.toString.toInt)\n        val onesZeros\
    \ = ones + zeros\n        val onesZeroArr = onesZeros.sortBy(_.toString.toInt)\n\
    \        val onesZeroArr2 = onesZeros.sortBy(_.toString.toInt).reverse\n     \
    \   val onesZeroArr3 = onesZeros.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt)\n\
    \        val onesZeroArr4 = onesZeros.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt).reverse\n\
    \        val onesZeroArr5 = onesZeros.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt)\n\
    \        val onesZeroArr6 = onesZeros.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt)\n\
    \        val onesZeroArr7 = onesZeros.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt)\n\
    \        val onesZeroArr8 = onesZeros.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt)\n\
    \        val onesZeroArr9 = onesZeros.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt)\n\
    \        val onesZeroArr10 = onesZeros.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt).reverse.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwujvt3af.scala:24:4 ----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpwujvt3af.scala:14:36 ------------------------\e[0m\e[0m\n\e[31m14\
    \ |\e[0m        \e[33mval\e[0m \e[36monesZeroArr\e[0m = onesZeros.sortBy(_.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                          value sortBy is not a member of Int\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpwujvt3af.scala:15:37 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr2\e[0m = onesZeros.sortBy(_.toString.toInt).reverse\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           value sortBy is not a member of Int\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpwujvt3af.scala:16:37 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr3\e[0m = onesZeros.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           value sortBy is not a member of Int\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpwujvt3af.scala:17:37 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr4\e[0m = onesZeros.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt).reverse\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           value sortBy is not a member of Int\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpwujvt3af.scala:18:37 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr5\e[0m = onesZeros.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt).reverse.sortBy(_.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           value sortBy is not a member of Int\n\e[31m\e\
    [31m-- [E008] Not Found Er"
  stdout: ''
  timestamp: 1660008766
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val twos = arr.count(_ ==\
    \ 2)\n        val threes = arr.count(_ == 3)\n        val fours = arr.count(_\
    \ == 4)\n        val fives = arr.count(_ == 5)\n        val sixes = arr.count(_\
    \ == 6)\n        val sevens = arr.count(_ == 7)\n        val eights = arr.count(_\
    \ == 8)\n        val nines = arr.count(_ == 9)\n        val tens = arr.count(_\
    \ == 10)\n        val hundreds = arr.count(_ == 100)\n        val thousands =\
    \ arr.count(_ == 1000)\n        val millions = arr.count(_ == 1000000)\n     \
    \   val billions = arr.count(_ == 1000000000)\n        val trillions = arr.count(_\
    \ == 1000000000000)\n        val quadrillions = arr.count(_ == 1000000000000000)\n\
    \        val quintillions = arr.count(_ == 1000000000000000000)\n        val onesAndZeros\
    \ = arr.count(_ == 1 && _ == 0)\n        val onesAndOnes = arr.count(_ == 1 &&\
    \ _ == 1)\n        val onesAndTwos = arr.count(_ == 1 && _ == 2)\n        val\
    \ onesAndThrees = arr.count(_ == 1 && _ == 3)\n        val onesAndFours = arr.count(_\
    \ == 1 && _ == 4)\n        val onesAndFives = arr.count(_ == 1 && _ == 5)\n  \
    \      val onesAndSixes = arr.count(_ == 1 && _ == 6)\n        val onesAndSevens\
    \ = arr.count(_ == 1 && _ == 7)\n        val onesAndEights = arr.count(_ == 1\
    \ && _ == 8)\n        val onesAndNines = arr.count(_ == 1 && _ == 9)\n       \
    \ val onesAndTens = arr.count(_ == 1 && _ == 10)\n        val onesAndHundreds\
    \ = arr.count(_ == 1 && _ == 100)\n        val onesAndThousands = arr.count(_\
    \ == 1 && _ == 1000)\n        val onesAndMillions = arr.count(_ == 1 && _ == 1000000)\n\
    \        val onesAndBillions = arr.count(_ == 1 && _ == 1000000000)\n        val\
    \ onesAndTrillions = arr.count(_ == 1 && _ == 1000000000000)\n        val onesAndQuadrillions\
    \ = arr.count(_ == 1 && _ == 1000000000000000)\n        val onesAndQuintillions\
    \ = arr.count(_ == 1 && _ == 1000000000000000000)\n        val onesAndOnesAndZeros\
    \ = arr.count(_ == 1 && \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmppmcvho8c.scala:44:53 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36monesAndOnesAndZeros\e[0m\
    \ = arr.count(_ == \e[31m1\e[0m && \n\e[31m\e[31m   |\e[0m                   \
    \                                  ^\e[0m\n\e[31m   |\e[0m                   \
    \                    expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmppmcvho8c.scala:23:39 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mtrillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000\e[0m)\n\e[31m\e[31m   |\e[0m                        \
    \               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \             number too large\n\e[31m\e[31m-- Error: /tmp/tmppmcvho8c.scala:24:42\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m24 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.count(_ == \e[31m1000000000000000\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                          ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                          number too large\n\
    \e[31m\e[31m-- Error: /tmp/tmppmcvho8c.scala:25:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mquintillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m                  \
    \                        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                               number too large\n\e[31m\e[31m-- [E086] Syntax\
    \ Error: /tmp/tmppmcvho8c.scala:26:37 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36monesAndZeros\e[0m = arr.count(_ == \e\
    [31m1\e[0m && _ == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                      \
    \               ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \          Wrong number of parameters, expected: 1\n\e[31m\e[31m-- [E086] Syntax\
    \ Error: /tmp/tmppmcvho8c.scala:27:36 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36monesAndOnes\e[0m = arr.count(_ == \e\
    [31m1\e[0m "
  stdout: ''
  timestamp: 1660008688
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val zeros = arr.count(_ ==\
    \ 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount = arr.count(_\
    \ == 0)\n        val onesDecimal = onesCount / arr.length\n        val zerosDecimal\
    \ = zerosCount / arr.length\n        val onesDecimalDecimal = onesDecimal / ones\n\
    \        val zerosDecimalDecimal = zerosDecimal / zeros\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal / ones\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3_l74h0g.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp3_l74h0g.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp3_l74h0g.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[3"
  stdout: ''
  timestamp: 1660008763
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val twos = arr.count(_ ==\
    \ 2)\n        val threes = arr.count(_ == 3)\n        val fours = arr.count(_\
    \ == 4)\n        val fives = arr.count(_ == 5)\n        val sixes = arr.count(_\
    \ == 6)\n        val sevens = arr.count(_ == 7)\n        val eights = arr.count(_\
    \ == 8)\n        val nines = arr.count(_ == 9)\n        val tens = arr.count(_\
    \ == 10)\n        val hundreds = arr.count(_ == 100)\n        val thousands =\
    \ arr.count(_ == 1000)\n        val millions = arr.count(_ == 1000000)\n     \
    \   val billions = arr.count(_ == 1000000000)\n        val trillions = arr.count(_\
    \ == 1000000000000)\n        val quadrillions = arr.count(_ == 1000000000000000)\n\
    \        val quintillions = arr.count(_ == 1000000000000000000)\n        val onesAndZeroes\
    \ = arr.count(_ == 1 && _ == 0)\n        val onesAndOnes = arr.count(_ == 1 &&\
    \ _ == 1)\n        val onesAndTwos = arr.count(_ == 1 && _ == 2)\n        val\
    \ onesAndThrees = arr.count(_ == 1 && _ == 3)\n        val onesAndFours = arr.count(_\
    \ == 1 && _ == 4)\n        val onesAndFives = arr.count(_ == 1 && _ == 5)\n  \
    \      val onesAndSixes = arr.count(_ == 1 && _ == 6)\n        val onesAndSevens\
    \ = arr.count(_ == 1 && _ == 7)\n        val onesAndEights = arr.count(_ == 1\
    \ && _ == 8)\n        val onesAndNines = arr.count(_ == 1 && _ == 9)\n       \
    \ val onesAndTens = arr.count(_ == 1 && _ == 10)\n        val onesAndHundreds\
    \ = arr.count(_ == 1 && _ == 100)\n        val onesAndThousands = arr.count(_\
    \ == 1 && _ == 1000)\n        val onesAndMillions = arr.count(_ == 1 && _ == 1000000)\n\
    \        val onesAndBillions = arr.count(_ == 1 && _ == 1000000000)\n        val\
    \ onesAndTrillions = arr.count(_ == 1 && _ == 1000000000000)\n        val onesAndQuadrillions\
    \ = arr.count(_ == 1 && _ == 1000000000000000)\n        val onesAndQuintillions\
    \ = arr.count(_ == 1 && _ == 1000000000000000000)\n        val twosAndZeroes =\
    \ arr.count(_ == 2 && _ == \n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp1pxj2psa.scala:44:52 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36mtwosAndZeroes\e[0m = arr.count(_\
    \ == \e[31m2\e[0m && _ == \n\e[31m\e[31m   |\e[0m                            \
    \                        ^\e[0m\n\e[31m   |\e[0m                             \
    \          expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- Error: /tmp/tmp1pxj2psa.scala:23:39 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mtrillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000\e[0m)\n\e[31m\e[31m   |\e[0m                        \
    \               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \             number too large\n\e[31m\e[31m-- Error: /tmp/tmp1pxj2psa.scala:24:42\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m24 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.count(_ == \e[31m1000000000000000\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                          ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                          number too large\n\
    \e[31m\e[31m-- Error: /tmp/tmp1pxj2psa.scala:25:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mquintillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m                  \
    \                        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                               number too large\n\e[31m\e[31m-- [E086] Syntax\
    \ Error: /tmp/tmp1pxj2psa.scala:26:38 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36monesAndZeroes\e[0m = arr.count(_ ==\
    \ \e[31m1\e[0m && _ == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                  \
    \                    ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \               Wrong number of parameters, expected: 1\n\e[31m\e[31m-- [E086]\
    \ Syntax Error: /tmp/tmp1pxj2psa.scala:27:36 ---------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36monesAndOnes\e[0m = arr.count(_\
    \ == \e[31m1\e[0m "
  stdout: ''
  timestamp: 1660008764
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ == 0)\n        val onesDecimals = ones * 10\n        val decimalsDecimals =\
    \ decimals * 10\n        val onesDecimalsDecimals = onesDecimals * 10\n      \
    \  val decimalsDecimalsDecimals = decimalsDecimals * 10\n        val onesDecimalsDecimalsDecimals\
    \ = onesDecimalsDecimals * 10\n        val decimalsDecimalsDecimalsDecimals =\
    \ decimalsDecimalsDecimals * 10\n        val onesDecimalsDecimalsDecimalsDecimals\
    \ = onesDecimalsDecimalsDecimals * 10\n        val decimalsDecimalsDecimalsDecimalsDecimals\
    \ = decimalsDecimalsDecimalsDecimals * 10\n        val onesDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = onesDecimalsDecimalsDecimalsDecimals * 10\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = decimalsDecimalsDecimalsDecimalsDecimals * 10\n        val onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = onesDecimalsDecimalsDecimalsDecimalsDecimals * 10\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = decimalsDecimalsDecimalsDecimalsDecimalsDecimals * 10\n        val onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals * 10\n      \
    \  val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals = decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ * 10\n        val onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ * 10\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ * 10\n        val onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ * 10\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ * 10\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpfbhrxekl.scala:29:11 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpfbhrxekl.scala:23:75 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36monesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\e\
    [0m = onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals * \e[31m10\e\
    [0m\n\e[31m\e[31m   |\e[0m                                                   \
    \                        ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e\
    [35monesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpfbhrxekl.scala:24:79\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mdecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\e[0m\
    \ = decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals * \e[31m10\e\
    [0m\n\e[31m\e[31m   |\e[0m                                                   \
    \                            ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m\
    \ \e[35mdecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\e[0m\
    \ needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfbhrxekl.scala:27:91\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\e\
    [0m = onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ * \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m                                     \
    \                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: onesDecimalsDecimals"
  stdout: ''
  timestamp: 1660008765
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ > 0)\n        val result = arr.sortBy(x => if (ones == 0) x else math.abs(x\
    \ - math.pow(2,ones)))\n        if (decimals > 0) result.sortBy(x => math.abs(x\
    \ - math.pow(2,decimals)))\n        else result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpge3dydlr.scala:11:90 -----------------------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = arr.sortBy(\e\
    [36mx\e[0m => \e[33mif\e[0m (ones == \e[31m0\e[0m) x \e[33melse\e[0m math.abs(x\
    \ - math.pow(\e[31m2\e[0m,ones)))\n\e[31m\e[31m   |\e[0m                     \
    \                                                                     ^\e[0m\n\
    \e[31m   |\e[0mNo implicit Ordering defined for AnyVal..\n\e[31m   |\e[0mI found:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m    scala.math.Ordering.ordered[\e[35mAnyVal\e\
    [0m](\n\e[31m   |\e[0m      /* missing */summon[scala.math.Ordering.AsComparable[AnyVal]]\n\
    \e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were\
    \ found that match type scala.math.Ordering.AsComparable[AnyVal].\n1 error found\n"
  stdout: ''
  timestamp: 1660008768
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val zeros = arr.count(_ ==\
    \ 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount = arr.count(_\
    \ == 0)\n        val onesDecimal = onesCount / arr.size\n        val zerosDecimal\
    \ = zerosCount / arr.size\n        val onesDecimalDecimal = onesDecimal + zerosDecimal\n\
    \        val zerosDecimalDecimal = zerosDecimal + onesDecimal\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal * 10\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * 10\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * 10\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * 10\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp86xik5wc.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal * \e[31m10\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp86xik5wc.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * \e[31m10\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp86xik5wc.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal * \e[31m10\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel defi"
  stdout: ''
  timestamp: 1660008769
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val zeros = arr.count(_ ==\
    \ 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount = arr.count(_\
    \ == 0)\n        val onesDecimal = onesCount / ones\n        val zerosDecimal\
    \ = zerosCount / zeros\n        val onesDecimalDecimal = onesDecimal / onesDecimal\n\
    \        val zerosDecimalDecimal = zerosDecimal / zerosDecimal\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal / onesDecimalDecimal\n        val zerosDecimalDecimalDecimal\
    \ = zerosDecimalDecimal / zerosDecimalDecimal\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimal / onesDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / zerosDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimal\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimal\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgjly2moq.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpgjly2moq.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpgjly2moq.scala:23:61 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimal"
  stdout: ''
  timestamp: 1660008731
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(x => x == 1).length\n        val decs = arr.filter(x\
    \ => x == 0).map(x => x.toString.toInt).sortBy(_.toString.toInt)\n        val\
    \ result = decs ++ ones\n        result.sortBy(_.toString.toInt)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfyk0t69z.scala:11:29\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e\
    [0m = decs ++ ones\n\e[31m\e[31m   |\e[0m                             ^^^^\e[0m\n\
    \e[31m   |\e[0m                             Found:    (ones : Int)\n\e[31m   |\e\
    [0m                             Required: IterableOnce[Int]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfyk0t69z.scala:12:8 ---------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        result.sortBy(_.toString.toInt)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \  Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e[0m        Required: List[\e\
    [1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660008772
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val zeros = arr.count(_ ==\
    \ 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount = arr.count(_\
    \ == 0)\n        val onesDecimal = onesCount / arr.length\n        val zerosDecimal\
    \ = zerosCount / arr.length\n        val onesDecimalDecimal = onesDecimal / ones\n\
    \        val zerosDecimalDecimal = zerosDecimal / zeros\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal / ones\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDeci\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp93dbtd8r.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp93dbtd8r.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp93dbtd8r.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote"
  stdout: ''
  timestamp: 1660008706
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(x => x % 2 == 0).length\n        val decimals\
    \ = arr.filter(x => x % 2 == 1).length\n        val sorted = arr.sortBy(x => (ones\
    \ - x.toString.toInt))\n        val decimalSorted = sorted.sortBy(x => (decimals\
    \ - x.toString.toInt))\n        decimalSorted\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplultafpq.scala:16)\n\tat Problem.main(tmplultafpq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660008775
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(_ % 2 == 0).length\n        val decimal =\
    \ arr.filter(_ % 2 == 1).length\n        val onesDecimal = ones * decimal\n  \
    \      val onesDecimalSorted = arr.sortBy(x => math.abs(x - onesDecimal))\n  \
    \      val onesDecimalSortedSortedByDecimal = onesDecimalSorted.sortBy(x => math.abs(x\
    \ - decimal))\n        onesDecimalSortedSortedByDecimal\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8b3un_s8.scala:17)\n\tat Problem.main(tmp8b3un_s8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660008775
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(x => x % 2 == 0).length\n        val twos\
    \ = arr.filter(x => x % 2 == 1).length\n        val decimals = arr.map(x => math.log10(x)).toArray\n\
    \        val sortedArray = arr.sortBy(x => decimals.indexOf(x) + ones - twos)\n\
    \        sortedArray\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpj2o6198f.scala:16)\n\tat Problem.main(tmpj2o6198f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660008776
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ == 0)\n        val maxOnes = arr.maxBy(_ == 1)\n        val maxDecimals = arr.maxBy(_\
    \ == 0)\n        val maxDecimalsIndex = arr.lastIndexWhere(_ == 0)\n        val\
    \ maxOnesIndex = arr.lastIndexWhere(_ == 1)\n        val maxDecimalsIndex2 = arr.lastIndexWhere(_\
    \ == 0)\n        val maxOnesIndex2 = arr.lastIndexWhere(_ == 1)\n        val maxDecimalsIndex3\
    \ = arr.lastIndexWhere(_ == 0)\n        val maxOnesIndex3 = arr.lastIndexWhere(_\
    \ == 1)\n        val maxDecimalsIndex4 = arr.lastIndexWhere(_ == 0)\n        val\
    \ maxOnesIndex4 = arr.lastIndexWhere(_ == 1)\n        val maxDecimalsIndex5 =\
    \ arr.lastIndexWhere(_ == 0)\n        val maxOnesIndex5 = arr.lastIndexWhere(_\
    \ == 1)\n        val maxDecimalsIndex6 = arr.lastIndexWhere(_ == 0)\n        val\
    \ maxOnesIndex6 = arr.lastIndexWhere(_ == 1)\n        val maxDecimalsIndex7 =\
    \ arr.lastIndexWhere(_ == 0)\n        val maxOnesIndex7 = arr.lastIndexWhere(_\
    \ == 1)\n        val maxDecimalsIndex8 = arr.lastIndexWhere(_ == 0)\n        val\
    \ maxOnesIndex8 = arr.lastIndexWhere(_ == 1)\n        val maxDecimalsIndex9 =\
    \ arr.lastIndexWhere(_ == 0)\n        val maxOnesIndex9 = arr.lastIndexWhere(_\
    \ == 1)\n        val maxDecimalsIndex10 = arr.lastIndexWhere(_ == 0)\n       \
    \ val maxOnesIndex10 = arr.lastIndexWhere(_ == 1)\n        val maxDecimalsIndex11\
    \ = arr.lastIndexWhere(_ == 0)\n        val maxOnesIndex11 = arr.lastIndexWhere(_\
    \ == 1)\n        val maxDecimalsIndex12 = arr.lastIndexWhere(_ == 0)\n       \
    \ val maxOnesIndex12 = arr.lastIndexWhere(_ == 1)\n        val maxDecimalsIndex13\
    \ = arr.lastIndexWhere(_ == 0)\n        val maxOnesIndex13 = arr.lastIndexWhere(_\
    \ == 1)\n        val maxDecimalsIndex14 = arr.lastIndexWhere(_ == 0)\n       \
    \ val maxOnesIndex14 = arr.lastIndexWhere(_ == 1)\n        val maxDecimalsIndex15\
    \ = arr.lastIndexWhere(_ == 0)\n        val maxOnesIndex15 = arr.lastIndexWhere(_\
    \ == 1)\n        val maxDecimalsIndex16 = arr.lastIndexWhere(_ == 0)\n       \
    \ val maxOnesIndex16 = arr.lastIndexWhere(_ == 1)\n        val maxDecimalsIndex17\
    \ = arr.lastIndexWhere(_ == 0)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4602_iu_.scala:46:5\
    \ ---------------------\e[0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660008772
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(_ % 2 == 0).length\n        val twos = arr.filter(_\
    \ % 2 == 1).length\n        val decimal = arr.filter(_ % 10 == 0).length\n   \
    \     val sorted = arr.sortBy(x => (ones, twos, decimal, x))\n        sorted.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvwm7bxm0.scala:16)\n\tat Problem.main(tmpvwm7bxm0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660008776
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decs = arr.map(_.toString.toInt)\n\
    \        val sorted = decs.sortWith((x, y) => x - y)\n        val result = sorted.take(ones)\n\
    \        result.sortWith((x, y) => x - y)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9ghp25hh.scala:11:45\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36msorted\e\
    [0m = decs.sortWith((\e[36mx\e[0m, \e[36my\e[0m) => x - y)\n\e[31m\e[31m   |\e\
    [0m                                             ^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                           Found:    Int\n\e[31m   |\e[0m   \
    \                                          Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9ghp25hh.scala:13:34 --------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        result.sortWith((\e[36mx\e[0m, \e[36my\e[0m)\
    \ => x - y)\n\e[31m\e[31m   |\e[0m                                  ^^^^^\e[0m\n\
    \e[31m   |\e[0m                                  Found:    Int\n\e[31m   |\e[0m\
    \                                  Required: Boolean\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660008775
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(x => x % 2 == 0).size\n        val twos =\
    \ arr.filter(x => x % 2 == 1).size\n        val decimal = arr.map(x => math.pow(2,\
    \ math.ceil(math.log(x, 2)))).sum\n        val result = arr.sortBy(x => (ones\
    \ - x) / decimal)\n        result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5vadcte7.scala:11:66\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mdecimal\e\
    [0m = arr.map(\e[36mx\e[0m => math.pow(\e[31m2\e[0m, math.ceil(math.log(x, \e\
    [31m2\e[0m)))).sum\n\e[31m\e[31m   |\e[0m                                    \
    \                              ^^^^\e[0m\n\e[31m   |\e[0m                    \
    \                               Found:    (Long, Int)\n\e[31m   |\e[0m       \
    \                                            Required: Double\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660008774
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(x => x == 1)\n        val zeros = arr.count(x\
    \ => x == 0)\n        val maxOnes = arr.count(x => x == 1)\n        val maxZeros\
    \ = arr.count(x => x == 0)\n        val maxOnesDecimal = maxOnes / arr.size\n\
    \        val maxZerosDecimal = maxZeros / arr.size\n        val maxOnesDecimalDecimal\
    \ = maxOnesDecimal / arr.size\n        val maxZerosDecimalDecimal = maxZerosDecimal\
    \ / arr.size\n        val maxOnesDecimalDecimalDecimal = maxOnesDecimalDecimal\
    \ / arr.size\n        val maxZerosDecimalDecimalDecimal = maxZerosDecimalDecimal\
    \ / arr.size\n        val maxOnesDecimalDecimalDecimalDecimal = maxOnesDecimalDecimalDecimal\
    \ / arr.size\n        val maxZerosDecimalDecimalDecimalDecimal = maxZerosDecimalDecimalDecimal\
    \ / arr.size\n        val maxOnesDecimalDecimalDecimalDecimalDecimal = maxOnesDecimalDecimalDecimalDecimal\
    \ / arr.size\n        val maxZerosDecimalDecimalDecimalDecimalDecimal = maxZerosDecimalDecimalDecimalDecimal\
    \ / arr.size\n        val maxOnesDecimalDecimalDecimalDecimalDecimalDecimal =\
    \ maxOnesDecimalDecimalDecimalDecimalDecimalDecimal / arr.size\n        val maxZerosDecimalDecimalDecimalDecimalDecimal\
    \ = maxZerosDecimalDecimalDecimalDecimalDecimal / arr.size\n        val maxOnesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / arr.size\n    \
    \    val maxZerosDecimalDecimalDecimalDecimalDecimalDecimal = maxZerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / arr.size\n        val maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / arr.size\n\
    \        val maxZerosDecimalDecimalDecimalDecimalDecimalDecimal = maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / arr.size\n        val maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / arr.size\n\
    \        val maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / arr.size\n        val maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpo79per2t.scala:32:4 ----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo79per2t.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxZerosDecimalDecimalDecimalDecimalDecimal\e[0m = maxZerosDecimalDecimalDecimalDecimalDecimal\
    \ / arr.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxZerosDecimalDecimalDecimalDecimalDecimal is already defined\
    \ as \e[33mvalue\e[0m \e[35mmaxZerosDecimalDecimalDecimalDecimalDecimal\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpo79per2t.scala:25:12 ---------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        \e[33mval\e[0m \e[36mmaxOnesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / arr.size\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxOnesDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mmaxOnesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpo79per2t.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36mmaxZerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / arr.size\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxZerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m "
  stdout: ''
  timestamp: 1660008776
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val zeros = arr.count(_ ==\
    \ 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount = arr.count(_\
    \ == 0)\n        val onesDecimal = onesCount / arr.length\n        val zerosDecimal\
    \ = zerosCount / arr.length\n        val onesDecimalDecimal = onesDecimal / onesCount\n\
    \        val zerosDecimalDecimal = zerosDecimal / zerosCount\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprtn5ugdl.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmprtn5ugdl.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmprtn5ugdl.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same gro"
  stdout: ''
  timestamp: 1660008774
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ < 0)\n        val onesDecimals = ones * decimals\n        val onesDecimalsSorted\
    \ = arr.sortBy(_ / onesDecimals)\n        val negativesDecimals = arr.count(_\
    \ < 0)\n        val negativesDecimalsSorted = arr.sortBy(_ / negativesDecimals)\n\
    \        onesDecimalsSorted.union(negativesDecimalsSorted)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArithmeticException: / by zero\n\tat Problem$.$anonfun$3(tmpzk4bdvvw.scala:12)\n\
    \tat scala.runtime.java8.JFunction1$mcJJ$sp.apply(JFunction1$mcJJ$sp.scala:17)\n\
    \tat scala.math.Ordering$$anon$1.compare(Ordering.scala:141)\n\tat java.base/java.util.TimSort.countRunAndMakeAscending(TimSort.java:355)\n\
    \tat java.base/java.util.TimSort.sort(TimSort.java:220)\n\tat java.base/java.util.Arrays.sort(Arrays.java:1233)\n\
    \tat scala.collection.SeqOps.sorted(Seq.scala:700)\n\tat scala.collection.SeqOps.sorted$(Seq.scala:692)\n\
    \tat scala.collection.immutable.List.scala$collection$immutable$StrictOptimizedSeqOps$$super$sorted(List.scala:79)\n\
    \tat scala.collection.immutable.StrictOptimizedSeqOps.sorted(StrictOptimizedSeqOps.scala:78)\n\
    \tat scala.collection.immutable.StrictOptimizedSeqOps.sorted$(StrictOptimizedSeqOps.scala:78)\n\
    \tat scala.collection.immutable.List.sorted(List.scala:79)\n\tat scala.collection.SeqOps.sortBy(Seq.scala:754)\n\
    \tat scala.collection.SeqOps.sortBy$(Seq.scala:754)\n\tat scala.collection.AbstractSeq.sortBy(Seq.scala:1161)\n\
    \tat Problem$.sortArray(tmpzk4bdvvw.scala:12)\n\tat Problem$.main(tmpzk4bdvvw.scala:18)\n\
    \tat Problem.main(tmpzk4bdvvw.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(Obje"
  stdout: ''
  timestamp: 1660008778
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decs = arr.map(_.toString.toInt)\n\
    \        val sorted = decs.sortBy(_.toInt).sortBy(_.toDouble)\n        val result\
    \ = sorted.map(x => (ones, x))\n        result.sortBy(_._1).map(x => x._2)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvdgzlgvy.scala:16)\n\tat Problem.main(tmpvdgzlgvy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660008779
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val zeros = arr.count(_ ==\
    \ 0)\n        val onesArray = arr.map(x => if (x == 1) 1 else 0)\n        val\
    \ zerosArray = arr.map(x => if (x == 0) 0 else 1)\n        val onesArrayLength\
    \ = onesArray.length\n        val zerosArrayLength = zerosArray.length\n     \
    \   val onesArrayLength = onesArrayLength + zerosArrayLength\n        val onesArray\
    \ = onesArray.toArray\n        val zerosArray = zerosArray.toArray\n        val\
    \ onesArrayLength = onesArray.length\n        val zerosArrayLength = zerosArray.length\n\
    \        val onesArrayLength = onesArrayLength + zerosArrayLength\n        val\
    \ onesArray = onesArray.toArray\n        val zerosArray = zerosArray.toArray\n\
    \        val onesArrayLength = onesArray.length\n        val zerosArrayLength\
    \ = zerosArray.length\n        val onesArrayLength = onesArrayLength + zerosArrayLength\n\
    \        val onesArray = onesArray.toArray\n        val zerosArray = zerosArray.toArray\n\
    \        val onesArrayLength = onesArray.length\n        val zerosArrayLength\
    \ = zerosArray.length\n        val onesArrayLength = onesArrayLength + zerosArrayLength\n\
    \        val onesArray = onesArray.toArray\n        val zerosArray = zerosArray.toArray\n\
    \        val onesArrayLength = onesArray.length\n        val zerosArrayLength\
    \ = zerosArray.length\n        val onesArrayLength = onesArrayLength + zerosArrayLength\n\
    \        val onesArray = onesArray.toArray\n        val zerosArray = zerosArray.toArray\n\
    \        val onesArrayLength = onesArray.length\n        val zerosArrayLength\
    \ = zerosArray.length\n        val onesArrayLength = onesArrayLength + zerosArrayLength\n\
    \        val onesArray = onesArray.toArray\n        val zerosArray = zerosArray.toArray\n\
    \        val onesArrayLength = onesArray.length\n        val zerosArrayLength\
    \ = zerosArray.length\n        val onesArrayLength = onesArrayLength + zerosArrayLength\n\
    \        val onesArray = onesArray.toArray\n        val zerosArray = zerosArray.toArray\n\
    \        val onesArrayLength = onesArray.length\n        val zerosArrayLength\
    \ = zerosArray.length\n        val onesArrayLength = onesArrayLength + zerosArrayLength\n\
    \        val onesArray = onesArray.toArray\n        val zerosArray = zerosArray.toArray\n\
    \        val onesArray\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8um1k5yt.scala:54:4 ----------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8um1k5yt.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesArrayLength\e[0m = onesArrayLength + zerosArrayLength\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0monesArrayLength is already defined as \e[33mvalue\e[0m \e[35monesArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8um1k5yt.scala:16:12 ---------------------------\e[0m\e[0m\n\e\
    [31m16 |\e[0m        \e[33mval\e[0m \e[36monesArray\e[0m = onesArray.toArray\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0monesArray is already defined as \e[33mvalue\e[0m \e[35monesArray\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp8um1k5yt.scala:17:12 ---------------------------\e[0m\e[0m\n\e[31m17\
    \ |\e[0m        \e[33mval\e[0m \e[36mzerosArray\e[0m = zerosArray.toArray\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mzerosArray is already defined as \e[33mvalue\e[0m \e[35mzerosArray\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp8um1k5yt.scala:18:12 ---------------------------\e[0m\e[0m\n\e[31m18\
    \ |\e[0m        \e[33mval\e[0m \e[36monesArrayLength\e[0m = onesArray.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0monesArrayLength is already defined as \e[33mvalue\e[0m \e[35monesArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/"
  stdout: ''
  timestamp: 1660008774
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val zeros = arr.count(_ ==\
    \ 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount = arr.count(_\
    \ == 0)\n        val onesDecimal = ones / onesCount\n        val zerosDecimal\
    \ = zeros / zerosCount\n        val onesDecimalDecimal = onesDecimal / onesCount\n\
    \        val zerosDecimalDecimal = zerosDecimal / zerosCount\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpggq1nse9.scala:34:4 ----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpggq1nse9.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpggq1nse9.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpggq1nse9.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660008750
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(_ % 2 == 0).length\n        val zeros = arr.filter(_\
    \ % 2 == 1).length\n        val onesZeros = ones + zeros\n        val onesZeroDec\
    \ = onesZeros / 10\n        val onesZeroDec2 = onesZeroDec.toInt\n        val\
    \ onesZeroDec3 = onesZeroDec2.toInt\n        val onesZeroDec4 = onesZeroDec3.toInt\n\
    \        val onesZeroDec5 = onesZeroDec4.toInt\n        val onesZeroDec6 = onesZeroDec5.toInt\n\
    \        val onesZeroDec7 = onesZeroDec6.toInt\n        val onesZeroDec8 = onesZeroDec7.toInt\n\
    \        val onesZeroDec9 = onesZeroDec8.toInt\n        val onesZeroDec10 = onesZeroDec9.toInt\n\
    \        val onesZeroDec11 = onesZeroDec10.toInt\n        val onesZeroDec12 =\
    \ onesZeroDec11.toInt\n        val onesZeroDec13 = onesZeroDec12.toInt\n     \
    \   val onesZeroDec14 = onesZeroDec13.toInt\n        val onesZeroDec15 = onesZeroDec14.toInt\n\
    \        val onesZeroDec16 = onesZeroDec15.toInt\n        val onesZeroDec17 =\
    \ onesZeroDec16.toInt\n        val onesZeroDec18 = onesZeroDec17.toInt\n     \
    \   val onesZeroDec19 = onesZeroDec18.toInt\n        val onesZeroDec20 = onesZeroDec19.toInt\n\
    \        val onesZeroDec21 = onesZeroDec20.toInt\n        val onesZeroDec22 =\
    \ onesZeroDec21.toInt\n        val onesZeroDec23 = onesZeroDec22.toInt\n     \
    \   val onesZeroDec24 = onesZeroDec23.toInt\n        val onesZeroDec25 = onesZeroDec24.toInt\n\
    \        val onesZeroDec26 = onesZeroDec25.toInt\n        val onesZeroDec27 =\
    \ onesZeroDec26.toInt\n        val onesZeroDec28 = onesZeroDec27.toInt\n     \
    \   val onesZeroDec29 = onesZeroDec28.toInt\n        val onesZeroDec30 = onesZeroDec29.toInt\n\
    \        val onesZeroDec31 = ones\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpy74e91ky.scala:43:5\
    \ ---------------------\e[0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660008777
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(_ % 2 == 0).length\n        val twos = arr.filter(_\
    \ % 2 == 1).length\n        val decimals = arr.filter(_ % 10 == 0).length\n  \
    \      val decimalsDecimals = arr.filter(_ % 10 == 1).length\n        val decimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 2).length\n        val decimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 3).length\n        val decimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 4).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 5).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 6).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 7).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 8).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 9).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 0).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 1).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 2).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 3).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 4).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 5).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6gntlqbl.scala:28:5\
    \ ---------------------\e[0m\e[0m\n\e[31m28 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660008777
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val twos = arr.count(_ ==\
    \ 2)\n        val threes = arr.count(_ == 3)\n        val fours = arr.count(_\
    \ == 4)\n        val fives = arr.count(_ == 5)\n        val sixes = arr.count(_\
    \ == 6)\n        val sevens = arr.count(_ == 7)\n        val eights = arr.count(_\
    \ == 8)\n        val nines = arr.count(_ == 9)\n        val tens = arr.count(_\
    \ == 10)\n        val hundreds = arr.count(_ == 100)\n        val thousands =\
    \ arr.count(_ == 1000)\n        val millions = arr.count(_ == 1000000)\n     \
    \   val billions = arr.count(_ == 1000000000)\n        val trillions = arr.count(_\
    \ == 1000000000000)\n        val quadrillions = arr.count(_ == 1000000000000000)\n\
    \        val quintillions = arr.count(_ == 1000000000000000000)\n        val onesAndZeros\
    \ = arr.count(_ == 1 && _ == 0)\n        val onesAndOnes = arr.count(_ == 1 &&\
    \ _ == 1)\n        val onesAndTwos = arr.count(_ == 1 && _ == 2)\n        val\
    \ onesAndThrees = arr.count(_ == 1 && _ == 3)\n        val onesAndFours = arr.count(_\
    \ == 1 && _ == 4)\n        val onesAndFives = arr.count(_ == 1 && _ == 5)\n  \
    \      val onesAndSixes = arr.count(_ == 1 && _ == 6)\n        val onesAndSevens\
    \ = arr.count(_ == 1 && _ == 7)\n        val onesAndEights = arr.count(_ == 1\
    \ && _ == 8)\n        val onesAndNines = arr.count(_ == 1 && _ == 9)\n       \
    \ val onesAndTens = arr.count(_ == 1 && _ == 10)\n        val onesAndHundreds\
    \ = arr.count(_ == 1 && _ == 100)\n        val onesAndThousands = arr.count(_\
    \ == 1 && _ == 1000)\n        val onesAndMillions = arr.count(_ == 1 && _ == 1000000)\n\
    \        val onesAndBillions = arr.count(_ == 1 && _ == 1000000000)\n        val\
    \ onesAndTrillions = arr.count(_ == 1 && _ == 1000000000000)\n        val onesAndQuadrillions\
    \ = arr.count(_ == 1 && _ == 1000000000000000)\n        val onesAndQuintillions\
    \ = arr.count(_ == 1 && _ == 1000000000000000000)\n        val onesAndOnesAndZeros\
    \ = arr.count(_ == 1 && \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmppmcvho8c.scala:44:53 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36monesAndOnesAndZeros\e[0m\
    \ = arr.count(_ == \e[31m1\e[0m && \n\e[31m\e[31m   |\e[0m                   \
    \                                  ^\e[0m\n\e[31m   |\e[0m                   \
    \                    expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmppmcvho8c.scala:23:39 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mtrillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000\e[0m)\n\e[31m\e[31m   |\e[0m                        \
    \               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \             number too large\n\e[31m\e[31m-- Error: /tmp/tmppmcvho8c.scala:24:42\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m24 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.count(_ == \e[31m1000000000000000\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                          ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                          number too large\n\
    \e[31m\e[31m-- Error: /tmp/tmppmcvho8c.scala:25:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mquintillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m                  \
    \                        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                               number too large\n\e[31m\e[31m-- [E086] Syntax\
    \ Error: /tmp/tmppmcvho8c.scala:26:37 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36monesAndZeros\e[0m = arr.count(_ == \e\
    [31m1\e[0m && _ == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                      \
    \               ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \          Wrong number of parameters, expected: 1\n\e[31m\e[31m-- [E086] Syntax\
    \ Error: /tmp/tmppmcvho8c.scala:27:36 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36monesAndOnes\e[0m = arr.count(_ == \e\
    [31m1\e[0m "
  stdout: ''
  timestamp: 1660008688
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(x => x == 1)\n        val decimals = arr.count(x\
    \ => x == 0)\n        val onesDecimals = ones * decimals\n        val onesDecimalsSortedArray\
    \ = arr.sortBy(x => onesDecimals.toDouble(x))\n        onesDecimalsSortedArray\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmplji7g1l0.scala:12:67 -----------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36monesDecimalsSortedArray\e\
    [0m = arr.sortBy(\e[36mx\e[0m => onesDecimals.toDouble(x))\n\e[31m\e[31m   |\e\
    [0m                                                      ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                   \e[33mmethod\e[0m \e[35mtoDouble\e[0m in\
    \ \e[33mclass\e[0m \e[35mInt\e[0m does not take parameters\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- Error: /tmp/tmplji7g1l0.scala:12:79 -----------------------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36monesDecimalsSortedArray\e\
    [0m = arr.sortBy(\e[36mx\e[0m => onesDecimals.toDouble(x))\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \     ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m\
    \ \e[35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e\
    [0m \e[35mBigInt\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B]\
    \ of parameter ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m\
    \ \e[35mSeqOps\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660008773
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ == 0)\n        val onesDecimals = ones * decimals\n        val onesDecimalsSorted\
    \ = arr.sortBy(_ / onesDecimals)\n        val zerosDecimals = arr.count(_ == 0)\n\
    \        val zerosDecimalsSorted = arr.sortBy(_ / zerosDecimals)\n        onesDecimalsSorted.union(zerosDecimalsSorted)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArithmeticException: / by zero\n\tat Problem$.$anonfun$3(tmp8bi66_ys.scala:12)\n\
    \tat scala.runtime.java8.JFunction1$mcJJ$sp.apply(JFunction1$mcJJ$sp.scala:17)\n\
    \tat scala.math.Ordering$$anon$1.compare(Ordering.scala:141)\n\tat java.base/java.util.TimSort.countRunAndMakeAscending(TimSort.java:355)\n\
    \tat java.base/java.util.TimSort.sort(TimSort.java:220)\n\tat java.base/java.util.Arrays.sort(Arrays.java:1233)\n\
    \tat scala.collection.SeqOps.sorted(Seq.scala:700)\n\tat scala.collection.SeqOps.sorted$(Seq.scala:692)\n\
    \tat scala.collection.immutable.List.scala$collection$immutable$StrictOptimizedSeqOps$$super$sorted(List.scala:79)\n\
    \tat scala.collection.immutable.StrictOptimizedSeqOps.sorted(StrictOptimizedSeqOps.scala:78)\n\
    \tat scala.collection.immutable.StrictOptimizedSeqOps.sorted$(StrictOptimizedSeqOps.scala:78)\n\
    \tat scala.collection.immutable.List.sorted(List.scala:79)\n\tat scala.collection.SeqOps.sortBy(Seq.scala:754)\n\
    \tat scala.collection.SeqOps.sortBy$(Seq.scala:754)\n\tat scala.collection.AbstractSeq.sortBy(Seq.scala:1161)\n\
    \tat Problem$.sortArray(tmp8bi66_ys.scala:12)\n\tat Problem$.main(tmp8bi66_ys.scala:18)\n\
    \tat Problem.main(tmp8bi66_ys.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(Obje"
  stdout: ''
  timestamp: 1660008782
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(x => x % 2 == 0).size\n        val twos =\
    \ arr.filter(x => x % 2 == 1).size\n        val threes = arr.filter(x => x % 3\
    \ == 0).size\n        val fours = arr.filter(x => x % 4 == 0).size\n        val\
    \ fives = arr.filter(x => x % 5 == 0).size\n        val sixes = arr.filter(x =>\
    \ x % 6 == 0).size\n        val sevens = arr.filter(x => x % 7 == 0).size\n  \
    \      val eights = arr.filter(x => x % 8 == 0).size\n        val nines = arr.filter(x\
    \ => x % 9 == 0).size\n        val tens = arr.filter(x => x % 10 == 0).size\n\
    \        val elevens = arr.filter(x => x % 11 == 0).size\n        val twelves\
    \ = arr.filter(x => x % 12 == 0).size\n        val thirteens = arr.filter(x =>\
    \ x % 13 == 0).size\n        val fourteens = arr.filter(x => x % 14 == 0).size\n\
    \        val fifteens = arr.filter(x => x % 15 == 0).size\n        val sixteens\
    \ = arr.filter(x => x % 16 == 0).size\n        val seventeens = arr.filter(x =>\
    \ x % 17 == 0).size\n        val eighteens = arr.filter(x => x % 18 == 0).size\n\
    \        val nineteens = arr.filter(x => x % 19 == 0).size\n        val twenties\
    \ = arr.filter(x => x % 20 == 0).size\n        val thirties = arr.filter(x =>\
    \ x % 30 == 0).size\n        val fourties = arr.filter(x => x % 40 == 0).size\n\
    \        val fifties = arr.filter(x => x % 50 == 0).size\n        val sixties\
    \ = arr.filter(x => x % 60 == 0).size\n        val seventies = arr.filter(x =>\
    \ x % 70 == 0).size\n        val eighties = arr.filter(x => x % 80 == 0).size\n\
    \        val nineties = arr.filter(x => x % 90 == 0).size\n        val hundreds\
    \ = arr.filter(x => x % 100 == 0).size\n        val thousands = arr.filter(x =>\
    \ x % 1000 == 0).size\n        val millions = arr.filter(x => x % 1000000 == 0).size\n\
    \        val billions = arr.filter(x => x % 1000000000 == 0).size\n        val\
    \ trillions = arr.filter(x => x % 1000000000000 == \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpx5qcl286.scala:40:60 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mtrillions\e[0m = arr.filter(\e\
    [36mx\e[0m => x % \e[31m1000000000000\e[0m == \n\e[31m\e[31m   |\e[0m        \
    \                                                    ^\e[0m\n\e[31m   |\e[0m \
    \                                      expression expected but \e[31m'}'\e[0m\
    \ found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpx5qcl286.scala:40:44 -----------------------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mtrillions\e[0m = arr.filter(\e\
    [36mx\e[0m => x % \e[31m1000000000000\e[0m == \n\e[31m\e[31m   |\e[0m        \
    \                                    ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                                       number too large\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpx5qcl286.scala:41:5 ---------------------\e[0m\e\
    [0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660008785
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ % 2 == 0)\n        val onesDecimals = ones * decimals\n        val onesDecimalsSorted\
    \ = arr.sortBy(x => onesDecimals.toDouble(x))\n        onesDecimalsSorted.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmprjsb6iut.scala:12:62 -----------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36monesDecimalsSorted\e[0m\
    \ = arr.sortBy(\e[36mx\e[0m => onesDecimals.toDouble(x))\n\e[31m\e[31m   |\e[0m\
    \                                                 ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                   \e[33mmethod\e[0m \e[35mtoDouble\e[0m in \e\
    [33mclass\e[0m \e[35mInt\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- Error: /tmp/tmprjsb6iut.scala:12:74 -----------------------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36monesDecimalsSorted\e[0m\
    \ = arr.sortBy(\e[36mx\e[0m => onesDecimals.toDouble(x))\n\e[31m\e[31m   |\e[0m\
    \                                                                          ^\e\
    [0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mChar\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mShort\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660008750
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(x => x % 2 == 0).length\n        val twos\
    \ = arr.filter(x => x % 2 == 1).length\n        val threes = arr.filter(x => x\
    \ % 3 == 0).length\n        val fours = arr.filter(x => x % 4 == 0).length\n \
    \       val fives = arr.filter(x => x % 5 == 0).length\n        val sixes = arr.filter(x\
    \ => x % 6 == 0).length\n        val sevens = arr.filter(x => x % 7 == 0).length\n\
    \        val eights = arr.filter(x => x % 8 == 0).length\n        val nines =\
    \ arr.filter(x => x % 9 == 0).length\n        val tens = arr.filter(x => x % 10\
    \ == 0).length\n        val hundreds = arr.filter(x => x % 100 == 0).length\n\
    \        val thousands = arr.filter(x => x % 1000 == 0).length\n        val tenThousands\
    \ = arr.filter(x => x % 10000 == 0).length\n        val oneThousands = arr.filter(x\
    \ => x % 100000 == 0).length\n        val oneMillion = arr.filter(x => x % 1000000\
    \ == 0).length\n        val oneBillion = arr.filter(x => x % 10000000 == 0).length\n\
    \        val oneTrillion = arr.filter(x => x % 100000000 == 0).length\n      \
    \  val oneQuadrillion = arr.filter(x => x % 1000000000 == 0).length\n        val\
    \ oneQuintillion = arr.filter(x => x % 10000000000 == 0).length\n        val oneGiganticillion\
    \ = arr.filter(x => x % 100000000000 == 0).length\n        val oneTrillionThousand\
    \ = arr.filter(x => x % 1000000000000 == 0).length\n        val oneTrillionBillion\
    \ = arr.filter(x => x % 10000000000000 == 0).length\n        val oneTrillionTrillion\
    \ = arr.filter(x => x % 100000000000000 == 0).length\n        val oneTrillionQuadrillion\
    \ = arr.filter(x => x % 1000000000000000 == 0).length\n        val oneTrillionQuintillion\
    \ = arr.filter(x => x % 10000000000000000 == 0).length\n        val oneTrillionGiganticillion\
    \ = arr.filter(x => x % 100000000000000000 == 0).length\n        val oneTrillionTrillionThousand\
    \ = arr.filter(x => x % 1000000000000000000 == 0).length\n        val oneTrillionTrillionBillion\
    \ = arr.filter(x => x \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpdqpyirf5.scala:37:4 ----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmpdqpyirf5.scala:27:49\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m27 |\e[0m       \
    \ \e[33mval\e[0m \e[36moneQuintillion\e[0m = arr.filter(\e[36mx\e[0m => x % \e\
    [31m10000000000\e[0m == \e[31m0\e[0m).length\n\e[31m\e[31m   |\e[0m          \
    \                                       ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                                             number too large\n\e[31m\e[31m--\
    \ Error: /tmp/tmpdqpyirf5.scala:28:52 -----------------------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36moneGiganticillion\e[0m =\
    \ arr.filter(\e[36mx\e[0m => x % \e[31m100000000000\e[0m == \e[31m0\e[0m).length\n\
    \e[31m\e[31m   |\e[0m                                                    ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                    number\
    \ too large\n\e[31m\e[31m-- Error: /tmp/tmpdqpyirf5.scala:29:54 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36moneTrillionThousand\e[0m\
    \ = arr.filter(\e[36mx\e[0m => x % \e[31m1000000000000\e[0m == \e[31m0\e[0m).length\n\
    \e[31m\e[31m   |\e[0m                                                      ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                      number\
    \ too large\n\e[31m\e[31m-- Error: /tmp/tmpdqpyirf5.scala:30:53 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36moneTrillionBillion\e[0m\
    \ = arr.filter(\e[36mx\e[0m => x % \e[31m10000000000000\e[0m == \e[31m0\e[0m).length\n\
    \e[31m\e[31m   |\e[0m                                                     ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                     number\
    \ too large\n\e[31m\e[31m-- Error: /tmp/tmpdqpyirf5.scala:31:54 -----------------------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36moneTrillionTrillion\e[0m\
    \ = arr.filter(\e[36mx\e[0m => x % \e[31m100000000000000\e[0m == \e[31m0\e[0m).leng"
  stdout: ''
  timestamp: 1660008788
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val zeros = arr.count(_ ==\
    \ 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount = arr.count(_\
    \ == 0)\n        val onesDecimal = onesCount / arr.length\n        val zerosDecimal\
    \ = zerosCount / arr.length\n        val onesDecimalDecimal = onesDecimal / ones\n\
    \        val zerosDecimalDecimal = zerosDecimal / zeros\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal / ones\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmz8xej3p.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpmz8xej3p.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpmz8xej3p.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote"
  stdout: ''
  timestamp: 1660008785
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ == 0)\n        val onesDecimals = ones * decimals\n        val onesDecimalsSorted\
    \ = arr.sortBy(x => onesDecimals.toDouble(x))\n        onesDecimalsSorted.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmpagf_6qc5.scala:12:62 -----------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36monesDecimalsSorted\e[0m\
    \ = arr.sortBy(\e[36mx\e[0m => onesDecimals.toDouble(x))\n\e[31m\e[31m   |\e[0m\
    \                                                 ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                   \e[33mmethod\e[0m \e[35mtoDouble\e[0m in \e\
    [33mclass\e[0m \e[35mInt\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- Error: /tmp/tmpagf_6qc5.scala:12:74 -----------------------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36monesDecimalsSorted\e[0m\
    \ = arr.sortBy(\e[36mx\e[0m => onesDecimals.toDouble(x))\n\e[31m\e[31m   |\e[0m\
    \                                                                          ^\e\
    [0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mChar\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mShort\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660008739
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val zeros = arr.count(_ ==\
    \ 0)\n        val onesDecimal = ones * 10\n        val zerosDecimal = zeros *\
    \ 10\n        val onesDecimalString = onesDecimal.toString\n        val zerosDecimalString\
    \ = zerosDecimal.toString\n        val onesDecimalStringArray = onesDecimalString.split(\"\
    \\\\.\")\n        val zerosDecimalStringArray = zerosDecimalString.split(\"\\\\\
    .\")\n        val onesDecimalStringArrayLength = onesDecimalStringArray.length\n\
    \        val zerosDecimalStringArrayLength = zerosDecimalStringArray.length\n\
    \        val onesDecimalStringArrayLength = onesDecimalStringArrayLength - 1\n\
    \        val zerosDecimalStringArrayLength = zerosDecimalStringArrayLength - 1\n\
    \        val onesDecimalStringArrayLength = onesDecimalStringArrayLength + 1\n\
    \        val zerosDecimalStringArrayLength = zerosDecimalStringArrayLength + 1\n\
    \        val onesDecimalStringArrayLength = onesDecimalStringArrayLength + onesDecimalStringArrayLength\n\
    \        val zerosDecimalStringArrayLength = zerosDecimalStringArrayLength + zerosDecimalStringArrayLength\n\
    \        val onesDecimalStringArrayLength = onesDecimalStringArrayLength + onesDecimalStringArrayLength\n\
    \        val zerosDecimalStringArrayLength = zerosDecimalStringArrayLength + zerosDecimalStringArrayLength\n\
    \        val onesDecimalStringArrayLength = onesDecimalStringArrayLength + onesDecimalStringArrayLength\n\
    \        val zerosDecimalStringArrayLength = zerosDecimalStringArrayLength + zerosDecimalStringArrayLength\n\
    \        val onesDecimalStringArrayLength = onesDecimalStringArrayLength + onesDecimalStringArrayLength\n\
    \        val zerosDecimalStringArrayLength = zerosDecimalStringArrayLength + zerosDecimalStringArrayLength\n\
    \        val onesDecimalStringArrayLength = onesDecimalStringArrayLength + onesDecimalStringArrayLength\n\
    \        val zerosDecimalStringArrayLength = zerosDecimalStringArrayLength + zerosDecimalStringArrayLength\n\
    \        val onesDecimalStringArrayLength = onesDecimalStringArrayLength + onesDecimalStringArrayLength\n\
    \        val zerosDecimalStringArrayLength = zerosDecimalStringArrayLength + zerosDecimalStringArrayLength\n\
    \        val onesDecimalStringArrayLength = onesDecimalStringArrayLength + onesDecimalStringArrayLength\n\
    \        val zerosDecimalStringArrayLength = zerosDecimalStringArrayLength + zerosDecimalStringArrayLength\n\
    \        val onesDecimalStringArrayLength = onesDecimalStringArrayLength + onesDecimalStringArrayLength\n\
    \        val zerosDecimalStringArrayLength = zerosDecimalStringArrayLength + zerosDecimalStringArrayLength\n\
    \        val onesDecimalStringArray\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpo75v65fp.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo75v65fp.scala:19:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesDecimalStringArrayLength\e[0m = onesDecimalStringArrayLength - \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalStringArrayLength is already defined as \e[33mvalue\e\
    [0m \e[35monesDecimalStringArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo75v65fp.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalStringArrayLength\e\
    [0m = zerosDecimalStringArrayLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mzerosDecimalStringArrayLength is already defined as \e[33mvalue\e\
    [0m \e[35mzerosDecimalStringArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo75v65fp.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36monesDecimalStringArrayLength\e\
    [0m = onesDecimalStringArrayLength + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0monesDecimalStringArrayLength is already defined as \e[33mvalue\e\
    [0m \e[35monesDecimalStringArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo75v65fp.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalStringArrayLength\e\
    [0m = zerosDecimalStringArrayLength + \e"
  stdout: ''
  timestamp: 1660008787
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(x => x == 1)\n        val decimals = arr.count(x\
    \ => x == 0)\n        val maxOnes = arr.count(x => x == 1)\n        val maxDecimals\
    \ = arr.count(x => x == 0)\n        val maxOnesDecimals = arr.count(x => x ==\
    \ 1)\n        val maxOnesDecimalsDecimals = arr.count(x => x == 1)\n        val\
    \ maxOnesDecimalsDecimalsDecimals = arr.count(x => x == 1)\n        val maxOnesDecimalsDecimalsDecimalsDecimals\
    \ = arr.count(x => x == 1)\n        val maxOnesDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.count(x => x == 1)\n        val maxOnesDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.count(x => x == 1)\n        val maxOnesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.count(x => x == 1)\n        val maxOnesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.count(x => x == 1)\n        val maxOnesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.count(x => x == 1)\n        val maxOnesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.count(x => x == 1)\n        val maxOnesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.count(x => x == 1)\n        val maxOnesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.count(x => x == 1)\n        val maxOnesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.count(x => x == 1)\n        val maxOnesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.count(x => x == 1)\n        val maxOnesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.count(x => x == 1)\n        val maxOnesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpz7u2_j2e.scala:29:4 ----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpz7u2_j2e.scala:29:5 ---------------------\e[0m\e[0m\n\e[31m29 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660008789
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        // Your code goes here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0_8sc31z.scala:8:51\
    \ ---------------------\e[0m\e[0m\n\e[31m 8 |\e[0m    \e[33mdef\e[0m \e[36msortArray\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m]) : \e[35mList\e[0m[\e[35mLong\e\
    [0m] = {\n\e[31m\e[31m   |\e[0m                                              \
    \     ^\e[0m\n\e[31m   |\e[0m                                                \
    \   Found:    Unit\n\e[31m   |\e[0m                                          \
    \         Required: List[Long]\n\e[31m 9 |\e[0m        \e[34m// Your code goes\
    \ here\e[0m\n\e[31m10 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660008788
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val zeros = arr.count(_ ==\
    \ 0)\n        val onesArray = arr.map(x => (x % 2 == 0 ? 1 : 0))\n        val\
    \ zerosArray = arr.map(x => (x % 2 == 0 ? 0 : 1))\n        val onesArraySorted\
    \ = onesArray.sortBy(x => x)\n        val zerosArraySorted = zerosArray.sortBy(x\
    \ => x)\n        val sortedArray = onesArraySorted.zip(zerosArraySorted).sortBy(x\
    \ => x._1).map(x => x._2)\n        sortedArray\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpipoe2pz8.scala:11:49 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36monesArray\e[0m = arr.map(\e\
    [36mx\e[0m => (x % \e[31m2\e[0m == \e[31m0\e[0m ? \e[31m1\e[0m : \e[31m0\e[0m))\n\
    \e[31m\e[31m   |\e[0m                                               ^^^\e[0m\n\
    \e[31m   |\e[0m                                          value ? is not a member\
    \ of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpipoe2pz8.scala:12:50\
    \ ------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e\
    [36mzerosArray\e[0m = arr.map(\e[36mx\e[0m => (x % \e[31m2\e[0m == \e[31m0\e[0m\
    \ ? \e[31m0\e[0m : \e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m                     \
    \                           ^^^\e[0m\n\e[31m   |\e[0m                        \
    \                  value ? is not a member of Int\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpipoe2pz8.scala:16:8 ---------------------\e[0m\e[0m\n\
    \e[31m16 |\e[0m        sortedArray\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    (sortedArray : List[Int])\n\e[31m   |\e\
    [0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660008793
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(_ % 2 == 0).length\n        val zeros = arr.filter(_\
    \ % 2 == 1).length\n        val onesArray = arr.filter(_ % 2 == 0).map(_.toInt)\n\
    \        val zerosArray = arr.filter(_ % 2 == 1).map(_.toInt)\n        val onesArraySorted\
    \ = onesArray.sortBy(_.toInt)\n        val zerosArraySorted = zerosArray.sortBy(_.toInt)\n\
    \        val onesArraySortedSorted: Array[Int] = onesArraySorted.sortBy(_.toInt)\n\
    \        val zerosArraySortedSorted: Array[Int] = zerosArraySorted.sortBy(_.toInt)\n\
    \        val onesArraySortedSortedSorted: Array[Int] = onesArraySortedSorted.sortBy(_.toInt)\n\
    \        val zerosArraySortedSortedSorted: Array[Int] = zerosArraySortedSorted.sortBy(_.toInt)\n\
    \        val onesArraySortedSortedSortedSorted: Array[Int] = onesArraySortedSortedSorted.sortBy(_.toInt)\n\
    \        val zerosArraySortedSortedSortedSorted: Array[Int] = zerosArraySortedSortedSorted.sortBy(_.toInt)\n\
    \        val onesArraySortedSortedSortedSortedSorted: Array[Int] = onesArraySortedSortedSortedSorted.sortBy(_.toInt)\n\
    \        val zerosArraySortedSortedSortedSorted: Array[Int] = zerosArraySortedSortedSorted.sortBy(_.toInt)\n\
    \        val onesArraySortedSortedSortedSortedSorted: Array[Int] = onesArraySortedSortedSortedSortedSorted.sortBy(_.toInt)\n\
    \        val zerosArraySortedSortedSortedSorted: Array[Int] = zerosArraySortedSortedSortedSorted.sortBy(_.toInt)\n\
    \        val onesArraySortedSortedSortedSortedSorted: Array[Int] = onesArraySortedSortedSortedSortedSorted.sortBy(_.toInt)\n\
    \        val zerosArraySortedSortedSortedSortedSorted: Array[Int] = zerosArraySortedSortedSortedSortedSorted.sortBy(_.toInt)\n\
    \        val onesArraySortedSortedSortedSortedSortedSorted: Array[Int] = onesArraySortedSortedSortedSortedSortedSorted.sortBy(_.toInt)\n\
    \        val zerosArraySortedSortedSortedSortedSorted: Array[Int] = zerosArraySortedSortedSortedSortedSorted.sortBy(_.toInt)\n\
    \        val onesArraySortedSortedSortedSortedSortedSorted: Array[Int] = onesArraySortedSortedSortedSortedSortedSorted.sortBy(_.toInt)\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp_wd2c5ta.scala:30:11 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp_wd2c5ta.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mzerosArraySortedSortedSortedSorted\e\
    [0m: \e[35mArray\e[0m[\e[35mInt\e[0m] = zerosArraySortedSortedSorted.sortBy(_.toInt)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosArraySortedSortedSortedSorted is already defined as \e\
    [33mvalue\e[0m \e[35mzerosArraySortedSortedSortedSorted\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_wd2c5ta.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesArraySortedSortedSortedSortedSorted\e[0m: \e[35mArray\e[0m[\e[35mInt\e\
    [0m] = onesArraySortedSortedSortedSortedSorted.sortBy(_.toInt)\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesArraySortedSortedSortedSortedSorted is already defined\
    \ as \e[33mvalue\e[0m \e[35monesArraySortedSortedSortedSortedSorted\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_wd2c5ta.scala:24:12 ---------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mval\e[0m \e[36mzerosArraySortedSortedSortedSorted\e[0m:\
    \ \e[35mArray\e[0m[\e[35mInt\e[0m] = zerosArraySortedSortedSortedSorted.sortBy(_.toInt)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosArraySortedSortedSortedSorted is alrea"
  stdout: ''
  timestamp: 1660008796
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val zeros = arr.count(_ ==\
    \ 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount = arr.count(_\
    \ == 0)\n        val onesDecimal = onesCount / arr.length\n        val zerosDecimal\
    \ = zerosCount / arr.length\n        val onesDecimalDecimal = onesDecimal / onesCount\n\
    \        val zerosDecimalDecimal = zerosDecimal / zerosCount\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_wjmvoel.scala:34:4 ----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_wjmvoel.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_wjmvoel.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_wjmvoel.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660008687
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val zeros = arr.count(_ ==\
    \ 0)\n        val onesArr = arr.filter(x => x == 1).sortBy(x => x.toString.toInt)\n\
    \        val zerosArr = arr.filter(x => x == 0).sortBy(x => x.toString.toInt)\n\
    \        val onesCount = onesArr.length\n        val zerosCount = zerosArr.length\n\
    \        val onesSum = onesArr.foldLeft(0)(_ + _)\n        val zerosSum = zerosArr.foldLeft(0)(_\
    \ + _)\n        val onesSumDecimal = onesSum / onesCount\n        val zerosSumDecimal\
    \ = zerosSum / zerosCount\n        val onesSumDecimalDecimal = onesSumDecimal\
    \ / onesCount\n        val zerosSumDecimalDecimal = zerosSumDecimal / zerosCount\n\
    \        val onesSumDecimalDecimalDecimal = onesSumDecimalDecimal / onesCount\n\
    \        val zerosSumDecimalDecimalDecimal = zerosSumDecimalDecimal / zerosCount\n\
    \        val onesSumDecimalDecimalDecimalDecimal = onesSumDecimalDecimalDecimal\
    \ / onesCount\n        val zerosSumDecimalDecimalDecimalDecimal = zerosSumDecimalDecimalDecimal\
    \ / zerosCount\n        val onesSumDecimalDecimalDecimalDecimalDecimal = onesSumDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosSumDecimalDecimalDecimalDecimalDecimal = zerosSumDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesSumDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesSumDecimalDecimalDecimalDecimalDecimal / onesCount\n        val zerosSumDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosSumDecimalDecimalDecimalDecimalDecimal / zerosCount\n        val onesSumDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesSumDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n        val\
    \ zerosSumDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosSumDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesSumDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesSumDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosSumDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosSumDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesSumDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesSumDecimalDecimalDecimal\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjazyaaub.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36monesSumDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesSumDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesSumDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35monesSumDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpjazyaaub.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mzerosSumDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosSumDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosSumDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosSumDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpjazyaaub.scala:15:42 --------------------\e[0m\e[0m\n\
    \e[31m15 |\e[0m        \e[33mval\e[0m \e[36monesSum\e[0m = onesArr.foldLeft(\e\
    [31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                                    \
    \      ^^^^^\e[0m\n\e[31m   |\e[0m                                          Found:\
    \    Long\n\e[31m   |\e[0m                                          Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjazyaaub.scala:16:44\
    \ --------------------\e[0m\e"
  stdout: ''
  timestamp: 1660008797
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val zeros = arr.count(_ ==\
    \ 0)\n        val onesDec = ones * 10\n        val zerosDec = zeros * 10\n   \
    \     val onesBin = ones.toBinaryString\n        val zerosBin = zeros.toBinaryString\n\
    \        val onesBinList = onesBin.split(' ').map(_.toLong)\n        val zerosBinList\
    \ = zerosBin.split(' ').map(_.toLong)\n        val onesBinMap = onesBinList.zip(zerosBinList).map(x\
    \ => (x._1, x._2)).toMap\n        val zerosBinMap = zerosBinList.zip(onesBinList).map(x\
    \ => (x._1, x._2)).toMap\n        val onesBinMapList = onesBinList.map(x => onesBinMap.getOrElse(x,\
    \ 0).toLong)\n        val zerosBinMapList = zerosBinList.map(x => zerosBinMap.getOrElse(x,\
    \ 0).toLong)\n        val onesBinMapMap = onesBinMap.zip(zerosBinMap).map(x =>\
    \ (x._1, x._2)).toMap\n        val zerosBinMapMap = zerosBinMap.zip(onesBinMap).map(x\
    \ => (x._1, x._2)).toMap\n        val onesBinMapMapList = onesBinMapList.map(x\
    \ => onesBinMapMap.getOrElse(x, 0).toLong)\n        val zerosBinMapMapList = zerosBinMapList.map(x\
    \ => zerosBinMapMap.getOrElse(x, 0).toLong)\n        val onesBinMapMapMap = onesBinMapMap.zip(zerosBinMapMap).map(x\
    \ => (x._1, x._2)).toMap\n        val zerosBinMapMapMap = zerosBinMapMap.zip(onesBinMapMap).map(x\
    \ => (x._1, x._2)).toMap\n        val onesBinMapMapMapList = onesBinMapMapList.map(x\
    \ => onesBinMapMapMap.getOrElse(x, 0).toLong)\n        val zerosBinMapMapMapList\
    \ = zerosBinMapMapList.map(x => zerosBinMapMapMap.getOrElse(x, 0).toLong)\n  \
    \      val onesBinMapMapMapMap = onesBinMapMapMap.zip(zerosBinMapMapMap).map(x\
    \ => (x._1, x._2)).toMap\n        val zerosBinMapMapMapMap = zerosBinMapMapMap.zip(onesBinMapMapMap).map(x\
    \ => (x._1, x._2)).toMap\n        val onesBinMapMapMapMapList = \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpg2hnw6t6.scala:31:37 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36monesBinMapMapMapMapList\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                     ^\e[0m\n\e[31m\
    \   |\e[0m                                     expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpg2hnw6t6.scala:19:77\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36monesBinMapList\e[0m = onesBinList.map(\e[36mx\e[0m => onesBinMap.getOrElse(x,\
    \ \e[31m0\e[0m).toLong)\n\e[31m\e[31m   |\e[0m                               \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ toLong is not a member of AnyVal, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- Error: /tmp/tmpg2hnw6t6.scala:19:84 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36monesBinMapList\e[0m = onesBinList.map(\e\
    [36mx\e[0m => onesBinMap.getOrElse(x, \e[31m0\e[0m).toLong)\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \          ^\e[0m\n\e[31m   |\e[0m                                          No\
    \ ClassTag available for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m                 \
    \                         where:    B is a type variable\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpg2hnw6t6.scala:20:80 ------------------------\e[0m\e\
    [0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mzerosBinMapList\e[0m = zerosBinList.map(\e\
    [36mx\e[0m => zerosBinMap.getOrElse(x, \e[31m0\e[0m).toLong)\n\e[31m\e[31m   |\e\
    [0m                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e"
  stdout: ''
  timestamp: 1660008799
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        // Your code here\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl8olg31u.scala:8:51\
    \ ---------------------\e[0m\e[0m\n\e[31m 8 |\e[0m    \e[33mdef\e[0m \e[36msortArray\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m]) : \e[35mList\e[0m[\e[35mLong\e\
    [0m] = {\n\e[31m\e[31m   |\e[0m                                              \
    \     ^\e[0m\n\e[31m   |\e[0m                                                \
    \   Found:    Unit\n\e[31m   |\e[0m                                          \
    \         Required: List[Long]\n\e[31m 9 |\e[0m        \e[34m// Your code here\e\
    [0m\n\e[31m10 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660008686
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val zeros = arr.count(_ ==\
    \ 0)\n        val onesArray = arr.map(x => if (x == 1) 1 else 0)\n        val\
    \ zerosArray = arr.map(x => if (x == 0) 0 else 1)\n        val onesArraySorted\
    \ = onesArray.sortBy(x => x)\n        val zerosArraySorted = zerosArray.sortBy(x\
    \ => x)\n        val sortedArray = onesArraySorted.zip(zerosArraySorted).sortBy(x\
    \ => x._1).zip(x._2).map(x => x._1 + x._2)\n        sortedArray\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgcy4t_kz.scala:15:86 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36msortedArray\e[0m = onesArraySorted.zip(zerosArraySorted).sortBy(\e\
    [36mx\e[0m => x._1).zip(x._2).map(\e[36mx\e[0m => x._1 + x._2)\n\e[31m\e[31m \
    \  |\e[0m                                                                    \
    \                  ^\e[0m\n\e[31m   |\e[0m                                   \
    \                         Not found: x\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpgcy4t_kz.scala:15:106 -----------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36msortedArray\e[0m = onesArraySorted.zip(zerosArraySorted).sortBy(\e\
    [36mx\e[0m => x._1).zip(x._2).map(\e[36mx\e[0m => x._1 + x._2)\n\e[31m\e[31m \
    \  |\e[0m                                                                    \
    \                                 ^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a\
    \ member of (Int, Int), but could be made available as an extension method.\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660008798
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ == 0)\n        val onesDecimals = ones * decimals\n        val onesDecimalsSorted\
    \ = arr.sortBy(x => onesDecimals.toDouble(x))\n        val zerosDecimals = arr.count(_\
    \ == 1)\n        val zerosDecimalsSorted = arr.sortBy(x => zerosDecimals.toDouble(x))\n\
    \        onesDecimalsSorted.toList ++ zerosDecimalsSorted.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmpwl838jon.scala:12:62 -----------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36monesDecimalsSorted\e[0m\
    \ = arr.sortBy(\e[36mx\e[0m => onesDecimals.toDouble(x))\n\e[31m\e[31m   |\e[0m\
    \                                                 ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                   \e[33mmethod\e[0m \e[35mtoDouble\e[0m in \e\
    [33mclass\e[0m \e[35mInt\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- Error: /tmp/tmpwl838jon.scala:12:74 -----------------------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36monesDecimalsSorted\e[0m\
    \ = arr.sortBy(\e[36mx\e[0m => onesDecimals.toDouble(x))\n\e[31m\e[31m   |\e[0m\
    \                                                                          ^\e\
    [0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mByte\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmpwl838jon.scala:14:64 -----------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalsSorted\e[0m\
    \ = arr.sortBy(\e[36mx\e[0m => zerosDecimals.toDouble(x))\n\e[31m\e[31m   |\e\
    [0m                                                  ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                   \e[33mmethod\e[0m \e[35mtoDouble\e[0m in\
    \ \e[33mclass\e[0m \e[35mInt\e[0m does not take parameters\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- Error: /tmp/tmpwl838jon.scala:14:76 -----------------------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalsSorted\e[0m\
    \ = arr.sortBy(\e[36mx\e[0m => zerosDecimals.toDouble(x))\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \  ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e\
    [35mByte\e[0m in \e[33mobject\e"
  stdout: ''
  timestamp: 1660008790
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(x => x % 2 == 0).length\n        val zeros\
    \ = arr.filter(x => x % 2 == 1).length\n        val onesArray = arr.filter(x =>\
    \ x % 2 == 0).map(x => x.toInt)\n        val zerosArray = arr.filter(x => x %\
    \ 2 == 1).map(x => x.toInt)\n        val onesArraySorted = onesArray.sortWith(_\
    \ < _)\n        val zerosArraySorted = zerosArray.sortWith(_ < _)\n        onesArraySorted.zip(zerosArraySorted).map\
    \ { case (one, zero) => one + zero }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvtx9nsrx.scala:18)\n\tat Problem.main(tmpvtx9nsrx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660008800
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        // Your code here\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl8olg31u.scala:8:51\
    \ ---------------------\e[0m\e[0m\n\e[31m 8 |\e[0m    \e[33mdef\e[0m \e[36msortArray\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m]) : \e[35mList\e[0m[\e[35mLong\e\
    [0m] = {\n\e[31m\e[31m   |\e[0m                                              \
    \     ^\e[0m\n\e[31m   |\e[0m                                                \
    \   Found:    Unit\n\e[31m   |\e[0m                                          \
    \         Required: List[Long]\n\e[31m 9 |\e[0m        \e[34m// Your code here\e\
    [0m\n\e[31m10 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660008686
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(x => x == 1)\n        val twos = arr.count(x\
    \ => x == 2)\n        val threes = arr.count(x => x == 3)\n        val fours =\
    \ arr.count(x => x == 4)\n        val fives = arr.count(x => x == 5)\n       \
    \ val sixes = arr.count(x => x == 6)\n        val sevens = arr.count(x => x ==\
    \ 7)\n        val eights = arr.count(x => x == 8)\n        val nines = arr.count(x\
    \ => x == 9)\n        val tens = arr.count(x => x == 10)\n        val hundreds\
    \ = arr.count(x => x == 100)\n        val thousands = arr.count(x => x == 1000)\n\
    \        val millions = arr.count(x => x == 1000000)\n        val billions = arr.count(x\
    \ => x == 1000000000)\n        val trillions = arr.count(x => x == 1000000000000)\n\
    \        val quadrillions = arr.count(x => x == 1000000000000000)\n        val\
    \ quintillions = arr.count(x => x == 1000000000000000000)\n        val onesAndZeros\
    \ = arr.count(x => x == 1 && x == 0)\n        val onesAndOnes = arr.count(x =>\
    \ x == 1 && x == 1)\n        val onesAndTwos = arr.count(x => x == 1 && x == 2)\n\
    \        val onesAndThrees = arr.count(x => x == 1 && x == 3)\n        val onesAndFours\
    \ = arr.count(x => x == 1 && x == 4)\n        val onesAndFives = arr.count(x =>\
    \ x == 1 && x == 5)\n        val onesAndSixes = arr.count(x => x == 1 && x ==\
    \ 6)\n        val onesAndSevens = arr.count(x => x == 1 && x == 7)\n        val\
    \ onesAndEights = arr.count(x => x == 1 && x == 8)\n        val onesAndNines =\
    \ arr.count(x => x == 1 && x == 9)\n        val onesAndTens = arr.count(x => x\
    \ == 1 && x == 10)\n        val onesAndHundreds = arr.count(x => x == 1 && x ==\
    \ 100)\n        val onesAndThousands = arr.count(x => x == 1 && x == 1000)\n \
    \       val onesAndMillions = arr.count(x => x == 1 && x == 1000000)\n       \
    \ val onesAndBillions = arr.count(x => x == 1 && x == 1000000000)\n        val\
    \ onesAndTrillions = arr.count(x => x == 1 && x == 1000000000000)\n        val\
    \ onesAndQuadrillions = arr.count(x => x == 1 && x == 1000000000000000)\n    \
    \    val onesAndQuintillions = arr.count(x => x == 1 && x == \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpreuhtywv.scala:43:63 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36monesAndQuintillions\e[0m\
    \ = arr.count(\e[36mx\e[0m => x == \e[31m1\e[0m && x == \n\e[31m\e[31m   |\e[0m\
    \                                                               ^\e[0m\n\e[31m\
    \   |\e[0m                                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpreuhtywv.scala:23:44\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m23 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.count(\e[36mx\e[0m => x == \e[31m1000000000000\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                            ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                            number too large\n\
    \e[31m\e[31m-- Error: /tmp/tmpreuhtywv.scala:24:47 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.count(\e\
    [36mx\e[0m => x == \e[31m1000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m       \
    \                                        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                               number too large\n\e[31m\e[31m--\
    \ Error: /tmp/tmpreuhtywv.scala:25:47 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mquintillions\e[0m = arr.count(\e\
    [36mx\e[0m => x == \e[31m1000000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m    \
    \                                           ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                                               number too large\n\e[31m\e\
    [31m-- Error: /tmp/tmpreuhtywv.scala:41:61 -----------------------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36monesAndTrillions\e[0m =\
    \ arr.count(\e[36mx\e[0m => x == \e[31m1\e[0m && x == \e[31m1000000000000\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \     ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                    \
    \                    number too large\n\e[31m\e[31m-- Error: /tmp/tmpre"
  stdout: ''
  timestamp: 1660008796
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val zeros = arr.count(_ ==\
    \ 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount = arr.count(_\
    \ == 0)\n        val onesDecimal = onesCount / arr.length\n        val zerosDecimal\
    \ = zerosCount / arr.length\n        val onesDecimalDecimal = onesDecimal + zerosDecimal\n\
    \        val zerosDecimalDecimal = zerosDecimal + onesDecimal\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal * 10\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * 10\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * 10\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprhogjonk.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal * \e[31m10\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmprhogjonk.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * \e[31m10\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmprhogjonk.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal * \e[31m10\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of"
  stdout: ''
  timestamp: 1660008797
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val zeros = arr.count(_ ==\
    \ 0)\n        val onesDecimal = ones * 10\n        val zerosDecimal = zeros *\
    \ 10\n        val onesDecimalString = onesDecimal.toString\n        val zerosDecimalString\
    \ = zerosDecimal.toString\n        val onesDecimalString = onesDecimalString.reverse\n\
    \        val zerosDecimalString = zerosDecimalString.reverse\n        val onesDecimalString\
    \ = onesDecimalString.reverse\n        val zerosDecimalString = zerosDecimalString.reverse\n\
    \        val onesDecimalString = onesDecimalString.reverse\n        val zerosDecimalString\
    \ = zerosDecimalString.reverse\n        val onesDecimalString = onesDecimalString.reverse\n\
    \        val zerosDecimalString = zerosDecimalString.reverse\n        val onesDecimalString\
    \ = onesDecimalString.reverse\n        val zerosDecimalString = zerosDecimalString.reverse\n\
    \        val onesDecimalString = onesDecimalString.reverse\n        val zerosDecimalString\
    \ = zerosDecimalString.reverse\n        val onesDecimalString = onesDecimalString.reverse\n\
    \        val zerosDecimalString = zerosDecimalString.reverse\n        val onesDecimalString\
    \ = onesDecimalString.reverse\n        val zerosDecimalString = zerosDecimalString.reverse\n\
    \        val onesDecimalString = onesDecimalString.reverse\n        val zerosDecimalString\
    \ = zerosDecimalString.reverse\n        val onesDecimalString = onesDecimalString.reverse\n\
    \        val zerosDecimalString = zerosDecimalString.reverse\n        val onesDecimalString\
    \ = onesDecimalString.reverse\n        val zerosDecimalString = zerosDecimalString.reverse\n\
    \        val onesDecimalString = onesDecimalString.reverse\n        val zerosDecimalString\
    \ = zerosDecimalString.reverse\n        val onesDecimalString = onesDecimalString.reverse\n\
    \        val zerosDecimalString = zerosDecimalString.reverse\n        val onesDecimalString\
    \ = onesDecimalString.reverse\n        val zerosDecimalString = zerosDecimalString.reverse\n\
    \        val onesDecimalString = onesDecimalString.reverse\n        val zerosDecimalString\
    \ = zerosDecimalString.reverse\n        val onesDecimalString = onesDecimalString.reverse\n\
    \        val zerosDecimalString = zerosDecimalString.reverse\n        val onesDecimalString\
    \ = onesDecimalString.reverse\n        val zerosDecimalString = zerosDecimalString.reverse\n\
    \        val onesDecimalString = onesDecimalString.reverse\n        val zerosDecimalString\
    \ = zerosDecimalString.reverse\n        val onesDecimalString = onesDecimalString.reverse\n\
    \        val zerosDecimalString = zerosDecimalString.reverse\n        val onesDecimalString\
    \ = onesDecimalString.reverse\n        val zerosDecimalString = zerosDecimalString.reverse\n\
    \        val onesDecimalString = onesDecimalString.reverse\n        \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmplb9vg11r.scala:15:12 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36monesDecimalString\e[0m =\
    \ onesDecimalString.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalString is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalString\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmplb9vg11r.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalString\e[0m\
    \ = zerosDecimalString.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalString is already defined as \e[33mvalue\e[0m\
    \ \e[35mzerosDecimalString\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmplb9vg11r.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36monesDecimalString\e[0m =\
    \ onesDecimalString.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalString is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalString\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmplb9vg11r.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalString\e[0m\
    \ = zerosDecimalString.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalString is already defined as \e[33mvalue\e[0m\
    \ \e[35mzerosDecimalString\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmplb9vg11r.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m"
  stdout: ''
  timestamp: 1660008799
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(x => x == 1).size\n        val zeros = arr.filter(x\
    \ => x == 0).size\n        val onesZeros = ones + zeros\n        val onesZeroDec\
    \ = onesZeros / 10\n        val zeroDec = zeros / 10\n        val onesZeroDecDec\
    \ = (onesZeroDec * 10).toInt\n        val zeroDecDec = (zeroDec * 10).toInt\n\
    \        val onesZeroDecDecDec = (onesZeroDecDec * 10).toInt\n        val zeroDecDecDec\
    \ = (zeroDecDec * 10).toInt\n        val onesZeroDecDecDecDec = (onesZeroDecDecDec\
    \ * 10).toInt\n        val zeroDecDecDecDec = (zeroDecDecDec * 10).toInt\n   \
    \     val onesZeroDecDecDecDecDec = (onesZeroDecDecDecDec * 10).toInt\n      \
    \  val zeroDecDecDecDecDecDec = (zeroDecDecDecDecDec * 10).toInt\n        val\
    \ onesZeroDecDecDecDecDecDec = (onesZeroDecDecDecDecDecDec * 10).toInt\n     \
    \   val zeroDecDecDecDecDecDecDec = (zeroDecDecDecDecDecDecDec * 10).toInt\n \
    \       val onesZeroDecDecDecDecDecDecDec = (onesZeroDecDecDecDecDecDecDecDec\
    \ * 10).toInt\n        val zeroDecDecDecDecDecDecDecDec = (zeroDecDecDecDecDecDecDecDec\
    \ * 10).toInt\n        val onesZeroDecDecDecDecDecDecDecDec = (onesZeroDecDecDecDecDecDecDecDecDec\
    \ * 10).toInt\n        val zeroDecDecDecDecDecDecDecDecDec = (zeroDecDecDecDecDecDecDecDecDec\
    \ * 10).toInt\n        val onesZeroDecDecDecDecDecDecDecDec = (onesZeroDecDecDecDecDecDecDecDecDec\
    \ * 10).toInt\n        val zeroDecDecDecDecDecDecDecDecDec = (zeroDecDecDecDecDecDecDecDecDec\
    \ * 10).toInt\n        val onesZeroDecDecDecDecDecDecDecDec = (onesZeroDecDecDecDecDecDecDecDecDec\
    \ * 10).toInt\n        val zeroDecDecDecDecDecDecDecDecDec = (zeroDecDecDecDecDecDecDecDecDecDec\
    \ * 10).toInt\n        val onesZeroDecDecDecDecDecDecDecDec = (onesZeroDecDecDecDecDecDecDecDecDec\
    \ * \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpmxu02fi6.scala:32:85 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36monesZeroDecDecDecDecDecDecDecDec\e\
    [0m = (onesZeroDecDecDecDecDecDecDecDecDec * \n\e[31m\e[31m   |\e[0m         \
    \                                                                            ^\e\
    [0m\n\e[31m   |\e[0m                                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpmxu02fi6.scala:28:12 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mval\e[0m \e[36monesZeroDecDecDecDecDecDecDecDec\e[0m = (onesZeroDecDecDecDecDecDecDecDecDec\
    \ * \e[31m10\e[0m).toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroDecDecDecDecDecDecDecDec is already defined as \e\
    [33mvalue\e[0m \e[35monesZeroDecDecDecDecDecDecDecDec\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmxu02fi6.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzeroDecDecDecDecDecDecDecDecDec\e[0m = (zeroDecDecDecDecDecDecDecDecDec\
    \ * \e[31m10\e[0m).toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzeroDecDecDecDecDecDecDecDecDec is already defined as \e[33mvalue\e\
    [0m \e[35mzeroDecDecDecDecDecDecDecDecDec\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmxu02fi6.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeroDecDecDecDecDecDecDecDec\e[0m = (onesZeroDecDecDecDecDecDecDecDecDec\
    \ * \e[31m10\e[0m).toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m "
  stdout: ''
  timestamp: 1660008797
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ < 0)\n        val onesDecimals = ones * decimals\n        val onesDecimalsSorted\
    \ = arr.sortBy(_ - onesDecimals)\n        val zerosDecimals = arr.count(_ > 0)\n\
    \        val zerosDecimalsSorted = arr.sortBy(_ - zerosDecimals)\n        onesDecimalsSorted.union(zerosDecimalsSorted)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp741a38o_.scala:18)\n\tat Problem.main(tmp741a38o_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660008801
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decs = arr.map(_.toString.toInt)\n\
    \        val sorted = decs.sortBy(_.toInt)\n        val onesSorted = sorted.takeWhile(_\
    \ < ones)\n        onesSorted.reverse.take(ones).sortBy(_.toString.toInt)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpq40yuj8i.scala:13:8\
    \ ---------------------\e[0m\e[0m\n\e[31m13 |\e[0m        onesSorted.reverse.take(ones).sortBy(_.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e\
    [0m        Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660008798
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(x => x % 2 == 0).length\n        val twos\
    \ = arr.filter(x => x % 2 == 1).length\n        val threes = arr.filter(x => x\
    \ % 3 == 0).length\n        val fours = arr.filter(x => x % 4 == 0).length\n \
    \       val fives = arr.filter(x => x % 5 == 0).length\n        val sixes = arr.filter(x\
    \ => x % 6 == 0).length\n        val sevens = arr.filter(x => x % 7 == 0).length\n\
    \        val eights = arr.filter(x => x % 8 == 0).length\n        val nines =\
    \ arr.filter(x => x % 9 == 0).length\n        val tens = arr.filter(x => x % 10\
    \ == 0).length\n        val hundreds = arr.filter(x => x % 100 == 0).length\n\
    \        val thousands = arr.filter(x => x % 1000 == 0).length\n        val tenThousands\
    \ = arr.filter(x => x % 10000 == 0).length\n        val oneThousands = arr.filter(x\
    \ => x % 100000 == 0).length\n        val oneMillion = arr.filter(x => x % 1000000\
    \ == 0).length\n        val oneBillion = arr.filter(x => x % 10000000 == 0).length\n\
    \        val oneTrillion = arr.filter(x => x % 100000000 == 0).length\n      \
    \  val oneQuadrillion = arr.filter(x => x % 1000000000 == 0).length\n        val\
    \ oneQuintillion = arr.filter(x => x % 10000000000 == 0).length\n        val oneBillionThousand\
    \ = arr.filter(x => x % 1000000000000 == 0).length\n        val oneTrillionThousand\
    \ = arr.filter(x => x % 10000000000000 == 0).length\n        val oneQuadrillionThousand\
    \ = arr.filter(x => x % 100000000000000 == 0).length\n        val oneQuintillionThousand\
    \ = arr.filter(x => x % 1000000000000000 == 0).length\n        val oneBillionThousandThousand\
    \ = arr.filter(x => x % 10000000000000000 == 0).length\n        val oneTrillionThousandThousand\
    \ = arr.filter(x => x % 100000000000000000 == 0).length\n        val oneQuadrillionThousandThousand\
    \ = arr.filter(x => x % 1000000000000000000 == 0).length\n        val oneQuintillionThousandThousand\
    \ = arr.filter(x => x % 100000000000000000000 == 0).length\n        \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpboakw5w0.scala:27:49 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36moneQuintillion\e[0m = arr.filter(\e\
    [36mx\e[0m => x % \e[31m10000000000\e[0m == \e[31m0\e[0m).length\n\e[31m\e[31m\
    \   |\e[0m                                                 ^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                                 number too large\n\
    \e[31m\e[31m-- Error: /tmp/tmpboakw5w0.scala:28:53 -----------------------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36moneBillionThousand\e[0m\
    \ = arr.filter(\e[36mx\e[0m => x % \e[31m1000000000000\e[0m == \e[31m0\e[0m).length\n\
    \e[31m\e[31m   |\e[0m                                                     ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                     number\
    \ too large\n\e[31m\e[31m-- Error: /tmp/tmpboakw5w0.scala:29:54 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36moneTrillionThousand\e[0m\
    \ = arr.filter(\e[36mx\e[0m => x % \e[31m10000000000000\e[0m == \e[31m0\e[0m).length\n\
    \e[31m\e[31m   |\e[0m                                                      ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                      number\
    \ too large\n\e[31m\e[31m-- Error: /tmp/tmpboakw5w0.scala:30:57 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36moneQuadrillionThousand\e\
    [0m = arr.filter(\e[36mx\e[0m => x % \e[31m100000000000000\e[0m == \e[31m0\e[0m).length\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \ ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                      \
    \                  number too large\n\e[31m\e[31m-- Error: /tmp/tmpboakw5w0.scala:31:57\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m31 |\e[0m       \
    \ \e[33mval\e[0m \e[36moneQuintillionThousand\e[0m = arr.filter(\e[36mx\e[0m =>\
    \ x % \e[31m1000000000000000\e[0m == \e[31m0\e[0m).length\n\e[31m\e[31m   |\e\
    [0m                                                         ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                       "
  stdout: ''
  timestamp: 1660008799
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(_ % 2 == 0).length\n        val twos = arr.filter(_\
    \ % 2 == 1).length\n        val decimals = arr.filter(_ % 10 == 0).length\n  \
    \      val decimalsDecimals = arr.filter(_ % 10 == 1).length\n        val decimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 2).length\n        val decimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 3).length\n        val decimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 4).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 5).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 6).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 7).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 8).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 9).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 0).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 1).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 2).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 3).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 4).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 5).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 6).length\n        val decimalsDecimal\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp25o9kpfh.scala:29:4 ----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp25o9kpfh.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mdecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\e\
    [0m = arr.filter(_ % \e[31m10\e[0m == \e[31m1\e[0m).length\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp25o9kpfh.scala:29:5 ---------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660008800
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(x => x % 2 == 0).length\n        val twos\
    \ = arr.filter(x => x % 2 == 1).length\n        val threes = arr.filter(x => x\
    \ % 3 == 0).length\n        val fours = arr.filter(x => x % 4 == 0).length\n \
    \       val fives = arr.filter(x => x % 5 == 0).length\n        val sixes = arr.filter(x\
    \ => x % 6 == 0).length\n        val sevens = arr.filter(x => x % 7 == 0).length\n\
    \        val eights = arr.filter(x => x % 8 == 0).length\n        val nines =\
    \ arr.filter(x => x % 9 == 0).length\n        val tens = arr.filter(x => x % 10\
    \ == 0).length\n        val elevens = arr.filter(x => x % 11 == 0).length\n  \
    \      val twelves = arr.filter(x => x % 12 == 0).length\n        val thirteens\
    \ = arr.filter(x => x % 13 == 0).length\n        val fourteens = arr.filter(x\
    \ => x % 14 == 0).length\n        val fifteens = arr.filter(x => x % 15 == 0).length\n\
    \        val sixteens = arr.filter(x => x % 16 == 0).length\n        val seventeens\
    \ = arr.filter(x => x % 17 == 0).length\n        val eighteens = arr.filter(x\
    \ => x % 18 == 0).length\n        val nineteens = arr.filter(x => x % 19 == 0).length\n\
    \        val twenties = arr.filter(x => x % 20 == 0).length\n        val thirties\
    \ = arr.filter(x => x % 30 == 0).length\n        val fourties = arr.filter(x =>\
    \ x % 40 == 0).length\n        val fifties = arr.filter(x => x % 50 == 0).length\n\
    \        val sixties = arr.filter(x => x % 60 == 0).length\n        val seventies\
    \ = arr.filter(x => x % 70 == 0).length\n        val eighties = arr.filter(x =>\
    \ x % 80 == 0).length\n        val nineties = arr.filter(x => x % 90 == 0).length\n\
    \        val hundreds = arr.filter(x => x % 100 == 0).length\n        val thousands\
    \ = arr.filter(x => x % 1000 == 0).length\n        val millions = arr.filter(x\
    \ => x % 1000000 == 0).length\n        val billions = arr.filter(x => x % 1000000000\
    \ == 0).length\n        val trillions = arr.filter(x => x % 1000000000000 == \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpm2vrvxst.scala:40:60 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mtrillions\e[0m = arr.filter(\e\
    [36mx\e[0m => x % \e[31m1000000000000\e[0m == \n\e[31m\e[31m   |\e[0m        \
    \                                                    ^\e[0m\n\e[31m   |\e[0m \
    \                                      expression expected but \e[31m'}'\e[0m\
    \ found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpm2vrvxst.scala:40:44 -----------------------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mtrillions\e[0m = arr.filter(\e\
    [36mx\e[0m => x % \e[31m1000000000000\e[0m == \n\e[31m\e[31m   |\e[0m        \
    \                                    ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                                       number too large\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpm2vrvxst.scala:41:5 ---------------------\e[0m\e\
    [0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660008802
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(_ % 2 == 0).length\n        val twos = arr.filter(_\
    \ % 2 == 1).length\n        val decimals = arr.filter(_ % 10 == 0).length\n  \
    \      val decimalsDecimals = arr.filter(_ % 10 == 1).length\n        val decimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 2).length\n        val decimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 3).length\n        val decimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 4).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 5).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 6).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 7).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 8).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 9).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 0).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 1).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 2).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 3).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 4).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 5).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6gntlqbl.scala:28:5\
    \ ---------------------\e[0m\e[0m\n\e[31m28 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660008777
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(x => x == 1)\n        val decimals = arr.count(x\
    \ => x == 0)\n        val onesDecimal = ones * 10\n        val decimalsDecimal\
    \ = decimals * 10\n        val onesDecimalDecimal = onesDecimal * 10\n       \
    \ val decimalsDecimalDecimal = decimalsDecimal * 10\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal * 10\n        val decimalsDecimalDecimalDecimal = decimalsDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimalDecimal = decimalsDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimalDecimalDecimal = decimalsDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimal = decimalsDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimal = decimalsDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimal = decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * 10\n  \
    \      val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * 10\n  \
    \      val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal *\
    \ 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal *\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp8g_tprty.scala:34:145 --------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mdecimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * \n\e[31m\e[31m   |\e[0m                                                  \
    \                                                                            \
    \                   ^\e[0m\n\e[31m   |\e[0m                                  \
    \     expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp8g_tprty.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mdecimalsDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = decimalsDecimalDecimalDecimalDecimalDecimalDecimal * \e[31m10\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalsDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mdecimalsDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8g_tprty.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal * \e[31m10\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tm"
  stdout: ''
  timestamp: 1660008805
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ == 0)\n        val onesDecimal = ones * 10\n        val decimalsDecimal = decimals\
    \ * 10\n        val onesDecimalDecimal = onesDecimal * 10\n        val decimalsDecimalDecimal\
    \ = decimalsDecimal * 10\n        val onesDecimalDecimalDecimal = onesDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimal = decimalsDecimalDecimal * 10\n\
    \        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal * 10\n\
    \        val decimalsDecimalDecimalDecimalDecimal = decimalsDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimalDecimalDecimal = decimalsDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimal = decimalsDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimal = decimalsDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimal = decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * 10\n  \
    \      val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * 10\n  \
    \      val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal *\
    \ 10\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * 10\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal *\
    \ 10\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmptprefwn_.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mdecimalsDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = decimalsDecimalDecimalDecimalDecimalDecimalDecimal * \e[31m10\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalsDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mdecimalsDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmptprefwn_.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * \e[31m10\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmptprefwn_.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36mdecimalsDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal * \e[31m10\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalsDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mdecimalsDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ define"
  stdout: ''
  timestamp: 1660008805
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ == 0)\n        val maxDecimals = decimals.max\n        val maxOnes = ones.max\n\
    \        val maxDecimalsOnes = maxDecimals * maxOnes\n        val maxDecimalsOnesCount\
    \ = maxDecimalsOnes.toInt\n        val maxDecimalsOnesCount2 = maxDecimalsOnesCount\
    \ * maxOnes\n        val maxDecimalsOnesCount3 = maxDecimalsOnesCount2 * maxOnes\n\
    \        val maxDecimalsOnesCount4 = maxDecimalsOnesCount3 * maxOnes\n       \
    \ val maxDecimalsOnesCount5 = maxDecimalsOnesCount4 * maxOnes\n        val maxDecimalsOnesCount6\
    \ = maxDecimalsOnesCount5 * maxOnes\n        val maxDecimalsOnesCount7 = maxDecimalsOnesCount6\
    \ * maxOnes\n        val maxDecimalsOnesCount8 = maxDecimalsOnesCount7 * maxOnes\n\
    \        val maxDecimalsOnesCount9 = maxDecimalsOnesCount8 * maxOnes\n       \
    \ val maxDecimalsOnesCount10 = maxDecimalsOnesCount9 * maxOnes\n        val maxDecimalsOnesCount11\
    \ = maxDecimalsOnesCount10 * maxOnes\n        val maxDecimalsOnesCount12 = maxDecimalsOnesCount11\
    \ * maxOnes\n        val maxDecimalsOnesCount13 = maxDecimalsOnesCount12 * maxOnes\n\
    \        val maxDecimalsOnesCount14 = maxDecimalsOnesCount13 * maxOnes\n     \
    \   val maxDecimalsOnesCount15 = maxDecimalsOnesCount14 * maxOnes\n        val\
    \ maxDecimalsOnesCount16 = maxDecimalsOnesCount15 * maxOnes\n        val maxDecimalsOnesCount17\
    \ = maxDecimalsOnesCount16 * maxOnes\n        val maxDecimalsOnesCount18 = maxDecimalsOnesCount17\
    \ * maxOnes\n        val maxDecimalsOnesCount19 = maxDecimalsOnesCount18 * maxOnes\n\
    \        val maxDecimalsOnesCount20 = maxDecimalsOnesCount19 * maxOnes\n     \
    \   val maxDecimalsOnesCount21 = maxDecimalsOnesCount20 * maxOnes\n        val\
    \ maxDecimalsOnesCount22 = maxDecimalsOnesCount21 * maxOnes\n        \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp19ux4pm8.scala:13:42 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxDecimalsOnes\e[0m = maxDecimals\
    \ * maxOnes\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue * is not a member of Int => Int, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp19ux4pm8.scala:37:5 ---------------------\e[0m\e\
    [0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660008808
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(x => x == 1).size\n        val zeros = arr.filter(x\
    \ => x == 0).size\n        val decimal = arr.map(x => math.log10(math.pow(x, 2))).sum\n\
    \        val decimalOnes = arr.map(x => math.log10(math.pow(x, 2))).filter(x =>\
    \ x == 1).sum\n        val decimalZeros = arr.map(x => math.log10(math.pow(x,\
    \ 2))).filter(x => x == 0).sum\n        val decimalOnesZeros = arr.map(x => math.log10(math.pow(x,\
    \ 2))).filter(x => x == 1 && x == 0).sum\n        val decimalOnesZerosZeros =\
    \ arr.map(x => math.log10(math.pow(x, 2))).filter(x => x == 1 && x == 0 && x ==\
    \ 0).sum\n        val decimalOnesZerosZerosZeros = arr.map(x => math.log10(math.pow(x,\
    \ 2))).filter(x => x == 1 && x == 0 && x == 0 && x == 0).sum\n        val decimalOnesZerosZerosZerosZeros\
    \ = arr.map(x => math.log10(math.pow(x, 2))).filter(x => x == 1 && x == 0 && x\
    \ == 0 && x == 0 && x == 0).sum\n        val decimalOnesZerosZerosZerosZerosZeros\
    \ = arr.map(x => math.log10(math.pow(x, 2))).filter(x => x == 1 && x == 0 && x\
    \ == 0 && x == 0 && x == 0 && x == 0).sum\n        val decimalOnesZerosZerosZerosZerosZerosZeros\
    \ = arr.map(x => math.log10(math.pow(x, 2))).filter(x => x == 1 && x == 0 && x\
    \ == 0 && x == 0 && x == 0 && x == 0 && x == 0).sum\n        val decimalOnesZerosZerosZerosZerosZerosZerosZeros\
    \ = arr.map(x => math.log10(math.pow(x, 2))).filter(x => x == 1 && x == 0 && x\
    \ == 0 && x == 0 && x == 0 && x == 0 && x == 0 && x == 0).sum\n        val decimalOnesZerosZerosZerosZerosZerosZerosZerosZeros\
    \ = arr.map(x => math.log10(math.pow(x, 2))).filter(x => x == 1 && x == 0 && x\
    \ == 0 && x == 0 && x == 0 && x == 0 && x == 0 && x == 0).sum\n        val decimalOnesZerosZerosZerosZerosZerosZerosZerosZerosZeros\
    \ = arr.map(x => math.log10(math.pow(x, 2))).filter(x => x == 1 && x == 0 && x\
    \ == 0 && x == 0 && x == 0 && x == 0 && x == 0 && \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpvjcia9ic.scala:22:193 --------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mdecimalOnesZerosZerosZerosZerosZerosZerosZerosZerosZeros\e\
    [0m = arr.map(\e[36mx\e[0m => math.log10(math.pow(x, \e[31m2\e[0m))).filter(\e\
    [36mx\e[0m => x == \e[31m1\e[0m && x == \e[31m0\e[0m && x == \e[31m0\e[0m && x\
    \ == \e[31m0\e[0m && x == \e[31m0\e[0m && x == \e[31m0\e[0m && x == \e[31m0\e\
    [0m && \n\e[31m\e[31m   |\e[0m                                               \
    \                                                                            \
    \                                                                      ^\e[0m\n\
    \e[31m   |\e[0m                                       expression expected but\
    \ \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvjcia9ic.scala:23:5\
    \ ---------------------\e[0m\e[0m\n\e[31m23 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660008809
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(x => x % 2 == 0).size\n        val twos =\
    \ arr.filter(x => x % 2 == 1).size\n        val threes = arr.filter(x => x % 3\
    \ == 0).size\n        val fours = arr.filter(x => x % 4 == 0).size\n        val\
    \ fives = arr.filter(x => x % 5 == 0).size\n        val sixes = arr.filter(x =>\
    \ x % 6 == 0).size\n        val sevens = arr.filter(x => x % 7 == 0).size\n  \
    \      val eights = arr.filter(x => x % 8 == 0).size\n        val nines = arr.filter(x\
    \ => x % 9 == 0).size\n        val tens = arr.filter(x => x % 10 == 0).size\n\
    \        val hundreds = arr.filter(x => x % 100 == 0).size\n        val thousands\
    \ = arr.filter(x => x % 1000 == 0).size\n        val millions = arr.filter(x =>\
    \ x % 1000000 == 0).size\n        val billions = arr.filter(x => x % 1000000000\
    \ == 0).size\n        val trillions = arr.filter(x => x % 1000000000000 == 0).size\n\
    \        val quadrillions = arr.filter(x => x % 1000000000000000 == 0).size\n\
    \        val quintillions = arr.filter(x => x % 1000000000000000000 == 0).size\n\
    \        val onesAndZeros = arr.filter(x => x == 1).size\n        val onesAndOnes\
    \ = arr.filter(x => x == 1).size\n        val onesAndTwos = arr.filter(x => x\
    \ == 1).size\n        val onesAndThrees = arr.filter(x => x == 1).size\n     \
    \   val onesAndFours = arr.filter(x => x == 1).size\n        val onesAndFives\
    \ = arr.filter(x => x == 1).size\n        val onesAndSixes = arr.filter(x => x\
    \ == 1).size\n        val onesAndSevens = arr.filter(x => x == 1).size\n     \
    \   val onesAndEights = arr.filter(x => x == 1).size\n        val onesAndNines\
    \ = arr.filter(x => x == 1).size\n        val onesAndTens = arr.filter(x => x\
    \ == 1).size\n        val onesAndHundreds = arr.filter(x => x == 1).size\n   \
    \     val onesAndThousands = arr.filter(x => x == 1).size\n        val onesAndMillions\
    \ = arr.filter(x => x == 1).size\n        val onesAndBillions = arr.filter(x =>\
    \ x == 1).size\n        val onesAndTrillions = arr.filter(x => x == 1).\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptvuwvvyi.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmptvuwvvyi.scala:23:44\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m23 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.filter(\e[36mx\e[0m => x % \e[31m1000000000000\e\
    [0m == \e[31m0\e[0m).size\n\e[31m\e[31m   |\e[0m                             \
    \               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \                  number too large\n\e[31m\e[31m-- Error: /tmp/tmptvuwvvyi.scala:24:47\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m24 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.filter(\e[36mx\e[0m => x % \e[31m1000000000000000\e\
    [0m == \e[31m0\e[0m).size\n\e[31m\e[31m   |\e[0m                             \
    \                  ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \                           number too large\n\e[31m\e[31m-- Error: /tmp/tmptvuwvvyi.scala:25:47\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m25 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquintillions\e[0m = arr.filter(\e[36mx\e[0m => x % \e[31m1000000000000000000\e\
    [0m == \e[31m0\e[0m).size\n\e[31m\e[31m   |\e[0m                             \
    \                  ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                              number too large\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmptvuwvvyi.scala:42:5 ---------------------\e[0m\e[0m\n\e[31m42\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660008810
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decs = arr.map(_.toString.toInt)\n\
    \        val sorted = decs.sortBy(_.toInt)\n        val sorted = sorted.sortBy(_.toInt)\n\
    \        val sorted = sorted.sortBy(_.toInt)\n        val sorted = sorted.sortBy(_.toInt)\n\
    \        val sorted = sorted.sortBy(_.toInt)\n        val sorted = sorted.sortBy(_.toInt)\n\
    \        val sorted = sorted.sortBy(_.toInt)\n        val sorted = sorted.sortBy(_.toInt)\n\
    \        val sorted = sorted.sortBy(_.toInt)\n        val sorted = sorted.sortBy(_.toInt)\n\
    \        val sorted = sorted.sortBy(_.toInt)\n        val sorted = sorted.sortBy(_.toInt)\n\
    \        val sorted = sorted.sortBy(_.toInt)\n        val sorted = sorted.sortBy(_.toInt)\n\
    \        val sorted = sorted.sortBy(_.toInt)\n        val sorted = sorted.sortBy(_.toInt)\n\
    \        val sorted = sorted.sortBy(_.toInt)\n        val sorted = sorted.sortBy(_.toInt)\n\
    \        val sorted = sorted.sortBy(_.toInt)\n        val sorted = sorted.sortBy(_.toInt)\n\
    \        val sorted = sorted.sortBy(_.toInt)\n        val sorted = sorted.sortBy(_.toInt)\n\
    \        val sorted = sorted.sortBy(_.toInt)\n        val sorted = sorted.sortBy(_.toInt)\n\
    \        val sorted = sorted.sortBy(_.toInt)\n        val sorted = sorted.sortBy(_.toInt)\n\
    \        val sorted = sorted.sortBy(_.toInt)\n        val sorted = sorted.sortBy(_.toInt)\n\
    \        val sorted = sorted.sortBy(_.toInt)\n        val sorted = sorted.sortBy(_.toInt)\n\
    \        val sorted = sorted.sortBy(_.toInt)\n        val sorted = sorted.sortBy(_.toInt)\n\
    \        val sorted = sorted.sortBy(_.toInt)\n        val sorted = sorted.sortBy(_.toInt)\n\
    \        val sorted = sorted.sortBy(_.toInt)\n        val sorted = sorted.sortBy(_.toInt)\n\
    \        val sorted = sorted.sortBy(_.toInt)\n        val sorted = sorted.sortBy(\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpsej9k0bq.scala:48:35 ---------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = sorted.sortBy(\n\
    \e[31m\e[31m   |\e[0m                                   ^\e[0m\n\e[31m   |\e[0m\
    \                                   expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsej9k0bq.scala:12:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36msorted\e[0m = sorted.sortBy(_.toInt)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msorted is already defined as \e[33mvalue\e[0m \e[35msorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpsej9k0bq.scala:13:12 ---------------------------\e[0m\e[0m\n\e\
    [31m13 |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = sorted.sortBy(_.toInt)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msorted is already defined as \e[33mvalue\e[0m \e[35msorted\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpsej9k0bq.scala:14:12 ---------------------------\e[0m\e[0m\n\e[31m14\
    \ |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = sorted.sortBy(_.toInt)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0msorted is already defined as \e[33mvalue\e[0m \e[35msorted\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpsej9k0bq.scala:15:12 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = sorted.sortBy(_.toInt)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0msorted is already defined as \e[33mvalue\e[0m \e[35msorted\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that o"
  stdout: ''
  timestamp: 1660008811
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ % 2 == 0)\n        val sortedArray = arr.sortBy(x => (ones - x) / decimals)\n\
    \        sortedArray\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmykoipcj.scala:15)\n\tat Problem.main(tmpmykoipcj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660008814
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ % 2 == 0)\n        val onesDecimals = ones * decimals\n        val onesDecimalsSorted\
    \ = arr.sortBy(_ / onesDecimals)\n        onesDecimalsSorted.reverse\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp53s8xz3b.scala:16)\n\tat Problem.main(tmp53s8xz3b.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660008815
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ < 0)\n        val onesDecimals = ones * decimals\n        val onesDecimalsSortedList\
    \ = arr.sortBy(_ / onesDecimals)\n        onesDecimalsSortedList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArithmeticException: / by zero\n\tat Problem$.$anonfun$3(tmp14a7r0b8.scala:12)\n\
    \tat scala.runtime.java8.JFunction1$mcJJ$sp.apply(JFunction1$mcJJ$sp.scala:17)\n\
    \tat scala.math.Ordering$$anon$1.compare(Ordering.scala:141)\n\tat java.base/java.util.TimSort.countRunAndMakeAscending(TimSort.java:355)\n\
    \tat java.base/java.util.TimSort.sort(TimSort.java:220)\n\tat java.base/java.util.Arrays.sort(Arrays.java:1233)\n\
    \tat scala.collection.SeqOps.sorted(Seq.scala:700)\n\tat scala.collection.SeqOps.sorted$(Seq.scala:692)\n\
    \tat scala.collection.immutable.List.scala$collection$immutable$StrictOptimizedSeqOps$$super$sorted(List.scala:79)\n\
    \tat scala.collection.immutable.StrictOptimizedSeqOps.sorted(StrictOptimizedSeqOps.scala:78)\n\
    \tat scala.collection.immutable.StrictOptimizedSeqOps.sorted$(StrictOptimizedSeqOps.scala:78)\n\
    \tat scala.collection.immutable.List.sorted(List.scala:79)\n\tat scala.collection.SeqOps.sortBy(Seq.scala:754)\n\
    \tat scala.collection.SeqOps.sortBy$(Seq.scala:754)\n\tat scala.collection.AbstractSeq.sortBy(Seq.scala:1161)\n\
    \tat Problem$.sortArray(tmp14a7r0b8.scala:12)\n\tat Problem$.main(tmp14a7r0b8.scala:16)\n\
    \tat Problem.main(tmp14a7r0b8.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(Obje"
  stdout: ''
  timestamp: 1660008819
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val zeros = arr.count(_ ==\
    \ 0)\n        val onesArr = arr.filter(_ == 1).sorted\n        val zerosArr =\
    \ arr.filter(_ == 0).sorted\n        val onesCount = onesArr.count(_ == 1)\n \
    \       val zerosCount = zerosArr.count(_ == 0)\n        val onesDecimal = onesArr.count(_\
    \ == 1) / (onesArr.count(_ == 1) + zerosArr.count(_ == 0))\n        val zerosDecimal\
    \ = zerosArr.count(_ == 0) / (onesArr.count(_ == 1) + zerosArr.count(_ == 0))\n\
    \        val onesDecimalDecimal = onesArr.count(_ == 1) / (onesArr.count(_ ==\
    \ 1) + zerosArr.count(_ == 0))\n        val zerosDecimalDecimal = zerosArr.count(_\
    \ == 0) / (onesArr.count(_ == 1) + zerosArr.count(_ == 0))\n        val onesDecimalDecimalDecimal\
    \ = onesArr.count(_ == 1) / (onesArr.count(_ == 1) + zerosArr.count(_ == 0))\n\
    \        val zerosDecimalDecimalDecimal = zerosArr.count(_ == 0) / (onesArr.count(_\
    \ == 1) + zerosArr.count(_ == 0))\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesArr.count(_ == 1) / (onesArr.count(_ == 1) + zerosArr.count(_ == 0))\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosArr.count(_ == 0) / (onesArr.count(_\
    \ == 1) + zerosArr.count(_ == 0))\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesArr.count(_ == 1) / (onesArr.count(_ == 1) + zerosArr.count(_ == 0))\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimal = zerosArr.count(_ == 0)\
    \ / (onesArr.count(_ == 1) + zerosArr.count(_ == 0))\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesArr.count(_ == 1) / (onesArr.count(_ == 1) + zerosArr.count(_ == 0))\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosArr.count(_\
    \ == 0) / (onesArr.count(_ == 1) + zerosArr.count(_ == 0))\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesArr.count(_ == 1) / (onesArr.count(_ == 1) + zerosArr.count(_ == 0))\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosArr.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppianynpc.scala:29:4 ----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmppianynpc.scala:29:5 ---------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660008817
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ > 0)\n        val onesDecimal = arr.count(_ == 1)/arr.count(_ > 0)\n       \
    \ val decimalsDecimal = decimals/arr.count(_ > 0)\n        val onesDecimalDecimal\
    \ = onesDecimal/decimals\n        val decimalsDecimalDecimal = decimalsDecimal/onesDecimal\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal/decimalsDecimal\n\
    \        val decimalsDecimalDecimalDecimal = decimalsDecimalDecimal/onesDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal/decimalsDecimalDecimal\n\
    \        val decimalsDecimalDecimalDecimalDecimal = decimalsDecimalDecimalDecimal/onesDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal/decimalsDecimalDecimalDecimal\n\
    \        val decimalsDecimalDecimalDecimalDecimalDecimal = decimalsDecimalDecimalDecimalDecimal/onesDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal/decimalsDecimalDecimalDecimalDecimal\n\
    \        val decimalsDecimalDecimalDecimalDecimalDecimalDecimal = decimalsDecimalDecimalDecimalDecimalDecimal/onesDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal/decimalsDecimalDecimalDecimalDecimalDecimal\n\
    \        val decimalsDecimalDecimalDecimalDecimalDecimalDecimal = decimalsDecimalDecimalDecimalDecimalDecimalDecimal/onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal/decimalsDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal = decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal/onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal/decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal = decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal/onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal/decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal = decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal/onesDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprwa21akr.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mdecimalsDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = decimalsDecimalDecimalDecimalDecimalDecimalDecimal/onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalsDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mdecimalsDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmprwa21akr.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal/decimalsDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmprwa21akr.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36mdecimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal/onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660008816
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        // Your code goes here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0_8sc31z.scala:8:51\
    \ ---------------------\e[0m\e[0m\n\e[31m 8 |\e[0m    \e[33mdef\e[0m \e[36msortArray\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m]) : \e[35mList\e[0m[\e[35mLong\e\
    [0m] = {\n\e[31m\e[31m   |\e[0m                                              \
    \     ^\e[0m\n\e[31m   |\e[0m                                                \
    \   Found:    Unit\n\e[31m   |\e[0m                                          \
    \         Required: List[Long]\n\e[31m 9 |\e[0m        \e[34m// Your code goes\
    \ here\e[0m\n\e[31m10 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660008788
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        // Your code here\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl8olg31u.scala:8:51\
    \ ---------------------\e[0m\e[0m\n\e[31m 8 |\e[0m    \e[33mdef\e[0m \e[36msortArray\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m]) : \e[35mList\e[0m[\e[35mLong\e\
    [0m] = {\n\e[31m\e[31m   |\e[0m                                              \
    \     ^\e[0m\n\e[31m   |\e[0m                                                \
    \   Found:    Unit\n\e[31m   |\e[0m                                          \
    \         Required: List[Long]\n\e[31m 9 |\e[0m        \e[34m// Your code here\e\
    [0m\n\e[31m10 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660008686
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val zeros = arr.count(_ ==\
    \ 0)\n        val onesDecimal = ones * 10\n        val zerosDecimal = zeros *\
    \ 10\n        val onesDecimalDecimal = onesDecimal * onesDecimal\n        val\
    \ zerosDecimalDecimal = zerosDecimal * zerosDecimal\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal * onesDecimalDecimal\n        val zerosDecimalDecimalDecimal\
    \ = zerosDecimalDecimal * zerosDecimalDecimal\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimal * onesDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal * zerosDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal * onesDecimalDecimalDecimalDecimal\n    \
    \    val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ * zerosDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal * onesDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ * zerosDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal * onesDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ * zerosDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal * onesDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ * zerosDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal * onesDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ * zerosDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal * onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * zerosDecimalDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal * onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ * zerosDecimalDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0qqc7wdz.scala:34:4 ----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0qqc7wdz.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimal\
    \ * zerosDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimal is already defined as \e\
    [33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimal\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0qqc7wdz.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesDecimalDecimalDecimalDecimalDecimal\e[0m = onesDecimalDecimalDecimalDecimalDecimal\
    \ * onesDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimal is already defined\
    \ as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimal\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp0qqc7wdz.scala:24:12 ---------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimal * zerosDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimal is already defined\
    \ as \e[33mvalue\e[0m \e[35mzerosDecimalDecim"
  stdout: ''
  timestamp: 1660008817
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(x => x % 2 == 0).length\n        val twos\
    \ = arr.filter(x => x % 2 == 1).length\n        val decimal = arr.map(x => math.pow(2,x)).sum\n\
    \        val result = arr.sortBy(x => math.pow(2,x)).sortBy(x => math.pow(2,x)\
    \ / decimal)\n        result\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpth1w1kla.scala:16)\n\tat Problem.main(tmpth1w1kla.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660008822
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(x => x % 2 == 0).size\n        val twos =\
    \ arr.filter(x => x % 2 == 1).size\n        val threes = arr.filter(x => x % 3\
    \ == 0).size\n        val fours = arr.filter(x => x % 4 == 0).size\n        val\
    \ fives = arr.filter(x => x % 5 == 0).size\n        val sixes = arr.filter(x =>\
    \ x % 6 == 0).size\n        val sevens = arr.filter(x => x % 7 == 0).size\n  \
    \      val eights = arr.filter(x => x % 8 == 0).size\n        val nines = arr.filter(x\
    \ => x % 9 == 0).size\n        val tens = arr.filter(x => x % 10 == 0).size\n\
    \        val hundreds = arr.filter(x => x % 100 == 0).size\n        val thousands\
    \ = arr.filter(x => x % 1000 == 0).size\n        val tenThousands = arr.filter(x\
    \ => x % 10000 == 0).size\n        val oneThousands = arr.filter(x => x % 100000\
    \ == 0).size\n        val oneHundreds = arr.filter(x => x % 1000000 == 0).size\n\
    \        val oneThousandHundreds = arr.filter(x => x % 10000000 == 0).size\n \
    \       val oneThousandThousandHundreds = arr.filter(x => x % 100000000 == 0).size\n\
    \        val oneThousandThousandThousandHundreds = arr.filter(x => x % 1000000000\
    \ == 0).size\n        val oneThousandThousandThousandThousandHundreds = arr.filter(x\
    \ => x % 10000000000 == 0).size\n        val oneThousandThousandThousandThousandThousandHundreds\
    \ = arr.filter(x => x % 100000000000 == 0).size\n        val oneThousandThousandThousandThousandThousandHundreds\
    \ = arr.filter(x => x % 1000000000000 == 0).size\n        val oneThousandThousandThousandThousandThousandThousandHundreds\
    \ = arr.filter(x => x % 10000000000000 == 0).size\n        val oneThousandThousandThousandThousandThousandThousandHundreds\
    \ = arr.filter(x => x % 100000000000000 == 0).size\n        val oneThousandThousandThousandThousandThousandThousandThousand\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpobo24gdi.scala:33:4 ----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpobo24gdi.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36moneThousandThousandThousandThousandThousandHundreds\e[0m = arr.filter(\e\
    [36mx\e[0m => x % \e[31m1000000000000\e[0m == \e[31m0\e[0m).size\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moneThousandThousandThousandThousandThousandHundreds is already\
    \ defined as \e[33mvalue\e[0m \e[35moneThousandThousandThousandThousandThousandHundreds\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpobo24gdi.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36moneThousandThousandThousandThousandThousandThousandHundreds\e\
    [0m = arr.filter(\e[36mx\e[0m => x % \e[31m100000000000000\e[0m == \e[31m0\e[0m).size\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moneThousandThousandThousandThousandThousandThousandHundreds\
    \ is already defined as \e[33mvalue\e[0m \e[35moneThousandThousandThousandThousandThousandThousandHundreds\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- Error: /tmp/tmpobo24gdi.scala:27:78\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m27 |\e[0m       \
    \ \e[33mval\e[0m \e[36moneThousandThousandThousandThousandHundreds\e[0m = arr.filter(\e\
    [36mx\e[0m => x % \e[31m10000000000\e[0m == \e[31m0\e[0m).size\n\e[31m\e[31m \
    \  |\e[0m                                                                    \
    \          ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                 \
    \                       number too large\n\e"
  stdout: ''
  timestamp: 1660008817
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ > 0)\n        val onesDecimals = ones * decimals\n        val onesDecimalsSorted\
    \ = arr.sortBy(_ / onesDecimals)\n        onesDecimalsSorted.reverse\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp67h2p2r4.scala:16)\n\tat Problem.main(tmp67h2p2r4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660008822
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ == 0)\n        val onesDecimal = ones * 10\n        val decimalsDecimal = decimals\
    \ * 10\n        val onesDecimals = onesDecimal.toInt\n        val decimalsDecimals\
    \ = decimalsDecimal.toInt\n        arr.sortWith(x => (onesDecimals - x.toInt))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpramxyztu.scala:15:23 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        arr.sortWith(\e[36mx\e[0m => (onesDecimals -\
    \ x.toInt))\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Wrong number of parameters, expected:\
    \ 2\n1 error found\n"
  stdout: ''
  timestamp: 1660008812
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(x => x == 1)\n        val decs = arr.map(x\
    \ => math.abs(x - math.floor(x / math.pow(2, math.ceil(math.log(x, 2))))).toInt)\n\
    \        val sorted = decs.sortWith((x, y) => x < y)\n        val result = sorted.map(x\
    \ => if (ones == 0) x else x + ones)\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb_ykv9xr.scala:10:91\
    \ --------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mdecs\e\
    [0m = arr.map(\e[36mx\e[0m => math.abs(x - math.floor(x / math.pow(\e[31m2\e[0m,\
    \ math.ceil(math.log(x, \e[31m2\e[0m))))).toInt)\n\e[31m\e[31m   |\e[0m      \
    \                                                                            \
    \         ^^^^\e[0m\n\e[31m   |\e[0m                                         \
    \          Found:    (Long, Int)\n\e[31m   |\e[0m                            \
    \                       Required: Double\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpb_ykv9xr.scala:13:8 ---------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m        result\n\e[31m\e[31m   |\e[0m        ^^^^^^\e[0m\n\
    \e[31m   |\e[0m        Found:    (result : List[Int])\n\e[31m   |\e[0m       \
    \ Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660008821
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(x => x % 2 == 0).length\n        val twos\
    \ = arr.filter(x => x % 2 == 1).length\n        val decimals = arr.map(x => math.log10(x)).sum\n\
    \        val sorted = arr.sortBy(x => math.log10(x/10)).sortBy(x => x/10).sortBy(x\
    \ => x/10).sortBy(x => x/10).sortBy(x => x/10).sortBy(x => x/10).sortBy(x => x/10).sortBy(x\
    \ => x/10).sortBy(x => x/10).sortBy(x => x/10).sortBy(x => x/10).sortBy(x => x/10).sortBy(x\
    \ => x/10).sortBy(x => x/10).sortBy(x => x/10).sortBy(x => x/10).sortBy(x => x/10).sortBy(x\
    \ => x/10).sortBy(x => x/10).sortBy(x => x/10).sortBy(x => x/10).sortBy(x => x/10).sortBy(x\
    \ => x/10).sortBy(x => x/10).sortBy(x => x/10).sortBy(x => x/10).sortBy(x => x/10).sortBy(x\
    \ => x/10).sortBy(x => x/10).sortBy(x => x/10).sortBy(x => x/10).sortBy(x => x/10).sortBy(x\
    \ => x/10).sortBy(x => x/10).sortBy(x => x/10).sortBy(x => x/10).sortBy(x => x/10).sortBy(x\
    \ => x/10).sortBy(x => x/10).sortBy(x => x/10).sortBy(x => x/10).sortBy(x => x/10).sortBy(x\
    \ => x/10).sortBy(x => x/10).sortBy(x => x/10).sortBy(x => x/10).sortBy(x => x/10).sortBy(x\
    \ => x/10).sortBy(x => x/10).sortBy(x => x/10).sortBy(x => x/10).sortBy(x => x/10).sortBy(x\
    \ => x/10).sortBy(x => x/10).sortBy(x => x/10).sortBy(x => x/10).sortBy(x => x/10).sortBy(x\
    \ => x/10).sortBy(x => x/10).sortBy(x => x/10).sortBy(x => x/10).sortBy(x => x/10).sortBy(x\
    \ => x/10).sortBy(x => x/10).sortBy(x => x/10).sortBy(x => x/10).\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpcqme_kzy.scala:13:4 ----------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpcqme_kzy.scala:13:5 ---------------------\e[0m\e[0m\n\e[31m13\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660008821
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val zeros = arr.count(_ ==\
    \ 0)\n        val onesDec = arr.map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val zerosDec = arr.map(_.toString.toInt).sortBy(_.toString.toInt)\n \
    \       val onesDec = onesDec.take(ones)\n        val zerosDec = zerosDec.take(zeros)\n\
    \        val onesDec = onesDec.zip(zerosDec)\n        val zerosDec = zerosDec.zip(onesDec)\n\
    \        val onesDec = onesDec.map(x => x._1 - x._2)\n        val zerosDec = zerosDec.map(x\
    \ => x._1 - x._2)\n        val onesDec = onesDec.map(x => x.toLong)\n        val\
    \ zerosDec = zerosDec.map(x => x.toLong)\n        val onesDec = onesDec.sortBy(x\
    \ => x)\n        val zerosDec = zerosDec.sortBy(x => x)\n        val onesDec =\
    \ onesDec.take(ones)\n        val zerosDec = zerosDec.take(zeros)\n        val\
    \ onesDec = onesDec.zip(zerosDec)\n        val zerosDec = zerosDec.zip(onesDec)\n\
    \        val onesDec = onesDec.map(x => x._1 - x._2)\n        val zerosDec = zerosDec.map(x\
    \ => x._1 - x._2)\n        val onesDec = onesDec.map(x => x.toLong)\n        val\
    \ zerosDec = zerosDec.map(x => x.toLong)\n        val onesDec = onesDec.sortBy(x\
    \ => x)\n        val zerosDec = zerosDec.sortBy(x => x)\n        val onesDec =\
    \ onesDec.take(ones)\n        val zerosDec = zerosDec.take(zeros)\n        val\
    \ onesDec = onesDec.zip(zerosDec)\n        val zerosDec = zerosDec.zip(onesDec)\n\
    \        val onesDec = onesDec.map(x => x._1 - x._2)\n        val zerosDec = zerosDec.map(x\
    \ => x._1 - x._2)\n        val onesDec = onesDec.map(x => x.toLong)\n        val\
    \ zerosDec = zerosDec.map(x => x.toLong)\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpy7vw5dwq.scala:13:12 ---------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36monesDec\e[0m = onesDec.take(ones)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0monesDec is already defined as \e[33mvalue\e[0m \e[35monesDec\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpy7vw5dwq.scala:14:12 ---------------------------\e[0m\e[0m\n\e[31m14\
    \ |\e[0m        \e[33mval\e[0m \e[36mzerosDec\e[0m = zerosDec.take(zeros)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mzerosDec is already defined as \e[33mvalue\e[0m \e[35mzerosDec\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpy7vw5dwq.scala:15:12 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36monesDec\e[0m = onesDec.zip(zerosDec)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0monesDec is already defined as \e[33mvalue\e[0m \e[35monesDec\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpy7vw5dwq.scala:16:12 ---------------------------\e[0m\e[0m\n\e[31m16\
    \ |\e[0m        \e[33mval\e[0m \e[36mzerosDec\e[0m = zerosDec.zip(onesDec)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mzerosDec is already defined as \e[33mvalue\e[0m \e[35mzerosDec\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpy7vw5dwq.scala:17:12 ---------------------------\e[0m\e[0m\n\e[31m17\
    \ |\e[0m        \e[33mval\e[0m \e[36monesDec\e[0m = onesDec.map(\e[36mx\e[0m =>\
    \ x._1 - x._2)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDec is already defined as \e[33mval"
  stdout: ''
  timestamp: 1660008822
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ == 0)\n        val onesDecimals = ones * decimals\n        val onesDecimalsSorted\
    \ = arr.sortBy(_ / onesDecimals)\n        onesDecimalsSorted.reverse\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArithmeticException: / by zero\n\tat Problem$.$anonfun$3(tmpsei11f01.scala:12)\n\
    \tat scala.runtime.java8.JFunction1$mcJJ$sp.apply(JFunction1$mcJJ$sp.scala:17)\n\
    \tat scala.math.Ordering$$anon$1.compare(Ordering.scala:141)\n\tat java.base/java.util.TimSort.countRunAndMakeAscending(TimSort.java:355)\n\
    \tat java.base/java.util.TimSort.sort(TimSort.java:220)\n\tat java.base/java.util.Arrays.sort(Arrays.java:1233)\n\
    \tat scala.collection.SeqOps.sorted(Seq.scala:700)\n\tat scala.collection.SeqOps.sorted$(Seq.scala:692)\n\
    \tat scala.collection.immutable.List.scala$collection$immutable$StrictOptimizedSeqOps$$super$sorted(List.scala:79)\n\
    \tat scala.collection.immutable.StrictOptimizedSeqOps.sorted(StrictOptimizedSeqOps.scala:78)\n\
    \tat scala.collection.immutable.StrictOptimizedSeqOps.sorted$(StrictOptimizedSeqOps.scala:78)\n\
    \tat scala.collection.immutable.List.sorted(List.scala:79)\n\tat scala.collection.SeqOps.sortBy(Seq.scala:754)\n\
    \tat scala.collection.SeqOps.sortBy$(Seq.scala:754)\n\tat scala.collection.AbstractSeq.sortBy(Seq.scala:1161)\n\
    \tat Problem$.sortArray(tmpsei11f01.scala:12)\n\tat Problem$.main(tmpsei11f01.scala:16)\n\
    \tat Problem.main(tmpsei11f01.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(Obje"
  stdout: ''
  timestamp: 1660008689
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ == 0)\n        val onesDecimal = ones * 10\n        val decimalsDecimal = decimals\
    \ * 10\n        val decimalsDecimals = decimalsDecimal + onesDecimal\n       \
    \ val decimalsDecimalsDecimal = decimalsDecimals * 10\n        val decimalsDecimalsDecimals\
    \ = decimalsDecimalsDecimal + onesDecimal\n        val decimalsDecimalsDecimalsDecimal\
    \ = decimalsDecimalsDecimals * 10\n        val decimalsDecimalsDecimalsDecimals\
    \ = decimalsDecimalsDecimalsDecimal + onesDecimal\n        val decimalsDecimalsDecimalsDecimalsDecimal\
    \ = decimalsDecimalsDecimalsDecimals * 10\n        val decimalsDecimalsDecimalsDecimalsDecimals\
    \ = decimalsDecimalsDecimalsDecimalsDecimal + onesDecimal\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimal\
    \ = decimalsDecimalsDecimalsDecimalsDecimals * 10\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = decimalsDecimalsDecimalsDecimalsDecimalsDecimal + onesDecimal\n        val\
    \ decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimal = decimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ * 10\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals =\
    \ decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimal + onesDecimal\n    \
    \    val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimal = decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ * 10\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimal + onesDecimal\n\
    \        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimal\
    \ = decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals * 10\n  \
    \      val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimal +\
    \ onesDecimal\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimal\
    \ = decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ * \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp6ym7gn6d.scala:28:176 --------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mdecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimal\e\
    [0m = decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ * \n\e[31m\e[31m   |\e[0m                                                  \
    \                                                                            \
    \                                                  ^\e[0m\n\e[31m   |\e[0m   \
    \                                    expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6ym7gn6d.scala:28:94\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mdecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimal\e\
    [0m = decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ * \n\e[31m\e[31m   |\e[0m                                                  \
    \                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6ym7gn6d.scala:29:5\
    \ ---------------------\e[0m\e[0m\n\e[31m29 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660008819
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(x => x % 2 == 0).length\n        val decs\
    \ = arr.filter(x => x % 2 == 1).map(_.toString.toDouble).sorted\n        val result\
    \ = decs.zip(ones).sortBy(_._1).map(x => x._2).reverse\n        result.map(x =>\
    \ if (x == 0) 0 else x)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6lzu4xjh.scala:11:30\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e\
    [0m = decs.zip(ones).sortBy(_._1).map(\e[36mx\e[0m => x._2).reverse\n\e[31m\e\
    [31m   |\e[0m                              ^^^^\e[0m\n\e[31m   |\e[0m        \
    \                      Found:    (ones : Int)\n\e[31m   |\e[0m               \
    \               Required: IterableOnce[Any]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660008821
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        // Your code goes here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0_8sc31z.scala:8:51\
    \ ---------------------\e[0m\e[0m\n\e[31m 8 |\e[0m    \e[33mdef\e[0m \e[36msortArray\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m]) : \e[35mList\e[0m[\e[35mLong\e\
    [0m] = {\n\e[31m\e[31m   |\e[0m                                              \
    \     ^\e[0m\n\e[31m   |\e[0m                                                \
    \   Found:    Unit\n\e[31m   |\e[0m                                          \
    \         Required: List[Long]\n\e[31m 9 |\e[0m        \e[34m// Your code goes\
    \ here\e[0m\n\e[31m10 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660008788
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val twos = arr.count(_ ==\
    \ 2)\n        val threes = arr.count(_ == 3)\n        val fours = arr.count(_\
    \ == 4)\n        val fives = arr.count(_ == 5)\n        val sixes = arr.count(_\
    \ == 6)\n        val sevens = arr.count(_ == 7)\n        val eights = arr.count(_\
    \ == 8)\n        val nines = arr.count(_ == 9)\n        val tens = arr.count(_\
    \ == 10)\n        val hundreds = arr.count(_ == 100)\n        val thousands =\
    \ arr.count(_ == 1000)\n        val millions = arr.count(_ == 1000000)\n     \
    \   val billions = arr.count(_ == 1000000000)\n        val trillions = arr.count(_\
    \ == 1000000000000)\n        val quadrillions = arr.count(_ == 1000000000000000)\n\
    \        val quintillions = arr.count(_ == 1000000000000000000)\n        val onesAndZeros\
    \ = arr.count(_ == 1 && _ == 0)\n        val onesAndOnes = arr.count(_ == 1 &&\
    \ _ == 1)\n        val onesAndTwos = arr.count(_ == 1 && _ == 2)\n        val\
    \ onesAndThrees = arr.count(_ == 1 && _ == 3)\n        val onesAndFours = arr.count(_\
    \ == 1 && _ == 4)\n        val onesAndFives = arr.count(_ == 1 && _ == 5)\n  \
    \      val onesAndSixes = arr.count(_ == 1 && _ == 6)\n        val onesAndSevens\
    \ = arr.count(_ == 1 && _ == 7)\n        val onesAndEights = arr.count(_ == 1\
    \ && _ == 8)\n        val onesAndNines = arr.count(_ == 1 && _ == 9)\n       \
    \ val onesAndTens = arr.count(_ == 1 && _ == 10)\n        val onesAndHundreds\
    \ = arr.count(_ == 1 && _ == 100)\n        val onesAndThousands = arr.count(_\
    \ == 1 && _ == 1000)\n        val onesAndMillions = arr.count(_ == 1 && _ == 1000000)\n\
    \        val onesAndBillions = arr.count(_ == 1 && _ == 1000000000)\n        val\
    \ onesAndTrillions = arr.count(_ == 1 && _ == 1000000000000)\n        val onesAndQuadrillions\
    \ = arr.count(_ == 1 && _ == 1000000000000000)\n        val onesAndQuintillions\
    \ = arr.count(_ == 1 && _ == 1000000000000000000)\n        val onesAndOnesAndZeros\
    \ = arr.count(_ == 1 && \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmppmcvho8c.scala:44:53 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36monesAndOnesAndZeros\e[0m\
    \ = arr.count(_ == \e[31m1\e[0m && \n\e[31m\e[31m   |\e[0m                   \
    \                                  ^\e[0m\n\e[31m   |\e[0m                   \
    \                    expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmppmcvho8c.scala:23:39 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mtrillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000\e[0m)\n\e[31m\e[31m   |\e[0m                        \
    \               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \             number too large\n\e[31m\e[31m-- Error: /tmp/tmppmcvho8c.scala:24:42\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m24 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.count(_ == \e[31m1000000000000000\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                          ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                          number too large\n\
    \e[31m\e[31m-- Error: /tmp/tmppmcvho8c.scala:25:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mquintillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m                  \
    \                        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                               number too large\n\e[31m\e[31m-- [E086] Syntax\
    \ Error: /tmp/tmppmcvho8c.scala:26:37 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36monesAndZeros\e[0m = arr.count(_ == \e\
    [31m1\e[0m && _ == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                      \
    \               ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \          Wrong number of parameters, expected: 1\n\e[31m\e[31m-- [E086] Syntax\
    \ Error: /tmp/tmppmcvho8c.scala:27:36 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36monesAndOnes\e[0m = arr.count(_ == \e\
    [31m1\e[0m "
  stdout: ''
  timestamp: 1660008688
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(x => x % 2 == 1).length\n        val zeros\
    \ = arr.filter(x => x % 2 == 0).length\n        val onesZeros = ones + zeros\n\
    \        val onesZero = onesZeros / 2\n        val onesZeros = onesZero / 2\n\
    \        val onesZero = onesZero % 2\n        val onesZeros = onesZeros % 2\n\
    \        val onesZeros = onesZeros % 2\n        val onesZeros = onesZeros % 2\n\
    \        val onesZeros = onesZeros % 2\n        val onesZeros = onesZeros % 2\n\
    \        val onesZeros = onesZeros % 2\n        val onesZeros = onesZeros % 2\n\
    \        val onesZeros = onesZeros % 2\n        val onesZeros = onesZeros % 2\n\
    \        val onesZeros = onesZeros % 2\n        val onesZeros = onesZeros % 2\n\
    \        val onesZeros = onesZeros % 2\n        val onesZeros = onesZeros % 2\n\
    \        val onesZeros = onesZeros % 2\n        val onesZeros = onesZeros % 2\n\
    \        val onesZeros = onesZeros % 2\n        val onesZeros = onesZeros % 2\n\
    \        val onesZeros = onesZeros % 2\n        val onesZeros = onesZeros % 2\n\
    \        val onesZeros = onesZeros % 2\n        val onesZeros = onesZeros % 2\n\
    \        val onesZeros = onesZeros % 2\n        val onesZeros = onesZeros % 2\n\
    \        val onesZeros = onesZeros % 2\n        val onesZeros = onesZeros % 2\n\
    \        val onesZeros = onesZeros % 2\n        val onesZeros = onesZeros % 2\n\
    \        val onesZeros = onesZeros % 2\n        val onesZeros = onesZeros % 2\n\
    \        val onesZeros = onesZeros % 2\n        val onesZeros = onesZeros % 2\n\
    \        val onesZeros = onesZeros % 2\n        val onesZeros = onesZeros % 2\n\
    \        val onesZero\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp531yqkb9.scala:49:4 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp531yqkb9.scala:13:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeros\e[0m = onesZero / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0monesZeros is already defined\
    \ as \e[33mvalue\e[0m \e[35monesZeros\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp531yqkb9.scala:14:12 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36monesZero\e[0m = onesZero\
    \ % \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0monesZero is already defined as \e[33mvalue\e[0m \e[35monesZero\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp531yqkb9.scala:15:12 ---------------------------\e[0m\e[0m\n\e\
    [31m15 |\e[0m        \e[33mval\e[0m \e[36monesZeros\e[0m = onesZeros % \e[31m2\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0monesZeros is already defined as \e[33mvalue\e[0m \e[35monesZeros\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp531yqkb9.scala:16:12 ---------------------------\e[0m\e[0m\n\e[31m16\
    \ |\e[0m        \e[33mval\e[0m \e[36monesZeros\e[0m = onesZeros % \e[31m2\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0monesZeros is already defined as \e[33mvalue\e[0m \e[35monesZeros\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp531yqkb9.scala:17:12 ---------------------------\e[0m\e[0m\n\e[31m17\
    \ |\e[0m        \e[33mval\e"
  stdout: ''
  timestamp: 1660008822
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ < 0)\n        val onesDecimals = ones * decimals\n        val onesDecimalsSorted\
    \ = arr.sortBy(_ - onesDecimals)\n        val zerosDecimals = arr.count(_ > 0)\n\
    \        val zerosDecimalsSorted = arr.sortBy(_ - zerosDecimals)\n        onesDecimalsSorted.::(zerosDecimalsSorted)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpav_qxhrj.scala:15:30\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        onesDecimalsSorted.::(zerosDecimalsSorted)\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                            Found:    (zerosDecimalsSorted : List[Long])\n\
    \e[31m   |\e[0m                            Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660008821
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        // Your code here\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl8olg31u.scala:8:51\
    \ ---------------------\e[0m\e[0m\n\e[31m 8 |\e[0m    \e[33mdef\e[0m \e[36msortArray\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m]) : \e[35mList\e[0m[\e[35mLong\e\
    [0m] = {\n\e[31m\e[31m   |\e[0m                                              \
    \     ^\e[0m\n\e[31m   |\e[0m                                                \
    \   Found:    Unit\n\e[31m   |\e[0m                                          \
    \         Required: List[Long]\n\e[31m 9 |\e[0m        \e[34m// Your code here\e\
    [0m\n\e[31m10 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660008686
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decs = arr.map(_.toString.toInt)\n\
    \        val decs = decs.sortBy(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.sortBy(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.sortBy(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.sortBy(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.sortBy(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.sortBy(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.sortBy(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.sortBy(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.sortBy(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.sortBy(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.sortBy(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.sortBy(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.sortBy(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.sortBy(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.sortBy(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.sortBy(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.sortBy(_.toString.toInt)\n        val decs = decs.map(_.toString.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxm8f_goo.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpxm8f_goo.scala:11:12 ---------------------------\e[0m\e[0m\n\e[31m11\
    \ |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = decs.sortBy(_.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mdecs is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpxm8f_goo.scala:12:12 ---------------------------\e[0m\e[0m\n\e[31m12\
    \ |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = decs.map(_.toString.toInt)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mdecs is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpxm8f_goo.scala:13:12 ---------------------------\e[0m\e[0m\n\e[31m13\
    \ |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = decs.sortBy(_.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mdecs is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpxm8f_goo.scala:14:12 ---------------------------\e[0m\e[0m\n\e[31m14\
    \ |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = decs.map(_.toString.toInt)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mdecs is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpxm8f_goo.scala:15:12 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0"
  stdout: ''
  timestamp: 1660008824
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decimals = arr.count(_\
    \ < 0)\n        val onesDecimals = ones * decimals\n        val decimalsOnes =\
    \ decimals * ones\n        val onesDecimalsOnes = onesDecimals * ones\n      \
    \  val onesDecimalsOnesDecimals = onesDecimalsOnes * decimals\n        val onesDecimalsOnesDecimalsOnes\
    \ = onesDecimalsOnesDecimals * ones\n        val onesDecimalsOnesDecimalsOnesDecimals\
    \ = onesDecimalsOnesDecimalsOnes * decimals\n        val onesDecimalsOnesDecimalsOnesDecimalsOnes\
    \ = onesDecimalsOnesDecimalsOnesDecimals * ones\n        val onesDecimalsOnesDecimalsOnesDecimalsOnesDecimals\
    \ = onesDecimalsOnesDecimalsOnesDecimalsOnes * decimals\n        val onesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnes\
    \ = onesDecimalsOnesDecimalsOnesDecimalsOnesDecimals * ones\n        val onesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnesDecimals\
    \ = onesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnes * decimals\n        val\
    \ onesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnes = onesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnesDecimals\
    \ * ones\n        val onesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnesDecimals\
    \ = onesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnes * decimals\n\
    \        val onesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnes\
    \ = onesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnesDecimals *\
    \ ones\n        val onesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnesDecimals\
    \ = onesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnes\
    \ * decimals\n        val onesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnesDecimals\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpursn5fuk.scala:26:4 ----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpursn5fuk.scala:26:5 ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660008823
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(x => x % 2 == 0).length\n        val decs\
    \ = arr.filter(x => x % 2 == 1).length\n        val sortedArr = arr.sortBy(x =>\
    \ if (x == 0) ones else decs)\n        sortedArr\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_cetfodn.scala:15)\n\tat Problem.main(tmp_cetfodn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660008826
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val decs = arr.map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val result = decs.zip(ones).sortBy(_._1).map(_._2)\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpa4lm9n5g.scala:11:30\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e\
    [0m = decs.zip(ones).sortBy(_._1).map(_._2)\n\e[31m\e[31m   |\e[0m           \
    \                   ^^^^\e[0m\n\e[31m   |\e[0m                              Found:\
    \    (ones : Int)\n\e[31m   |\e[0m                              Required: IterableOnce[Any]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660008825
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val zeros = arr.count(_ ==\
    \ 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount = arr.count(_\
    \ == 0)\n        val onesDecimal = onesCount / ones\n        val zerosDecimal\
    \ = zerosCount / zeros\n        val onesDecimalDecimal = onesDecimal / onesDecimal\n\
    \        val zerosDecimalDecimal = zerosDecimal / zerosDecimal\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal / onesDecimalDecimal\n        val zerosDecimalDecimalDecimal\
    \ = zerosDecimalDecimal / zerosDecimalDecimal\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimal / onesDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / zerosDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimal\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimal\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppznmro45.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmppznmro45.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmppznmro45.scala:23:61 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimal"
  stdout: ''
  timestamp: 1660008825
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(_ % 2 == 0).length\n        val decimals\
    \ = arr.filter(_ % 2 == 1).length\n        val onesDecimals = ones * decimals\n\
    \        val onesDecimalsSorted = arr.sortBy(x => (onesDecimals - x.toString.toInt))\n\
    \        onesDecimalsSorted.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi6usl9xr.scala:16)\n\tat Problem.main(tmpi6usl9xr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660008827
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val zeros = arr.count(_ ==\
    \ 0)\n        val onesArr = arr.filter(_ == 1).sortBy(x => x.toString.toInt)\n\
    \        val zerosArr = arr.filter(_ == 0).sortBy(x => x.toString.toInt)\n   \
    \     val onesZeros = ones + zeros\n        val onesZeroArr = onesZeros.sortBy(x\
    \ => x.toString.toInt)\n        val onesZeroArr2 = onesZeros.sortBy(x => x.toString.toInt)\n\
    \        val onesZeroArr3 = onesZeros.sortBy(x => x.toString.toInt)\n        val\
    \ onesZeroArr4 = onesZeros.sortBy(x => x.toString.toInt)\n        val onesZeroArr5\
    \ = onesZeros.sortBy(x => x.toString.toInt)\n        val onesZeroArr6 = onesZeros.sortBy(x\
    \ => x.toString.toInt)\n        val onesZeroArr7 = onesZeros.sortBy(x => x.toString.toInt)\n\
    \        val onesZeroArr8 = onesZeros.sortBy(x => x.toString.toInt)\n        val\
    \ onesZeroArr9 = onesZeros.sortBy(x => x.toString.toInt)\n        val onesZeroArr10\
    \ = onesZeros.sortBy(x => x.toString.toInt)\n        val onesZeroArr11 = onesZeros.sortBy(x\
    \ => x.toString.toInt)\n        val onesZeroArr12 = onesZeros.sortBy(x => x.toString.toInt)\n\
    \        val onesZeroArr13 = onesZeros.sortBy(x => x.toString.toInt)\n       \
    \ val onesZeroArr14 = onesZeros.sortBy(x => x.toString.toInt)\n        val onesZeroArr15\
    \ = onesZeros.sortBy(x => x.toString.toInt)\n        val onesZeroArr16 = onesZeros.sortBy(x\
    \ => x.toString.toInt)\n        val onesZeroArr17 = onesZeros.sortBy(x => x.toString.toInt)\n\
    \        val onesZeroArr18 = onesZeros.sortBy(x => x.toString.toInt)\n       \
    \ val onesZeroArr19 = onesZeros.sortBy(x => x.to\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9cishqnq.scala:33:4 ----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9cishqnq.scala:14:36\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36monesZeroArr\e[0m = onesZeros.sortBy(\e[36mx\e[0m => x.toString.toInt)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value sortBy is not a member of Int\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp9cishqnq.scala:15:37 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr2\e[0m = onesZeros.sortBy(\e\
    [36mx\e[0m => x.toString.toInt)\n\e[31m\e[31m   |\e[0m                       \
    \    ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                           value sortBy\
    \ is not a member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9cishqnq.scala:16:37\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36monesZeroArr3\e[0m = onesZeros.sortBy(\e[36mx\e[0m => x.toString.toInt)\n\e\
    [31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                           value sortBy is not a member of Int\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp9cishqnq.scala:17:37 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36monesZeroArr4\e[0m = onesZeros.sortBy(\e\
    [36mx\e[0m => x.toString.toInt)\n\e[31m\e[31m   |\e[0m                       \
    \    ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                           value sortBy\
    \ is not a member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9cishqnq.scala:18:37\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36monesZeroArr5\e[0m = onesZeros.sortBy(\e[36mx\e[0m => x.toString.toInt)\n\e\
    [31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                           value sortBy is not a member of Int\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp9cishqnq.scala:19:37 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        "
  stdout: ''
  timestamp: 1660008827
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.filter(x => x == 1).length\n        val twos = arr.filter(x\
    \ => x == 2).length\n        val threes = arr.filter(x => x == 3).length\n   \
    \     val fours = arr.filter(x => x == 4).length\n        val fives = arr.filter(x\
    \ => x == 5).length\n        val sixes = arr.filter(x => x == 6).length\n    \
    \    val sevens = arr.filter(x => x == 7).length\n        val eights = arr.filter(x\
    \ => x == 8).length\n        val nines = arr.filter(x => x == 9).length\n    \
    \    val tens = arr.filter(x => x == 10).length\n        val hundreds = arr.filter(x\
    \ => x == 11).length\n        val thousands = arr.filter(x => x == 100).length\n\
    \        val millions = arr.filter(x => x == 1000).length\n        val billions\
    \ = arr.filter(x => x == 1000000).length\n        val trillions = arr.filter(x\
    \ => x == 1000000000).length\n        val quadrillions = arr.filter(x => x ==\
    \ 1000000000000).length\n        val quintillions = arr.filter(x => x == 1000000000000000).length\n\
    \        val sextillions = arr.filter(x => x == 1000000000000000000).length\n\
    \        val onesAndZeros = arr.filter(x => x == 1 && x != 0).length\n       \
    \ val onesAndOnes = arr.filter(x => x == 1 && x == 0).length\n        val twosAndZeros\
    \ = arr.filter(x => x == 2 && x != 0).length\n        val twosAndOnes = arr.filter(x\
    \ => x == 2 && x == 0).length\n        val threesAndZeros = arr.filter(x => x\
    \ == 3 && x != 0).length\n        val threesAndOnes = arr.filter(x => x == 3 &&\
    \ x == 0).length\n        val foursAndZeros = arr.filter(x => x == 4 && x != 0).length\n\
    \        val foursAndOnes = arr.filter(x => x == 4 && x == 0).length\n       \
    \ val fivesAndZeros = arr.filter(x => x == 5 && x != 0).length\n        val fivesAndOnes\
    \ = arr.filter(x => x == 5 && x == 0).length\n        val sixesAndZeros = arr.filter(x\
    \ => x == 6 && x != 0).length\n        val sixesAndOnes = arr.filter(x => x ==\
    \ 6 && x == 0).length\n        val sevensAndZeros = arr.filter(x => x == 7 &&\
    \ x != 0).length\n        val sevensAndOnes = arr.filter(x => x == 7 && x == 0).length\n\
    \        val eightsAndZeros = \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmph1o3x9jd.scala:41:28 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36meightsAndZeros\e[0m = \n\
    \e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m     \
    \                       expression expected but \e[31m'}'\e[0m found\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmph1o3x9jd.scala:24:48 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.filter(\e\
    [36mx\e[0m => x == \e[31m1000000000000\e[0m).length\n\e[31m\e[31m   |\e[0m   \
    \                                             ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                                number too large\n\e[31m\e\
    [31m-- Error: /tmp/tmph1o3x9jd.scala:25:48 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mquintillions\e[0m = arr.filter(\e\
    [36mx\e[0m => x == \e[31m1000000000000000\e[0m).length\n\e[31m\e[31m   |\e[0m\
    \                                                ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                                number too large\n\e\
    [31m\e[31m-- Error: /tmp/tmph1o3x9jd.scala:26:47 -----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36msextillions\e[0m = arr.filter(\e\
    [36mx\e[0m => x == \e[31m1000000000000000000\e[0m).length\n\e[31m\e[31m   |\e\
    [0m                                               ^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                               number too large\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph1o3x9jd.scala:42:5 ---------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1660008827
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val zeros = arr.count(_ ==\
    \ 0)\n        val onesArr = arr.filter(_ == 1).sortBy(_.toString.toInt)\n    \
    \    val zerosArr = arr.filter(_ == 0).sortBy(_.toString.toInt)\n        val onesCount\
    \ = onesArr.length\n        val zerosCount = zerosArr.length\n        val onesSum\
    \ = onesArr.sum\n        val zerosSum = zerosArr.sum\n        val onesSumDecimal\
    \ = onesSum.toString.toInt\n        val zerosSumDecimal = zerosSum.toString.toInt\n\
    \        val onesSumDecimalDecimal = onesSumDecimal.toString.toInt\n        val\
    \ zerosSumDecimalDecimal = zerosSumDecimal.toString.toInt\n        val onesSumDecimalDecimalDecimal\
    \ = onesSumDecimalDecimal.toString.toInt\n        val zerosSumDecimalDecimalDecimal\
    \ = zerosSumDecimalDecimal.toString.toInt\n        val onesSumDecimalDecimalDecimalDecimal\
    \ = onesSumDecimalDecimalDecimal.toString.toInt\n        val zerosSumDecimalDecimalDecimalDecimal\
    \ = zerosSumDecimalDecimalDecimal.toString.toInt\n        val onesSumDecimalDecimalDecimalDecimalDecimal\
    \ = onesSumDecimalDecimalDecimalDecimal.toString.toInt\n        val zerosSumDecimalDecimalDecimalDecimalDecimal\
    \ = zerosSumDecimalDecimalDecimalDecimal.toString.toInt\n        val onesSumDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesSumDecimalDecimalDecimalDecimalDecimal.toString.toInt\n        val zerosSumDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosSumDecimalDecimalDecimalDecimalDecimal.toString.toInt\n        val onesSumDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesSumDecimalDecimalDecimalDecimalDecimalDecimal.toString.toInt\n       \
    \ val zerosSumDecimalDecimalDecimalDecimalDecimalDecimal = zerosSumDecimalDecimalDecimalDecimalDecimalDecimal.toString.toInt\n\
    \        val onesSumDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesSumDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toInt\n\
    \        val zerosSumDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosSumDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toInt\n\
    \        val onesSumDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesSumDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toInt\n\
    \        val zerosSumDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosSumDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toInt\n\
    \        val onesSumDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal =\
    \ onesSumDecimalDecimalDecimalDecimalDecimalDecimal\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa95d1r7z.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mzerosSumDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosSumDecimalDecimalDecimalDecimalDecimalDecimal.toString.toInt\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosSumDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosSumDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa95d1r7z.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36monesSumDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesSumDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesSumDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35monesSumDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa95d1r7z.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36monesSumDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesSumDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesSumDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35monesSumDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e"
  stdout: ''
  timestamp: 1660008827
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    def sortArray(arr : List[Long]) : List[Long]\
    \ = {\n        val ones = arr.count(_ == 1)\n        val zeros = arr.count(_ ==\
    \ 0)\n        val onesCount = arr.count(_ == 1)\n        val zerosCount = arr.count(_\
    \ == 0)\n        val onesDecimal = onesCount / ones\n        val zerosDecimal\
    \ = zerosCount / zeros\n        val onesDecimalDecimal = onesDecimal / onesDecimal\n\
    \        val zerosDecimalDecimal = zerosDecimal / zerosDecimal\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal / onesDecimalDecimal\n        val zerosDecimalDecimalDecimal\
    \ = zerosDecimalDecimal / zerosDecimalDecimal\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimal / onesDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / zerosDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimal\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimal\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppznmro45.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmppznmro45.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmppznmro45.scala:23:61 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimal"
  stdout: ''
  timestamp: 1660008825
