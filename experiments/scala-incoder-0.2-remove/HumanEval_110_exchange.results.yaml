language: scala
name: HumanEval_110_exchange
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n        val lst3 = lst1.filter(_ %\
    \ 2 == 0).zip(lst2.filter(_ % 2 == 0)).filter(_._1 == _._1).map(_._2).toList\n\
    \        if (lst3.isEmpty) \"\"\n        else lst3.head == lst3.last ? \"YES\"\
    \ : \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmgvd87xp.scala:15:81 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mlst3\e[0m = lst1.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).zip(lst2.filter(_ % \e[31m2\e[0m == \e[31m0\e\
    [0m)).filter(_._1 == _._1).map(_._2).toList\n\e[31m\e[31m   |\e[0m           \
    \                                                                    ^^^^\e[0m\n\
    \e[31m   |\e[0m                                        value _1 is not a member\
    \ of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmgvd87xp.scala:17:36\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33melse\e[0m lst3.head\
    \ == lst3.last ? \e[31m\"YES\"\e[0m : \e[31m\"NO\"\e[0m\n\e[31m\e[31m   |\e[0m\
    \                          ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \         value ? is not a member of Long\n2 errors found\n"
  stdout: ''
  timestamp: 1659979701
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val lst3 = lst1.toSet diff lst2.toSet\n        if (lst3.isEmpty)\
    \ \"\" else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvb5wdxwt.scala:18)\n\tat Problem.main(tmpvb5wdxwt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979701
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n        val lst3 = lst1.toSet\n   \
    \     val lst4 = lst2.toSet\n        val lst5 = lst3.intersect(lst4)\n       \
    \ val lst6 = lst5.filter(x => x % 2 == 0)\n        if(lst6.size == lst1.size){\n\
    \            return \"YES\"\n        }else{\n            return \"NO\"\n     \
    \   }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_k57vjze.scala:26)\n\tat Problem.main(tmp_k57vjze.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979702
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val even = lst1 filter (x => x % 2 == 0)\n        val\
    \ odd = lst2 filter (x => x % 2 != 0)\n        if (even.size == odd.size) {\n\
    \            val evenList = even.sortWith(_ < _)\n            val oddList = odd.sortWith(_\
    \ < _)\n            val evenSet = evenList.mkSet\n            val oddSet = oddList.mkSet\n\
    \            if (evenSet.size == oddSet.size && evenSet.intersect(oddSet).size\
    \ == evenSet.size) {\n                return \"YES\"\n            }\n        }\n\
    \        return \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpm95b9lgl.scala:19:35 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mval\e[0m \e[36mevenSet\e[0m = evenList.mkSet\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue mkSet is not a member of List[Long] - did you mean evenList.toSet?\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpm95b9lgl.scala:20:33 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mval\e[0m \e[36moddSet\e[0m = oddList.mkSet\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m value mkSet is not a member of List[Long] - did you mean oddList.toSet?\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659979702
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code goes here\n        val even = lst1.filter(x\
    \ => x % 2 == 0)\n        val odd = lst2.filter(x => x % 2 != 0)\n        val\
    \ evenAndOdd = even.intersect(odd)\n        if (evenAndOdd.isEmpty) {\n      \
    \      return \"NO\"\n        } else {\n            return \"YES\"\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpboqbq9bs.scala:25)\n\tat Problem.main(tmpboqbq9bs.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979702
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n        val even = lst1.filter(x =>\
    \ x % 2 == 0)\n        val odd = lst2.filter(x => x % 2 != 0)\n        val evenOdd\
    \ = even.zip(odd)\n        val evenOddMap = evenOdd.toMap\n        val evenOddMapKeys\
    \ = evenOddMap.keys\n        val evenOddMapValues = evenOddMap.values.toList\n\
    \        val evenOddMapValuesLength = evenOddMapValues.length\n        val evenOddMapValuesLength\
    \ = evenOddMapValues.length\n        val evenOddMapValuesLength = evenOddMapValues.length\n\
    \        val evenOddMapValuesLength = evenOddMapValues.length\n        val evenOddMapValuesLength\
    \ = evenOddMapValues.length\n        val evenOddMapValuesLength = evenOddMapValues.length\n\
    \        val evenOddMapValuesLength = evenOddMapValues.length\n        val evenOddMapValuesLength\
    \ = evenOddMapValues.length\n        val evenOddMapValuesLength = evenOddMapValues.length\n\
    \        val evenOddMapValuesLength = evenOddMapValues.length\n        val evenOddMapValuesLength\
    \ = evenOddMapValues.length\n        val evenOddMapValuesLength = evenOddMapValues.length\n\
    \        val evenOddMapValuesLength = evenOddMapValues.length\n        val evenOddMapValuesLength\
    \ = evenOddMapValues.length\n        val evenOddMapValuesLength = evenOddMapValues.length\n\
    \        val evenOddMapValuesLength = evenOddMapValues.length\n        val evenOddMapValuesLength\
    \ = evenOddMapValues.length\n        val evenOddMapValuesLength = evenOddMapValues.length\n\
    \        val evenOddMapValuesLength = evenOddMapValues.length\n        val evenOddMapValuesLength\
    \ = evenOddMapValues.length\n        val evenOddMapValuesLength = evenOddMapValues.length\n\
    \        val evenOddMapValuesLength = evenOddMapValues.length\n        val evenOddMapValuesLength\
    \ = evenOddMapValues.length\n        val evenOddMapValuesLength = evenOddMapValues.length\n\
    \        val evenOddMapValuesLength = evenOddMapValues.length\n        val evenOddMapValuesLength\
    \ = evenOddMapValues.length\n        val evenOddMapValuesLength = evenOddMapValues.length\n\
    \        val evenOddMapValuesLength = evenOddMapValues.length\n        val \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpzcxzqjza.scala:49:11 ---------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpzcxzqjza.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mevenOddMapValuesLength\e\
    [0m = evenOddMapValues.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenOddMapValuesLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenOddMapValuesLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzcxzqjza.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mevenOddMapValuesLength\e\
    [0m = evenOddMapValues.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenOddMapValuesLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenOddMapValuesLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzcxzqjza.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mevenOddMapValuesLength\e\
    [0m = evenOddMapValues.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenOddMapValuesLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenOddMapValuesLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzcxzqjza.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mevenOddMapValuesLength\e\
    [0m = evenOddMapValues.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659979701
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n        val even = lst1.filter(x =>\
    \ x % 2 == 0)\n        val odd = lst2.filter(x => x % 2 != 0)\n        val evenOdd\
    \ = even.zip(odd)\n        val evenOdd2 = evenOdd.filter(x => x._1 == x._2)\n\
    \        val evenOdd3 = evenOdd2.filter(x => x._1 == x._2)\n        val evenOdd4\
    \ = evenOdd3.filter(x => x._1 == x._2)\n        val evenOdd5 = evenOdd4.filter(x\
    \ => x._1 == x._2)\n        val evenOdd6 = evenOdd5.filter(x => x._1 == x._2)\n\
    \        val evenOdd7 = evenOdd6.filter(x => x._1 == x._2)\n        val evenOdd8\
    \ = evenOdd7.filter(x => x._1 == x._2)\n        val evenOdd9 = evenOdd8.filter(x\
    \ => x._1 == x._2)\n        val evenOdd10 = evenOdd9.filter(x => x._1 == x._2)\n\
    \        val evenOdd11 = evenOdd10.filter(x => x._1 == x._2)\n        val evenOdd12\
    \ = evenOdd11.filter(x => x._1 == x._2)\n        val evenOdd13 = evenOdd12.filter(x\
    \ => x._1 == x._2)\n        val evenOdd14 = evenOdd13.filter(x => x._1 == x._2)\n\
    \        val evenOdd15 = evenOdd14.filter(x => x._1 == x._2)\n        val evenOdd16\
    \ = evenOdd15.filter(x => x._1 == x._2)\n        val evenOdd17 = evenOdd16.filter(x\
    \ => x._1 == x._2)\n        val evenOdd18 = evenOdd17.filter(x => x._1 == x._2)\n\
    \        val evenOdd19 = evenOdd18.filter(x => x._1 == x._2)\n        val evenOdd20\
    \ = evenOdd19.filter(x => x._1 == x._2)\n        val evenOdd21 = evenOdd20.filter(x\
    \ => x._1 == x._2)\n        val evenOdd22 = evenOdd21.filter(x => x._1 == x._2)\n\
    \        val evenOdd23 = evenOdd22.filter(x => x._1 == x._2)\n        val evenOdd24\
    \ = evenOdd23.filter(x => x.\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0thnidgn.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp0thnidgn.scala:41:5 ---------------------\e[0m\e[0m\n\e[31m41\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979701
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code goes here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpblp1a3w7.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code goes here\e[0m\n\e[31m15 |\e\
    [0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979701
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val even = lst1.filter(_ % 2 == 0)\n        val odd =\
    \ lst2.filter(_ % 2 != 0)\n        val evenAndOdd = even.intersect(odd)\n    \
    \    val evenAndOddAndEven = evenAndOdd.intersect(even)\n        if(evenAndOddAndEven.isEmpty)\
    \ \"YES\" else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpx7c0bm31.scala:22)\n\tat Problem.main(tmpx7c0bm31.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979702
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val even = lst1.filter(x => x % 2 == 0)\n        val odd\
    \ = lst2.filter(x => x % 2 == 1)\n        val evenAndOdd = even.intersect(odd)\n\
    \        if(evenAndOdd.isEmpty) \"NO\" else \"YES\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmporowdxbp.scala:20)\n\tat Problem.main(tmporowdxbp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979702
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n        val lst3 = lst1.filter(_ %\
    \ 2 == 0).sortWith(_ < _)\n        val lst4 = lst2.filter(_ % 2 == 0).sortWith(_\
    \ < _)\n        val lst5 = lst3.zip(lst4).filter(_._1 == _._2).map(_._1)\n   \
    \     val lst6 = lst5.filter(_ % 2 == 0).sortWith(_ < _)\n        val lst7 = lst6.filter(_\
    \ % 2 == 0).sortWith(_ < _)\n        val lst8 = lst7.filter(_ % 2 == 0).sortWith(_\
    \ < _)\n        val lst9 = lst8.filter(_ % 2 == 0).sortWith(_ < _)\n        val\
    \ lst10 = lst9.filter(_ % 2 == 0).sortWith(_ < _)\n        val lst11 = lst10.filter(_\
    \ % 2 == 0).sortWith(_ < _)\n        val lst12 = lst11.filter(_ % 2 == 0).sortWith(_\
    \ < _)\n        val lst13 = lst12.filter(_ % 2 == 0).sortWith(_ < _)\n       \
    \ val lst14 = lst13.filter(_ % 2 == 0).sortWith(_ < _)\n        val lst15 = lst14.filter(_\
    \ % 2 == 0).sortWith(_ < _)\n        val lst16 = lst15.filter(_ % 2 == 0).sortWith(_\
    \ < _)\n        val lst17 = lst16.filter(_ % 2 == 0).sortWith(_ < _)\n       \
    \ val lst18 = lst17.filter(_ % 2 == 0).sortWith(_ < _)\n        val lst19 = lst18.filter(_\
    \ % 2 == 0).sortWith(_ < _)\n        val lst20 = lst19.filter(_ % 2 == 0).sortWith(_\
    \ < _)\n        val lst21 = lst20.filter(_ % 2 == 0).sortWith(_ < _)\n       \
    \ val lst22 = lst21.filter(_ % 2 == 0).sortWith(_ < _)\n        val lst23 = lst22.filter(_\
    \ % 2 == 0).sortWith(_ < _)\n        val lst24 = lst23.filter(_ % 2 == 0).sortWith(_\
    \ < _)\n        val lst25 = lst24.filter(_ % 2 == 0).sortWith(_ < _)\n       \
    \ val lst26 = lst25.filter(_ % 2 == 0).sortWith(_ < _)\n        val lst27 = lst26.filter(_\
    \ % 2 == 0).sortWith(_ < _)\n        val lst28 = lst27.filter(_ % 2 == 0).sortWith(_\
    \ < _)\n        val lst29 = lst28.filter(_ % 2 == 0).sortWith(_ < _)\n\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7a1hm24_.scala:17:43 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mlst5\e[0m = lst3.zip(lst4).filter(_._1\
    \ == _._2).map(_._1)\n\e[31m\e[31m   |\e[0m                                  \
    \       ^^^^\e[0m\n\e[31m   |\e[0m                                        value\
    \ _1 is not a member of Long\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7a1hm24_.scala:43:5\
    \ ---------------------\e[0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979702
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code goes here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpblp1a3w7.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code goes here\e[0m\n\e[31m15 |\e\
    [0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979701
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val even = lst1.filter(x => x % 2 == 0)\n        val odd\
    \ = lst2.filter(x => x % 2 != 0)\n        val evenAndOdd = even.intersect(odd)\n\
    \        val evenAndEven = even.intersect(even)\n        val evenAndOddAndEven\
    \ = evenAndOdd.intersect(evenAndEven)\n        val evenAndOddAndEvenAndOdd = evenAndOddAndEven.intersect(evenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEven = evenAndOddAndEvenAndOdd.intersect(evenAndOddAndEven)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOdd = evenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEven = evenAndOddAndEvenAndOddAndEvenAndOdd.intersect(evenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd = evenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\
    \ = even\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpve82g316.scala:23:118 --------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\e\
    [0m = evenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                              ^\e[0m\n\e[31m\
    \   |\e[0mRecursive \e[33mvalue\e[0m \e[35mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpve82g316.scala:24:71\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\e[0m = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpve82g316.scala:27:5\
    \ ---------------------\e[0m\e[0m\n\e[31m27 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val even = lst1.filter(x => x % 2 == 0)\n        val odd\
    \ = lst2.filter(x => x % 2 != 0)\n        val evenAndOdd = even.intersect(odd)\n\
    \        val evenAndOddLength = evenAndOdd.length\n        if (evenAndOddLength\
    \ == even.length && evenAndOddLength == odd.length) {\n            evenAndOdd.toList.map(x\
    \ => x % 2 == 0).mkString(\",\")\n        } else {\n            \"NO\"\n     \
    \   }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcz26ja6_.scala:25)\n\tat Problem.main(tmpcz26ja6_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979702
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code goes here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpblp1a3w7.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code goes here\e[0m\n\e[31m15 |\e\
    [0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979701
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val lst3 = lst1 ++ lst2\n        val lst4 = lst3.filter(_\
    \ % 2 == 0)\n        val lst5 = lst4.filter(_ % 2 == 0)\n        val lst6 = lst5.filter(_\
    \ % 2 == 0)\n        val lst7 = lst6.filter(_ % 2 == 0)\n        val lst8 = lst7.filter(_\
    \ % 2 == 0)\n        val lst9 = lst8.filter(_ % 2 == 0)\n        val lst10 = lst9.filter(_\
    \ % 2 == 0)\n        val lst11 = lst10.filter(_ % 2 == 0)\n        val lst12 =\
    \ lst11.filter(_ % 2 == 0)\n        val lst13 = lst12.filter(_ % 2 == 0)\n   \
    \     val lst14 = lst13.filter(_ % 2 == 0)\n        val lst15 = lst14.filter(_\
    \ % 2 == 0)\n        val lst16 = lst15.filter(_ % 2 == 0)\n        val lst17 =\
    \ lst16.filter(_ % 2 == 0)\n        val lst18 = lst17.filter(_ % 2 == 0)\n   \
    \     val lst19 = lst18.filter(_ % 2 == 0)\n        val lst20 = lst19.filter(_\
    \ % 2 == 0)\n        val lst21 = lst20.filter(_ % 2 == 0)\n        val lst22 =\
    \ lst21.filter(_ % 2 == 0)\n        val lst23 = lst22.filter(_ % 2 == 0)\n   \
    \     val lst24 = lst23.filter(_ % 2 == 0)\n        val lst25 = lst24.filter(_\
    \ % 2 == 0)\n        val lst26 = lst25.filter(_ % 2 == 0)\n        val lst27 =\
    \ lst26.filter(_ % 2 == 0)\n        val lst28 = lst27.filter(_ % 2 == 0)\n   \
    \     val lst29 = lst28.filter(_ % 2 == 0)\n        val lst30 = lst29.filter(_\
    \ % 2 == 0)\n        val lst31 = lst30.filter(_ % 2 == 0)\n        val lst32 =\
    \ lst31.filter(_ % 2 == 0)\n        val lst33 = lst32.filter(_ % 2 == 0)\n   \
    \     val lst34 = lst33.filter(_ % 2 == 0)\n        val lst35 = lst34.filter(_\
    \ % 2 == 0)\n        val lst36 = lst35.filter(_ % 2 == 0)\n        val lst37 =\
    \ lst36.filter(_ % 2 == 0)\n        val lst38 = lst37.filter(_ % 2 == 0)\n   \
    \     val lst39 = lst38.filter(_ % 2 == 0)\n        val lst40 = lst39.filter(_\
    \ % 2 == 0)\n        val lst41 = lst40.filter(_ % 2 == 0)\n        val lst42 =\
    \ lst41.filter(_ % 2 == 0)\n        val \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpflny79um.scala:54:11 ---------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpflny79um.scala:55:5 ---------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659979701
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val even = lst1.filter(x => x % 2 == 0)\n        val odd\
    \ = lst2.filter(x => x % 2 != 0)\n        val evenAndOdd = even.intersect(odd)\n\
    \        val evenAndEven = even.intersect(even)\n        val evenAndOddAndEven\
    \ = evenAndOdd.intersect(evenAndEven)\n        val evenAndOddAndEvenAndOdd = evenAndOddAndEven.intersect(evenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEven = evenAndOddAndEvenAndOdd.intersect(evenAndOddAndEven)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOdd = evenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEven = evenAndOddAndEvenAndOddAndEvenAndOdd.intersect(evenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd = evenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\
    \ = evenAndO\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp6lwhx1ca.scala:23:118 --------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\e\
    [0m = evenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                              ^\e[0m\n\e[31m\
    \   |\e[0mRecursive \e[33mvalue\e[0m \e[35mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6lwhx1ca.scala:24:71\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\e[0m = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6lwhx1ca.scala:25:84\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\e[0m\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation availabl"
  stdout: ''
  timestamp: 1659979701
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n        val lst3 = lst1.toSet\n   \
    \     val lst4 = lst2.toSet\n        val lst5 = lst3.intersect(lst4)\n       \
    \ val lst6 = lst5.toList\n        val lst7 = lst6.filter(_ % 2 == 0)\n       \
    \ if(lst7.size == lst6.size) {\n            return \"YES\"\n        }\n      \
    \  return \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprhuv5c53.scala:26)\n\tat Problem.main(tmprhuv5c53.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979702
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code goes here\n        val lst3 = lst1.toSet\n\
    \        val lst4 = lst2.toSet\n        val lst5 = lst3.intersect(lst4)\n    \
    \    if(lst5.isEmpty){\n            return \"NO\"\n        }\n        else{\n\
    \            return \"YES\"\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpizr29faf.scala:27)\n\tat Problem.main(tmpizr29faf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979702
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val even = lst1.filter(x => x % 2 == 0)\n        val odd\
    \ = lst2.filter(x => x % 2 == 1)\n        val evenAndOdd = even.zip(odd)\n   \
    \     val evenAndOdd2 = evenAndOdd.filter(x => x._1 == x._2)\n        val evenAndOdd3\
    \ = evenAndOdd2.filter(x => x._1 == x._2)\n        val evenAndOdd4 = evenAndOdd3.filter(x\
    \ => x._1 == x._2)\n        val evenAndOdd5 = evenAndOdd4.filter(x => x._1 ==\
    \ x._2)\n        val evenAndOdd6 = evenAndOdd5.filter(x => x._1 == x._2)\n   \
    \     val evenAndOdd7 = evenAndOdd6.filter(x => x._1 == x._2)\n        val evenAndOdd8\
    \ = evenAndOdd7.filter(x => x._1 == x._2)\n        val evenAndOdd9 = evenAndOdd8.filter(x\
    \ => x._1 == x._2)\n        val evenAndOdd10 = evenAndOdd9.filter(x => x._1 ==\
    \ x._2)\n        val evenAndOdd11 = evenAndOdd10.filter(x => x._1 == x._2)\n \
    \       val evenAndOdd12 = evenAndOdd11.filter(x => x._1 == x._2)\n        val\
    \ evenAndOdd13 = evenAndOdd12.filter(x => x._1 == x._2)\n        val evenAndOdd14\
    \ = evenAndOdd13.filter(x => x._1 == x._2)\n        val evenAndOdd15 = evenAndOdd14.filter(x\
    \ => x._1 == x._2)\n        val evenAndOdd16 = evenAndOdd15.filter(x => x._1 ==\
    \ x._2)\n        val evenAndOdd17 = evenAndOdd16.filter(x => x._1 == x._2)\n \
    \       val evenAndOdd18 = evenAndOdd17.filter(x => x._1 == x._2)\n        val\
    \ evenAndOdd19 = evenAndOdd18.filter(x => x._1 == x._2)\n        val evenAndOdd20\
    \ = evenAndOdd19.filter(x => x._1 == x._2)\n        val evenAndOdd21 = evenAndOdd20.filter(x\
    \ => x._1 == x._2)\n        val evenAndOdd22 = evenAndOdd21.filter(x => x._1 ==\
    \ x._2)\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo_i2amjz.scala:38:5\
    \ ---------------------\e[0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979701
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val lst3 = lst1.filter(_ % 2 == 0)\n        val lst4 =\
    \ lst2.filter(_ % 2 == 0)\n        val lst5 = lst3.filter(_ != lst4)\n       \
    \ val lst6 = lst5.filter(_ != lst3)\n        val lst7 = lst6.filter(_ != lst5)\n\
    \        val lst8 = lst7.filter(_ != lst6)\n        val lst9 = lst8.filter(_ !=\
    \ lst7)\n        val lst10 = lst9.filter(_ != lst8)\n        val lst11 = lst10.filter(_\
    \ != lst9)\n        val lst12 = lst11.filter(_ != lst10)\n        val lst13 =\
    \ lst12.filter(_ != lst11)\n        val lst14 = lst13.filter(_ != lst12)\n   \
    \     val lst15 = lst14.filter(_ != lst13)\n        val lst16 = lst15.filter(_\
    \ != lst14)\n        val lst17 = lst16.filter(_ != lst15)\n        val lst18 =\
    \ lst17.filter(_ != lst16)\n        val lst19 = lst18.filter(_ != lst17)\n   \
    \     val lst20 = lst19.filter(_ != lst18)\n        val lst21 = lst20.filter(_\
    \ != lst19)\n        val lst22 = lst21.filter(_ != lst20)\n        val lst23 =\
    \ lst22.filter(_ != lst21)\n        val lst24 = lst23.filter(_ != lst22)\n   \
    \     val lst25 = lst24.filter(_ != lst23)\n        val lst26 = lst25.filter(_\
    \ != lst24)\n        val lst27 = lst26.filter(_ != lst25)\n        val lst28 =\
    \ lst27.filter(_ != lst26)\n        val lst29 = lst28.filter(_ != lst27)\n   \
    \     val lst30 = lst29.filter(_ != lst28)\n        val lst31 = lst30.filter(_\
    \ != lst29)\n        val lst32 = lst31.filter(_ != lst30)\n        val lst33 =\
    \ lst32.filter(_ != lst31)\n        val lst34 = lst33.filter(_ != lst32)\n   \
    \     val lst35 = lst34.filter(_ != lst33)\n        val lst36 = lst35.filter(_\
    \ != lst34)\n        val lst37 = lst36.filter(_ != lst35)\n        val lst38 =\
    \ lst37.filter(_ != lst36)\n        val lst39 = lst38.filter(_ != lst37)\n   \
    \     val lst40 = lst39.filter(_ != lst38)\n        val lst41 = lst40.filter(_\
    \ != lst39)\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp6vmmthxt.scala:16:31 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mlst5\e[0m = lst3.filter(_\
    \ != lst4)\n\e[31m\e[31m   |\e[0m                               ^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m    Values of types Long and List[Long] cannot be compared with\
    \ == or !=\n\e[31m\e[31m-- Error: /tmp/tmp6vmmthxt.scala:17:31 -----------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mlst6\e[0m = lst5.filter(_\
    \ != lst3)\n\e[31m\e[31m   |\e[0m                               ^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m    Values of types Long and List[Long] cannot be compared with\
    \ == or !=\n\e[31m\e[31m-- Error: /tmp/tmp6vmmthxt.scala:18:31 -----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mlst7\e[0m = lst6.filter(_\
    \ != lst5)\n\e[31m\e[31m   |\e[0m                               ^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m    Values of types Long and List[Long] cannot be compared with\
    \ == or !=\n\e[31m\e[31m-- Error: /tmp/tmp6vmmthxt.scala:19:31 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mlst8\e[0m = lst7.filter(_\
    \ != lst6)\n\e[31m\e[31m   |\e[0m                               ^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m    Values of types Long and List[Long] cannot be compared with\
    \ == or !=\n\e[31m\e[31m-- Error: /tmp/tmp6vmmthxt.scala:20:31 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mlst9\e[0m = lst8.filter(_\
    \ != lst7)\n\e[31m\e[31m   |\e[0m                               ^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m    Values of types Long and List[Long] cannot be compared with\
    \ == or !=\n\e[31m\e[31m-- Error: /tmp/tmp6vmmthxt.scala:21:32 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mlst10\e[0m = lst9.filter(_\
    \ != lst8)\n\e[31m\e[31m   |\e[0m                                ^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m    Values of types Long and List[Long] cannot be compared with\
    \ == or !=\n\e[31m\e[31m-- Error: /tmp/tmp6vmmthxt.scala:22:33 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        "
  stdout: ''
  timestamp: 1659979704
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val even = lst1.filter(x => x % 2 == 0)\n        val odd\
    \ = lst2.filter(x => x % 2 != 0)\n        val evenAndOdd = even.zip(odd)\n   \
    \     val evenAndOddToList = evenAndOdd.map(x => x._1)\n        val evenAndOddToList2\
    \ = evenAndOdd.map(x => x._2)\n        val evenAndOddToList3 = evenAndOdd.map(x\
    \ => x._1)\n        val evenAndOddToList4 = evenAndOdd.map(x => x._2)\n      \
    \  val evenAndOddToList5 = evenAndOdd.map(x => x._1)\n        val evenAndOddToList6\
    \ = evenAndOdd.map(x => x._2)\n        val evenAndOddToList7 = evenAndOdd.map(x\
    \ => x._1)\n        val evenAndOddToList8 = evenAndOdd.map(x => x._2)\n      \
    \  val evenAndOddToList9 = evenAndOdd.map(x => x._1)\n        val evenAndOddToList10\
    \ = evenAndOdd.map(x => x._2)\n        val evenAndOddToList11 = evenAndOdd.map(x\
    \ => x._1)\n        val evenAndOddToList12 = evenAndOdd.map(x => x._2)\n     \
    \   val evenAndOddToList13 = evenAndOdd.map(x => x._1)\n        val evenAndOddToList14\
    \ = evenAndOdd.map(x => x._2)\n        val evenAndOddToList15 = evenAndOdd.map(x\
    \ => x._1)\n        val evenAndOddToList16 = evenAndOdd.map(x => x._2)\n     \
    \   val evenAndOddToList17 = evenAndOdd.map(x => x._1)\n        val evenAndOddToList18\
    \ = evenAndOdd.map(x => x._2)\n        val evenAndOddToList19 = evenAndOdd.map(x\
    \ => x._1)\n        val evenAndOddToList20 = evenAndOdd.map(x => x._2)\n     \
    \   val evenAndOddToList21 = evenAndOdd.map(x => x._1)\n        val evenAndOddToList22\
    \ = evenAndOdd.map(x => x._2)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkfspqw_d.scala:39:5\
    \ ---------------------\e[0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979701
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code goes here\n        val lst3 = lst1.toList\n\
    \        val lst4 = lst2.toList\n        val lst5 = lst3.toList\n        val lst6\
    \ = lst4.toList\n        val lst7 = lst5.toList\n        val lst8 = lst6.toList\n\
    \        val lst9 = lst7.toList\n        val lst10 = lst8.toList\n        val\
    \ lst11 = lst9.toList\n        val lst12 = lst10.toList\n        val lst13 = lst11.toList\n\
    \        val lst14 = lst12.toList\n        val lst15 = lst13.toList\n        val\
    \ lst16 = lst14.toList\n        val lst17 = lst15.toList\n        val lst18 =\
    \ lst16.toList\n        val lst19 = lst17.toList\n        val lst20 = lst18.toList\n\
    \        val lst21 = lst19.toList\n        val lst22 = lst20.toList\n        val\
    \ lst23 = lst21.toList\n        val lst24 = lst22.toList\n        val lst25 =\
    \ lst23.toList\n        val lst26 = lst24.toList\n        val lst27 = lst25.toList\n\
    \        val lst28 = lst26.toList\n        val lst29 = lst27.toList\n        val\
    \ lst30 = lst28.toList\n        val lst31 = lst29.toList\n        val lst32 =\
    \ lst30.toList\n        val lst33 = lst31.toList\n        val lst34 = lst32.toList\n\
    \        val lst35 = lst33.toList\n        val lst36 = lst34.toList\n        val\
    \ lst37 = lst35.toList\n        val lst38 = lst36.toList\n        val lst39 =\
    \ lst37.toList\n        val lst40 = lst38.toList\n        val lst41 = lst39.toList\n\
    \        val lst42 = lst40.toList\n        val lst43 = lst41.toList\n        val\
    \ lst44 = lst42.toList\n        val lst45 = lst43.toList\n        val lst46 =\
    \ lst44.toList\n        val lst47 = lst45.toList\n        val lst48 = lst46.toList\n\
    \        val lst49 = lst47.toList\n        val lst50 = lst48.toList\n        val\
    \ lst51 = lst49.toList\n        val lst52 = lst50.toList\n        val lst53 =\
    \ lst51.toList\n        \n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkt750cd5.scala:67:5\
    \ ---------------------\e[0m\e[0m\n\e[31m67 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979701
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val even = lst1.filter(x => x % 2 == 0)\n        val odd\
    \ = lst2.filter(x => x % 2 == 1)\n        val exchanged = even.zip(odd).filter(x\
    \ => x._1 == x._2)\n        if(exchanged.isEmpty) \"\" else \"NO\"\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpopn7qn2y.scala:20)\n\tat Problem.main(tmpopn7qn2y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979702
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code goes here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpblp1a3w7.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code goes here\e[0m\n\e[31m15 |\e\
    [0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979701
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n        val lst3 = lst1.toList\n  \
    \      val lst4 = lst2.toList\n        val lst5 = lst3.filter(_ % 2 == 0)\n  \
    \      val lst6 = lst4.filter(_ % 2 == 0)\n        val lst7 = lst5.filter(_ %\
    \ 2 == 0)\n        val lst8 = lst6.filter(_ % 2 == 0)\n        val lst9 = lst7.filter(_\
    \ % 2 == 0)\n        val lst10 = lst8.filter(_ % 2 == 0)\n        val lst11 =\
    \ lst9.filter(_ % 2 == 0)\n        val lst12 = lst10.filter(_ % 2 == 0)\n    \
    \    val lst13 = lst11.filter(_ % 2 == 0)\n        val lst14 = lst12.filter(_\
    \ % 2 == 0)\n        val lst15 = lst13.filter(_ % 2 == 0)\n        val lst16 =\
    \ lst14.filter(_ % 2 == 0)\n        val lst17 = lst15.filter(_ % 2 == 0)\n   \
    \     val lst18 = lst16.filter(_ % 2 == 0)\n        val lst19 = lst17.filter(_\
    \ % 2 == 0)\n        val lst20 = lst18.filter(_ % 2 == 0)\n        val lst21 =\
    \ lst19.filter(_ % 2 == 0)\n        val lst22 = lst20.filter(_ % 2 == 0)\n   \
    \     val lst23 = lst21.filter(_ % 2 == 0)\n        val lst24 = lst22.filter(_\
    \ % 2 == 0)\n        val lst25 = lst23.filter(_ % 2 == 0)\n        val lst26 =\
    \ lst24.filter(_ % 2 == 0)\n        val lst27 = lst25.filter(_ % 2 == 0)\n   \
    \     val lst28 = lst26.filter(_ % 2 == 0)\n        val lst29 = lst27.filter(_\
    \ % 2 == 0)\n        val lst30 = lst28.filter(_ % 2 == 0)\n        val lst31 =\
    \ lst29.filter(_ % 2 == 0)\n        val lst32 = lst30.filter(_ % 2 == 0)\n   \
    \     val lst33 = lst31.filter(_ % 2 == 0)\n        val lst34 = lst32.filter(_\
    \ % 2 == 0)\n        val lst35 = lst33.filter(_ % 2 == 0)\n        val lst36 =\
    \ lst34.filter(_ % 2 == 0)\n        val lst37 = lst35.filter(_ % 2 == 0)\n   \
    \     val lst38 = lst36.filter(_ % 2 == 0)\n        val lst39 = lst37.filter(_\
    \ % 2 == 0)\n        val lst40 = lst38.filter(_ % 2 == 0)\n        val lst41 =\
    \ lst39.filter(_ % 2 == 0)\n        val lst42 = lst40.filter(_ % 2 == 0)\n   \
    \     \n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9i1jlfjh.scala:56:5\
    \ ---------------------\e[0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979712
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n        val even = lst1.filter(_ %\
    \ 2 == 0)\n        val odd = lst2.filter(_ % 2 != 0)\n        if(even.size ==\
    \ odd.size) {\n            val evenList = even.toList\n            val oddList\
    \ = odd.toList\n            val exchanged = evenList.zip(oddList).filter(_._1\
    \ == _._2)\n            if(exchanged.size == evenList.size) {\n              \
    \  return \"YES\"\n            } else {\n                return \"NO\"\n     \
    \       }\n        } else {\n            return \"NO\"\n        }\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpr8ugjb3n.scala:20:59 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mval\e[0m \e[36mexchanged\e[0m = evenList.zip(oddList).filter(_._1\
    \ == _._2)\n\e[31m\e[31m   |\e[0m                                            \
    \             ^^^^\e[0m\n\e[31m   |\e[0m                                     \
    \   value _1 is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1659979710
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code goes here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpblp1a3w7.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code goes here\e[0m\n\e[31m15 |\e\
    [0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979701
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val even = lst1.filter(x => x % 2 == 0)\n        val odd\
    \ = lst2.filter(x => x % 2 != 0)\n        val evenAndOdd = even.intersect(odd)\n\
    \        if (evenAndOdd.isEmpty) \"NO\" else \"YES\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_i0r3w83.scala:20)\n\tat Problem.main(tmp_i0r3w83.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979714
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n        val lst3 = lst1.filter(_ %\
    \ 2 == 0).filter(_ != lst2.head).filter(_ != lst2.last)\n        val lst4 = lst2.filter(_\
    \ % 2 == 0).filter(_ != lst1.head).filter(_ != lst1.last)\n        if(lst3.isEmpty\
    \ || lst4.isEmpty) return(\"NO\")\n        if(lst3.forall(x => lst4.contains(x)))\
    \ return(\"YES\")\n        return(\"NO\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_hxb2pr1.scala:24)\n\tat Problem.main(tmp_hxb2pr1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979713
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code goes here\n        val lst3 = lst1 ++ lst2\n\
    \        val lst4 = lst3.filter(_ % 2 == 0)\n        if (lst4.isEmpty) {\n   \
    \         \"NO\"\n        } else {\n            \"YES\"\n        }\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1xmyrnj5.scala:25)\n\tat Problem.main(tmp1xmyrnj5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979713
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n        val lst1Even = lst1.filter(x\
    \ => x % 2 == 0)\n        val lst2Even = lst2.filter(x => x % 2 == 0)\n      \
    \  val lst1Odd = lst1.filter(x => x % 2 != 0)\n        val lst2Odd = lst2.filter(x\
    \ => x % 2 != 0)\n        val lst1EvenOdd = lst1Even.zip(lst2Even).filter(x =>\
    \ x._1 == x._2)\n        val lst2EvenOdd = lst2Even.zip(lst1Even).filter(x =>\
    \ x._1 == x._2)\n        val lst1EvenEven = lst1Even.zip(lst2Even).filter(x =>\
    \ x._1 == x._2)\n        val lst2EvenEven = lst2Even.zip(lst1Even).filter(x =>\
    \ x._1 == x._2)\n        val lst1EvenEvenOdd = lst1EvenEven.zip(lst2EvenEven).filter(x\
    \ => x._1 == x._2)\n        val lst2EvenEvenOdd = lst2EvenEven.zip(lst1EvenEven).filter(x\
    \ => x._1 == x._2)\n        val lst1EvenEvenEven = lst1EvenEven.zip(lst2EvenEven).filter(x\
    \ => x._1 == x._2)\n        val lst2EvenEvenEven = lst2EvenEven.zip(lst1EvenEven).filter(x\
    \ => x._1 == x._2)\n        val lst1EvenEvenEvenOdd = lst1EvenEvenEven.zip(lst2EvenEvenEven).filter(x\
    \ => x._1 == x._2)\n        val lst2EvenEvenEvenOdd = lst2EvenEvenEven.zip(lst1EvenEvenEven).filter(x\
    \ => x._1 == x._2)\n        val lst1EvenEvenEvenEven = lst1EvenEvenEven.zip(lst2EvenEvenEven).filter(x\
    \ => x._1 == x._2)\n        val lst2EvenEvenEvenEven = lst2EvenEvenEven.zip(lst1EvenEvenEven).filter(x\
    \ => x._1 == x._2)\n        val lst1EvenEvenEvenEvenOdd = lst1EvenEvenEvenEven.zip(lst2EvenEvenEvenEven).filter(x\
    \ => x._1 == x._2)\n        val lst2EvenEvenEvenEvenOdd = lst2EvenEvenEvenEven.zip(lst1EvenEvenEvenEven).filter(x\
    \ => x._1 == x._2)\n        val lst1EvenEvenEvenEvenEven = lst1Even\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjlm505gx.scala:34:5\
    \ ---------------------\e[0m\e[0m\n\e[31m34 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979713
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val even = lst1.filter(x => x % 2 == 0)\n        val odd\
    \ = lst2.filter(x => x % 2 == 1)\n        val evenAndOdd = even.intersect(odd)\n\
    \        val evenAndEven = even.intersect(even)\n        val evenAndOddAndEven\
    \ = evenAndOdd.intersect(evenAndEven)\n        val evenAndOddAndEvenAndOdd = evenAndOddAndEven.intersect(evenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEven = evenAndOddAndEvenAndOdd.intersect(evenAndOddAndEven)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOdd = evenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEven = evenAndOddAndEvenAndOddAndEvenAndOdd.intersect(evenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd = evenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpw0xhh2_5.scala:27:4 ----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpw0xhh2_5.scala:23:118\
    \ --------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\e[0m = evenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                              ^\e[0m\n\e[31m\
    \   |\e[0mRecursive \e[33mvalue\e[0m \e[35mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw0xhh2_5.scala:24:71\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\e[0m = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw0xhh2_5.scala:25:84\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\e[0m\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659979711
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val lst3 = lst1.toSet.diff(lst2.toSet)\n        if (lst3.isEmpty)\
    \ \"\"\n        else lst3.forall(x => x % 2 == 0).map(\"YES\").orElse(\"NO\")\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpb56pyzk2.scala:16:42 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33melse\e[0m lst3.forall(x => x % \e[31m2\e\
    [0m == \e[31m0\e[0m).map(\e[31m\"YES\"\e[0m).orElse(\e[31m\"NO\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m             value map is not a member of Boolean\n1 error found\n"
  stdout: ''
  timestamp: 1659979713
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n        val even = lst1.filter(x =>\
    \ x % 2 == 0)\n        val odd = lst2.filter(x => x % 2 != 0)\n        val evenAndOdd\
    \ = even.intersect(odd)\n        if(evenAndOdd.isEmpty) \n            \"NO\"\n\
    \        else\n            \"YES\"\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnx9t9hqj.scala:24)\n\tat Problem.main(tmpnx9t9hqj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979714
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code goes here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpblp1a3w7.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code goes here\e[0m\n\e[31m15 |\e\
    [0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979701
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n        val even = lst1.filter(x =>\
    \ x % 2 == 0)\n        val odd = lst2.filter(x => x % 2 != 0)\n        val evenAndOdd\
    \ = even.zip(odd)\n        val evenAndOddList = evenAndOdd.toList\n        val\
    \ evenAndOddList2 = evenAndOddList.filter(x => x._1 == x._2)\n        val evenAndOddList3\
    \ = evenAndOddList2.toList\n        val evenAndOddList4 = evenAndOddList3.filter(x\
    \ => x._1 == x._2)\n        val evenAndOddList5 = evenAndOddList4.toList\n   \
    \     val evenAndOddList6 = evenAndOddList5.filter(x => x._1 == x._2)\n      \
    \  val evenAndOddList7 = evenAndOddList6.toList\n        val evenAndOddList8 =\
    \ evenAndOddList7.filter(x => x._1 == x._2)\n        val evenAndOddList9 = evenAndOddList8.toList\n\
    \        val evenAndOddList10 = evenAndOddList9.filter(x => x._1 == x._2)\n  \
    \      val evenAndOddList11 = evenAndOddList10.toList\n        val evenAndOddList12\
    \ = evenAndOddList11.filter(x => x._1 == x._2)\n        val evenAndOddList13 =\
    \ evenAndOddList12.toList\n        val evenAndOddList14 = evenAndOddList13.filter(x\
    \ => x._1 == x._2)\n        val evenAndOddList15 = evenAndOddList14.toList\n \
    \       val evenAndOddList16 = evenAndOddList15.filter(x => x._1 == x._2)\n  \
    \      val evenAndOddList17 = evenAndOddList16.toList\n        val evenAndOddList18\
    \ = evenAndOddList17.filter(x => x._1 == x._2)\n        val evenAndOddList19 =\
    \ evenAndOddList18.toList\n        val evenAndOddList20 = evenAndOddList19.filter(x\
    \ => x._1 == x._2)\n        val evenAndOddList21 = evenAndOddList20.toList\n \
    \       val evenAndOddList22 = evenAndOddList21.filter(x => x._1 == x._2)\n  \
    \      val evenAndOddList\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvnbx2cx3.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpvnbx2cx3.scala:41:5 ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979712
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code goes here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpblp1a3w7.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code goes here\e[0m\n\e[31m15 |\e\
    [0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979701
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val even = lst1.filter(x => x % 2 == 0)\n        val odd\
    \ = lst2.filter(x => x % 2 != 0)\n        val evenAndOdd = even.zip(odd)\n   \
    \     val evenAndOddToList = evenAndOdd.map(x => x._1 + x._2)\n        val evenAndOddToListToList\
    \ = evenAndOddToList.map(x => List(x))\n        val evenAndOddToListToListToList\
    \ = evenAndOddToListToList.map(x => List(x))\n        val evenAndOddToListToListToListToList\
    \ = evenAndOddToListToListToList.map(x => List(x))\n        val evenAndOddToListToListToListToListToList\
    \ = evenAndOddToListToListToListToList.map(x => List(x))\n        val evenAndOddToListToListToListToListToListToList\
    \ = evenAndOddToListToListToListToListToList.map(x => List(x))\n        val evenAndOddToListToListToListToListToListToListToList\
    \ = evenAndOddToListToListToListToListToListToList.map(x => List(x))\n       \
    \ val evenAndOddToListToListToListToListToListToListToListToListToList = evenAndOddToListToListToListToListToListToListToListToList.map(x\
    \ => List(x))\n        val evenAndOddToListToListToListToListToListToListToListToListToListToListToList\
    \ = evenAndOddToListToListToListToListToListToListToListToListToListToList.map(x\
    \ => List(x))\n        val evenAndOddToListToListToListToListToListToListToListToListToListToListToListToListToList\
    \ = evenAndOddToListToListToListToListToListToListToListToListToListToListToListToListToList.map(x\
    \ => List(x))\n        val evenAndOddToListToListToListToListToListToListToListToListToListToListToListToListToListToListToListToList\
    \ = evenAndOddToListToListToListToListToListToListToListToListToListToListToListToListToListToList.map(x\
    \ => List(x))\n        val even\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpilfrjwxj.scala:29:4 ----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpilfrjwxj.scala:24:79\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mevenAndOddToListToListToListToListToListToListToListToListToList\e[0m = evenAndOddToListToListToListToListToListToListToListToList.map(\e\
    [36mx\e[0m => List(x))\n\e[31m\e[31m   |\e[0m                                \
    \                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m   Not found: evenAndOddToListToListToListToListToListToListToListToList\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpilfrjwxj.scala:25:91\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mevenAndOddToListToListToListToListToListToListToListToListToListToListToList\e\
    [0m = evenAndOddToListToListToListToListToListToListToListToListToListToList.map(\e\
    [36mx\e[0m => List(x))\n\e[31m\e[31m   |\e[0m                                \
    \                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: evenAndOddToListToListToListToListToListToListToListToListToListToList\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpilfrjwxj.scala:26:103\
    \ --------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevenAndOddToListToListToListToListToListToListToListToListToListToListToListToListToList\e\
    [0m = evenAndOddToListToListToListToListToListToListToListToListToListToListToListToListToList.map(\e\
    [36mx\e[0m => List(x))\n\e[31m\e[31m   |\e[0m                                \
    \                                                                       ^\e[0m\n\
    \e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  evenAnd"
  stdout: ''
  timestamp: 1659979713
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val even = lst1.filter(x => x % 2 == 0)\n        val odd\
    \ = lst2.filter(x => x % 2 != 0)\n        val evenAndOdd = even.intersect(odd)\n\
    \        if (evenAndOdd.isEmpty) \"NO\" else \"YES\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_i0r3w83.scala:20)\n\tat Problem.main(tmp_i0r3w83.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979714
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n        val lst3 = lst1.filter(_ %\
    \ 2 == 0).filter(_ != 0).filter(_ != lst2.head).filter(_ != lst2.last)\n     \
    \   val lst4 = lst2.filter(_ % 2 == 0).filter(_ != 0).filter(_ != lst1.head).filter(_\
    \ != lst1.last)\n        if(lst3.isEmpty) \"\"\n        else if(lst4.isEmpty)\
    \ \"\"\n        else if(lst3.forall(x => lst4.contains(x))) \"YES\"\n        else\
    \ \"\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpaf_o35_y.scala:24)\n\tat Problem.main(tmpaf_o35_y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979715
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val even = lst1.filter(x => x % 2 == 0)\n        val odd\
    \ = lst2.filter(x => x % 2 != 0)\n        val evenAndOdd = even.zip(odd)\n   \
    \     val evenAndOddAndEvenAndOdd = evenAndOdd.filter(x => x._1 == x._2)\n   \
    \     val evenAndOddAndEvenAndOddAndEvenAndOdd = evenAndOddAndEvenAndOdd.filter(x\
    \ => x._1 == x._2)\n        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\
    \ = evenAndOddAndEvenAndOddAndEvenAndOdd.filter(x => x._1 == x._2)\n        val\
    \ evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.filter(x\
    \ => x._1 == x._2)\n        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.filter(x\
    \ => x._1 == x._2)\n        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.filter(x\
    \ => x._1 == x._2)\n        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.filter(x\
    \ => x._1 == x._2)\n        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOd\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpz3hpc21b.scala:25:4 ----------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpz3hpc21b.scala:20:77\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\e[0m =\
    \ evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.filter(\e[36mx\e\
    [0m => x._1 == x._2)\n\e[31m\e[31m   |\e[0m                                  \
    \                                           ^\e[0m\n\e[31m   |\e[0mRecursive \e\
    [33mvalue\e[0m \e[35mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpz3hpc21b.scala:21:90\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\e\
    [0m = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.filter(\e\
    [36mx\e[0m => x._1 == x._2)\n\e[31m\e[31m   |\e[0m                           \
    \                                                               ^\e[0m\n\e[31m\
    \   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpz3hpc21b.scala:22:103 --------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\e\
    [0m = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.filter(\e\
    [36mx\e[0m => x._1 == x._2)\n\e[31m\e[31m   |\e[0m                           \
    \                                                                            ^\e\
    [0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  ev"
  stdout: ''
  timestamp: 1659979713
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n        val lst1Size = lst1.size\n\
    \        val lst2Size = lst2.size\n        val evenList = lst1.filter(_ % 2 ==\
    \ 0)\n        val oddList = lst1.filter(_ % 2 != 0)\n        val evenListSize\
    \ = evenList.size\n        val oddListSize = oddList.size\n        if(evenListSize\
    \ == lst2Size && oddListSize == lst1Size){\n            val evenList = lst1.filter(_\
    \ % 2 == 0)\n            val oddList = lst1.filter(_ % 2 != 0)\n            val\
    \ evenListSize = evenList.size\n            val oddListSize = oddList.size\n \
    \           if(evenListSize == lst2Size && oddListSize == lst1Size){\n       \
    \         val evenList = lst1.filter(_ % 2 == 0)\n                val oddList\
    \ = lst1.filter(_ % 2 != 0)\n                val evenListSize = evenList.size\n\
    \                val oddListSize = oddList.size\n                if(evenListSize\
    \ == lst2Size && oddListSize == lst1Size){\n                    val evenList =\
    \ lst1.filter(_ % 2 == 0)\n                    val oddList = lst1.filter(_ % 2\
    \ != 0)\n                    val evenListSize = evenList.size\n              \
    \      val oddListSize = oddList.size\n                    if(evenListSize ==\
    \ lst2Size && oddListSize == lst1Size){\n                        val evenList\
    \ = lst1.filter(_ % 2 == 0)\n                        val oddList = lst1.filter(_\
    \ % 2 != 0)\n                        val evenListSize = evenList.size\n      \
    \                  val oddListSize = oddList.size\n                        if(evenListSize\
    \ == lst2Size && oddListSize == lst1Size){\n                            val evenList\
    \ = lst1.filter(_ % 2 == 0)\n                            val oddList = lst1.filter(_\
    \ % 2 != 0)\n                            val evenListSize = evenList.size\n  \
    \                          val oddListSize = oddList.size\n                  \
    \          if(evenListSize == lst2Size && oddListSize == lst1Size){\n        \
    \                        val evenList = lst1.filter(_ % 2 == 0)\n            \
    \                    val oddList = lst1.filter(_ % 2 != 0)\n                 \
    \               val evenListSize = evenList.size\n                           \
    \     val oddListSize = oddList.size\n                                if(evenListSize\
    \ == lst2Size && oddListSize == lst1Size){\n                                 \
    \   val evenList = lst1.filter(_ % 2 == 0)\n                                 \
    \   val oddList = lst1.filter(_ % 2 != 0)\n                                  \
    \  val evenListSize = evenList.size\n                                    val oddListSize\
    \ = oddList.size\n                                    if(evenListSize == lst2Size\
    \ && oddListSize == lst\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1fx9gfwd.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1fx9gfwd.scala:69:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m69 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmp1fx9gfwd.scala:56:82 ------------------------\e[0m\e[0m\n\
    \e[31m56 |\e[0m                                    \e[33mif\e[0m(evenListSize\
    \ == lst2Size && oddListSize == lst\n\e[31m\e[31m   |\e[0m                   \
    \                                                               ^^^\e[0m\n\e[31m\
    \   |\e[0m                                                          Not found:\
    \ lst\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmp1fx9gfwd.scala:58:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m58 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n3 errors found\n"
  stdout: ''
  timestamp: 1659979711
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val even = lst1.filter(_ % 2 == 0)\n        val odd =\
    \ lst2.filter(_ % 2 != 0)\n        val evenOdd = even.zip(odd)\n        val evenOddMap\
    \ = evenOdd.toMap\n        val evenOddMapKeys = evenOddMap.keys\n        val evenOddMapValues\
    \ = evenOddMap.values\n        val evenOddMapKeysSet = evenOddMapKeys.toSet\n\
    \        val evenOddMapValuesSet = evenOddMapValues.toSet\n        val evenOddMapKeysSetSize\
    \ = evenOddMapKeysSet.size\n        val evenOddMapValuesSetSize = evenOddMapValuesSet.size\n\
    \        val evenOddMapKeysSetIsAllEven = evenOddMapKeysSet.isEmpty || evenOddMapKeysSet.isEmpty\n\
    \        val evenOddMapValuesSetIsAllEven = evenOddMapValuesSet.isEmpty || evenOddMapValuesSet.isEmpty\n\
    \        val evenOddMapKeysSetIsAllOdd = evenOddMapKeysSet.isEmpty || evenOddMapKeysSet.isEmpty\n\
    \        val evenOddMapValuesSetIsAllOdd = evenOddMapValuesSet.isEmpty || evenOddMapValuesSet.isEmpty\n\
    \        val evenOddMapKeysSetIsAllEvenOdd = evenOddMapKeysSet.isEmpty || evenOddMapKeysSet.isEmpty\n\
    \        val evenOddMapValuesSetIsAllEvenOdd = evenOddMapValuesSet.isEmpty ||\
    \ evenOddMapValuesSet.isEmpty\n        val evenOddMapKeysSetIsAllEvenOddEvenOdd\
    \ = evenOddMapKeysSet.isEmpty || evenOddMapKeysSet.isEmpty\n        val evenOddMapValuesSetIsAllEvenOddEvenOdd\
    \ = evenOddMapValuesSet.isEmpty || evenOddMapValuesSet.isEmpty\n        val evenOddMapKeysSetIsAllEvenOddEvenOddEvenOdd\
    \ = evenOddMapKeysSet.isEmpty || evenOddMapKeysSet.isEmpty\n        val evenOddMapValuesSetIsAllEvenOddEvenOddEvenOdd\
    \ = evenOddMapValuesSet.isEmpty || evenOddMapValuesSet.isEmpty\n        val evenOddMapKeysSetIsAllEvenOddEven\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmph42opnbu.scala:35:4 ----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmph42opnbu.scala:35:5 ---------------------\e[0m\e[0m\n\e[31m35 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979714
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n        val even = lst1.filter(x =>\
    \ x % 2 == 0).length\n        val odd = lst2.filter(x => x % 2 == 1).length\n\
    \        if (even > odd) {\n            return \"NO\"\n        } else {\n    \
    \        return \"YES\"\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2hrt82nb.scala:25)\n\tat Problem.main(tmp2hrt82nb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979714
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val lst3 = lst1 ++ lst2\n        val lst4 = lst3.filter(_\
    \ % 2 == 0)\n        val lst5 = lst3.filter(_ % 2 != 0)\n        val lst6 = lst4.filter(_\
    \ % 2 == 0)\n        val lst7 = lst4.filter(_ % 2 != 0)\n        val lst8 = lst5.filter(_\
    \ % 2 == 0)\n        val lst9 = lst5.filter(_ % 2 != 0)\n        val lst10 = lst6.filter(_\
    \ % 2 == 0)\n        val lst11 = lst6.filter(_ % 2 != 0)\n        val lst12 =\
    \ lst7.filter(_ % 2 == 0)\n        val lst13 = lst7.filter(_ % 2 != 0)\n     \
    \   val lst14 = lst8.filter(_ % 2 == 0)\n        val lst15 = lst8.filter(_ % 2\
    \ != 0)\n        val lst16 = lst9.filter(_ % 2 == 0)\n        val lst17 = lst9.filter(_\
    \ % 2 != 0)\n        val lst18 = lst10.filter(_ % 2 == 0)\n        val lst19 =\
    \ lst10.filter(_ % 2 != 0)\n        val lst20 = lst11.filter(_ % 2 == 0)\n   \
    \     val lst21 = lst11.filter(_ % 2 != 0)\n        val lst22 = lst12.filter(_\
    \ % 2 == 0)\n        val lst23 = lst12.filter(_ % 2 != 0)\n        val lst24 =\
    \ lst13.filter(_ % 2 == 0)\n        val lst25 = lst13.filter(_ % 2 != 0)\n   \
    \     val lst26 = lst14.filter(_ % 2 == 0)\n        val lst27 = lst14.filter(_\
    \ % 2 != 0)\n        val lst28 = lst15.filter(_ % 2 == 0)\n        val lst29 =\
    \ lst15.filter(_ % 2 != 0)\n        val lst30 = lst16.filter(_ % 2 == 0)\n   \
    \     val lst31 = lst16.filter(_ % 2 != 0)\n        val lst32 = lst17.filter(_\
    \ % 2 == 0)\n        val lst33 = lst17.filter(_ % 2 != 0)\n        val lst34 =\
    \ lst18.filter(_ % 2 == 0)\n        val lst35 = lst18.filter(_ % 2 != 0)\n   \
    \     val lst36 = lst19.filter(_ % 2 == 0)\n        val lst37 = lst19.filter(_\
    \ % 2 != 0)\n        val lst38 = lst20.filter(_ % 2 == 0)\n        val lst39 =\
    \ lst20.filter(_ % 2 != 0)\n        val lst40 = lst21.filter(_ % 2 == 0)\n   \
    \     val lst41 = lst21.filter(_ % 2 != \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp8vtpabio.scala:52:41 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m        \e[33mval\e[0m \e[36mlst41\e[0m = lst21.filter(_\
    \ % \e[31m2\e[0m != \n\e[31m\e[31m   |\e[0m                                  \
    \       ^\e[0m\n\e[31m   |\e[0m                                       expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp8vtpabio.scala:53:5 ---------------------\e[0m\e[0m\n\e[31m53\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979713
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val even = lst1.filter(_ % 2 == 0)\n        val odd =\
    \ lst2.filter(_ % 2 != 0)\n        val evenAndOdd = even.intersect(odd)\n    \
    \    val evenAndEven = even.intersect(even)\n        if(evenAndOdd.isEmpty) \"\
    NO\" else \"YES\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1jdu1jjn.scala:21)\n\tat Problem.main(tmp1jdu1jjn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979714
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val lst3 = lst1 ++ lst2\n        val lst4 = lst3.filter(_\
    \ % 2 == 0)\n        val lst5 = lst4.filter(_ % 2 == 0)\n        val lst6 = lst5.filter(_\
    \ % 2 == 0)\n        val lst7 = lst6.filter(_ % 2 == 0)\n        val lst8 = lst7.filter(_\
    \ % 2 == 0)\n        val lst9 = lst8.filter(_ % 2 == 0)\n        val lst10 = lst9.filter(_\
    \ % 2 == 0)\n        val lst11 = lst10.filter(_ % 2 == 0)\n        val lst12 =\
    \ lst11.filter(_ % 2 == 0)\n        val lst13 = lst12.filter(_ % 2 == 0)\n   \
    \     val lst14 = lst13.filter(_ % 2 == 0)\n        val lst15 = lst14.filter(_\
    \ % 2 == 0)\n        val lst16 = lst15.filter(_ % 2 == 0)\n        val lst17 =\
    \ lst16.filter(_ % 2 == 0)\n        val lst18 = lst17.filter(_ % 2 == 0)\n   \
    \     val lst19 = lst18.filter(_ % 2 == 0)\n        val lst20 = lst19.filter(_\
    \ % 2 == 0)\n        val lst21 = lst20.filter(_ % 2 == 0)\n        val lst22 =\
    \ lst21.filter(_ % 2 == 0)\n        val lst23 = lst22.filter(_ % 2 == 0)\n   \
    \     val lst24 = lst23.filter(_ % 2 == 0)\n        val lst25 = lst24.filter(_\
    \ % 2 == 0)\n        val lst26 = lst25.filter(_ % 2 == 0)\n        val lst27 =\
    \ lst26.filter(_ % 2 == 0)\n        val lst28 = lst27.filter(_ % 2 == 0)\n   \
    \     val lst29 = lst28.filter(_ % 2 == 0)\n        val lst30 = lst29.filter(_\
    \ % 2 == 0)\n        val lst31 = lst30.filter(_ % 2 == 0)\n        val lst32 =\
    \ lst31.filter(_ % 2 == 0)\n        val lst33 = lst32.filter(_ % 2 == 0)\n   \
    \     val lst34 = lst33.filter(_ % 2 == 0)\n        val lst35 = lst34.filter(_\
    \ % 2 == 0)\n        val lst36 = lst35.filter(_ % 2 == 0)\n        val lst37 =\
    \ lst36.filter(_ % 2 == 0)\n        val lst38 = lst37.filter(_ % 2 == 0)\n   \
    \     val lst39 = lst38.filter(_ % 2 == 0)\n        val lst40 = lst39.filter(_\
    \ % 2 == 0)\n        val lst41 = lst40.filter(_ % 2 == 0)\n        val lst42 =\
    \ lst41.filter(_ % 2 == 0)\n        val \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpflny79um.scala:54:11 ---------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpflny79um.scala:55:5 ---------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659979701
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n        val lst3 = lst1 ++ lst2\n \
    \       val lst4 = lst3.filter(x => x % 2 == 0)\n        val lst5 = lst4.toList\n\
    \        if (lst5.size == lst1.size + lst2.size) {\n            val lst6 = lst5.sortWith((x,\
    \ y) => x < y)\n            val lst7 = lst6.filter(x => x % 2 == 0)\n        \
    \    val lst8 = lst7.sortWith((x, y) => x < y)\n            val lst9 = lst8.filter(x\
    \ => x % 2 == 0)\n            val lst10 = lst9.sortWith((x, y) => x < y)\n   \
    \         val lst11 = lst10.filter(x => x % 2 == 0)\n            val lst12 = lst11.sortWith((x,\
    \ y) => x < y)\n            val lst13 = lst12.filter(x => x % 2 == 0)\n      \
    \      val lst14 = lst13.sortWith((x, y) => x < y)\n            val lst15 = lst14.filter(x\
    \ => x % 2 == 0)\n            val lst16 = lst15.sortWith((x, y) => x < y)\n  \
    \          val lst17 = lst16.filter(x => x % 2 == 0)\n            val lst18 =\
    \ lst17.sortWith((x, y) => x < y)\n            val lst19 = lst18.filter(x => x\
    \ % 2 == 0)\n            val lst20 = lst19.sortWith((x, y) => x < y)\n       \
    \     val lst21 = lst20.filter(x => x % 2 == 0)\n            val lst22 = lst21.sortWith((x,\
    \ y) => x < y)\n            val lst23 = lst22.filter(x => x % 2 == 0)\n      \
    \      val lst24 = lst23.sortWith((x, y) => x < y)\n            val lst25 = lst24.filter(x\
    \ => x % 2 == 0)\n            val lst26 = lst25.sortWith((x, y) => x < y)\n  \
    \          val lst27 = lst26.filter(x => x % 2 == 0)\n            val lst28 =\
    \ lst27.sortWith((x, y) => x < y)\n            val lst29 = lst28.filter(x => x\
    \ % 2 == 0)\n            val lst30 = lst29.sortWith((x, y) => x < y)\n       \
    \     val lst31 = lst30.filter(x => x % 2 == 0)\n            val lst32 = lst31.sortWith((x,\
    \ y) => x < y)\n            val lst33 = lst32.filter(x => x % 2 == 0)\n      \
    \      val lst34 = lst33.sortWith((x, y) => x < y)\n            val lst35 = lst34.filter(x\
    \ => x % 2 == 0)\n            val lst36 = lst35.sortWith((x, y) => x < y)\n  \
    \          val lst37 = \n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp57v18bqn.scala:50:23 ---------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m            \e[33mval\e[0m \e[36mlst37\e[0m = \n\e[31m\e\
    [31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m                  \
    \     expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E040] Syntax Error: /tmp/tmp57v18bqn.scala:63:0 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp57v18bqn.scala:62:1\
    \ ---------------------\e[0m\e[0m\n\e[31m62 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: String\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmp57v18bqn.scala:52:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m52 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n3 errors found\n"
  stdout: ''
  timestamp: 1659979715
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code goes here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpblp1a3w7.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code goes here\e[0m\n\e[31m15 |\e\
    [0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979701
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val even = lst1.filter(x => x % 2 == 0)\n        val odd\
    \ = lst2.filter(x => x % 2 == 1)\n        val evenAndOdd = even.zip(odd)\n   \
    \     val evenAndOdd2 = evenAndOdd.filter(x => x._1 == x._2)\n        val evenAndOdd3\
    \ = evenAndOdd2.filter(x => x._1 == x._2)\n        val evenAndOdd4 = evenAndOdd3.filter(x\
    \ => x._1 == x._2)\n        val evenAndOdd5 = evenAndOdd4.filter(x => x._1 ==\
    \ x._2)\n        val evenAndOdd6 = evenAndOdd5.filter(x => x._1 == x._2)\n   \
    \     val evenAndOdd7 = evenAndOdd6.filter(x => x._1 == x._2)\n        val evenAndOdd8\
    \ = evenAndOdd7.filter(x => x._1 == x._2)\n        val evenAndOdd9 = evenAndOdd8.filter(x\
    \ => x._1 == x._2)\n        val evenAndOdd10 = evenAndOdd9.filter(x => x._1 ==\
    \ x._2)\n        val evenAndOdd11 = evenAndOdd10.filter(x => x._1 == x._2)\n \
    \       val evenAndOdd12 = evenAndOdd11.filter(x => x._1 == x._2)\n        val\
    \ evenAndOdd13 = evenAndOdd12.filter(x => x._1 == x._2)\n        val evenAndOdd14\
    \ = evenAndOdd13.filter(x => x._1 == x._2)\n        val evenAndOdd15 = evenAndOdd14.filter(x\
    \ => x._1 == x._2)\n        val evenAndOdd16 = evenAndOdd15.filter(x => x._1 ==\
    \ x._2)\n        val evenAndOdd17 = evenAndOdd16.filter(x => x._1 == x._2)\n \
    \       val evenAndOdd18 = evenAndOdd17.filter(x => x._1 == x._2)\n        val\
    \ evenAndOdd19 = evenAndOdd18.filter(x => x._1 == x._2)\n        val evenAndOdd20\
    \ = evenAndOdd19.filter(x => x._1 == x._2)\n        val evenAndOdd21 = evenAndOdd20.filter(x\
    \ => x._1 == x._2)\n        val evenAndOdd22 = evenAndOdd21.filter(x => x._1 ==\
    \ x._2)\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo_i2amjz.scala:38:5\
    \ ---------------------\e[0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979701
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code goes here\n        val lst3 = lst1 ++ lst2\n\
    \        val lst4 = lst3.filter(_ % 2 == 0)\n        val lst5 = lst4.filter(_\
    \ % 2 == 0)\n        if(lst5.isEmpty) \n            \"NO\"\n        else\n   \
    \         \"YES\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxw7rpbz0.scala:25)\n\tat Problem.main(tmpxw7rpbz0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979715
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val even = lst1.filter(x => x % 2 == 0)\n        val odd\
    \ = lst2.filter(x => x % 2 != 0)\n        val exchange = even.zip(odd).filter(x\
    \ => x._1 == x._2)\n        if(exchange.isEmpty) \"\" else \"NO\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe0a9xabc.scala:20)\n\tat Problem.main(tmpe0a9xabc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979714
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val even = lst1.filter(x => x % 2 == 0)\n        val odd\
    \ = lst2.filter(x => x % 2 == 1)\n        val evenAndOdd = even.intersect(odd)\n\
    \        val evenAndEven = even.intersect(even)\n        val evenAndOddAndEven\
    \ = evenAndOdd.intersect(evenAndEven)\n        val evenAndOddAndOdd = evenAndOdd.intersect(evenAndOdd)\n\
    \        val evenAndOddAndEvenAndOdd = evenAndOddAndEven.intersect(evenAndOddAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEven = evenAndOddAndEvenAndOdd.intersect(evenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndOdd = evenAndOddAndEvenAndOdd.intersect(evenAndOddAndEvenAndOddAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOdd = evenAndOddAndEvenAndOddAndEvenAndOdd.intersect(evenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEven = evenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd =\
    \ evenAndOddAndEvenAndOddAndEvenAnd\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp_odzia1x.scala:22:78 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mevenAndOddAndEvenAndOddAndOdd\e\
    [0m = evenAndOddAndEvenAndOdd.intersect(evenAndOddAndEvenAndOddAndOdd)\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \              ^\e[0m\n\e[31m   |\e[0m                Recursive \e[33mvalue\e\
    [0m \e[35mevenAndOddAndEvenAndOddAndOdd\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmp_odzia1x.scala:23:51 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mevenAndOddAndEvenAndOddAndEvenAndOdd\e\
    [0m = evenAndOddAndEvenAndOddAndEvenAndOdd.intersect(evenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \e[31m\e[31m   |\e[0m                                                   ^\e[0m\n\
    \e[31m   |\e[0m         Recursive \e[33mvalue\e[0m \e[35mevenAndOddAndEvenAndOddAndEvenAndOdd\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp_odzia1x.scala:24:58\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevenAndOddAndEvenAndOddAndEvenAndOddAndEven\e[0m = evenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \  ^\e[0m\n\e[31m   |\e[0m  Recursive \e[33mvalue\e[0m \e[35mevenAndOddAndEvenAndOddAndEvenAndOddAndEven\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp_odzia1x.scala:25:64\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\e[0m = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \        ^\e[0m\n\e[31m   |\e[0mRe"
  stdout: ''
  timestamp: 1659979714
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val even = lst1.filter(x => x % 2 == 0)\n        val odd\
    \ = lst2.filter(x => x % 2 != 0)\n        val evenAndOdd = even.intersect(odd)\n\
    \        if (evenAndOdd.isEmpty) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgi0gr5hz.scala:21)\n\tat Problem.main(tmpgi0gr5hz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979717
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n        val even = lst1.filter(x =>\
    \ x % 2 == 0)\n        val odd = lst2.filter(x => x % 2 != 0)\n        if (even.size\
    \ == odd.size) {\n            val evenList = even.toList\n            val oddList\
    \ = odd.toList\n            val newList = evenList.zip(oddList).filter(_._1 ==\
    \ _._2).map(_._2).toList\n            if (newList.size == evenList.size) {\n \
    \               return \"YES\"\n            } else {\n                return \"\
    NO\"\n            }\n        } else {\n            return \"NO\"\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpegffopo7.scala:20:57 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mval\e[0m \e[36mnewList\e[0m = evenList.zip(oddList).filter(_._1\
    \ == _._2).map(_._2).toList\n\e[31m\e[31m   |\e[0m                           \
    \                            ^^^^\e[0m\n\e[31m   |\e[0m                      \
    \                  value _1 is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1659979721
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code goes here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpblp1a3w7.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code goes here\e[0m\n\e[31m15 |\e\
    [0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979701
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code goes here\n        val lst3 = lst1.toSet\n\
    \        val lst4 = lst2.toSet\n        val lst5 = lst3.intersect(lst4)\n    \
    \    val lst6 = lst5.toList\n        val lst7 = lst6.filter(x => x % 2 == 0)\n\
    \        val lst8 = lst7.map(x => lst1.indexOf(x))\n        val lst9 = lst8.filter(x\
    \ => x != -1)\n        val lst10 = lst9.map(x => lst2.indexOf(x))\n        val\
    \ lst11 = lst10.filter(x => x != -1)\n        val lst12 = lst11.map(x => lst1.indexOf(x))\n\
    \        val lst13 = lst12.filter(x => x != -1)\n        val lst14 = lst13.map(x\
    \ => lst2.indexOf(x))\n        val lst15 = lst14.filter(x => x != -1)\n      \
    \  val lst16 = lst15.map(x => lst1.indexOf(x))\n        val lst17 = lst16.filter(x\
    \ => x != -1)\n        val lst18 = lst17.map(x => lst2.indexOf(x))\n        val\
    \ lst19 = lst18.filter(x => x != -1)\n        val lst20 = lst19.map(x => lst1.indexOf(x))\n\
    \        val lst21 = lst20.filter(x => x != -1)\n        val lst22 = lst21.map(x\
    \ => lst2.indexOf(x))\n        val lst23 = lst22.filter(x => x != -1)\n      \
    \  val lst24 = lst23.map(x => lst1.indexOf(x))\n        val lst25 = lst24.filter(x\
    \ => x != -1)\n        val lst26 = lst25.map(x => lst2.indexOf(x))\n        val\
    \ lst27 = lst26.filter(x => x != -1)\n        val lst28 = lst27.map(x => lst1.indexOf(x))\n\
    \        val lst29 = lst28.filter(x => x != -1)\n        val lst30 = lst29.map(x\
    \ => lst2.indexOf(x))\n        val lst31 = lst30.filter(x => x != -1)\n      \
    \  val lst32 = lst31.map(x => lst1.indexOf(x))\n        val lst33 = lst32.filter(x\
    \ => x != -1)\n        val lst34 = lst33.map(x => lst2.indexOf(x))\n        val\
    \ lst35 = lst34.filter(x => x != -1)\n        val lst36 = lst35.map(x => lst1.indexOf(x))\n\
    \        val lst37 = lst36.filter(x => x != -1)\n        val lst38 = lst37.map(x\
    \ => lst2.indexOf(x))\n        val lst39 = lst38.\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpkp7z4uk4.scala:52:4 ----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpkp7z4uk4.scala:52:5 ---------------------\e[0m\e[0m\n\e[31m52\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979722
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code goes here\n        val even = lst1.filter(x\
    \ => x % 2 == 0)\n        val odd = lst2.filter(x => x % 2 == 1)\n        val\
    \ exchange = even.zip(odd).filter(x => x._1 == x._2)\n        if (exchange.isEmpty)\
    \ \"\"\n        else exchange.map(x => x._1).mkString(\" \")\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxm4jbegr.scala:22)\n\tat Problem.main(tmpxm4jbegr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979724
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val even = lst1.filter(x => x % 2 == 0).length\n     \
    \   val odd = lst2.filter(x => x % 2 == 1).length\n        if (even > odd) {\n\
    \            return \"NO\"\n        }\n        else {\n            return \"YES\"\
    \n        }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpc4zw21jm.scala:25)\n\tat Problem.main(tmpc4zw21jm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979724
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n        val lst3 = lst1.toList\n  \
    \      val lst4 = lst2.toList\n        val lst5 = lst3.toList\n        val lst6\
    \ = lst4.toList\n        val lst7 = lst5.toList\n        val lst8 = lst6.toList\n\
    \        val lst9 = lst7.toList\n        val lst10 = lst8.toList\n        val\
    \ lst11 = lst9.toList\n        val lst12 = lst10.toList\n        val lst13 = lst11.toList\n\
    \        val lst14 = lst12.toList\n        val lst15 = lst13.toList\n        val\
    \ lst16 = lst14.toList\n        val lst17 = lst15.toList\n        val lst18 =\
    \ lst16.toList\n        val lst19 = lst17.toList\n        val lst20 = lst18.toList\n\
    \        val lst21 = lst19.toList\n        val lst22 = lst20.toList\n        val\
    \ lst23 = lst21.toList\n        val lst24 = lst22.toList\n        val lst25 =\
    \ lst23.toList\n        val lst26 = lst24.toList\n        val lst27 = lst25.toList\n\
    \        val lst28 = lst26.toList\n        val lst29 = lst27.toList\n        val\
    \ lst30 = lst28.toList\n        val lst31 = lst29.toList\n        val lst32 =\
    \ lst30.toList\n        val lst33 = lst31.toList\n        val lst34 = lst32.toList\n\
    \        val lst35 = lst33.toList\n        val lst36 = lst34.toList\n        val\
    \ lst37 = lst35.toList\n        val lst38 = lst36.toList\n        val lst39 =\
    \ lst37.toList\n        val lst40 = lst38.toList\n        val lst41 = lst39.toList\n\
    \        val lst42 = lst40.toList\n        val lst43 = lst41.toList\n        val\
    \ lst44 = lst42.toList\n        val lst45 = lst43.toList\n        val lst46 =\
    \ lst44.toList\n        val lst47 = lst45.toList\n        val lst48 = lst46.toList\n\
    \        val lst49 = lst47.toList\n        val lst50 = lst48.toList\n        val\
    \ lst51 = lst49.toList\n        val lst52 = lst50.toList\n        val lst53 =\
    \ lst51.toList\n        val \n    }\n    def main(args: Array[String]) = {\n \
    \   assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpp46fh4br.scala:66:11 ---------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp46fh4br.scala:67:5 ---------------------\e\
    [0m\e[0m\n\e[31m67 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659979722
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val even = lst1.filter(x => x % 2 == 0)\n        val odd\
    \ = lst2.filter(x => x % 2 == 1)\n        val evenAndOdd = even.zip(odd)\n   \
    \     val evenAndOddWithoutEven = evenAndOdd.filter(_._1 != _._2)\n        val\
    \ evenAndOddWithoutEvenAndOdd = evenAndOddWithoutEven.filter(_._1 != _._2)\n \
    \       val evenAndOddWithoutEvenAndOddWithoutEven = evenAndOddWithoutEvenAndOdd.filter(_._1\
    \ != _._2)\n        val evenAndOddWithoutEvenAndOddWithoutEvenAndOdd = evenAndOddWithoutEvenAndOddWithoutEven.filter(_._1\
    \ != _._2)\n        val evenAndOddWithoutEvenAndOddWithoutEvenAndOddWithoutEven\
    \ = evenAndOddWithoutEvenAndOddWithoutEvenAndOdd.filter(_._1 != _._2)\n      \
    \  val evenAndOddWithoutEvenAndOddWithoutEvenAndOddWithoutEvenAndOdd = evenAndOddWithoutEvenAndOddWithoutEvenAndOddWithoutEven.filter(_._1\
    \ != _._2)\n        val evenAndOddWithoutEvenAndOddWithoutEvenAndOddWithoutEvenAndOddWithoutEven\
    \ = evenAndOddWithoutEvenAndOddWithoutEvenAndOddWithoutEvenAndOdd.filter(_._1\
    \ != _._2)\n        val evenAndOddWithoutEvenAndOddWithoutEvenAndOddWithoutEvenAndOddWithoutEvenAndOdd\
    \ = evenAndOddWithoutEvenAndOddWithoutEvenAndOddWithoutEvenAndOddWithoutEven.filter(_._1\
    \ != _._2)\n        val evenAndOddWithoutEvenAndOddWithoutEvenAndOddWithoutEvenAndOddWithoutEvenAndOddWithoutEven\
    \ = evenAndOddWithoutEvenAndOddWithoutEvenAndOddWithoutEvenAndOddWithoutEvenAndOddWithoutEvenAndOdd.filter(_._1\
    \ != _._2)\n        val evenAndOddWithoutEvenAndOddWithoutEvenAndOddWithoutEvenAndOddWithoutEvenAndOddWithoutEvenAndOddWithoutEven\
    \ = evenAndOddWithoutEvenAndOddWithoutEvenAndOddWithoutEvenAndOddWithoutEvenAndOddWithoutEvenAndOddWithoutEvenAndOdd.filter(_._1\
    \ != _._2)\n        val evenAndOddWithoutEvenAndOdd\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpehag5_ic.scala:28:4 ----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpehag5_ic.scala:17:56\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mevenAndOddWithoutEven\e[0m = evenAndOdd.filter(_._1 != _._2)\n\e[31m\e[31m\
    \   |\e[0m                                                      ^^^^\e[0m\n\e\
    [31m   |\e[0m                                        value _1 is not a member\
    \ of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpehag5_ic.scala:18:73\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mevenAndOddWithoutEvenAndOdd\e[0m = evenAndOddWithoutEven.filter(_._1 != _._2)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \               ^^^^\e[0m\n\e[31m   |\e[0m                                   \
    \     value _1 is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpehag5_ic.scala:19:90 ------------------------\e[0m\e[0m\n\e[31m19 |\e\
    [0m        \e[33mval\e[0m \e[36mevenAndOddWithoutEvenAndOddWithoutEven\e[0m =\
    \ evenAndOddWithoutEvenAndOdd.filter(_._1 != _._2)\n\e[31m\e[31m   |\e[0m    \
    \                                                                            \
    \        ^^^^\e[0m\n\e[31m   |\e[0m                                        value\
    \ _1 is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpehag5_ic.scala:20:107\
    \ -----------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mevenAndOddWithoutEvenAndOddWithoutEvenAndOdd\e[0m = evenAndOddWithoutEvenAndOddWithoutEven.filter(_._1\
    \ != _._2)\n\e[31m\e[31m   |\e[0m                                            \
    \                                                             ^^^^\e[0m\n\e[31m\
    \   |\e[0m                                        value _1 is not a member of\
    \ Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpehag5_ic.scala:21:124 -----------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mevenAndOddWithoutEvenAndOddWithoutEvenAndOddWithoutEven"
  stdout: ''
  timestamp: 1659979726
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n        val even = lst1.filter(_ %\
    \ 2 == 0)\n        val odd = lst2.filter(_ % 2 == 1)\n        if(even.size ==\
    \ lst1.size && odd.size == lst2.size) {\n            val evenList = even.sortWith(_\
    \ < _)\n            val oddList = odd.sortWith(_ < _)\n            if(evenList.length\
    \ == oddList.length) {\n                val evenList = evenList.sortWith(_ < _)\n\
    \                val oddList = oddList.sortWith(_ < _)\n                val evenList\
    \ = evenList.filter(_ % 2 == 0)\n                val oddList = oddList.filter(_\
    \ % 2 == 1)\n                if(evenList.length == oddList.length) {\n       \
    \             if(evenList.length == even.size && oddList.length == odd.size) {\n\
    \                        if(evenList.length == even.size && evenList.forall(x\
    \ => x == x)) {\n                            return \"YES\"\n                \
    \        } else {\n                            return \"NO\"\n               \
    \         }\n                    } else {\n                        return \"NO\"\
    \n                    }\n                } else {\n                    return\
    \ \"NO\"\n                }\n            } else {\n                return \"NO\"\
    \n            }\n        } else {\n            return \"NO\"\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpun41p9hr.scala:23:20 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                \e[33mval\e[0m \e[36mevenList\e[0m =\
    \ evenList.filter(_ % \e[31m2\e[0m == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m   \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mevenList\
    \ is already defined as \e[33mvalue\e[0m \e[35mevenList\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpun41p9hr.scala:24:20\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m                \e[33mval\e\
    [0m \e[36moddList\e[0m = oddList.filter(_ % \e[31m2\e[0m == \e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moddList is already defined as \e[33mvalue\e[0m \e[35moddList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpun41p9hr.scala:21:31 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m                \e[33mval\e[0m \e[36mevenList\e[0m = evenList.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m   |\e\
    [0m                               Recursive \e[33mvalue\e[0m \e[35mevenList\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpun41p9hr.scala:22:30\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m                \e[33mval\e\
    [0m \e[36moddList\e[0m = oddList.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m      \
    \                        ^\e[0m\n\e[31m   |\e[0m                             \
    \ Recursive \e[33mvalue\e[0m \e[35moddList\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979720
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n        val even = lst1.filter(_ %\
    \ 2 == 0)\n        val odd = lst2.filter(_ % 2 == 1)\n        if (even.size ==\
    \ lst1.size && odd.size == lst2.size) {\n            val evenList = even.map(x\
    \ => lst2.indexOf(x)).filter(x => x >= 0)\n            val oddList = odd.map(x\
    \ => lst1.indexOf(x)).filter(x => x >= 0)\n            evenList.zip(oddList).forall\
    \ { case (ev, od) => ev == od }\n        } else {\n            \"NO\"\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpf2tse9ql.scala:20:41\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m            evenList.zip(oddList).forall\
    \ { \e[33mcase\e[0m (ev, od) => ev == od }\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Found:    Boolean\n\e[31m   |\e[0m           \
    \ Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979723
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val even = lst1.filter(x => x % 2 == 0)\n        val odd\
    \ = lst2.filter(x => x % 2 == 1)\n        val evenAndOdd = even.intersect(odd)\n\
    \        val evenAndEven = even.intersect(even)\n        val evenAndOddAndEven\
    \ = evenAndOdd.intersect(evenAndEven)\n        val evenAndOddAndOdd = evenAndOdd.intersect(evenAndOdd)\n\
    \        val evenAndOddAndEvenAndOdd = evenAndOddAndEven.intersect(evenAndOddAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEven = evenAndOddAndEvenAndOdd.intersect(evenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOdd = evenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEven = evenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd =\
    \ evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAnd\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmk5wi6b3.scala:27:4 ----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpmk5wi6b3.scala:22:92\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevenAndOddAndEvenAndOddAndEvenAndOdd\e[0m = evenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                    ^\e[0m\n\e[31m   |\e[0m         Recursive\
    \ \e[33mvalue\e[0m \e[35mevenAndOddAndEvenAndOddAndEvenAndOdd\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpmk5wi6b3.scala:23:58\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevenAndOddAndEvenAndOddAndEvenAndOddAndEven\e[0m = evenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \  ^\e[0m\n\e[31m   |\e[0m  Recursive \e[33mvalue\e[0m \e[35mevenAndOddAndEvenAndOddAndEvenAndOddAndEven\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmk5wi6b3.scala:25:71\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\e[0m = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006]"
  stdout: ''
  timestamp: 1659979724
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n        val even = lst1.filter(x =>\
    \ x % 2 == 0)\n        val odd = lst2.filter(x => x % 2 != 0)\n        if(even.size\
    \ == lst1.size && odd.size == lst2.size){\n            val evenList = even.toList\n\
    \            val oddList = odd.toList\n            val evenSet = evenList.map(x\
    \ => x -> true).toSet\n            val oddSet = oddList.map(x => x -> true).toSet\n\
    \            val newSet = evenSet.intersect(oddSet)\n            if(newSet.isEmpty){\n\
    \                return \"NO\"\n            }else{\n                return \"\
    YES\"\n            }\n        }else{\n            return \"NO\"\n        }\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfnigc3mx.scala:33)\n\tat Problem.main(tmpfnigc3mx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979725
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code goes here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpblp1a3w7.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code goes here\e[0m\n\e[31m15 |\e\
    [0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979701
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val lst1Even = lst1.filter(x => x % 2 == 0)\n        val\
    \ lst2Even = lst2.filter(x => x % 2 == 0)\n        val lst1Odd = lst1.filter(x\
    \ => x % 2 != 0)\n        val lst2Odd = lst2.filter(x => x % 2 != 0)\n       \
    \ val lst1EvenAndOdd = lst1Even.intersect(lst1Odd)\n        val lst2EvenAndOdd\
    \ = lst2Even.intersect(lst2Odd)\n        val lst1EvenAndOddAndNotBothEvenAndOdd\
    \ = lst1EvenAndOdd.filter(x => !lst2EvenAndOdd.contains(x))\n        val lst2EvenAndOddAndNotBothEvenAndOdd\
    \ = lst2EvenAndOdd.filter(x => !lst1EvenAndOdd.contains(x))\n        val lst1EvenAndOddAndNotBothEvenAndOddAndNotBothEvenAndOdd\
    \ = lst1EvenAndOddAndNotBothEvenAndOdd.filter(x => !lst2EvenAndOddAndNotBothEvenAndOdd.contains(x))\n\
    \        val lst2EvenAndOddAndNotBothEvenAndOddAndNotBothEvenAndOdd = lst2EvenAndOddAndNotBothEvenAndOdd.filter(x\
    \ => !lst1EvenAndOddAndNotBothEvenAndOdd.contains(x))\n        val lst1EvenAndOddAndNotBothEvenAndOddAndNotBothEvenAndOddAndNotBothEvenAndOdd\
    \ = lst1EvenAndOddAndNotBothEvenAndOddAndNotBothEvenAndOdd.filter(x => !lst2EvenAndOddAndNotBothEvenAndOddAndNotBothEvenAndOdd.contains(x))\n\
    \        val lst2EvenAndOddAndNotBothEvenAndOddAndNotBothEvenAndOddAndNotBothEvenAndOdd\
    \ = lst2EvenAndOddAndNotBothEvenAndOddAndNotBothEvenAndOdd.filter(x => !lst1EvenAndOddAndNotBothEvenAndOddAndNotBothEvenAndOdd.contains(x))\n\
    \        val lst1EvenAndOddAndNotBothEvenAndOddAndNotBothEvenAndOddAndNotBothEvenAndOddAndNotBothEvenAndOdd\
    \ = lst1EvenAndOddAndNotBothEvenAndOddAndNot\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxv2s192d.scala:26:109 -----------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mlst1EvenAndOddAndNotBothEvenAndOddAndNotBothEvenAndOddAndNotBothEvenAndOddAndNotBothEvenAndOdd\e\
    [0m = lst1EvenAndOddAndNotBothEvenAndOddAndNot\n\e[31m\e[31m   |\e[0m        \
    \                                                                            \
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: lst1EvenAndOddAndNotBothEvenAndOddAndNot\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxv2s192d.scala:27:5\
    \ ---------------------\e[0m\e[0m\n\e[31m27 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979724
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val lst3 = lst1.filter(_ % 2 == 0).sortBy(_)\n       \
    \ val lst4 = lst2.filter(_ % 2 == 0).sortBy(_)\n        val lst5 = lst3.zip(lst4).filter(_._1\
    \ == _._2).map(_._1).sortBy(_)\n        val lst6 = lst5.filter(_ % 2 == 0).sortBy(_)\n\
    \        val lst7 = lst6.filter(_ % 2 == 0).sortBy(_)\n        val lst8 = lst7.filter(_\
    \ % 2 == 0).sortBy(_)\n        val lst9 = lst8.filter(_ % 2 == 0).sortBy(_)\n\
    \        val lst10 = lst9.filter(_ % 2 == 0).sortBy(_)\n        val lst11 = lst10.filter(_\
    \ % 2 == 0).sortBy(_)\n        val lst12 = lst11.filter(_ % 2 == 0).sortBy(_)\n\
    \        val lst13 = lst12.filter(_ % 2 == 0).sortBy(_)\n        val lst14 = lst13.filter(_\
    \ % 2 == 0).sortBy(_)\n        val lst15 = lst14.filter(_ % 2 == 0).sortBy(_)\n\
    \        val lst16 = lst15.filter(_ % 2 == 0).sortBy(_)\n        val lst17 = lst16.filter(_\
    \ % 2 == 0).sortBy(_)\n        val lst18 = lst17.filter(_ % 2 == 0).sortBy(_)\n\
    \        val lst19 = lst18.filter(_ % 2 == 0).sortBy(_)\n        val lst20 = lst19.filter(_\
    \ % 2 == 0).sortBy(_)\n        val lst21 = lst20.filter(_ % 2 == 0).sortBy(_)\n\
    \        val lst22 = lst21.filter(_ % 2 == 0).sortBy(_)\n        val lst23 = lst22.filter(_\
    \ % 2 == 0).sortBy(_)\n        val lst24 = lst23.filter(_ % 2 == 0).sortBy(_)\n\
    \        val lst25 = lst24.filter(_ % 2 == 0).sortBy(_)\n        val lst26 = lst25.filter(_\
    \ % 2 == 0).sortBy(_)\n        val lst27 = lst26.filter(_ % 2 == 0).sortBy(_)\n\
    \        val lst28 = lst27.filter(_ % 2 == 0).sortBy(_)\n        val lst29 = lst28.filter(_\
    \ % 2 == 0).sortBy(_)\n        val lst30 = lst29.filter(_ % 2 == 0).sortBy(_)\n\
    \        val lst31 = lst30.filter(_ % 2 == 0).sortBy(_)\n        val lst32 = lst31.filter(_\
    \ % 2 == 0).sortBy(_)\n        val \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpzmv7la37.scala:44:11 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- Error: /tmp/tmpzmv7la37.scala:14:52 -----------------------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mlst3\e[0m = lst1.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_)\n\e[31m\e[31m   |\e[0m           \
    \                                         ^\e[0m\n\e[31m   |\e[0mNo implicit Ordering\
    \ defined for Any..\n\e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \    scala.math.Ordering.comparatorToOrdering[\e[35mAny\e[0m](\n\e[31m   |\e[0m\
    \      /* missing */summon[java.util.Comparator[Any]]\n\e[31m   |\e[0m    )\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were found that match type\
    \ java.util.Comparator[Any].\n\e[31m\e[31m-- Error: /tmp/tmpzmv7la37.scala:15:52\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m15 |\e[0m       \
    \ \e[33mval\e[0m \e[36mlst4\e[0m = lst2.filter(_ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_)\n\
    \e[31m\e[31m   |\e[0m                                                    ^\e[0m\n\
    \e[31m   |\e[0mNo implicit Ordering defined for Any..\n\e[31m   |\e[0mI found:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m    scala.math.Ordering.comparatorToOrdering[\e\
    [35mAny\e[0m](\n\e[31m   |\e[0m      /* missing */summon[java.util.Comparator[Any]]\n\
    \e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were\
    \ found that match type java.util.Comparator[Any].\n\e[31m\e[31m-- [E081] Type\
    \ Error: /tmp/tmpzmv7la37.scala:16:72 -----------------------------\e[0m\e[0m\n\
    \e[31m16 |\e[0m        \e[33mval\e[0m \e[36mlst5\e[0m = lst3.zip(lst4).filter(_._1\
    \ == _._2).map(_._1).sortBy(_)\n\e[31m\e[31m   |\e[0m                        \
    \                                                ^\e[0m\n\e[31m   |\e[0mMissing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0mI could not infer the type of\
    \ the parameter _$8 of expanded function:\n\e[31m   |\e[0m_$8 => \n\e[31m   |\e\
    [0m  lst3.zip(lst4).filter((_$5"
  stdout: ''
  timestamp: 1659979726
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n        val even = lst1.filter(_ %\
    \ 2 == 0)\n        val odd = lst2.filter(_ % 2 != 0)\n        if (even.size ==\
    \ odd.size) {\n            val evenList = even.sortWith(_ < _)\n            val\
    \ oddList = odd.sortWith(_ < _)\n            if (evenList.size == oddList.size)\
    \ {\n                val evenList = evenList.sortWith(_ < _)\n               \
    \ val oddList = oddList.sortWith(_ < _)\n                if (evenList.size ==\
    \ even.size && oddList.size == odd.size) {\n                    val evenList =\
    \ evenList.sortWith(_ < _)\n                    val oddList = oddList.sortWith(_\
    \ < _)\n                    if (evenList.size == even.size && oddList.size ==\
    \ odd.size) {\n                        val evenList = evenList.sortWith(_ < _)\n\
    \                        val oddList = oddList.sortWith(_ < _)\n             \
    \           if (evenList.size == even.size && oddList.size == odd.size) {\n  \
    \                          val evenList = evenList.sortWith(_ < _)\n         \
    \                   val oddList = oddList.sortWith(_ < _)\n                  \
    \          if (evenList.size == even.size && oddList.size == odd.size) {\n   \
    \                             val evenList = evenList.sortWith(_ < _)\n      \
    \                          val oddList = oddList.sortWith(_ < _)\n           \
    \                     if (evenList.size == even.size && oddList.size == odd.size)\
    \ {\n                                    val evenList = evenList.sortWith(_ <\
    \ _)\n                                    val oddList = oddList.sortWith(_ < _)\n\
    \                                    if (evenList.size == even.size && oddList.size\
    \ == odd.size) {\n                                        val evenList = evenList.sortWith(_\
    \ < _)\n                                        val oddList = oddList.sortWith(_\
    \ < _)\n                                        if (evenList.size == even.size\
    \ && oddList.size == odd.size) {\n                                           \
    \ return \"YES\"\n                                        } else {\n         \
    \                                   return \"NO\"\n                          \
    \              }\n                                    } else {\n             \
    \                           return \"NO\"\n                                  \
    \  }\n                                } else {\n                             \
    \       return \"NO\"\n                                }\n                   \
    \         } else {\n                                return \"NO\"\n          \
    \                  }\n                        } else {\n                     \
    \       return \"NO\"\n                        }\n                    } else {\n\
    \                        return \"NO\"\n                    }\n              \
    \  } else {\n                    return \"NO\"\n                }\n          \
    \  } else {\n                return \"NO\"\n            }\n        } else {\n\
    \            return \"NO\"\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpk35zmiuj.scala:21:31 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                \e[33mval\e[0m \e[36mevenList\e[0m =\
    \ evenList.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m                            \
    \   ^\e[0m\n\e[31m   |\e[0m                               Recursive \e[33mvalue\e\
    [0m \e[35mevenList\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpk35zmiuj.scala:22:30 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m                \e[33mval\e[0m \e[36moddList\e[0m = oddList.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                              ^\e[0m\n\e[31m   |\e\
    [0m                              Recursive \e[33mvalue\e[0m \e[35moddList\e[0m\
    \ needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpk35zmiuj.scala:24:35\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m                    \e\
    [33mval\e[0m \e[36mevenList\e[0m = evenList.sortWith(_ < _)\n\e[31m\e[31m   |\e\
    [0m                                   ^\e[0m\n\e[31m   |\e[0m                \
    \                   Recursive \e[33mvalue\e[0m \e[35mevenList\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpk35zmiuj.scala:25:34\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m                    \e\
    [33mval\e[0m \e[36moddList\e[0m = oddList.sortWith(_ < _)\n\e[31m\e[31m   |\e\
    [0m                                  ^\e[0m\n\e[31m   |\e[0m                 \
    \                 Recursive \e[33mvalue\e[0m \e[35moddList\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpk35zmiuj.scala:27:39\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m                     \
    \   \e[33mval\e[0m \e[36mevenList\e[0m = evenList.sortWith(_ < _)\n\e[31m\e[31m\
    \   |\e[0m                                       ^\e[0m\n\e[31m   |\e[0m     \
    \                                Recursive \e[33mvalu"
  stdout: ''
  timestamp: 1659979721
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val lst3 = lst1.toSet ++ lst2.toSet\n        if (lst3.size\
    \ == lst1.size + lst2.size) {\n            if (lst3.forall(x => x % 2 == 0)) {\n\
    \                return \"YES\"\n            }\n        }\n        return \"NO\"\
    \n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxbpvzh_0.scala:23)\n\tat Problem.main(tmpxbpvzh_0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979725
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val even = lst1.filter(x => x % 2 == 0)\n        val odd\
    \ = lst2.filter(x => x % 2 == 1)\n        val evenAndOdd = even.intersect(odd)\n\
    \        val evenAndEven = even.intersect(even)\n        val evenAndOddAndEven\
    \ = evenAndOdd.intersect(evenAndEven)\n        val evenAndOddAndEvenAndOdd = evenAndOddAndEven.intersect(evenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEven = evenAndOddAndEvenAndOdd.intersect(evenAndOddAndEven)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOdd = evenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEven = evenAndOddAndEvenAndOddAndEvenAndOdd.intersect(evenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd = evenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven)\n\
    \        val evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpw0xhh2_5.scala:27:4 ----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpw0xhh2_5.scala:23:118\
    \ --------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\e[0m = evenAndOddAndEvenAndOddAndEvenAndOddAndEven.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                              ^\e[0m\n\e[31m\
    \   |\e[0mRecursive \e[33mvalue\e[0m \e[35mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw0xhh2_5.scala:24:71\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\e[0m = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw0xhh2_5.scala:25:84\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mevenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven\e[0m\
    \ = evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOdd.intersect(evenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEvenAndOddAndEven)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659979711
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val even = lst1.filter(x => x % 2 == 0)\n        val odd\
    \ = lst2.filter(x => x % 2 == 1)\n        val evenAndOdd = even.zip(odd)\n   \
    \     val evenAndOddToList = evenAndOdd.map(x => x._1 + x._2)\n        val evenAndOddToListToSet\
    \ = evenAndOddToList.map(x => x % 2 == 0)\n        val evenAndOddToSet = evenAndOddToList.toSet\n\
    \        val evenAndOddToSetToList = evenAndOddToSet.toList\n        val evenAndOddToSetToSet\
    \ = evenAndOddToListToSet.map(x => x % 2 == 0)\n        val evenAndOddToSetToSetToList\
    \ = evenAndOddToSetToSet.toList\n        val evenAndOddToSetToSetToSet = evenAndOddToSetToList.toSet\n\
    \        val evenAndOddToSetToSetToList = evenAndOddToSetToSet.toList\n      \
    \  val evenAndOddToSetToSetToSet = evenAndOddToSetToList.toSet\n        val evenAndOddToSetToSetToSetToList\
    \ = evenAndOddToSetToSet.toList\n        val evenAndOddToSetToSetToSetToSet =\
    \ evenAndOddToSetToSet.toSet\n        val evenAndOddToSetToSetToSetToList = evenAndOddToSetToSet.toList\n\
    \        val evenAndOddToSetToSetToSetToSet = evenAndOddToSetToSet.toSet\n   \
    \     val evenAndOddToSetToSetToSetToList = evenAndOddToSetToSet.toList\n    \
    \    val evenAndOddToSetToSetToSetToSet = evenAndOddToSetToSet.toSet\n       \
    \ val evenAndOddToSetToSetToSetToSetToList = evenAndOddToSetToSet.toList\n   \
    \     val evenAndOddToSetToSetToSetToSet = evenAndOddToSetToSet.toSet\n      \
    \  val evenAndOddToSetToSetToSetToSetToList = evenAndOddToSetToSet.toList\n  \
    \      val evenAndOddToSetToSetToSetToSetToSet = evenAndOddToSetToSet.toSet\n\
    \        val evenAnd\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmduxn7ad.scala:37:4 ----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmduxn7ad.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevenAndOddToSetToSetToList\e[0m = evenAndOddToSetToSet.toList\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenAndOddToSetToSetToList is already defined as \e[33mvalue\e\
    [0m \e[35mevenAndOddToSetToSetToList\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmduxn7ad.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mevenAndOddToSetToSetToSet\e\
    [0m = evenAndOddToSetToList.toSet\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenAndOddToSetToSetToSet is already defined as \e[33mvalue\e\
    [0m \e[35mevenAndOddToSetToSetToSet\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmduxn7ad.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mevenAndOddToSetToSetToSetToList\e\
    [0m = evenAndOddToSetToSet.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenAndOddToSetToSetToSetToList is already defined as \e[33mvalue\e\
    [0m \e[35mevenAndOddToSetToSetToSetToList\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmduxn7ad.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevenAndOddToSetToSetToSetToSet\e[0m = evenAndOddToSetToSet.toSet\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659979725
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val lst3 = lst1.toSet - lst2.toSet\n        if(lst3.isEmpty)\
    \ \n            \"NO\"\n        else\n            \"YES\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2zgc9ipj.scala:22)\n\tat Problem.main(tmp2zgc9ipj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979725
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val even = lst1.filter(x => x % 2 == 0)\n        val odd\
    \ = lst2.filter(x => x % 2 != 0)\n        val evenAndOdd = even.intersect(odd)\n\
    \        if (evenAndOdd.isEmpty) \"YES\" else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgi0gr5hz.scala:21)\n\tat Problem.main(tmpgi0gr5hz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979717
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n        val lst3 = lst1.filter(_ %\
    \ 2 == 0).zip(lst2.filter(_ % 2 == 0)).filter(_._1 == _._2).map(_._1).distinct\n\
    \        if(lst3.size == lst1.size)\n            return \"YES\"\n        else\n\
    \            return \"NO\"\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptzw0emca.scala:15:81 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mlst3\e[0m = lst1.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).zip(lst2.filter(_ % \e[31m2\e[0m == \e[31m0\e\
    [0m)).filter(_._1 == _._2).map(_._1).distinct\n\e[31m\e[31m   |\e[0m         \
    \                                                                      ^^^^\e\
    [0m\n\e[31m   |\e[0m                                        value _1 is not a\
    \ member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1659979725
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val lst3 = lst1.zip(lst2).filter(_._1 % 2 == 0).map(_._2)\n\
    \        if (lst3.isEmpty) \"\"\n        else lst3.foldLeft(\"\")(_ + _)\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf97oox1t.scala:19)\n\tat Problem.main(tmpf97oox1t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979726
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val even = lst1.filter(x => x % 2 == 0)\n        val odd\
    \ = lst2.filter(x => x % 2 == 1)\n        val evenOdd = even.zip(odd)\n      \
    \  val evenOddList = evenOdd.toList\n        val evenOddList2 = evenOddList.map(x\
    \ => x._2)\n        val evenOddList3 = evenOddList2.filter(x => x % 2 == 0)\n\
    \        val evenOddList4 = evenOddList3.filter(x => x % 2 == 1)\n        val\
    \ evenOddList5 = evenOddList4.map(x => x._1)\n        val evenOddList6 = evenOddList5.filter(x\
    \ => x % 2 == 0)\n        val evenOddList7 = evenOddList6.filter(x => x % 2 ==\
    \ 1)\n        val evenOddList8 = evenOddList7.map(x => x._1)\n        val evenOddList9\
    \ = evenOddList8.filter(x => x % 2 == 0)\n        val evenOddList10 = evenOddList9.filter(x\
    \ => x % 2 == 1)\n        val evenOddList11 = evenOddList10.map(x => x._1)\n \
    \       val evenOddList12 = evenOddList11.filter(x => x % 2 == 0)\n        val\
    \ evenOddList13 = evenOddList12.filter(x => x % 2 == 1)\n        val evenOddList14\
    \ = evenOddList13.map(x => x._1)\n        val evenOddList15 = evenOddList14.filter(x\
    \ => x % 2 == 0)\n        val evenOddList16 = evenOddList15.filter(x => x % 2\
    \ == 1)\n        val evenOddList17 = evenOddList16.map(x => x._1)\n        val\
    \ evenOddList18 = evenOddList17.filter(x => x % 2 == 0)\n        val evenOddList19\
    \ = evenOddList18.filter(x => x % 2 == 1)\n        val evenOddList20 = evenOddList19.map(x\
    \ => x._1)\n        val evenOddList21 = evenOddList20.filter(x => x % 2 == 0)\n\
    \        val evenOddList22 = evenOddList21.filter(x => x % 2 == 1)\n        val\
    \ evenOddList23 = evenOddList22.map(x => x._1)\n        val evenOddList24 = evenOddList23.filter(x\
    \ => x \n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1b_8zgn9.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1b_8zgn9.scala:21:51\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mevenOddList5\e[0m = evenOddList4.map(\e[36mx\e[0m => x._1)\n\e[31m\e[31m \
    \  |\e[0m                                                 ^^^^\e[0m\n\e[31m  \
    \ |\e[0m                                        value _1 is not a member of Long\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1b_8zgn9.scala:22:54 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mevenOddList6\e[0m = evenOddList5.filter(\e\
    [36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m       \
    \                                             ^^^\e[0m\n\e[31m   |\e[0mvalue %\
    \ is not a member of Nothing, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\e[31m   |\e[0m  import\
    \ Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\e[31m   |\e[0m  import\
    \ Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\e[31m   |\e[0m  import\
    \ Char.char2double\n\e[31m   |\e[0m  import Char.char2float\n\e[31m   |\e[0m \
    \ import Char.char2int\n\e[31m   |\e[0m  import Char.char2long\n\e[31m   |\e[0m\
    \  import math.BigDecimal.javaBigDecimal2bigDecimal\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp1b_8zgn9.scala:23:54 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mevenOddList7\e[0m = evenOddList6.filter(\e\
    [36mx\e[0m => x % \e[31m2\e[0m == \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m       \
    \                                             ^^^\e[0m\n\e[31m   |\e[0mvalue %\
    \ is not a member of Nothing, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\e[31m   |\e[0m  import\
    \ Byte.byte2float\n\e[31m   |\e[0m  import "
  stdout: ''
  timestamp: 1659979727
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val lst3 = lst1 ++ lst2\n        val lst4 = lst3.filter(_\
    \ % 2 == 0)\n        val lst5 = lst4.filter(_ % 2 == 0)\n        if (lst5.isEmpty)\
    \ \"\" else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiqae_yit.scala:20)\n\tat Problem.main(tmpiqae_yit.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979726
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val evens = lst1.filter(x => x % 2 == 0)\n        val\
    \ odds = lst2.filter(x => x % 2 == 1)\n        val exchanged = evens.zip(odds).filter(_._1\
    \ == _._2)\n        if (exchanged.isEmpty) \"\"\n        else exchanged.head._1\
    \ + exchanged.last._1\n    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp34rghjwr.scala:16:49 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mexchanged\e[0m = evens.zip(odds).filter(_._1\
    \ == _._2)\n\e[31m\e[31m   |\e[0m                                            \
    \   ^^^^\e[0m\n\e[31m   |\e[0m                                        value _1\
    \ is not a member of Long\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp34rghjwr.scala:18:48\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33melse\e[0m exchanged.head._1\
    \ + exchanged.last._1\n\e[31m\e[31m   |\e[0m                                 ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Found:    Long\n\e[31m  \
    \ |\e[0m                                 Required: String\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979726
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val even = lst1.filter(x => x % 2 == 0)\n        val odd\
    \ = lst2.filter(x => x % 2 != 0)\n        val evenOdd = even.zip(odd)\n      \
    \  val evenOdd2 = evenOdd.filter(x => x._1 == x._2)\n        val evenOdd3 = evenOdd2.filter(x\
    \ => x._1 == x._2)\n        val evenOdd4 = evenOdd3.filter(x => x._1 == x._2)\n\
    \        val evenOdd5 = evenOdd4.filter(x => x._1 == x._2)\n        val evenOdd6\
    \ = evenOdd5.filter(x => x._1 == x._2)\n        val evenOdd7 = evenOdd6.filter(x\
    \ => x._1 == x._2)\n        val evenOdd8 = evenOdd7.filter(x => x._1 == x._2)\n\
    \        val evenOdd9 = evenOdd8.filter(x => x._1 == x._2)\n        val evenOdd10\
    \ = evenOdd9.filter(x => x._1 == x._2)\n        val evenOdd11 = evenOdd10.filter(x\
    \ => x._1 == x._2)\n        val evenOdd12 = evenOdd11.filter(x => x._1 == x._2)\n\
    \        val evenOdd13 = evenOdd12.filter(x => x._1 == x._2)\n        val evenOdd14\
    \ = evenOdd13.filter(x => x._1 == x._2)\n        val evenOdd15 = evenOdd14.filter(x\
    \ => x._1 == x._2)\n        val evenOdd16 = evenOdd15.filter(x => x._1 == x._2)\n\
    \        val evenOdd17 = evenOdd16.filter(x => x._1 == x._2)\n        val evenOdd18\
    \ = evenOdd17.filter(x => x._1 == x._2)\n        val evenOdd19 = evenOdd18.filter(x\
    \ => x._1 == x._2)\n        val evenOdd20 = evenOdd19.filter(x => x._1 == x._2)\n\
    \        val evenOdd21 = evenOdd20.filter(x => x._1 == x._2)\n        val evenOdd22\
    \ = evenOdd21.filter(x => x._1 == x._2)\n        val evenOdd23 = evenOdd22.filter(x\
    \ => x._1 == x._2)\n        val evenOdd24 = evenOdd23.filter(x => x._1 == x._2)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0dfdm4n2.scala:40:5\
    \ ---------------------\e[0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979726
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        val even = lst1.filter(_ % 2 == 0)\n        val odd =\
    \ lst2.filter(_ % 2 == 1)\n        val evenAndOdd = even.zip(odd)\n        val\
    \ evenAndOddSet = evenAndOdd.toSet\n        val lst1Set = lst1.toSet\n       \
    \ if (evenAndOddSet.size == lst1Set.size) {\n            val evenAndOddSet2 =\
    \ evenAndOdd.toSet\n            val lst2Set = lst2.toSet\n            if (evenAndOddSet2.size\
    \ == lst2Set.size) {\n                val evenAndOddSet3 = evenAndOdd2.toSet\n\
    \                if (evenAndOddSet3.size == lst2Set.size) {\n                \
    \    val evenAndOddSet4 = evenAndOdd3.toSet\n                    if (evenAndOddSet4.size\
    \ == lst2Set.size) {\n                        val evenAndOddSet5 = evenAndOdd4.toSet\n\
    \                        if (evenAndOddSet5.size == lst2Set.size) {\n        \
    \                    val evenAndOddSet6 = evenAndOdd5.toSet\n                \
    \            if (evenAndOddSet6.size == lst2Set.size) {\n                    \
    \            val evenAndOddSet7 = evenAndOdd6.toSet\n                        \
    \        if (evenAndOddSet7.size == lst2Set.size) {\n                        \
    \            val evenAndOddSet8 = evenAndOdd7.toSet\n                        \
    \            if (evenAndOddSet8.size == lst2Set.size) {\n                    \
    \                    val evenAndOddSet9 = evenAndOdd8.toSet\n                \
    \                        if (evenAndOddSet9.size == lst2Set.size) {\n        \
    \                                    return \"YES\"\n                        \
    \                } else {\n                                            return\
    \ \"NO\"\n                                        }\n                        \
    \            } else {\n                                        return \"NO\"\n\
    \                                    }\n                                } else\
    \ {\n                                    return \"NO\"\n                     \
    \           }\n                            } else {\n                        \
    \        return \"NO\"\n                            }\n                      \
    \  } else {\n                            return \"NO\"\n                     \
    \   }\n                    } else {\n                        return \"NO\"\n \
    \                   }\n                } else {\n                    return \"\
    NO\"\n                }\n            } else {\n                return \"NO\"\n\
    \            }\n        } else {\n            return \"NO\"\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](2l.toLong, 1l.toLong, 4l.toLong,\
    \ 3l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 4l.toLong))).equals((\"\
    YES\")));\n    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)),\
    \ (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](3l.toLong,\
    \ 2l.toLong, 6l.toLong, 1l.toLong, 8l.toLong, 9l.toLong)), (List[Long](3l.toLong,\
    \ 5l.toLong, 5l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](100l.toLong, 200l.toLong)), (List[Long](200l.toLong,\
    \ 200l.toLong))).equals((\"YES\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpy6198kvc.scala:23:37 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                \e[33mval\e[0m \e[36mevenAndOddSet3\e\
    [0m = evenAndOdd2.toSet\n\e[31m\e[31m   |\e[0m                               \
    \      ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                     Not\
    \ found: evenAndOdd2\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpy6198kvc.scala:25:41\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m                    \e[33mval\e\
    [0m \e[36mevenAndOddSet4\e[0m = evenAndOdd3.toSet\n\e[31m\e[31m   |\e[0m     \
    \                                    ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                                  Not found: evenAndOdd3\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpy6198kvc.scala:27:45 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                        \e[33mval\e[0m \e[36mevenAndOddSet5\e\
    [0m = evenAndOdd4.toSet\n\e[31m\e[31m   |\e[0m                               \
    \              ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                             \
    \                Not found: evenAndOdd4\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpy6198kvc.scala:29:49 ------------------------\e[0m\e\
    [0m\n\e[31m29 |\e[0m                            \e[33mval\e[0m \e[36mevenAndOddSet6\e\
    [0m = evenAndOdd5.toSet\n\e[31m\e[31m   |\e[0m                               \
    \                  ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \                        Not found: evenAndOdd5\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpy6198kvc.scala:31:53 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                                \e[33mval\e[0m \e[36mevenAndOddSet7\e\
    [0m = evenAndOdd6.toSet\n\e[31m\e[31m   |\e[0m                               \
    \                      ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       "
  stdout: ''
  timestamp: 1659979726
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code goes here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpblp1a3w7.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code goes here\e[0m\n\e[31m15 |\e\
    [0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979701
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n        val lst3 = lst1.filter(_%2==0)\n\
    \        val lst4 = lst2.filter(_%2==0)\n        if(lst3.isEmpty==true && lst4.isEmpty==true){\n\
    \            return \"NO\"\n        }\n        else if(lst3.isEmpty==true && lst4.isEmpty==false){\n\
    \            return \"NO\"\n        }\n        else if(lst3.isEmpty==false &&\
    \ lst4.isEmpty==true){\n            return \"NO\"\n        }\n        else if(lst3.isEmpty==false\
    \ && lst4.isEmpty==false){\n            return \"YES\"\n        }\n        else{\n\
    \            return \"NO\"\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp77rzlk0y.scala:35)\n\tat Problem.main(tmp77rzlk0y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979728
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this problem, you will implement a function that takes two lists\
    \ of numbers,\n    // and determines whether it is possible to perform an exchange\
    \ of elements\n    // between them to make lst1 a list of only even numbers.\n\
    \    // There is no limit on the number of exchanged elements between lst1 and\
    \ lst2.\n    // If it is possible to exchange elements between the lst1 and lst2\
    \ to make\n    // all the elements of lst1 to be even, return \"YES\".\n    //\
    \ Otherwise, return \"NO\".\n    // For example:\n    // It is assumed that the\
    \ input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2 : List[Long])\
    \ : String = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"NO\")));\n\
    \    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
    \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
    \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
    \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
    \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
    NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
    \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
    \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj77vvp_k.scala:13:66\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m    \e[33mdef\e[0m \e[36mexchange\e\
    [0m(\e[36mlst1\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mlst2\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m]) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m         \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                                        Found:    Unit\n\e\
    [31m   |\e[0m                                                        Required:\
    \ String\n\e[31m14 |\e[0m        \e[34m// Your code here\e[0m\n\e[31m15 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979700
