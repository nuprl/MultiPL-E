language: scala
name: HumanEval_68_pluck
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val evensSorted\
    \ = evens.sortWith((x, y) => x < y)\n        val evensSortedSortedWithIndex =\
    \ evensSorted.zipWithIndex\n        val smalest_value = evensSortedSortedWithIndex.minBy(_._1)._2\n\
    \        val smalest_index = evensSortedSortedWithIndex.minBy(_._1)._1\n     \
    \   val smalest_even = evensSortedSortedWithIndex.filter(x => x._1 == smalest_value).minBy(_._1)._2\n\
    \        val smalest_even_index = evensSortedSortedWithIndex.filter(x => x._1\
    \ == smalest_value).minBy(_._1)._1\n        val smalest_even_even = evensSortedSortedWithIndex.filter(x\
    \ => x._1 == smalest_value).filter(x => x._2 == smalest_even).minBy(_._1)._2\n\
    \        val smalest_even_even_index = evensSortedSortedWithIndex.filter(x =>\
    \ x._1 == smalest_value).filter(x => x._2 == smalest_even).minBy(_._1)._1\n  \
    \      val smalest_even_even_even = evensSortedSortedWithIndex.filter(x => x._1\
    \ == smalest_value).filter(x => x._2 == smalest_even).filter(x => x._2 == smalest_even_even).minBy(_._1)._2\n\
    \        val smalest_even_even_even_index = evensSortedSortedWithIndex.filter(x\
    \ => x._1 == smalest_value).filter(x => x._2 == smalest_even).filter(x => x._2\
    \ == smalest_even_even).minBy(_._1)._1\n        val smalest_even_even_even_even\
    \ = evensSortedSortedWithIndex.filter(x => x._1 == smalest_value).filter(x =>\
    \ x._2 == smalest_even).filter(x => x._2 == smalest_even_even).filter(x => x._2\
    \ == smalest_even_even_even).minBy(_._1)._2\n        val smalest_even_even_even_even_index\
    \ = evensSortedSortedWithIndex.filter(x => x._1 == smalest_value).filter(x =>\
    \ x._2 == smalest_even).filter(x => x._2 == smalest_even_even).filter(x => x._2\
    \ == smalest_even_even_even).minBy(_._1)._1\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo__en359.scala:35:5\
    \ ---------------------\e[0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009814
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_even = evens(smalest_index)\n        val smalest_even_index =\
    \ evens.indexOf(smalest_even)\n        val smalest_even_value = evens(smalest_even_index)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_value)\n  \
    \      val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8dwtjk_q.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = evens.indexOf(smalest_even_index_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8dwtjk_q.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = evens.indexOf(smalest_even_index_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8dwtjk_q.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = evens.indexOf(smalest_even_index_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8dwtjk_q.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = evens.indexOf(smalest_even_index_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31"
  stdout: ''
  timestamp: 1660009815
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val evensSorted\
    \ = evens.sortWith((x, y) => x < y)\n        val smallestEven = evensSorted.head\n\
    \        val smallestEvenIndex = evensSorted.indexOf(0)\n        val smallestEvenValue\
    \ = smallestEven % 2\n        val smallestEvenIndex = smallestEvenIndex + 1\n\
    \        val smallestEvenValue = smallestEvenValue % 2\n        val smallestEvenIndex\
    \ = smallestEvenIndex + 1\n        val smallestEvenValue = smallestEvenValue %\
    \ 2\n        val smallestEvenIndex = smallestEvenIndex + 1\n        val smallestEvenValue\
    \ = smallestEvenValue % 2\n        val smallestEvenIndex = smallestEvenIndex +\
    \ 1\n        val smallestEvenValue = smallestEvenValue % 2\n        val smallestEvenIndex\
    \ = smallestEvenIndex + 1\n        val smallestEvenValue = smallestEvenValue %\
    \ 2\n        val smallestEvenIndex = smallestEvenIndex + 1\n        val smallestEvenValue\
    \ = smallestEvenValue % 2\n        val smallestEvenIndex = smallestEvenIndex +\
    \ 1\n        val smallestEvenValue = smallestEvenValue % 2\n        val smallestEvenIndex\
    \ = smallestEvenIndex + 1\n        val smallestEvenValue = smallestEvenValue %\
    \ 2\n        val smallestEvenIndex = smallestEvenIndex + 1\n        val smallestEvenValue\
    \ = smallestEvenValue % 2\n        val smallestEvenIndex = smallestEvenIndex +\
    \ 1\n        val smallestEvenValue = smallestEvenValue % 2\n        val smallestEvenIndex\
    \ = smallestEvenIndex + 1\n        val smallestEvenValue = smallestEvenValue %\
    \ 2\n        val smallestEvenIndex = smallestEvenIndex + 1\n        val smallestEvenValue\
    \ = smallestEvenValue % 2\n        val smallestEvenIndex = smallestEvenIndex +\
    \ 1\n        val smallestEvenValue = smallestEvenValue % 2\n        val smallestEvenIndex\
    \ = smallestEvenIndex + 1\n        val smallestEvenValue = smallestEvenValue %\
    \ 2\n        val smallestEvenIndex = smallestEvenIndex + 1\n        val smallestEvenValue\
    \ = smallestEvenValue % 2\n        val smallestEvenIndex = smallestEvenIndex +\
    \ 1\n        val smallestEvenValue = smallestEvenValue % 2\n        val smallestEvenIndex\
    \ = smallestEvenIndex + 1\n        val smallestEvenValue = smallestEvenValue %\
    \ 2\n        val smallestEvenIndex = smallestEvenIndex + 1\n        val smallestEvenValue\
    \ = smallestEven\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgmpagd7_.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpgmpagd7_.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m =\
    \ smallestEvenValue % \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpgmpagd7_.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpgmpagd7_.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m =\
    \ smallestEvenValue % \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpgmpagd7_.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        "
  stdout: ''
  timestamp: 1660009815
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0).sortBy(x => x)\n      \
    \  val smalest_value = evens.head\n        val smalest_index = evens.indexOf(0)\n\
    \        val evens_with_smallest_value = evens.filter(x => x == smalest_value)\n\
    \        if (evens_with_smallest_value.isEmpty) List(smalest_value, smalest_index)\n\
    \        else evens_with_smallest_value.head\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpc_9d8m7d.scala:27:39\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33melse\e[0m evens_with_smallest_value.head\n\
    \e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m             Found:    Long\n\e[31m   |\e[0m             Required: \e\
    [1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_even = evens(smalest_index)\n        val smalest_even_index =\
    \ evens.indexOf(smalest_even)\n        val smalest_even_value = evens(smalest_even_index)\n\
    \        val smalest_even_index_list = evens.indexOf(smalest_even)\n        val\
    \ smalest_even_index_list_list = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = even\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb80je3pc.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_list_list_list_list_list_list_list_list\e\
    [0m = evens.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_list_list_list_list_list_list_list_list\
    \ is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index_list_list_list_list_list_list_list_list_list\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpb80je3pc.scala:40:12 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_list_list_list_list_list_list_list_list_list_list\e\
    [0m = evens.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_list_list_list_list_list_list_list_list_list_list\
    \ is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index_list_list_list_list_list_list_list_list_list_list_list\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpb80je3pc.scala:42:12 ---------------------------\e[0m\e[0m\n\e\
    [31m42 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list\e\
    [0m = evens.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNo"
  stdout: ''
  timestamp: 1660009813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        if (evens.isEmpty)\
    \ List()\n        else {\n            val minEven = evens.min\n            val\
    \ minIndex = arr.indexOf(minEven)\n            val minValue = arr.min\n      \
    \      val minIndexList = List(minIndex, minEven)\n            val minValueList\
    \ = List(minValue, minEven)\n            val minIndexSet = mutable.HashSet[Int]()\n\
    \            val minValueSet = mutable.HashSet[Int]()\n            val minIndexSet2\
    \ = mutable.HashSet[Int]()\n            val minValueSet2 = mutable.HashSet[Int]()\n\
    \            val minIndexSet3 = mutable.HashSet[Int]()\n            val minValueSet3\
    \ = mutable.HashSet[Int]()\n            val minIndexSet4 = mutable.HashSet[Int]()\n\
    \            val minValueSet4 = mutable.HashSet[Int]()\n            val minIndexSet5\
    \ = mutable.HashSet[Int]()\n            val minValueSet5 = mutable.HashSet[Int]()\n\
    \            val minIndexSet6 = mutable.HashSet[Int]()\n            val minValueSet6\
    \ = mutable.HashSet[Int]()\n            val minIndexSet7 = mutable.HashSet[Int]()\n\
    \            val minValueSet7 = mutable.HashSet[Int]()\n            val minIndexSet8\
    \ = mutable.HashSet[Int]()\n            val minValueSet8 = mutable.HashSet[Int]()\n\
    \            val minIndexSet9 = mutable.HashSet[Int]()\n            val minValueSet9\
    \ = mutable.HashSet[Int]()\n            val minIndexSet10 = mutable.HashSet[Int]()\n\
    \            val minValueSet10 = mutable.HashSet[Int]()\n            val minIndexSet11\
    \ = mutable.HashSet[Int]()\n            val minValueSet11 = mutable.HashSet[Int]()\n\
    \            val minIndexSet12 = mutable.HashSet[Int]()\n            val minValueSet12\
    \ = mutable.HashSet[Int]()\n            val minIndexSet13 = mutable.HashSet[Int]()\n\
    \            val minValueSet13 = mutable.HashSet[Int]()\n            val minIndexSet14\
    \ = mutable.HashSet[Int]()\n            val minValueSet14 = mutable.HashSet[Int]()\n\
    \            val minIndexSet15 = mutable.HashSet[Int]()\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpb1x31_my.scala:73:0 ----------------------------\e\
    [0m\e[0m\n\e[31m73 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb1x31_my.scala:30:30\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m            \e[33mval\e[0m\
    \ \e[36mminIndexSet\e[0m = mutable.HashSet[\e[35mInt\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                              ^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpb1x31_my.scala:31:30 ------------------------\e[0m\e[0m\n\e[31m31 |\e\
    [0m            \e[33mval\e[0m \e[36mminValueSet\e[0m = mutable.HashSet[\e[35mInt\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                              ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                              Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpb1x31_my.scala:32:31 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e[0m \e[36mminIndexSet2\e[0m =\
    \ mutable.HashSet[\e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                   \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                               Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb1x31_my.scala:33:31\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e[0m\
    \ \e[36mminValueSet2\e[0m = mutable.HashSet[\e[35mInt\e[0m]()\n\e[31m\e[31m  \
    \ |\e[0m                               ^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpb1x31_my.scala:34:31 ------------------------\e[0m\e\
    [0m\n\e[31m34 |\e[0m            \e[33mval\e[0m \e[36mminIndexSet3\e[0m = mutable.HashSet[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                               ^^^^^^^\e\
    [0m\n\e["
  stdout: ''
  timestamp: 1660009815
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_even = evens(smalest_index)\n        val smalest_even_index =\
    \ arr.indexOf(smalest_even)\n        val smalest_even_value = smalest_even\n \
    \       val smalest_even_index_value = smalest_even_index\n        val smalest_even_index_value\
    \ = smalest_even_index_value\n        val smalest_even_index_value = smalest_even_index_value\n\
    \        val smalest_even_index_value = smalest_even_index_value\n        val\
    \ smalest_even_index_value = smalest_even_index_value\n        val smalest_even_index_value\
    \ = smalest_even_index_value\n        val smalest_even_index_value = smalest_even_index_value\n\
    \        val smalest_even_index_value = smalest_even_index_value\n        val\
    \ smalest_even_index_value = smalest_even_index_value\n        val smalest_even_index_value\
    \ = smalest_even_index_value\n        val smalest_even_index_value = smalest_even_index_value\n\
    \        val smalest_even_index_value = smalest_even_index_value\n        val\
    \ smalest_even_index_value = smalest_even_index_value\n        val smalest_even_index_value\
    \ = smalest_even_index_value\n        val smalest_even_index_value = smalest_even_index_value\n\
    \        val smalest_even_index_value = smalest_even_index_value\n        val\
    \ smalest_even_index_value = smalest_even_index_value\n        val smalest_even_index_value\
    \ = smalest_even_index_value\n        val smalest_even_index_value = smalest_even_index_value\n\
    \        val smalest_even_index_value = smalest_even_index_value\n        val\
    \ smalest_even_index_value = smalest_even_index_value\n        val smalest_even_index_value\
    \ = smalest_even_index_value\n        val smalest_even_index_value = smalest_even_index_value\n\
    \        val smalest_even_index_value = smalest_even_index_value\n        val\
    \ smalest_even_index_value = smalest_even_index_value\n        val smalest_even_index_value\
    \ = smalest_even_index_value\n        val smalest_even_index_value = smalest_even_index_value\n\
    \        val smalest_even_index_value = smalest_even_index_value\n        val\
    \ smalest_even_index_value = smalest_even_index_value\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwgg_glkv.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = smalest_even_index_value\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwgg_glkv.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = smalest_even_index_value\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwgg_glkv.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = smalest_even_index_value\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwgg_glkv.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = smalest_even_index_value\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] "
  stdout: ''
  timestamp: 1660009815
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_evens = evens.take(smalest_index)\n        val smalest_evens_index\
    \ = evens.indexOf(smalest_evens.min) match {\n            case Some(index) =>\
    \ index\n            case None => -1\n        }\n        val smalest_evens_value\
    \ = smalest_evens.min\n        val smalest_evens_index = evens.indexOf(smalest_evens_value)\n\
    \        val smalest_evens_index = smalest_evens_index match {\n            case\
    \ Some(index) => index\n            case None => -1\n        }\n        val smalest_evens_value\
    \ = smalest_evens.min\n        val smalest_evens_index = evens.indexOf(smalest_evens_value)\n\
    \        val smalest_evens_index = smalest_evens_index match {\n            case\
    \ Some(index) => index\n            case None => -1\n        }\n        val smalest_evens_value\
    \ = smalest_evens.min\n        val smalest_evens_index = evens.indexOf(smalest_evens_value)\n\
    \        val smalest_evens_index = smalest_evens_index match {\n            case\
    \ Some(index) => index\n            case None => -1\n        }\n        val smalest_evens_value\
    \ = smalest_evens.min\n        val smalest_evens_index = evens.indexOf(smalest_evens_value)\n\
    \        val smalest_evens_index = smalest_evens_index match {\n            case\
    \ Some(index) => index\n            case None => -1\n        }\n        val smalest_evens_value\
    \ = smalest_evens.min\n        val smalest_evens_index = evens.indexOf(smalest_evens_value)\n\
    \        val smalest_evens_index = smalest_evens_index match {\n            case\
    \ Some(index) => index\n            case None => -1\n        }\n        val smalest_evens_value\
    \ = smalest_evens.min\n        val smalest_evens_index = evens.indexOf(smalest_evens_value)\n\
    \        val smalest_evens_index = smalest_evens_index match {\n            case\
    \ Some(index) => index\n            case None => -1\n        }\n        val smalest_evens_value\
    \ = smalest_evens.min\n        val smalest_evens_index = evens.indexOf(smalest_evens_value)\n\
    \        val smalest_evens_\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3uin4v2w.scala:69:4 ----------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3uin4v2w.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_evens_index\e[0m = evens.indexOf(smalest_evens_value)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evens_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evens_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp3uin4v2w.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens_index\e[0m\
    \ = smalest_evens_index \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\
    \e[31m   |\e[0msmalest_evens_index is already defined as \e[33mvalue\e[0m \e[35msmalest_evens_index\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m33 |\e[0m         \
    \   \e[33mcase\e[0m Some(index) => index\n\e[31m34 |\e[0m            \e[33mcase\e\
    [0m None => -\e[31m1\e[0m\n\e[31m35 |\e[0m        }\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp3uin4v2w.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens_value\e[0m = smalest_evens.min\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msmalest_evens_value is already defined as \e[33mvalue\e[0m \e[35msmalest_evens_value\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp3uin4v2w.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens_index\e[0m = evens.indexOf(smalest_evens_value)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660009814
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOfMin\n        val smalest_even\
    \ = evens.find(x => x == smalest_value)\n        val smalest_even_index = evens.indexOf(smalest_even)\n\
    \        val smalest_even_value = smalest_even._2\n        val smalest_even_index_value\
    \ = smalest_even_index_value._2\n        val smalest_even_index_value = smalest_even_index_value._2\n\
    \        val smalest_even_index_value = smalest_even_index_value._2\n        val\
    \ smalest_even_index_value = smalest_even_index_value._2\n        val smalest_even_index_value\
    \ = smalest_even_index_value._2\n        val smalest_even_index_value = smalest_even_index_value._2\n\
    \        val smalest_even_index_value = smalest_even_index_value._2\n        val\
    \ smalest_even_index_value = smalest_even_index_value._2\n        val smalest_even_index_value\
    \ = smalest_even_index_value._2\n        val smalest_even_index_value = smalest_even_index_value._2\n\
    \        val smalest_even_index_value = smalest_even_index_value._2\n        val\
    \ smalest_even_index_value = smalest_even_index_value._2\n        val smalest_even_index_value\
    \ = smalest_even_index_value._2\n        val smalest_even_index_value = smalest_even_index_value._2\n\
    \        val smalest_even_index_value = smalest_even_index_value._2\n        val\
    \ smalest_even_index_value = smalest_even_index_value._2\n        val smalest_even_index_value\
    \ = smalest_even_index_value._2\n        val smalest_even_index_value = smalest_even_index_value._2\n\
    \        val smalest_even_index_value = smalest_even_index_value._2\n        val\
    \ smalest_even_index_value = smalest_even_index_value._2\n        val smalest_even_index_value\
    \ = smalest_even_index_value._2\n        val smalest_even_index_value = smalest_even_index_value._2\n\
    \        val smalest_even_index_value = smalest_even_index_value._2\n        val\
    \ smalest_even_index_value = smalest_even_index_value._2\n        val smalest_even_index_value\
    \ = smalest_even_index_value._2\n        val smalest_\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpngtmfurl.scala:54:4 ----------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpngtmfurl.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_even_index_value\e[0m = smalest_even_index_value._2\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpngtmfurl.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = smalest_even_index_value._2\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpngtmfurl.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = smalest_even_index_value._2\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpngtmfurl.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = smalest_even_index_value._2\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_"
  stdout: ''
  timestamp: 1660009816
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_even = evens(smalest_index)\n        val smalest_even_index =\
    \ smalest_index\n        val smalest_even_value = smalest_value\n        val smalest_even_value_and_index\
    \ = smalest_value + smalest_even_index\n        val smalest_even_value_and_index_list\
    \ = List(smalest_even_value_and_index, smalest_even_value_and_index_list)\n  \
    \      val smalest_even_value_and_index_list_sorted = smalest_even_value_and_index_list.sortWith(_\
    \ < _)\n        val smalest_even_value_and_index_list_sorted_reversed = smalest_even_value_and_index_list_sorted.reverse\n\
    \        val smalest_even_value_and_index_list_sorted_reversed_sorted = smalest_even_value_and_index_list_sorted_reversed.sortWith(_\
    \ < _)\n        val smalest_even_value_and_index_list_sorted_reversed_sorted_reversed\
    \ = smalest_even_value_and_index_list_sorted_reversed_sorted.reverse\n       \
    \ val smalest_even_value_and_index_list_sorted_reversed_sorted_reversed_sorted\
    \ = smalest_even_value_and_index_list_sorted_reversed_sorted_reversed.sortWith(_\
    \ < _)\n        val smalest_even_value_and_index_list_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = smalest_even_value_and_index_list_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val smalest_even_value_and_index_list_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = smalest_even_value_and_index_list_sorted_reversed_sorted_reversed_sorted_reversed.sortWith(_\
    \ < _)\n        val smalest_even_value_and_index_list_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = smalest_even_value_and_index_list_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val smalest_even_value_and_index_list_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = smalest_even_value_and_index_list_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed.sortWith(_\
    \ < _)\n        val smalest_even_value_and_index_list_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = smalest_even_value_and_index_list_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val smalest_even_value_and_index_list_\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2uma75gl.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp2uma75gl.scala:29:83\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_even_value_and_index_list\e[0m = List(smalest_even_value_and_index,\
    \ smalest_even_value_and_index_list)\n\e[31m\e[31m   |\e[0m                  \
    \                                                                 ^\e[0m\n\e[31m\
    \   |\e[0m            Recursive \e[33mvalue\e[0m \e[35msmalest_even_value_and_index_list\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2uma75gl.scala:41:5\
    \ ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009815
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_even = evens(smalest_index)\n        val smalest_even_index =\
    \ evens.indexOf(smalest_even)\n        val smalest_even_value = evens(smalest_even_index)\n\
    \        val smalest_even_index_list = evens.indexOf(smalest_even)\n        val\
    \ smalest_even_value_list = evens.indexOf(smalest_even_value)\n        val smalest_even_index_list_list\
    \ = evens.indexOf(smalest_even_index_list)\n        val smalest_even_value_list\
    \ = evens.indexOf(smalest_even_value_list)\n        val smalest_even_index_list_list_list\
    \ = evens.indexOf(smalest_even_index_list_list)\n        val smalest_even_value_list\
    \ = evens.indexOf(smalest_even_value_list)\n        val smalest_even_index_list_list_list_list\
    \ = evens.indexOf(smalest_even_index_list_list_list)\n        val smalest_even_value_list\
    \ = evens.indexOf(smalest_even_value_list)\n        val smalest_even_index_list_list_list_list_list\
    \ = evens.indexOf(smalest_even_index_list_list_list_list)\n        val smalest_even_value_list\
    \ = evens.indexOf(smalest_even_value_list)\n        val smalest_even_index_list_list_list_list_list\
    \ = evens.indexOf(smalest_even_index_list_list_list_list)\n        val smalest_even_value_list\
    \ = evens.indexOf(smalest_even_value_list)\n        val smalest_even_index_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even_index_list_list_list_list_list)\n        val smalest_even_value_list\
    \ = evens.indexOf(smalest_even_value_list)\n        val smalest_even_index_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even_index_list_list_list_list_list)\n        val smalest_even_value_list\
    \ = evens.indexOf(smalest_even_value_list)\n        val smalest_even_index_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even_index_list_list_list_list_list_list)\n        val\
    \ smalest_even_value_list = evens.indexOf(smalest_even_value_list)\n        val\
    \ smalest_even_index_list_list_list_list_list_list_list = evens.indexOf(smalest_even_index_list_list_list_list_list_list_list)\n\
    \        val smalest_even_value_list = evens.indexOf(smalest_even_value_list)\n\
    \        val smalest_even_index_list_list_\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4senfyn8.scala:49:4 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4senfyn8.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_even_value_list\e[0m = evens.indexOf(smalest_even_value_list)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_value_list is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_value_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4senfyn8.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value_list\e\
    [0m = evens.indexOf(smalest_even_value_list)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_value_list is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_value_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4senfyn8.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value_list\e\
    [0m = evens.indexOf(smalest_even_value_list)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_value_list is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_value_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4senfyn8.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value_list\e\
    [0m = evens.indexOf(smalest_even_value_list)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660009814
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(_ % 2 == 0)\n        val smallest = evens.min\n\
    \        val index = evens.indexOf(smallest)\n        val result = if (index ==\
    \ -1) Nil else List(smallest, index)\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxfe2njn7.scala:26:8\
    \ ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[AnyVal])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009812
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(_ % 2 == 0)\n        val smallestEven =\
    \ evens.min\n        val smallestIndex = evens.indexOf(smallestEven)\n       \
    \ val smalestValue = smallestEven % 2 == 0 ? smallestEven : smallestEven + 1\n\
    \        val result = List(smalestValue, smallestIndex)\n        if (arr.isEmpty)\
    \ result\n        else result.::(pluck(arr.filter(_ != smallestEven)))\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyc7070wn.scala:25:79 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36msmalestValue\e[0m = smallestEven\
    \ % \e[31m2\e[0m == \e[31m0\e[0m ? smallestEven : \e[35msmallestEven\e[0m \e[35m+\e\
    [0m \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \                                         ^\e[0m\n\e[31m   |\e[0m            \
    \                                           Not found: type +\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpyc7070wn.scala:25:49 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36msmalestValue\e[0m = smallestEven\
    \ % \e[31m2\e[0m == \e[31m0\e[0m ? smallestEven : \e[35msmallestEven\e[0m \e[35m+\e\
    [0m \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \         ^^^\e[0m\n\e[31m   |\e[0m                                          value\
    \ ? is not a member of Int\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyc7070wn.scala:27:25\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mif\e[0m (arr.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                         ^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                         Found:    (result : List[Int])\n\e[31m   |\e\
    [0m                         Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpyc7070wn.scala:28:22 --------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33melse\e[0m result.::(pluck(arr.filter(_\
    \ != smallestEven)))\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m             Found:    List[Matchable]\n\e[31m   |\e[0m  \
    \           Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009815
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(_ % 2 == 0)\n        val smallest = evens.min\n\
    \        val index = evens.indexOf(smallest)\n        val result = List(smallest,\
    \ index)\n        if (arr.isEmpty) result\n        else pluck(arr.drop(index))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwzecfo61.scala:26:25\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mif\e[0m (arr.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                         ^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                         Found:    (result : List[AnyVal])\n\e[31m   |\e\
    [0m                         Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_even_value = evens(smalest_index)\n        val smalest_even_index\
    \ = evens.indexOf(smalest_even_value)\n        val smalest_even_index_list = evens.take(smalest_even_index).toList\n\
    \        val smalest_even_index_list_with_zero = smalest_even_index_list.filter(_\
    \ != 0)\n        val smalest_even_index_list_with_zero_with_zero = smalest_even_index_list_with_zero.filter(_\
    \ != 0)\n        val smalest_even_index_list_with_zero_with_zero_with_zero = smalest_even_index_list_with_zero_with_zero.filter(_\
    \ != 0)\n        val smalest_even_index_list_with_zero_with_zero_with_zero_with_zero\
    \ = smalest_even_index_list_with_zero_with_zero_with_zero.filter(_ != 0)\n   \
    \     val smalest_even_index_list_with_zero_with_zero_with_zero_with_zero_with_zero\
    \ = smalest_even_index_list_with_zero_with_zero_with_zero_with_zero.filter(_ !=\
    \ 0)\n        val smalest_even_index_list_with_zero_with_zero_with_zero_with_zero_with_zero_with_zero\
    \ = smalest_even_index_list_with_zero_with_zero_with_zero_with_zero_with_zero.filter(_\
    \ != 0)\n        val smalest_even_index_list_with_zero_with_zero_with_zero_with_zero_with_zero_with_zero_with_zero\
    \ = smalest_even_index_list_with_zero_with_zero_with_zero_with_zero_with_zero.filter(_\
    \ != 0)\n        val smalest_even_index_list_with_zero_with_zero_with_zero_with_zero_with_zero_with_zero_with_zero_with_zero\
    \ = smalest_even_index_list_with_zero_with_zero_with_zero_with_zero_with_zero.filter(_\
    \ != 0)\n        val smalest_even_index_list_with_zero_with_zero_with_zero_with_zero_with_zero_with_zero_with_zero_with_zero_with_zero\
    \ = smalest_even_index_list_with_zero_with_zero_with_zero_with_zero_with_zero.filter(_\
    \ != 0)\n        val smalest_even_index_list_with_zero_with_zero_with_zero_with_zero_with_zero_with_zero_with_zero_with_zero_with_zero_with_zero\
    \ = smalest_even_index_list_with_zero_with_zero_with_zero_with_zero_with_zero.filter(_\
    \ != 0)\n        val smalest_even_index_list_with_zero_with_zero_with_zero_with_zero_with_zero_with_zero_with_zero_with_zero_with_zero_with_zero\
    \ = smalest_even_index_list_with_zero_with_zero_with_zero_with_zero_with_zero.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpf9bz9zzu.scala:39:4 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpf9bz9zzu.scala:38:12 ---------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_with_zero_with_zero_with_zero_with_zero_with_zero_with_zero_with_zero_with_zero_with_zero_with_zero\e\
    [0m = smalest_even_index_list_with_zero_with_zero_with_zero_with_zero_with_zero.\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_with_zero_with_zero_with_zero_with_zero_with_zero_with_zero_with_zero_with_zero_with_zero_with_zero\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  smalest_even_index_list_with_zero_with_zero_with_zero_with_zero_with_zero_with_zero_with_zero_with_zero_with_zero_with_zero\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpf9bz9zzu.scala:39:5 ---------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009814
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        if (evens.isEmpty)\
    \ Nil\n        else {\n            val smalest_value = evens.min\n           \
    \ val index = evens.indexOf(smalest_value)\n            val smalest_value_and_index\
    \ = smalest_value -> index\n            evens.filter(_ % 2 == 0).sortWith(_ <\
    \ smalest_value).takeWhile(_ < smalest_value).map(smalest_value_and_index).toList\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpny0bn51c.scala:28:46 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            evens.filter(_ % \e[31m2\e[0m == \e[31m0\e\
    [0m).sortWith(_ < smalest_value).takeWhile(_ < smalest_value).map(smalest_value_and_index).toList\n\
    \e[31m\e[31m   |\e[0m                                              ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Wrong number of parameters,\
    \ expected: 2\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpny0bn51c.scala:28:98\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m            evens.filter(_ %\
    \ \e[31m2\e[0m == \e[31m0\e[0m).sortWith(_ < smalest_value).takeWhile(_ < smalest_value).map(smalest_value_and_index).toList\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                          ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Found:    (smalest_value_and_index : (Long, Int))\n\
    \e[31m   |\e[0m                       Required: Long => Any\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009814
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smallest =\
    \ evens.min\n        val index = evens.indexOf(smallest)\n        val result:\
    \ List[Long] = List(smallest, index)\n        if (evens.isEmpty) result\n    \
    \    else result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsdnt435l.scala:31)\n\tat Problem.main(tmpsdnt435l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009816
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0).sorted\n        val even\
    \ = evens.head\n        val index = evens.indexOf(0)\n        val result = List(even,\
    \ index)\n        if (evens.isEmpty) result\n        else result.sortBy(-_)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp634eza2k.scala:26:27\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mif\e[0m (evens.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    (result : List[AnyVal])\n\e[31m\
    \   |\e[0m                           Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp634eza2k.scala:27:27 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33melse\e[0m result.sortBy(-_)\n\e[31m\e[31m\
    \   |\e[0m                           ^^\e[0m\n\e[31m   |\e[0mvalue unary_- is\
    \ not a member of AnyVal, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- Error: /tmp/tmp634eza2k.scala:27:30 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33melse\e[0m result.sortBy(-_)\n\e[31m\e[31m\
    \   |\e[0m                              ^\e[0m\n\e[31m   |\e[0mambiguous given\
    \ instances: both \e[33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m and \e[33mobject\e[0m \e[35mDeprecatedDoubleOrdering\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[B] of parameter ord of \e[33mmethod\e\
    [0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n3 errors found\n"
  stdout: ''
  timestamp: 1660009815
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_even = evens(smalest_index)\n        val smalest_even_index =\
    \ arr.indexOf(smalest_even)\n        val smalest_even_value = smalest_even\n \
    \       val smalest_even_index_value = smalest_even_index\n        val smalest_even_index_value\
    \ = smalest_even_index_value\n        val smalest_even_index_value = smalest_even_index_value\n\
    \        val smalest_even_index_value = smalest_even_index_value\n        val\
    \ smalest_even_index_value = smalest_even_index_value\n        val smalest_even_index_value\
    \ = smalest_even_index_value\n        val smalest_even_index_value = smalest_even_index_value\n\
    \        val smalest_even_index_value = smalest_even_index_value\n        val\
    \ smalest_even_index_value = smalest_even_index_value\n        val smalest_even_index_value\
    \ = smalest_even_index_value\n        val smalest_even_index_value = smalest_even_index_value\n\
    \        val smalest_even_index_value = smalest_even_index_value\n        val\
    \ smalest_even_index_value = smalest_even_index_value\n        val smalest_even_index_value\
    \ = smalest_even_index_value\n        val smalest_even_index_value = smalest_even_index_value\n\
    \        val smalest_even_index_value = smalest_even_index_value\n        val\
    \ smalest_even_index_value = smalest_even_index_value\n        val smalest_even_index_value\
    \ = smalest_even_index_value\n        val smalest_even_index_value = smalest_even_index_value\n\
    \        val smalest_even_index_value = smalest_even_index_value\n        val\
    \ smalest_even_index_value = smalest_even_index_value\n        val smalest_even_index_value\
    \ = smalest_even_index_value\n        val smalest_even_index_value = smalest_even_index_value\n\
    \        val smalest_even_index_value = smalest_even_index_value\n        val\
    \ smalest_even_index_value = smalest_even_index_value\n        val smalest_even_index_value\
    \ = smalest_even_index_value\n        val smalest_even_index_value = smalest_even_index_value\n\
    \        val smalest_even_index_value = smalest_even_index_value\n        val\
    \ smalest_even_index_value = smalest_even_index_value\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwgg_glkv.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = smalest_even_index_value\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwgg_glkv.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = smalest_even_index_value\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwgg_glkv.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = smalest_even_index_value\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwgg_glkv.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = smalest_even_index_value\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] "
  stdout: ''
  timestamp: 1660009815
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_even_value = evens(smalest_index)\n        val smalest_even_index\
    \ = evens.indexOf(smalest_even_value)\n        val smalest_even_value_with_index\
    \ = smalest_value + smalest_index\n        val smalest_even_index_with_index =\
    \ smalest_index + smalest_even_value\n        val smalest_even_value_with_index_with_index\
    \ = smalest_value + smalest_index + smalest_even_value\n        val smalest_even_index_with_index_with_index\
    \ = smalest_index + smalest_even_value + smalest_even_index\n        val smalest_even_value_with_index_with_index_with_index\
    \ = smalest_value + smalest_index + smalest_even_value + smalest_even_index +\
    \ smalest_even_value_with_index\n        val smalest_even_index_with_index_with_index_with_index\
    \ = smalest_index + smalest_even_value + smalest_even_index + smalest_even_value_with_index\
    \ + smalest_even_index_with_index\n        val smalest_even_index_with_index_with_index_with_index_with_index\
    \ = smalest_index + smalest_even_value + smalest_even_index + smalest_even_value_with_index\
    \ + smalest_even_index_with_index + smalest_even_index_with_index_with_index\n\
    \        val smalest_even_index_with_index_with_index_with_index_with_index_with_index\
    \ = smalest_index + smalest_even_value + smalest_even_index + smalest_even_value_with_index\
    \ + smalest_even_index_with_index + smalest_even_index_with_index_with_index +\
    \ smalest_even_index_with_index_with_index_with_index\n        val smalest_even_index_with_index_with_index_with_index_with_index_with_index_with_index\
    \ = smalest_index + smalest_even_value + smalest_even_index + smalest_even_value_with_index\
    \ + smalest_even_index_with_index + smalest_even_index_with_index_with_index +\
    \ smalest_even_index_with_index_with_index_with_index + smalest_even_index_with_index_with_index_with_index_with_index\n\
    \        val smalest_even_index_with_index_with_index_with_index_with_index_with_index_with_index_with_index\
    \ = smalest_index + smalest_even_value + smalest_even_index + smalest_even_value_with\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpuhomhb74.scala:36:168 -----------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_with_index_with_index_with_index_with_index_with_index_with_index_with_index\e\
    [0m = smalest_index + smalest_even_value + smalest_even_index + smalest_even_value_with\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \                                    ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                      Not found: smalest_even_value_with\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuhomhb74.scala:37:5\
    \ ---------------------\e[0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009814
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_even = evens(smalest_index)\n        val smalest_even_index =\
    \ evens.indexOf(smalest_even)\n        val smalest_even_index_plus_one = smalest_even_index\
    \ + 1\n        val smalest_even_index_plus_two = smalest_even_index + 2\n    \
    \    val smalest_even_index_plus_three = smalest_even_index + 3\n        val smalest_even_index_plus_four\
    \ = smalest_even_index + 4\n        val smalest_even_index_plus_five = smalest_even_index\
    \ + 5\n        val smalest_even_index_plus_six = smalest_even_index + 6\n    \
    \    val smalest_even_index_plus_seven = smalest_even_index + 7\n        val smalest_even_index_plus_eight\
    \ = smalest_even_index + 8\n        val smalest_even_index_plus_nine = smalest_even_index\
    \ + 9\n        val smalest_even_index_plus_ten = smalest_even_index + 10\n   \
    \     val smalest_even_index_plus_eleven = smalest_even_index + 11\n        val\
    \ smalest_even_index_plus_twelve = smalest_even_index + 12\n        val smalest_even_index_plus_thirteen\
    \ = smalest_even_index + 13\n        val smalest_even_index_plus_fourteen = smalest_even_index\
    \ + 14\n        val smalest_even_index_plus_fifteen = smalest_even_index + 15\n\
    \        val smalest_even_index_plus_sixteen = smalest_even_index + 16\n     \
    \   val smalest_even_index_plus_seventeen = smalest_even_index + 17\n        val\
    \ smalest_even_index_plus_eighteen = smalest_even_index + 18\n        val smalest_even_index_plus_nineteen\
    \ = smalest_even_index + 19\n        val smalest_even_index_plus_twenty = smalest_even_index\
    \ + 20\n        val smalest_even_index_plus_twenty_one = smalest_even_index +\
    \ 21\n        val smalest_even_index_plus_twenty_two = smalest_even_index + 22\n\
    \        val smalest_even_index_plus_twenty_three = smalest_even_index + 23\n\
    \        val smalest_\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvefi8l6h.scala:51:4 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpvefi8l6h.scala:51:5 ---------------------\e[0m\e[0m\n\e[31m51 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009814
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val even = arr.filter(x => x % 2 == 0).sortBy(x => x).takeWhile(x\
    \ => x < arr.last).reverse\n        val index = arr.lastIndexWhere(x => x % 2\
    \ == 0)\n        val smalest_value = even.head\n        val smalest_index = index\n\
    \        val result = if (smalest_value == 0) List(smalest_value, smalest_index)\
    \ else even.takeWhile(x => x < smalest_value).reverse.zip(index).filter(x => x._1\
    \ < x._2)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpku3vwpnt.scala:26:136\
    \ -------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mresult\e\
    [0m = \e[33mif\e[0m (smalest_value == \e[31m0\e[0m) List(smalest_value, smalest_index)\
    \ \e[33melse\e[0m even.takeWhile(\e[36mx\e[0m => x < smalest_value).reverse.zip(index).filter(\e\
    [36mx\e[0m => x._1 < x._2)\n\e[31m\e[31m   |\e[0m                            \
    \                                                                            \
    \                                ^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                            Found:    (index : Int)\n\e[31m   |\e[0m        \
    \                                     Required: IterableOnce[Any]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E051] Reference Error: /tmp/tmpku3vwpnt.scala:26:160 -----------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mif\e\
    [0m (smalest_value == \e[31m0\e[0m) List(smalest_value, smalest_index) \e[33melse\e\
    [0m even.takeWhile(\e[36mx\e[0m => x < smalest_value).reverse.zip(index).filter(\e\
    [36mx\e[0m => x._1 < x._2)\n\e[31m\e[31m   |\e[0m                            \
    \                                                                            \
    \                                                   ^^^^^^\e[0m\n\e[31m   |\e\
    [0mAmbiguous overload. The overloaded alternatives of \e[33mmethod\e[0m \e[35m<\e\
    [0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double):\
    \ Boolean\n\e[31m   |\e[0m (x: Float): Boolean\n\e[31m   |\e[0m (x: Long): Boolean\n\
    \e[31m   |\e[0m (x: Int): Boolean\n\e[31m   |\e[0m (x: Char): Boolean\n\e[31m\
    \   |\e[0m (x: Short): Boolean\n\e[31m   |\e[0m (x: Byte): Boolean\n\e[31m   |\e\
    [0mall match arguments ((x._2 : => Nothing))\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpku3vwpnt.scala:27:8 ---------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        result\n\e[31m\e[31m   |\e[0m        ^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    (result : List[AnyVal | (Long, Nothing)])\n\
    \e[31m   |\e"
  stdout: ''
  timestamp: 1660009816
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val even = evens.min\n\
    \        val index = evens.indexOf(even)\n        val result: List[Long] = if\
    \ (index == -1) Nil else List(even, index)\n        return result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpv20lbhap.scala:30)\n\tat Problem.main(tmpv20lbhap.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009816
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val evensSorted\
    \ = evens.sortWith(_ < _)\n        val smalest_value = evensSorted.head\n    \
    \    val smalest_index = evensSorted.indexOf(0)\n        val smalest_even = evensSorted.takeWhile(_\
    \ < smalest_value).last\n        val smalest_even_index = evensSorted.indexOf(smalest_even)\n\
    \        val smalest_even_index = evensSorted.indexOf(smalest_even)\n        val\
    \ smalest_even_index = evensSorted.indexOf(smalest_even)\n        val smalest_even_index\
    \ = evensSorted.indexOf(smalest_even)\n        val smalest_even_index = evensSorted.indexOf(smalest_even)\n\
    \        val smalest_even_index = evensSorted.indexOf(smalest_even)\n        val\
    \ smalest_even_index = evensSorted.indexOf(smalest_even)\n        val smalest_even_index\
    \ = evensSorted.indexOf(smalest_even)\n        val smalest_even_index = evensSorted.indexOf(smalest_even)\n\
    \        val smalest_even_index = evensSorted.indexOf(smalest_even)\n        val\
    \ smalest_even_index = evensSorted.indexOf(smalest_even)\n        val smalest_even_index\
    \ = evensSorted.indexOf(smalest_even)\n        val smalest_even_index = evensSorted.indexOf(smalest_even)\n\
    \        val smalest_even_index = evensSorted.indexOf(smalest_even)\n        val\
    \ smalest_even_index = evensSorted.indexOf(smalest_even)\n        val smalest_even_index\
    \ = evensSorted.indexOf(smalest_even)\n        val smalest_even_index = evensSorted.indexOf(smalest_even)\n\
    \        val smalest_even_index = evensSorted.indexOf(smalest_even)\n        val\
    \ smalest_even_index = evensSorted.indexOf(smalest_even)\n        val smalest_even_index\
    \ = evensSorted.indexOf(smalest_even)\n        val smalest_even_index = evensSorted.indexOf(smalest_even)\n\
    \        val smalest_even_index = evensSorted.indexOf(smalest_even)\n        val\
    \ smalest_even_index = evensSorted.indexOf(smalest_even)\n        val smalest_even_index\
    \ = evensSorted.indexOf(smalest_even)\n        val smalest_\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpk4mhmq0c.scala:52:4 ----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpk4mhmq0c.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_even_index\e[0m = evensSorted.indexOf(smalest_even)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_even_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpk4mhmq0c.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m\
    \ = evensSorted.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_even_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpk4mhmq0c.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m\
    \ = evensSorted.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_even_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpk4mhmq0c.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m\
    \ = evensSorted.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m"
  stdout: ''
  timestamp: 1660009815
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val even = arr.filter(x => x % 2 == 0).sortBy(x => x).takeWhile(x\
    \ => x < arr.last).reverse\n        if (even.isEmpty) List()\n        else {\n\
    \            val smalest_value = even.head\n            val smalest_index = even.indexOf(0)\n\
    \            val index = arr.indexOf(smalest_value)\n            if (index ==\
    \ -1) List()\n            else {\n                val result = List(smalest_value,\
    \ smalest_index)\n                arr.drop(index).takeWhile(x => x != smalest_value).reverse.foreach(x\
    \ => result += List(x))\n                result\n            }\n        }\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp193584qu.scala:31:95 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                arr.drop(index).takeWhile(\e[36mx\e[0m\
    \ => x != smalest_value).reverse.foreach(\e[36mx\e[0m => result += List(x))\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \                              ^^^^^^^^^\e[0m\n\e[31m   |\e[0m      value += is\
    \ not a member of List[AnyVal] - did you mean result.!=?\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp193584qu.scala:32:16 --------------------\e[0m\e\
    [0m\n\e[31m32 |\e[0m                result\n\e[31m\e[31m   |\e[0m            \
    \    ^^^^^^\e[0m\n\e[31m   |\e[0m                Found:    (result : List[AnyVal])\n\
    \e[31m   |\e[0m                Required: List[Long]\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009835
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_even = evens(smalest_index)\n        val smalest_even_index =\
    \ smalest_index\n        val smalest_even_value = smalest_value\n        val smalest_even_index_value\
    \ = smalest_index\n        val smalest_even_index_value = smalest_value\n    \
    \    val smalest_even_index_value = smalest_value\n        val smalest_even_index_value\
    \ = smalest_value\n        val smalest_even_index_value = smalest_value\n    \
    \    val smalest_even_index_value = smalest_value\n        val smalest_even_index_value\
    \ = smalest_value\n        val smalest_even_index_value = smalest_value\n    \
    \    val smalest_even_index_value = smalest_value\n        val smalest_even_index_value\
    \ = smalest_value\n        val smalest_even_index_value = smalest_value\n    \
    \    val smalest_even_index_value = smalest_value\n        val smalest_even_index_value\
    \ = smalest_value\n        val smalest_even_index_value = smalest_value\n    \
    \    val smalest_even_index_value = smalest_value\n        val smalest_even_index_value\
    \ = smalest_value\n        val smalest_even_index_value = smalest_value\n    \
    \    val smalest_even_index_value = smalest_value\n        val smalest_even_index_value\
    \ = smalest_value\n        val smalest_even_index_value = smalest_value\n    \
    \    val smalest_even_index_value = smalest_value\n        val smalest_even_index_value\
    \ = smalest_value\n        val smalest_even_index_value = smalest_value\n    \
    \    val smalest_even_index_value = smalest_value\n        val smalest_even_index_value\
    \ = smalest_value\n        val smalest_even_index_value = smalest_value\n    \
    \    val smalest_even_index_value = smalest_value\n        val smalest_even_index_value\
    \ = smalest_value\n        val smalest_even_index_value = smalest_value\n    \
    \    val smalest_even_index_value = smalest_value\n        val smalest_even_index_value\
    \ = smalest_value\n        val smalest_even_index_value = smalest_value\n    \
    \    val smalest_even_index_value = smalest_value\n        val smalest_even_index_value\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpd6kv_tv8.scala:61:38 ---------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                      ^\e[0m\n\e\
    [31m   |\e[0m                                      expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpd6kv_tv8.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_even_index_value\e[0m = smalest_value\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msmalest_even_index_value\
    \ is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index_value\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpd6kv_tv8.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e[0m = smalest_value\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpd6kv_tv8.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = smalest_value\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpd6kv_tv8.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = smalest_va"
  stdout: ''
  timestamp: 1660009833
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0).sortBy(x => x).reverse\n\
    \        val smalest_value = evens.head\n        val smalest_index = evens.indexWhere(x\
    \ => x == smalest_value)\n        val smalest_even = evens(smalest_index)\n  \
    \      val smalest_even_index = evens.indexWhere(x => x == smalest_even)\n   \
    \     val smalest_even_value = evens(smalest_even_index)\n        val smalest_even_index_list\
    \ = evens.take(smalest_even_index_list)\n        val smalest_even_index_list =\
    \ smalest_even_index_list.sortBy(x => x).reverse\n        val smalest_even_index_list\
    \ = smalest_even_index_list.take(1)\n        val smalest_even_index_list = smalest_even_index_list.sortBy(x\
    \ => x).reverse\n        val smalest_even_index_list = smalest_even_index_list.take(1)\n\
    \        val smalest_even_index_list = smalest_even_index_list.sortBy(x => x).reverse\n\
    \        val smalest_even_index_list = smalest_even_index_list.take(1)\n     \
    \   val smalest_even_index_list = smalest_even_index_list.sortBy(x => x).reverse\n\
    \        val smalest_even_index_list = smalest_even_index_list.take(1)\n     \
    \   val smalest_even_index_list = smalest_even_index_list.sortBy(x => x).reverse\n\
    \        val smalest_even_index_list = smalest_even_index_list.take(1)\n     \
    \   val smalest_even_index_list = smalest_even_index_list.sortBy(x => x).reverse\n\
    \        val smalest_even_index_list = smalest_even_index_list.take(1)\n     \
    \   val smalest_even_index_list = smalest_even_index_list.sortBy(x => x).reverse\n\
    \        val smalest_even_index_list = smalest_even_index_list.take(1)\n     \
    \   val smalest_even_index_list = smalest_even_index_list.sortBy(x => x).reverse\n\
    \        val smalest_even_index_list = smalest_even_index_list.take(1)\n     \
    \   val smalest_even_index_list = smalest_even_index_list.sortBy(x => x).reverse\n\
    \        val smalest_even_index_list = smalest_even_index_list.take(1)\n     \
    \   val smalest_even_index_list = smalest_even_index_list.sortBy(x => x).reverse\n\
    \        val smalest_even_index_list = smalest_even_index_list.take(1)\n     \
    \   val smalest_even_index_list = smalest_even_index_list.sort\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv_n_p_js.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list\e\
    [0m = smalest_even_index_list.sortBy(\e[36mx\e[0m => x).reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv_n_p_js.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list\e\
    [0m = smalest_even_index_list.take(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msmalest_even_index_list is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index_list\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv_n_p_js.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list\e[0m = smalest_even_index_list.sortBy(\e\
    [36mx\e[0m => x).reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv_n_p_js.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list\e\
    [0m = smalest_even_index_list.take(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msmalest_even_index_list is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index_list\e\
    [0m\n\e["
  stdout: ''
  timestamp: 1660009834
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val even = arr.filter(_ % 2 == 0).sortBy(x => x).take(1)\n    \
    \    if (even.isEmpty) List()\n        else {\n            val smalest_value =\
    \ even.head\n            val index = arr.indexOf(smalest_value)\n            val\
    \ result = List(smalest_value, index)\n            if (arr.contains(smalest_value))\
    \ result :+ smalest_value\n            else result\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp987ssckc.scala:28:45\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m            \e[33mif\e[0m (arr.contains(smalest_value))\
    \ result :+ smalest_value\n\e[31m\e[31m   |\e[0m                             \
    \                ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                              Found:    List[\e[1m\e[31mAnyVal\e[0m]\n\e[31m\
    \   |\e[0m                                             Required: List[\e[1m\e\
    [32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp987ssckc.scala:29:17\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m            \e[33melse\e[0m result\n\
    \e[31m\e[31m   |\e[0m                 ^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \      Found:    (result : List[AnyVal])\n\e[31m   |\e[0m                 Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009836
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_even = evens(smalest_index)\n        val smalest_even_index =\
    \ evens.indexOf(smalest_even)\n        val smalest_even_index = smalest_even_index\
    \ + 1\n        val smalest_even = evens(smalest_even_index)\n        val smalest_even_index\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index = smalest_even_index\
    \ + 1\n        val smalest_even = evens(smalest_even_index)\n        val smalest_even_index\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index = smalest_even_index\
    \ + 1\n        val smalest_even = evens(smalest_even_index)\n        val smalest_even_index\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index = smalest_even_index\
    \ + 1\n        val smalest_even = evens(smalest_even_index)\n        val smalest_even_index\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index = smalest_even_index\
    \ + 1\n        val smalest_even = evens(smalest_even_index)\n        val smalest_even_index\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index = smalest_even_index\
    \ + 1\n        val smalest_even = evens(smalest_even_index)\n        val smalest_even_index\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index = smalest_even_index\
    \ + 1\n        val smalest_even = evens(smalest_even_index)\n        val smalest_even_index\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index = smalest_even_index\
    \ + 1\n        val smalest_even = evens(smalest_even_index)\n        val smalest_even_index\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index = smalest_even_index\
    \ + 1\n        val smalest_even = evens(smalest_even_index)\n        val smalest_even_index\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index = smalest_even_index\
    \ + 1\n        val smalest_even = evens(smalest_even_index)\n        val smalest_even_index\
    \ = evens.indexOf(sm\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7jiw0psl.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7jiw0psl.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_even_index\e[0m = smalest_even_index + \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp7jiw0psl.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36msmalest_even\e[0m = evens(smalest_even_index)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msmalest_even is already defined as \e[33mvalue\e[0m \e[35msmalest_even\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp7jiw0psl.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m = evens.indexOf(smalest_even)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_even_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp7jiw0psl.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m\
    \ = smalest_even_index + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_even_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ m"
  stdout: ''
  timestamp: 1660009835
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val evensSorted\
    \ = evens.sorted\n        val smallestEven = evensSorted.head\n        val smallestEvenIndex\
    \ = evensSorted.indexOfFirst { x => x == smallestEven }\n        val smallestEvenValue\
    \ = smallestEven\n        val smallestEvenIndexList = List(smallestEvenIndex,\
    \ smallestEvenIndex + 1)\n        val smallestEvenValueList = List(smallestEvenValue,\
    \ smallestEvenValue + 1)\n        val smallestEvenIndexAndValue = smallestEvenIndexAndValueList(smallestEvenIndexList,\
    \ smallestEvenValueList)\n        smallestEvenIndexAndValue\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqciwx0ws.scala:25:44 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ evensSorted.indexOfFirst { \e[36mx\e[0m => x == smallestEven }\n\e[31m\e[31m\
    \   |\e[0m                                ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                        value indexOfFirst is not a member of List[Long]\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqciwx0ws.scala:29:40 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndexAndValue\e\
    [0m = smallestEvenIndexAndValueList(smallestEvenIndexList, smallestEvenValueList)\n\
    \e[31m\e[31m   |\e[0m                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                Not found: smallestEvenIndexAndValueList\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009836
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_even = evens(smalest_index)\n        val smalest_even_index =\
    \ smalest_index\n        val smalest_even_value = smalest_value\n        val smalest_even_index\
    \ = smalest_index\n        val smalest_even_value = smalest_value\n        val\
    \ smalest_even_index = smalest_index\n        val smalest_even_value = smalest_value\n\
    \        val smalest_even_index = smalest_index\n        val smalest_even_value\
    \ = smalest_value\n        val smalest_even_index = smalest_index\n        val\
    \ smalest_even_value = smalest_value\n        val smalest_even_index = smalest_index\n\
    \        val smalest_even_value = smalest_value\n        val smalest_even_index\
    \ = smalest_index\n        val smalest_even_value = smalest_value\n        val\
    \ smalest_even_index = smalest_index\n        val smalest_even_value = smalest_value\n\
    \        val smalest_even_index = smalest_index\n        val smalest_even_value\
    \ = smalest_value\n        val smalest_even_index = smalest_index\n        val\
    \ smalest_even_value = smalest_value\n        val smalest_even_index = smalest_index\n\
    \        val smalest_even_value = smalest_value\n        val smalest_even_index\
    \ = smalest_index\n        val smalest_even_value = smalest_value\n        val\
    \ smalest_even_index = smalest_index\n        val smalest_even_value = smalest_value\n\
    \        val smalest_even_index = smalest_index\n        val smalest_even_value\
    \ = smalest_value\n        val smalest_even_index = smalest_index\n        val\
    \ smalest_even_value = smalest_value\n        val smalest_even_index = smalest_index\n\
    \        val smalest_even_value = smalest_value\n        val smalest_even_index\
    \ = smalest_index\n        val smalest_even_value = smalest_value\n        val\
    \ smalest_even_index = smalest_index\n        val smalest_even_value = smalest_value\n\
    \        val smalest_even_index = smalest_index\n        val smalest_even_value\
    \ = smalest_value\n        val smalest_\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnt13t900.scala:65:4 ----------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnt13t900.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_even_index\e[0m = smalest_index\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msmalest_even_index\
    \ is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpnt13t900.scala:29:12 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value\e[0m = smalest_value\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msmalest_even_value is already defined as \e[33mvalue\e[0m \e[35msmalest_even_value\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpnt13t900.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m = smalest_index\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpnt13t900.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value\e[0m = smalest_value\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msmalest_even_value is already defined as \e[33mvalue\e[0m \e[35msmalest_even_value\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- "
  stdout: ''
  timestamp: 1660009835
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(_ % 2 == 0)\n        val even = evens.min\n\
    \        val index = evens.indexOf(even)\n        val result = arr.filter(_ ==\
    \ even).sortWith(_ < _).take(index).map(_ + 1)\n        if (result.isEmpty) List()\n\
    \        else result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_9c3c3jj.scala:30)\n\tat Problem.main(tmp_9c3c3jj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009839
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_even = evens(smalest_index)\n        val smalest_even_index =\
    \ evens.indexOf(smalest_even)\n        val smalest_even_value = evens(smalest_even_index)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_value)\n  \
    \      val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8dwtjk_q.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = evens.indexOf(smalest_even_index_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8dwtjk_q.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = evens.indexOf(smalest_even_index_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8dwtjk_q.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = evens.indexOf(smalest_even_index_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8dwtjk_q.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = evens.indexOf(smalest_even_index_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31"
  stdout: ''
  timestamp: 1660009815
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val evensSorted\
    \ = evens.sortWith(_ < _)\n        val smallestEven = evensSorted.head\n     \
    \   val smallestEvenIndex = evensSorted.indexOf(0)\n        val smallestEvenValue\
    \ = smallestEven / 2\n        val smallestEvenIndex = smallestEvenIndex + 1\n\
    \        val result: List[Long] = List(smallestEvenValue, smallestEvenIndex)\n\
    \        if (evensSorted.isEmpty) result\n        else result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2papwz_c.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009828
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val even = arr.filter(x => x % 2 == 0).sortBy(x => x).take(1)\n\
    \        if (even.isEmpty) List()\n        else {\n            val smalest_value\
    \ = even.head\n            val smalest_index = even.indexWhere(x => x == smalest_value)\n\
    \            val index = smalest_index\n            val smalest_even = even.filter(x\
    \ => x % 2 == 0)\n            val smalest_even_value = smalest_even.head\n   \
    \         val smalest_even_count = smalest_even.count\n            val smalest_even_count_index\
    \ = smalest_even_count - 1\n            val smalest_even_count_index = smalest_even_count_index\
    \ - 1\n            val smalest_even_count_index = smalest_even_count_index - 1\n\
    \            val smalest_even_count_index = smalest_even_count_index - 1\n   \
    \         val smalest_even_count_index = smalest_even_count_index - 1\n      \
    \      val smalest_even_count_index = smalest_even_count_index - 1\n         \
    \   val smalest_even_count_index = smalest_even_count_index - 1\n            val\
    \ smalest_even_count_index = smalest_even_count_index - 1\n            val smalest_even_count_index\
    \ = smalest_even_count_index - 1\n            val smalest_even_count_index = smalest_even_count_index\
    \ - 1\n            val smalest_even_count_index = smalest_even_count_index - 1\n\
    \            val smalest_even_count_index = smalest_even_count_index - 1\n   \
    \         val smalest_even_count_index = smalest_even_count_index - 1\n      \
    \      val smalest_even_count_index = smalest_even_count_index - 1\n         \
    \   val smalest_even_count_index = smalest_even_count_index - 1\n            val\
    \ smalest_even_count_index = smalest_even_count_index - 1\n            val smalest_even_count_index\
    \ = smalest_even_count_index - 1\n            val smalest_even_count_index = smalest_even_count_index\
    \ - 1\n            val smalest_even_count_index = smalest_even_count_index - 1\n\
    \            val smalest_even_count_index = smalest_even_count_index - 1\n   \
    \         val smalest_even_count_index = smalest_even_count_index - 1\n      \
    \      val smalest_even_count_index = smalest_even_count_index - 1\n         \
    \   val smalest_\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpe7lqurd5.scala:54:4 ----------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpe7lqurd5.scala:67:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m67 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpe7lqurd5.scala:32:16 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m            \e[33mval\e[0m \e[36msmalest_even_count_index\e[0m =\
    \ smalest_even_count_index - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_count_index is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_count_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe7lqurd5.scala:33:16 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e[0m \e[36msmalest_even_count_index\e\
    [0m = smalest_even_count_index - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m         \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0msmalest_even_count_index is already defined as \e[33mvalue\e[0m \e[35msmalest_even_count_index\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpe7lqurd5.scala:34:16 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m            \e[33mval\e[0m \e[36msmalest_even_count_index\e[0m =\
    \ smalest_even_count_index - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_count_index is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_count_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe7lqurd5.scala:35:16 --------------------"
  stdout: ''
  timestamp: 1660009839
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val evensSorted\
    \ = evens.sortWith((x, y) => x < y)\n        val smallestEven = evensSorted.head\n\
    \        val smallestEvenIndex = evensSorted.indexOf(0)\n        val smallestEvenValue\
    \ = smallestEven\n        val smallestEvenIndex = smallestEvenIndex\n        val\
    \ evensSorted = evensSorted.drop(1)\n        val evensSorted = evensSorted.takeWhile(x\
    \ => x % 2 == 0)\n        val evensSorted = evensSorted.sortWith((x, y) => x <\
    \ y)\n        val smallestEven = evensSorted.head\n        val smallestEvenIndex\
    \ = evensSorted.indexOf(0)\n        val smallestEvenValue = smallestEven\n   \
    \     val smallestEvenIndex = smallestEvenIndex\n        val evensSorted = evensSorted.drop(1)\n\
    \        val evensSorted = evensSorted.takeWhile(x => x % 2 == 0)\n        val\
    \ evensSorted = evensSorted.sortWith((x, y) => x < y)\n        val smallestEven\
    \ = evensSorted.head\n        val smallestEvenIndex = evensSorted.indexOf(0)\n\
    \        val smallestEvenValue = smallestEven\n        val smallestEvenIndex =\
    \ smallestEvenIndex\n        val evensSorted = evensSorted.drop(1)\n        val\
    \ evensSorted = evensSorted.takeWhile(x => x % 2 == 0)\n        val evensSorted\
    \ = evensSorted.sortWith((x, y) => x < y)\n        val smallestEven = evensSorted.head\n\
    \        val smallestEvenIndex = evensSorted.indexOf(0)\n        val smallestEvenValue\
    \ = smallestEven\n        val smallestEvenIndex = smallestEvenIndex\n        val\
    \ evensSorted = evensSorted.drop(1)\n        val evensSorted = evensSorted.takeWhile(x\
    \ => x % 2 == 0)\n        val evensSorted = evensSorted.sortWith((x, y) => x <\
    \ y)\n        val smallestEven = evensSorted.head\n        val smallestEvenIndex\
    \ = evensSorted.indexOf(0)\n        val smallestEvenValue = smallestEven\n   \
    \     val smallestEvenIndex = smallestEvenIndex\n        val evensSorted = evensSorted.drop(1)\n\
    \        val evensSorted = evensSorted.takeWhile(x => x % 2 == 0)\n        val\
    \ evensSorted = evensSorted.sortWith((x, y) => x < \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp1tr_re8p.scala:58:60 ---------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evensSorted.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => x < \n\e[31m\e[31m   |\e[0m                     \
    \                                       ^\e[0m\n\e[31m   |\e[0m              \
    \                         expression expected but \e[31m'}'\e[0m found\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1tr_re8p.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp1tr_re8p.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evensSorted.drop(\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp1tr_re8p.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evensSorted.takeWhile(\e\
    [36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp1tr_re8p.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36meven"
  stdout: ''
  timestamp: 1660009837
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(_ % 2 == 0)\n        if (evens.isEmpty)\
    \ List()\n        else {\n            val smalest_value = evens.min\n        \
    \    val smalest_index = evens.indexOf(smalest_value)\n            val smalest_even\
    \ = evens(smalest_index)\n            val smalest_even_index = evens.indexOf(smalest_even)\n\
    \            val smalest_even_value = evens(smalest_even_index)\n            val\
    \ smalest_even_index_plus_one = smalest_even_index + 1\n            val smalest_even_index_plus_two\
    \ = smalest_even_index + 2\n            val smalest_even_index_plus_three = smalest_even_index\
    \ + 3\n            val smalest_even_index_plus_four = smalest_even_index + 4\n\
    \            val smalest_even_index_plus_five = smalest_even_index + 5\n     \
    \       val smalest_even_index_plus_six = smalest_even_index + 6\n           \
    \ val smalest_even_index_plus_seven = smalest_even_index + 7\n            val\
    \ smalest_even_index_plus_eight = smalest_even_index + 8\n            val smalest_even_index_plus_nine\
    \ = smalest_even_index + 9\n            val smalest_even_index_plus_ten = smalest_even_index\
    \ + 10\n            val smalest_even_index_plus_eleven = smalest_even_index +\
    \ 11\n            val smalest_even_index_plus_twelve = smalest_even_index + 12\n\
    \            val smalest_even_index_plus_thirteen = smalest_even_index + 13\n\
    \            val smalest_even_index_plus_fourteen = smalest_even_index + 14\n\
    \            val smalest_even_index_plus_fifteen = smalest_even_index + 15\n \
    \           val smalest_even_index_plus_sixteen = smalest_even_index + 16\n  \
    \          val smalest_even_index_plus_seventeen = smalest_even_index + 17\n \
    \           val smalest_even_index_plus_eighteen = smalest_even_index + 18\n \
    \           val smalest_even_index_plus_nineteen = smalest_even_index + 19\n \
    \           val smalest_even_index_plus_twenty = smalest_even_index + 20\n   \
    \         val smalest_even_index_plus_twenty_one = smalest_even_index + 21\n \
    \           val smalest_even_index_plus_twenty_two = smalest_even_index + 22\n\
    \            val smale\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxvu6248x.scala:53:4 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxvu6248x.scala:66:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m66 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpxvu6248x.scala:65:1 ---------------------\e[0m\e[0m\n\
    \e[31m65 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\
    \e[31m   |\e[0m Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[33m\e[33m-- Warning:\
    \ /tmp/tmpxvu6248x.scala:54:4 ----------------------------------------\e[0m\e\
    [0m\n\e[33m54 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e\
    [0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m\
    \    Line is indented too far to the left, or a `}` is missing\n1 warning found\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009836
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_even = evens(smalest_index)\n        val smalest_even_index =\
    \ evens.indexOf(smalest_even)\n        val smalest_even_value = evens(smalest_even_index)\n\
    \        val smalest_even_index_in_list = evens.indexOf(smalest_even, smalest_index)\n\
    \        val smalest_even_value_in_list_index = evens.indexOf(smalest_even, smalest_even_index)\n\
    \        val smalest_even_value_in_list_value = evens.indexOf(smalest_even, smalest_even_index_in_list)\n\
    \        val smalest_even_value_in_list_value_in_list_index = evens.indexOf(smalest_even,\
    \ smalest_even_value_in_list_index)\n        val smalest_even_value_in_list_value_in_list_value\
    \ = evens.indexOf(smalest_even, smalest_even_value_in_list_value_in_list_index)\n\
    \        val smalest_even_value_in_list_value_in_list_value_in_list_index = evens.indexOf(smalest_even,\
    \ smalest_even_value_in_list_value_in_list_value_in_list_index)\n        val smalest_even_value_in_list_value_in_list_value_in_list_value\
    \ = evens.indexOf(smalest_even, smalest_even_value_in_list_value_in_list_value_in_list_index)\n\
    \        val smalest_even_value_in_list_value_in_list_value_in_list_value_in_list_index\
    \ = evens.indexOf(smalest_even, smalest_even_value_in_list_value_in_list_value_in_list_value_in_list_index)\n\
    \        val smalest_even_value_in_list_value_in_list_value_in_list_value_in_list_value\
    \ = evens.indexOf(smalest_even, smalest_even_value_in_list_value_in_list_value_in_list_value_in_list_index)\n\
    \        val smalest_even_value_in_list_value_in_list_value_in_list_value_in_list_value_in_list_index\
    \ = evens.indexOf(smalest_even, smalest_even_value_in_list_value_in_list_value_in_list_value_in_list_value_in_list_index)\n\
    \        val smalest_even_value_in_list_value_in_list_value_in_list_value_in_list_value_in_list_value\
    \ = evens.indexOf(smalest_even, smalest_even_value_in_list_value_in_list_value_in_list_value_in_list_value_in_list_index)\n\
    \        val smalest_even_value_in_list_value_in_list_value_in_list_value_in_list_value_in_list_value_in_list_index\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpbzu2andi.scala:39:116 --------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value_in_list_value_in_list_value_in_list_value_in_list_value_in_list_value_in_list_index\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                                \
    \                                                                    ^\e[0m\n\e\
    [31m   |\e[0m                                       expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpbzu2andi.scala:33:103\
    \ --------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_even_value_in_list_value_in_list_value_in_list_index\e[0m = evens.indexOf(smalest_even,\
    \ smalest_even_value_in_list_value_in_list_value_in_list_index)\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \                                    ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35msmalest_even_value_in_list_value_in_list_value_in_list_index\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpbzu2andi.scala:35:117\
    \ --------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_even_value_in_list_value_in_list_value_in_list_value_in_list_index\e\
    [0m = evens.indexOf(smalest_even, smalest_even_value_in_list_value_in_list_value_in_list_value_in_list_index)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                             ^\e[0m\n\e[31m \
    \  |\e[0mRecursive \e[33mvalue\e[0m \e[35msmalest_even_value_in_list_value_in_list_value_in_list_value_in_list_index\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpbzu2andi.scala:37:131\
    \ --------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_even_value_in_lis"
  stdout: ''
  timestamp: 1660009836
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        if (evens.isEmpty)\
    \ List(0) else evens.minBy(x => x)._2\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzkhg04l6.scala:23:60 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mif\e[0m (evens.isEmpty) List(\e[31m0\e\
    [0m) \e[33melse\e[0m evens.minBy(\e[36mx\e[0m => x)._2\n\e[31m\e[31m   |\e[0m\
    \                                        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                                        value _2 is not a member of Long\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009836
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_even = evens(smalest_index)\n        val smalest_even_index =\
    \ evens.indexOf(smalest_even)\n        val smalest_even_index = smalest_even_index\
    \ + 1\n        val smalest_even_value = evens(smalest_even_index)\n        val\
    \ smalest_even_index_in_list = evens.indexOf(smalest_even_value)\n        val\
    \ smalest_even_index_in_list = smalest_even_index_in_list + 1\n        val smalest_even_index_in_list\
    \ = evens.indexOf(smalest_even_index_in_list)\n        val smalest_even_index_in_list\
    \ = smalest_even_index_in_list + 1\n        val smalest_even_index_in_list = evens.indexOf(smalest_even_index_in_list)\n\
    \        val smalest_even_index_in_list = smalest_even_index_in_list + 1\n   \
    \     val smalest_even_index_in_list = evens.indexOf(smalest_even_index_in_list)\n\
    \        val smalest_even_index_in_list = smalest_even_index_in_list + 1\n   \
    \     val smalest_even_index_in_list = evens.indexOf(smalest_even_index_in_list)\n\
    \        val smalest_even_index_in_list = smalest_even_index_in_list + 1\n   \
    \     val smalest_even_index_in_list = evens.indexOf(smalest_even_index_in_list)\n\
    \        val smalest_even_index_in_list = smalest_even_index_in_list + 1\n   \
    \     val smalest_even_index_in_list = evens.indexOf(smalest_even_index_in_list)\n\
    \        val smalest_even_index_in_list = smalest_even_index_in_list + 1\n   \
    \     val smalest_even_index_in_list = evens.indexOf(smalest_even_index_in_list)\n\
    \        val smalest_even_index_in_list = smalest_even_index_in_list + 1\n   \
    \     val smalest_even_index_in_list = evens.indexOf(smalest_even_index_in_list)\n\
    \        val smalest_even_index_in_list = smalest_even_index_in_list + 1\n   \
    \     val smalest_even_index_in_list = evens.indexOf(smalest_even_index_in_list)\n\
    \        val smalest_even_index_in_list = smalest_even_index_in_list + 1\n   \
    \     val smalest_even_index_in_list = evens.indexOf(smalest_even_index_in_list)\n\
    \        val smalest_even_index_in_list = smalest_even_index_in_list + 1\n\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpw0ymthic.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m\
    \ = smalest_even_index + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_even_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpw0ymthic.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_in_list\e\
    [0m = smalest_even_index_in_list + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msmalest_even_index_in_list is already defined as \e[33mvalue\e[0m \e\
    [35msmalest_even_index_in_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpw0ymthic.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_in_list\e\
    [0m = evens.indexOf(smalest_even_index_in_list)\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_in_list is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_in_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpw0ymthic.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_in_list\e\
    [0m = smalest_even_index_in_list + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msmalest_even_index_in_list is already defined as \e[33mvalue\e[0m \e\
    [35msmalest_even_index_in_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods m"
  stdout: ''
  timestamp: 1660009837
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_even = evens(smalest_index)\n        val smalest_even_index =\
    \ evens.indexOf(smalest_even)\n        val smalest_even_value = evens(smalest_even_index)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_value)\n  \
    \      val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8dwtjk_q.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = evens.indexOf(smalest_even_index_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8dwtjk_q.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = evens.indexOf(smalest_even_index_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8dwtjk_q.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = evens.indexOf(smalest_even_index_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8dwtjk_q.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = evens.indexOf(smalest_even_index_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31"
  stdout: ''
  timestamp: 1660009815
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val evensSorted\
    \ = evens.sortWith((x, y) => x < y)\n        val smallestEven = evensSorted.head\n\
    \        val smallestEvenIndex = evensSorted.indexOf(0)\n        val smallestEvenValue\
    \ = smallestEven\n        val smallestEvenIndexList = List(smallestEvenIndex,\
    \ smallestEvenValue)\n        val smallestEvenIndexSet = smallestEvenIndexList.map(x\
    \ => x.toString)\n        val smallestEvenIndexSetSet = smallestEvenIndexSet.map(x\
    \ => x.toSet)\n        val smallestEvenIndexSetSet = smallestEvenIndexSetSet.map(x\
    \ => x.toSet)\n        val smallestEvenIndexSetSetSet = smallestEvenIndexSetSet.map(x\
    \ => x.toSet)\n        val smallestEvenIndexSetSetSetSet = smallestEvenIndexSetSet.map(x\
    \ => x.toSet)\n        val smallestEvenIndexSetSetSetSet = smallestEvenIndexSetSet.map(x\
    \ => x.toSet)\n        val smallestEvenIndexSetSetSetSet = smallestEvenIndexSetSet.map(x\
    \ => x.toSet)\n        val smallestEvenIndexSetSetSetSet = smallestEvenIndexSetSet.map(x\
    \ => x.toSet)\n        val smallestEvenIndexSetSetSetSet = smallestEvenIndexSetSet.map(x\
    \ => x.toSet)\n        val smallestEvenIndexSetSetSetSet = smallestEvenIndexSetSet.map(x\
    \ => x.toSet)\n        val smallestEvenIndexSetSetSetSet = smallestEvenIndexSetSet.map(x\
    \ => x.toSet)\n        val smallestEvenIndexSetSetSetSet = smallestEvenIndexSetSet.map(x\
    \ => x.toSet)\n        val smallestEvenIndexSetSetSetSet = smallestEvenIndexSetSet.map(x\
    \ => x.toSet)\n        val smallestEvenIndexSetSetSetSet = smallestEvenIndexSetSet.map(x\
    \ => x.toSet)\n        val smallestEvenIndexSetSetSetSet = smallestEvenIndexSetSet.map(x\
    \ => x.toSet)\n        val smallestEvenIndexSetSetSetSet = smallestEvenIndexSetSet.map(x\
    \ => x.toSet)\n        val smallestEvenIndexSetSetSetSet = smallestEvenIndexSetSet.map(x\
    \ => x.toSet)\n        val smallestEvenIndexSetSetSetSet = smallestEvenIndexSetSet.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpuhf93lo3.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpuhf93lo3.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndexSetSet\e[0m = smallestEvenIndexSetSet.map(\e\
    [36mx\e[0m => x.toSet)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndexSetSet is already defined as \e[33mvalue\e\
    [0m \e[35msmallestEvenIndexSetSet\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuhf93lo3.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndexSetSetSetSet\e\
    [0m = smallestEvenIndexSetSet.map(\e[36mx\e[0m => x.toSet)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndexSetSetSetSet is already defined as \e[33mvalue\e\
    [0m \e[35msmallestEvenIndexSetSetSetSet\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuhf93lo3.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndexSetSetSetSet\e\
    [0m = smallestEvenIndexSetSet.map(\e[36mx\e[0m => x.toSet)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndexSetSetSetSet is already defined as \e[33mvalue\e\
    [0m \e[35msmallestEvenIndexSetSetSetSet\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuhf93lo3.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndexSetSet"
  stdout: ''
  timestamp: 1660009837
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(_ % 2 == 0).sortBy(_)\n        val smalest_value\
    \ = evens.head\n        val smalest_index = evens.indexOf(0)\n        val smalest_evens\
    \ = evens.takeWhile(_ < smalest_value)\n        val smalest_evens_index = evens.indexOf(smalest_value)\n\
    \        if (smalest_evens_index == -1) smalest_evens_index = evens.length\n \
    \       if (smalest_evens.length == 0) smalest_evens_index = 0\n        smalest_evens.take(smalest_evens_index).map(_\
    \ + smalest_index).toList\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp5duvg1x1.scala:22:52 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_)\n\e[31m\e[31m   |\e[0m           \
    \                                         ^\e[0m\n\e[31m   |\e[0mNo implicit Ordering\
    \ defined for Any..\n\e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \    scala.math.Ordering.ordered[\e[35mAny\e[0m](\n\e[31m   |\e[0m      /* missing\
    \ */summon[scala.math.Ordering.AsComparable[Any]]\n\e[31m   |\e[0m    )\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mBut no implicit values were found that match type scala.math.Ordering.AsComparable[Any].\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmp5duvg1x1.scala:27:59 -----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mif\e[0m (smalest_evens_index == -\e[31m1\e\
    [0m) smalest_evens_index = evens.length\n\e[31m\e[31m   |\e[0m               \
    \                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                 Reassignment to val smalest_evens_index\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp5duvg1x1.scala:28:59 -----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mif\e[0m (smalest_evens.length == \e[31m0\e\
    [0m) smalest_evens_index = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m               \
    \                        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                          Reassignment to val smalest_evens_index\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009839
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        if (evens.isEmpty)\
    \ List()\n        else {\n            val smalest_value = evens.min\n        \
    \    val index = evens.indexOf(smalest_value)\n            val smalest_even =\
    \ evens(index)\n            val smalest_even_index = evens.indexOf(smalest_even)\n\
    \            val smalest_even_value = evens(smalest_even_index)\n            val\
    \ smalest_even_index_value = evens.indexOf(smalest_even_value)\n            val\
    \ smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n       \
    \     val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpei6av6hq.scala:54:4 ----------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpei6av6hq.scala:67:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m67 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpei6av6hq.scala:31:16 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m            \e[33mval\e[0m \e[36msmalest_even_index_value\e[0m =\
    \ evens.indexOf(smalest_even_index_value)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpei6av6hq.scala:32:16 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = evens.indexOf(smalest_even_index_value)\n\e[31m\e[31m   |\e[0m         \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpei6av6hq.scala:33:16 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = evens.indexOf(smalest_even_index_value)\n\e[31m\e[31m   |\e[0m         \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpei"
  stdout: ''
  timestamp: 1660009839
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0).sortBy(x => x).reverse\n\
    \        if (evens.isEmpty) List()\n        else evens.headOption.getOrElse(arr.minBy(x\
    \ => x))\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpz9zc1gsm.scala:24:39\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33melse\e[0m evens.headOption.getOrElse(arr.minBy(x\
    \ => x))\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m             Found:    Long\n\e[31m   |\e[0m             Required:\
    \ \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009836
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val even = evens.min\n\
    \        val index = evens.indexOf(even)\n        val smalest_value = arr.min\n\
    \        val smalest_index = arr.indexOf(smalest_value)\n        val smalest_even\
    \ = evens.filter(x => x % 2 == 0).min\n        val smalest_even_index = evens.indexOf(smalest_even)\n\
    \        val smalest_even_index = smalest_even_index match {\n            case\
    \ -1 => -1\n            case x => x\n        }\n        val smalest_even_value\
    \ = evens.filter(x => x % 2 == 0).min\n        val smalest_even_value = smalest_even_value\
    \ match {\n            case -1 => -1\n            case x => x\n        }\n   \
    \     val smalest_even_value = smalest_even_value match {\n            case -1\
    \ => -1\n            case x => x\n        }\n        val smalest_even_value =\
    \ smalest_even_value match {\n            case -1 => -1\n            case x =>\
    \ x\n        }\n        val smalest_even_value = smalest_even_value match {\n\
    \            case -1 => -1\n            case x => x\n        }\n        val smalest_even_value\
    \ = smalest_even_value match {\n            case -1 => -1\n            case x\
    \ => x\n        }\n        val smalest_even_value = smalest_even_value match {\n\
    \            case -1 => -1\n            case x => x\n        }\n        val smalest_even_value\
    \ = smalest_even_value match {\n            case -1 => -1\n            case x\
    \ => x\n        }\n        val smalest_even_value = smalest_even_value match {\n\
    \            case -1 => -1\n            case x => x\n        }\n        val smalest_even_value\
    \ = smalest_even_value match {\n            case -1 => -1\n            case x\
    \ => x\n        }\n        val smalest_even_value = smalest_even_value match {\n\
    \            case -1 => -1\n            case x => x\n        }\n        val smalest_even_value\
    \ = smalest_even_value match {\n            case -1 => -1\n            case x\
    \ => x\n        }\n        val smalest_even_value = smalest_even_value match {\n\
    \            case -1 => -1\n            case x => x\n        }\n        val smalest_even_value\
    \ = smalest_even_value match {\n            case -1 => -1\n            case x\
    \ => x\n        }\n        val smalest_even_value = smalest_even_value match {\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqfhpq68_.scala:88:4 ----------------------------\e\
    [0m\e[0m\n\e[31m88 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    'case' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqfhpq68_.scala:101:0\
    \ ---------------------------\e[0m\e[0m\n\e[31m101 |\e[0m\n\e[31m\e[31m    |\e\
    [0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161]\
    \ Naming Error: /tmp/tmpqfhpq68_.scala:29:12 ---------------------------\e[0m\e\
    [0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m = smalest_even_index\
    \ \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0msmalest_even_index\
    \ is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m30 |\e[0m            \e[33mcase\e\
    [0m -\e[31m1\e[0m => -\e[31m1\e[0m\n\e[31m31 |\e[0m            \e[33mcase\e[0m\
    \ x => x\n\e[31m32 |\e[0m        }\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqfhpq68_.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_even_value\e[0m = smalest_even_value \e[33mmatch\e[0m {\n\e[31m\e\
    [31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0msmalest_even_value is already defined\
    \ as \e[33mvalue\e[0m \e[35msmalest_even_value\e[0m\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m35 |\e[0m            \e[33mcase\e[0m -\e[31m1\e\
    [0m => -\e[31m1\e[0m\n\e[31m36 |\e[0m            \e[33mcase\e[0m x => x\n\e[31m37\
    \ |\e[0m        }\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqfhpq68_.scala:38:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_even_value\e[0m = smalest_even_value \e[33mmatch\e[0m {\n\e[31m\e\
    [31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0msmalest_even_value is already defined\
    \ as \e[33mvalue\e[0m \e[35msmalest_even_value\e[0m\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m39 |\e[0m            \e[33mcase\e[0m -\e[31m1\e\
    [0m => -\e[31m1\e[0m"
  stdout: ''
  timestamp: 1660009839
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_even = evens(smalest_index)\n        val smalest_even_index =\
    \ evens.indexOf(smalest_even)\n        val smalest_even_value = evens(smalest_even_index)\n\
    \        val smalest_even_index_list = evens.indexOf(smalest_even)\n        val\
    \ smalest_even_index_list_size = evens.size - smalest_even_index_list\n      \
    \  val smalest_even_index_list_size = evens.size - smalest_even_index_list_size\n\
    \        val smalest_even_index_list_size = evens.size - smalest_even_index_list_size\n\
    \        val smalest_even_index_list_size = evens.size - smalest_even_index_list_size\n\
    \        val smalest_even_index_list_size = evens.size - smalest_even_index_list_size\n\
    \        val smalest_even_index_list_size = evens.size - smalest_even_index_list_size\n\
    \        val smalest_even_index_list_size = evens.size - smalest_even_index_list_size\n\
    \        val smalest_even_index_list_size = evens.size - smalest_even_index_list_size\n\
    \        val smalest_even_index_list_size = evens.size - smalest_even_index_list_size\n\
    \        val smalest_even_index_list_size = evens.size - smalest_even_index_list_size\n\
    \        val smalest_even_index_list_size = evens.size - smalest_even_index_list_size\n\
    \        val smalest_even_index_list_size = evens.size - smalest_even_index_list_size\n\
    \        val smalest_even_index_list_size = evens.size - smalest_even_index_list_size\n\
    \        val smalest_even_index_list_size = evens.size - smalest_even_index_list_size\n\
    \        val smalest_even_index_list_size = evens.size - smalest_even_index_list_size\n\
    \        val smalest_even_index_list_size = evens.size - smalest_even_index_list_size\n\
    \        val smalest_even_index_list_size = evens.size - smalest_even_index_list_size\n\
    \        val smalest_even_index_list_size = evens.size - smalest_even_index_list_size\n\
    \        val smalest_even_index_list_size = evens.size - smalest_even_index_list_size\n\
    \        val smalest_even_index_list_size = evens.size - smalest_even_index_list_size\n\
    \        val smalest_even_index_list_size = evens.size - smale\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpod6idvg5.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_size\e\
    [0m = evens.size - smalest_even_index_list_size\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_size is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_list_size\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpod6idvg5.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_size\e\
    [0m = evens.size - smalest_even_index_list_size\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_size is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_list_size\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpod6idvg5.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_size\e\
    [0m = evens.size - smalest_even_index_list_size\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_size is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_list_size\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpod6idvg5.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_size\e\
    [0m = evens.size - smalest_even_index_list_size\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_size is already de"
  stdout: ''
  timestamp: 1660009838
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_even = evens(smalest_index)\n        val smalest_even_index =\
    \ evens.indexOf(smalest_even)\n        val smalest_even_value = evens(smalest_even_index)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_value)\n  \
    \      val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8dwtjk_q.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = evens.indexOf(smalest_even_index_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8dwtjk_q.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = evens.indexOf(smalest_even_index_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8dwtjk_q.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = evens.indexOf(smalest_even_index_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8dwtjk_q.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = evens.indexOf(smalest_even_index_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31"
  stdout: ''
  timestamp: 1660009815
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOfMin\n        val result\
    \ = evens.filterNot(x => x == smalest_value)\n        if (result.isEmpty) List(smalest_value,\
    \ smalest_index)\n        else result.minBy(x => x)._2\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkp0yr667.scala:24:34 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36msmalest_index\e[0m = evens.indexOfMin\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue indexOfMin is not a member of List[Long] - did you mean evens.indexOf?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkp0yr667.scala:27:34 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33melse\e[0m result.minBy(x => x)._2\n\e[31m\e\
    [31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \       value _2 is not a member of Long\n2 errors found\n"
  stdout: ''
  timestamp: 1660009840
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(_ % 2 == 0)\n        val smalest_value =\
    \ evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n      \
    \  val smalest_even = evens(smalest_index)\n        val smalest_even_index = arr.indexOf(smalest_even)\n\
    \        val smalest_even_value = smalest_even\n        val smalest_even_index\
    \ = smalest_even_index\n        val smalest_even_value = smalest_even_value\n\
    \        val smalest_even_index = smalest_even_index\n        val smalest_even_value\
    \ = smalest_even_value\n        val smalest_even_index = smalest_even_index\n\
    \        val smalest_even_value = smalest_even_value\n        val smalest_even_index\
    \ = smalest_even_index\n        val smalest_even_value = smalest_even_value\n\
    \        val smalest_even_index = smalest_even_index\n        val smalest_even_value\
    \ = smalest_even_value\n        val smalest_even_index = smalest_even_index\n\
    \        val smalest_even_value = smalest_even_value\n        val smalest_even_index\
    \ = smalest_even_index\n        val smalest_even_value = smalest_even_value\n\
    \        val smalest_even_index = smalest_even_index\n        val smalest_even_value\
    \ = smalest_even_value\n        val smalest_even_index = smalest_even_index\n\
    \        val smalest_even_value = smalest_even_value\n        val smalest_even_index\
    \ = smalest_even_index\n        val smalest_even_value = smalest_even_value\n\
    \        val smalest_even_index = smalest_even_index\n        val smalest_even_value\
    \ = smalest_even_value\n        val smalest_even_index = smalest_even_index\n\
    \        val smalest_even_value = smalest_even_value\n        val smalest_even_index\
    \ = smalest_even_index\n        val smalest_even_value = smalest_even_value\n\
    \        val smalest_even_index = smalest_even_index\n        val smalest_even_value\
    \ = smalest_even_value\n        val smalest_even_index = smalest_even_index\n\
    \        val smalest_even_value = smalest_even_value\n        val smalest_even_index\
    \ = smalest_even_index\n        val smalest_even_value = smalest_even_value\n\
    \        val smalest_even_index = smalest_even_index\n        val smalest_even_value\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp2z0ukkz5.scala:61:32 ---------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value\e[0m\
    \ = \n\e[31m\e[31m   |\e[0m                                ^\e[0m\n\e[31m   |\e\
    [0m                                expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2z0ukkz5.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_even_index\e[0m = smalest_even_index\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msmalest_even_index\
    \ is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp2z0ukkz5.scala:29:12 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value\e[0m = smalest_even_value\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msmalest_even_value is already defined as \e[33mvalue\e[0m \e[35msmalest_even_value\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp2z0ukkz5.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m = smalest_even_index\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp2z0ukkz5.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value\e[0m = smalest_even_value\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660009839
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val evensSorted\
    \ = evens.sortWith(_ < _)\n        val smalest_value = evensSorted.head\n    \
    \    val smalest_index = evensSorted.indexOf(0)\n        val smalest_even = evensSorted.take(smalest_index).sum\n\
    \        val smalest_odd = evensSorted.drop(smalest_index).sum\n        val smalest_even_index\
    \ = evensSorted.indexOf(smalest_even)\n        val smalest_odd_index = evensSorted.indexOf(smalest_odd)\n\
    \        val smalest_even_value = evensSorted.take(smalest_even_index).sum\n \
    \       val smalest_odd_value = evensSorted.drop(smalest_odd_index).sum\n    \
    \    val smalest_even_index_list = evensSorted.indexOf(smalest_even)\n       \
    \ val smalest_odd_index_list = evensSorted.indexOf(smalest_odd)\n        val smalest_even_value_list\
    \ = evensSorted.take(smalest_even_index_list).sum\n        val smalest_odd_value_list\
    \ = evensSorted.drop(smalest_odd_index_list).sum\n        val smalest_even_index_list_list\
    \ = evensSorted.indexOf(smalest_even)\n        val smalest_odd_index_list_list\
    \ = evensSorted.indexOf(smalest_odd)\n        val smalest_even_value_list = evensSorted.take(smalest_even_index_list_list).sum\n\
    \        val smalest_odd_value_list = evensSorted.drop(smalest_odd_index_list_list).sum\n\
    \        val smalest_even_index_list_list_list = evensSorted.indexOf(smalest_even)\n\
    \        val smalest_odd_index_list_list_list = evensSorted.indexOf(smalest_odd)\n\
    \        val smalest_even_value_list = evensSorted.take(smalest_even_index_list_list_list).sum\n\
    \        val smalest_odd_value_list = evensSorted.drop(smalest_odd_index_list_list_list).sum\n\
    \        val smalest_even_index_list_list_list_list = evensSorted.indexOf(smalest_even)\n\
    \        val smalest_odd_index_list_list_list_list = evensSorted.indexOf(smalest_odd)\n\
    \        val smalest_even_value_list = evensSorted.take(smalest_even_index_list_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4znf07we.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4znf07we.scala:38:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_even_value_list\e[0m = evensSorted.take(smalest_even_index_list_list).sum\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_value_list is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_value_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4znf07we.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36msmalest_odd_value_list\e\
    [0m = evensSorted.drop(smalest_odd_index_list_list).sum\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_odd_value_list is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_odd_value_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4znf07we.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value_list\e\
    [0m = evensSorted.take(smalest_even_index_list_list_list).sum\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_value_list is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_value_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4znf07we.scala:43:12 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36msmalest_odd_value_list\e\
    [0m = evensSorted.drop(smal"
  stdout: ''
  timestamp: 1660009849
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val evensSorted\
    \ = evens.sortWith((x, y) => x < y)\n        val evenSmallest = evensSorted.head\n\
    \        val evenSmallestIndex = evensSorted.indexOf(0)\n        val evenSmallestValue\
    \ = evenSmallest\n        val evenSmallestIndexList = evenSmallestIndex.toList\n\
    \        val evenSmallestValueList = evenSmallestValue.toList\n        if (evenSmallestIndexList.length\
    \ == 0)\n            evenSmallestValueList :: evenSmallestIndexList\n        else\
    \ if (evenSmallestValueList.length == 0)\n            evenSmallestIndexList ::\
    \ evenSmallestValueList\n        else\n            evenSmallestValueList :: evenSmallestIndexList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptyu5odhi.scala:27:54 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexList\e\
    [0m = evenSmallestIndex.toList\n\e[31m\e[31m   |\e[0m                        \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList is not\
    \ a member of Int - did you mean evenSmallestIndex.toInt?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmptyu5odhi.scala:28:54 ------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueList\e[0m =\
    \ evenSmallestValue.toList\n\e[31m\e[31m   |\e[0m                            \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList is not a member\
    \ of Long - did you mean evenSmallestValue.toInt?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009857
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val evensSorted\
    \ = evens.sortWith((x, y) => x < y)\n        val evensSorted = evensSorted.takeWhile(_\
    \ < arr.length)\n        val smallestEven = evensSorted.head\n        val smallestEvenIndex\
    \ = evensSorted.indexOf(0)\n        val smallestEvenIndex = smallestEvenIndex.asInstanceOf[Int]\n\
    \        val smallestEvenValue = smallestEven\n        val smallestEvenValueIndex\
    \ = arr.indexOf(smallestEvenValue)\n        val smallestEvenValueIndex = smallestEvenValueIndex.asInstanceOf[Int]\n\
    \        val smallestEvenValueIndex = smallestEvenValueIndex + 1\n        val\
    \ smallestEvenValueIndex = smallestEvenValueIndex - 1\n        val smallestEvenValueIndex\
    \ = smallestEvenValueIndex + 1\n        val smallestEvenValueIndex = smallestEvenValueIndex\
    \ - 1\n        val smallestEvenValueIndex = smallestEvenValueIndex + 1\n     \
    \   val smallestEvenValueIndex = smallestEvenValueIndex - 1\n        val smallestEvenValueIndex\
    \ = smallestEvenValueIndex + 1\n        val smallestEvenValueIndex = smallestEvenValueIndex\
    \ - 1\n        val smallestEvenValueIndex = smallestEvenValueIndex + 1\n     \
    \   val smallestEvenValueIndex = smallestEvenValueIndex - 1\n        val smallestEvenValueIndex\
    \ = smallestEvenValueIndex + 1\n        val smallestEvenValueIndex = smallestEvenValueIndex\
    \ - 1\n        val smallestEvenValueIndex = smallestEvenValueIndex + 1\n     \
    \   val smallestEvenValueIndex = smallestEvenValueIndex - 1\n        val smallestEvenValueIndex\
    \ = smallestEvenValueIndex + 1\n        val smallestEvenValueIndex = smallestEvenValueIndex\
    \ - 1\n        val smallestEvenValueIndex = smallestEvenValueIndex + 1\n     \
    \   val smallestEvenValueIndex = smallestEvenValueIndex - 1\n        val smallestEvenValueIndex\
    \ = smallestEvenValueIndex + 1\n        val smallestEvenValueIndex = smallestEvenValueIndex\
    \ - 1\n        val smallestEvenValueIndex = smallestEvenValueIndex + 1\n     \
    \   val smallestEvenValueIndex = smallestEvenValueIndex - 1\n        val smallestEvenValueIndex\
    \ = smallestEvenValueIndex + 1\n        val smallestEvenValueIndex = smallestEvenValueIndex\
    \ - 1\n        val smallestEvenValueIndex = smallestEvenValueIndex + 1\n     \
    \   val smallestEvenValueIndex = smallestEvenValueIndex - 1\n        val smallestEvenValueIndex\
    \ = smallestEvenValueIndex + 1\n        \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2gc20n_e.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evensSorted.takeWhile(_\
    \ < arr.length)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp2gc20n_e.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m = smallestEvenIndex.asInstanceOf[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp2gc20n_e.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValueIndex\e\
    [0m = smallestEvenValueIndex.asInstanceOf[\e[35mInt\e[0m]\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValueIndex is already defined as \e[33mvalue\e\
    [0m \e[35msmallestEvenValueIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2gc20n_e.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValueIndex\e\
    [0m = smallestEvenValueIndex + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValueIndex is already defined as \e[33mvalue\e\
    [0m \e[35msmallestEvenValueIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m"
  stdout: ''
  timestamp: 1660009857
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0).sorted\n        val smalest_value\
    \ = evens.head\n        val smalest_index = evens.indexOf(0)\n        if (evens.isEmpty)\
    \ List(smalest_value, smalest_index)\n        else {\n            val evens_with_smallest_index\
    \ = evens.zip(evens.indexOf(0))\n            val smalest_value_with_smallest_index\
    \ = evens_with_smallest_index.minBy(_._1)\n            val smalest_index_with_smallest_index\
    \ = evens_with_smallest_index.minBy(_._2)\n            val smalest_value_with_largest_index\
    \ = evens_with_smallest_index.maxBy(_._1)\n            val smalest_index_with_largest_index\
    \ = evens_with_smallest_index.maxBy(_._2)\n            val smalest_value_with_largest_index_index\
    \ = evens_with_smallest_index.zipWithIndex.minBy(_._1)\n            val smalest_index_with_largest_index_index\
    \ = evens_with_smallest_index.zipWithIndex.minBy(_._2)\n            val smalest_value_with_largest_index_index_index\
    \ = evens_with_smallest_index.zipWithIndex.maxBy(_._1)\n            val smalest_index_with_largest_index_index_index\
    \ = evens_with_smallest_index.zipWithIndex.maxBy(_._2)\n            val smalest_value_with_largest_index_index_index_index\
    \ = evens_with_smallest_index.zipWithIndex.zipWithIndex.minBy(_._1)\n        \
    \    val smalest_index_with_largest_index_index_index_index = evens_with_smallest_index.zipWithIndex.zipWithIndex.minBy(_._2)\n\
    \            val smalest_value_with_largest_index_index_index_index_index = evens_with_smallest_index.zipWithIndex.zipWithIndex.maxBy(_._1)\n\
    \            val smalest_index_with_largest_index_index_index_index_index = evens_with_smallest_index.zipWithIndex.zipWithIndex.maxBy(_._2)\n\
    \            val smalest_value_with_largest_index_index_index_index_index_index\
    \ = evens_with_smallest_index.zipWithIndex.zipWithIndex.zipWithIndex.maxBy(_._1)\n\
    \            val smalest_index_with_largest_index_index_index_index_index_index\
    \ = evens_with_smallest_index.zipWithIndex.zipWithIndex.zipWithIndex.maxBy(_._2)\n\
    \            val smalest_value_with_largest_index_index_index_index_index_index_index\
    \ = even\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpb39tqr6c.scala:56:0 ----------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb39tqr6c.scala:27:67\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e\
    [36mevens_with_smallest_index\e[0m = evens.zip(evens.indexOf(\e[31m0\e[0m))\n\e\
    [31m\e[31m   |\e[0m                                                      ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                             Found:    Int\n\
    \e[31m   |\e[0m                                             Required: IterableOnce[Any]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpb39tqr6c.scala:29:89 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mval\e[0m \e[36msmalest_index_with_smallest_index\e\
    [0m = evens_with_smallest_index.minBy(_._2)\n\e[31m\e[31m   |\e[0m           \
    \                                                                            \
    \  ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e\
    [35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e\
    [35mChar\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B]\
    \ of parameter cmp of \e[33mmethod\e[0m \e[35mminBy\e[0m in \e[33mtrait\e[0m \e\
    [35mIterableOnceOps\e[0m\n\e[31m\e[31m-- Error: /tmp/tmpb39tqr6c.scala:31:88 -----------------------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33mval\e[0m \e[36msmalest_index_with_largest_index\e\
    [0m = evens_with_smallest_index.maxBy(_._2)\n\e[31m\e[31m   |\e[0m           \
    \                                                                            \
    \ ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e\
    [35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e\
    [35mChar\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B]\
    \ of parameter cmp of \e[33mmethod\e[0m \e[35mmaxBy\e[0m in \e[33mtrait\e[0m \e\
    [35mIterableOnceOps\e[0m\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb39tqr6c.sc"
  stdout: ''
  timestamp: 1660009862
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(_ % 2 == 0)\n        val smalest_value =\
    \ evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n      \
    \  val smalest_even = evens(smalest_index)\n        val smalest_even_index = evens.indexOf(smalest_even)\n\
    \        val smalest_even_index = if (smalest_even_index == -1) -1 else smalest_even_index\n\
    \        val smalest_even_value = evens(smalest_even_index)\n        val smalest_even_index_value\
    \ = evens.indexOf(smalest_even_value)\n        val smalest_even_index_value =\
    \ if (smalest_even_index_value == -1) -1 else smalest_even_index_value\n     \
    \   val smalest_even_index_value = if (smalest_even_index_value == -1) -1 else\
    \ smalest_even_index_value\n        val smalest_even_index_value = if (smalest_even_index_value\
    \ == -1) -1 else smalest_even_index_value\n        val smalest_even_index_value\
    \ = if (smalest_even_index_value == -1) -1 else smalest_even_index_value\n   \
    \     val smalest_even_index_value = if (smalest_even_index_value == -1) -1 else\
    \ smalest_even_index_value\n        val smalest_even_index_value = if (smalest_even_index_value\
    \ == -1) -1 else smalest_even_index_value\n        val smalest_even_index_value\
    \ = if (smalest_even_index_value == -1) -1 else smalest_even_index_value\n   \
    \     val smalest_even_index_value = if (smalest_even_index_value == -1) -1 else\
    \ smalest_even_index_value\n        val smalest_even_index_value = if (smalest_even_index_value\
    \ == -1) -1 else smalest_even_index_value\n        val smalest_even_index_value\
    \ = if (smalest_even_index_value == -1) -1 else smalest_even_index_value\n   \
    \     val smalest_even_index_value = if (smalest_even_index_value == -1) -1 else\
    \ smalest_even_index_value\n        val smalest_even_index_value = if (smalest_even_index_value\
    \ == -1) -1 else smalest_even_index_value\n        val smalest_even_index_value\
    \ = if (smalest_even_index_value == -1) -1 else smalest_even_index_value\n   \
    \     val smalest_even_index_value = if (smalest_even_index_value == -1) -1 else\
    \ smalest_even_index_value\n        val smalest_even_index_value = if (smalest_even_index_value\
    \ == -1) -1 else smalest_even_index_value\n        val smalest_even_index_value\
    \ = if (smalest_even_index_value == -1) -1 \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsxkk8llq.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m\
    \ = \e[33mif\e[0m (smalest_even_index == -\e[31m1\e[0m) -\e[31m1\e[0m \e[33melse\e\
    [0m smalest_even_index\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_even_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpsxkk8llq.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = \e[33mif\e[0m (smalest_even_index_value == -\e[31m1\e[0m) -\e[31m1\e[0m\
    \ \e[33melse\e[0m smalest_even_index_value\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsxkk8llq.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = \e[33mif\e[0m (smalest_even_index_value == -\e[31m1\e[0m) -\e[31m1\e[0m\
    \ \e[33melse\e[0m smalest_even_index_value\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsxkk8llq.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = \e[33mif\e[0m (smalest_even_index_va"
  stdout: ''
  timestamp: 1660009858
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val even = evens.min\n\
    \        val index = evens.indexOf(even)\n        val smalest_value = evens.take(index).min\n\
    \        val smalest_index = evens.indexOf(smalest_value)\n        val smalest_even\
    \ = evens.take(smalest_index).min\n        val smalest_even_index = evens.indexOf(smalest_even)\n\
    \        val smalest_even_and_index = smalest_even + smalest_index\n        val\
    \ smalest_even_and_index_list = List(smalest_even_and_index)\n        val smalest_even_and_index_list_with_zeros\
    \ = smalest_even_and_index_list ++ List(smalest_even_and_index)\n        val smalest_even_and_index_list_with_zeros_and_zeros\
    \ = smalest_even_and_index_list_with_zeros ++ List(smalest_even_and_index)\n \
    \       val smalest_even_and_index_list_with_zeros_and_zeros_and_zeros = smalest_even_and_index_list_with_zeros_and_zeros\
    \ ++ List(smalest_even_and_index)\n        val smalest_even_and_index_list_with_zeros_and_zeros_and_zeros_and_zeros\
    \ = smalest_even_and_index_list_with_zeros_and_zeros_and_zeros ++ List(smalest_even_and_index)\n\
    \        val smalest_even_and_index_list_with_zeros_and_zeros_and_zeros_and_zeros_and_zeros\
    \ = smalest_even_and_index_list_with_zeros_and_zeros_and_zeros_and_zeros ++ List(smalest_even_and_index)\n\
    \        val smalest_even_and_index_list_with_zeros_and_zeros_and_zeros_and_zeros_and_zeros_and_zeros\
    \ = smalest_even_and_index_list_with_zeros_and_zeros_and_zeros_and_zeros_and_zeros\
    \ ++ List(smalest_even_and_index)\n        val smalest_even_and_index_list_with_zeros_and_zeros_and_zeros_and_zeros_and_zeros_and_zeros_and_zeros\
    \ = smalest_even_and_index_list_with_zeros_and_zeros_and_zeros_and_zeros_and_zeros_and_zeros\
    \ ++ List(smalest_even_and_index)\n        val smalest_even_and_index_list_with_zeros_and_zeros_and_zeros_and_zeros_and_zeros_and_zeros_and_zeros_and_zeros\
    \ = smalest_even_and_index_list_with_zeros_and_zeros_and_zeros_and_zeros_and_zeros_and_zeros_and_zeros\
    \ ++ List(smalest_even_and_index)\n        val smalest_even_and_index_list_with_zeros_and_zeros_and_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmfjle1ly.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpmfjle1ly.scala:40:5 ---------------------\e[0m\e[0m\n\e[31m40 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009857
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        if (evens.isEmpty)\
    \ List()\n        else {\n            val smalest_value = evens.min\n        \
    \    val index = evens.indexOf(smalest_value)\n            val smalest_value_and_index\
    \ = smalest_value :: index :: Nil\n            smalest_value_and_index\n     \
    \   }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpx88q6h5a.scala:28:12\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m            smalest_value_and_index\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \            Found:    (smalest_value_and_index : List[AnyVal])\n\e[31m   |\e\
    [0m            Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009856
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_even = evens(smalest_index)\n        val smalest_even_index =\
    \ evens.indexOf(smalest_even)\n        val smalest_even_index = smalest_even_index\
    \ match {\n            case -1 => -1\n            case x => x\n        }\n   \
    \     val smalest_even_value = evens(smalest_even_index)\n        val smalest_even_value_index\
    \ = evens.indexOf(smalest_even_value)\n        val smalest_even_value_index =\
    \ smalest_even_value_index match {\n            case -1 => -1\n            case\
    \ x => x\n        }\n        val smalest_even_value_value = evens(smalest_even_value_index)\n\
    \        val smalest_even_value_value_index = evens.indexOf(smalest_even_value_value)\n\
    \        val smalest_even_value_value_index = smalest_even_value_value_index match\
    \ {\n            case -1 => -1\n            case x => x\n        }\n        val\
    \ smalest_even_value_value_value = evens(smalest_even_value_value_index)\n   \
    \     val smalest_even_value_value_value_index = evens.indexOf(smalest_even_value_value_value)\n\
    \        val smalest_even_value_value_value_index = smalest_even_value_value_value_index\
    \ match {\n            case -1 => -1\n            case x => x\n        }\n   \
    \     val smalest_even_value_value_value_index = evens.indexOf(smalest_even_value_value_value)\n\
    \        val smalest_even_value_value_value_index = smalest_even_value_value_value_index\
    \ match {\n            case -1 => -1\n            case x => x\n        }\n   \
    \     val smalest_even_value_value_value_index = evens.indexOf(smalest_even_value_value_value)\n\
    \        val smalest_even_value_value_value_index = smalest_even_value_value_value_index\
    \ match {\n            case -1 => -1\n            case x => x\n        }\n   \
    \     val smalest_even_value_value_value_value_index = evens.indexOf(smalest_even_value_value_value)\n\
    \        val smalest_even_value_value_value_value_index = smalest_even_value_value_value_value_index\
    \ match {\n            case -1 => -1\n            case x => x\n        }\n   \
    \     val smalest_even_value_value_value_value_index = evens.indexOf(smalest_even_value_value_value)\n\
    \        val smalest_even_value_value_value_value_index = smalest_even_value_value_value_value_index\
    \ match {\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpu36lfhu3.scala:66:4 ----------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    'case' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpu36lfhu3.scala:79:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m79 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpu36lfhu3.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m = smalest_even_index\
    \ \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0msmalest_even_index\
    \ is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m28 |\e[0m            \e[33mcase\e\
    [0m -\e[31m1\e[0m => -\e[31m1\e[0m\n\e[31m29 |\e[0m            \e[33mcase\e[0m\
    \ x => x\n\e[31m30 |\e[0m        }\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpu36lfhu3.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_even_value_index\e[0m = smalest_even_value_index \e[33mmatch\e\
    [0m {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0msmalest_even_value_index\
    \ is already defined as \e[33mvalue\e[0m \e[35msmalest_even_value_index\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m34 |\e[0m            \e[33mcase\e\
    [0m -\e[31m1\e[0m => -\e[31m1\e[0m\n\e[31m35 |\e[0m            \e[33mcase\e[0m\
    \ x => x\n\e[31m36 |\e[0m        }\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpu36lfhu3.scala:39:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_even_value_value_index\e[0m = smalest_even_value_value_index \e\
    [33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0msmalest_even_value_value_index\
    \ is already defined as \e[33mvalue\e[0m \e[35msmalest_even_value_value_index\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definiti"
  stdout: ''
  timestamp: 1660009859
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val even = evens.min\n\
    \        val index = evens.indexOf(even)\n        val result = if (index == -1)\
    \ Nil else List(even, index)\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph40kia2o.scala:26:8\
    \ ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[AnyVal])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009858
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0).sortBy(x => x).reverse\n\
    \        if (evens.isEmpty) List()\n        else {\n            val smalest_value\
    \ = evens.head\n            val smalest_index = evens.indexWhere(x => x == smalest_value)\n\
    \            val smalest_even = evens(smalest_index)\n            val smalest_even_index\
    \ = evens.indexWhere(x => x == smalest_even)\n            val smalest_even_value\
    \ = evens(smalest_even_index)\n            val smalest_even_index_list = List(smalest_even_index,\
    \ smalest_even_value)\n            val smalest_even_index_list_sorted = smalest_even_index_list.sortBy(x\
    \ => x).reverse\n            val smalest_even_index_list_sorted = smalest_even_index_list_sorted.takeWhile(x\
    \ => x < arr.length)\n            val smalest_even_index_list_sorted = smalest_even_index_list_sorted.takeWhile(x\
    \ => x >= 0)\n            val smalest_even_index_list_sorted = smalest_even_index_list_sorted.takeWhile(x\
    \ => x < arr.length)\n            val smalest_even_index_list_sorted = smalest_even_index_list_sorted.takeWhile(x\
    \ => x >= 0)\n            val smalest_even_index_list_sorted = smalest_even_index_list_sorted.takeWhile(x\
    \ => x < arr.length)\n            val smalest_even_index_list_sorted = smalest_even_index_list_sorted.takeWhile(x\
    \ => x >= 0)\n            val smalest_even_index_list_sorted = smalest_even_index_list_sorted.takeWhile(x\
    \ => x < arr.length)\n            val smalest_even_index_list_sorted = smalest_even_index_list_sorted.takeWhile(x\
    \ => x >= 0)\n            val smalest_even_index_list_sorted = smalest_even_index_list_sorted.takeWhile(x\
    \ => x < arr.length)\n            val smalest_even_index_list_sorted = smalest_even_index_list_sorted.takeWhile(x\
    \ => x >= 0)\n            val smalest_even_index_list_sorted = smalest_even_index_list_sorted.takeWhile(x\
    \ => x < arr.length)\n            val smalest_even_index_list_sorted = smalest_even_index_list_sorted.takeWhile(x\
    \ => x >= 0)\n            val smalest_even_index_list_sorted = smalest_even_index_list_sorted.takeWhile(x\
    \ => x < arr.length)\n            val smalest_even_index_list_sorted = smalest_even_index_list_sor\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpdk7kewxx.scala:59:0 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdk7kewxx.scala:32:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e\
    [0m \e[36msmalest_even_index_list_sorted\e[0m = smalest_even_index_list_sorted.takeWhile(\e\
    [36mx\e[0m => x < arr.length)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_sorted is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_list_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdk7kewxx.scala:33:16 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e[0m \e[36msmalest_even_index_list_sorted\e\
    [0m = smalest_even_index_list_sorted.takeWhile(\e[36mx\e[0m => x >= \e[31m0\e\
    [0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_sorted is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_list_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdk7kewxx.scala:34:16 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e[0m \e[36msmalest_even_index_list_sorted\e\
    [0m = smalest_even_index_list_sorted.takeWhile(\e[36mx\e[0m => x < arr.length)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_sorted is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_list_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-"
  stdout: ''
  timestamp: 1660009861
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        if (evens.isEmpty)\
    \ List()\n        else {\n            val smallestEven = evens.min\n         \
    \   val smallestIndex = evens.indexOf(smallestEven)\n            val smalestValue\
    \ = smallestEven % 2\n            List(smalestValue, smallestIndex)\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf7uxiniw.scala:32)\n\tat Problem.main(tmpf7uxiniw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009862
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smallest =\
    \ evens.min\n        val index = evens.indexOf(smallest)\n        val result =\
    \ if (index == -1) Nil else List(smallest, index)\n        result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe6mkdhaf.scala:26:8\
    \ ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[AnyVal])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009858
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val even = evens.min\n\
    \        val index = arr.indexOf(even)\n        val result = List(even, index)\n\
    \        if (evens.isEmpty) result\n        else result.reverse\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyualzn8_.scala:26:27\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mif\e[0m (evens.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    (result : List[AnyVal])\n\e[31m\
    \   |\e[0m                           Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyualzn8_.scala:27:20 --------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33melse\e[0m result.reverse\n\e[31m\e[31m\
    \   |\e[0m             ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             Found:\
    \    List[\e[1m\e[31mAnyVal\e[0m]\n\e[31m   |\e[0m             Required: List[\e\
    [1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009860
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smallestEven\
    \ = evens.min\n        val index = evens.indexOf(smallestEven)\n        val smalestValue\
    \ = evens(index)\n        val result: List[Long] = if (evens.isEmpty) Nil else\
    \ List(smallestEven, index)\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpceh6856s.scala:31)\n\tat Problem.main(tmpceh6856s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009862
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0).sortBy(x => x).reverse\n\
    \        val smalest_value = evens.head\n        val smalest_index = evens.indexOf(0)\n\
    \        val smalest_even = evens.takeWhile(x => x % 2 == 0).min\n        val\
    \ smalest_even_index = evens.indexOf(smalest_even)\n        val smalest_even_index\
    \ = smalest_even_index + 1\n        val smalest_even_index = smalest_even_index\
    \ - 1\n        val smalest_even_index = smalest_even_index - 1\n        val smalest_even_index\
    \ = smalest_even_index - 1\n        val smalest_even_index = smalest_even_index\
    \ - 1\n        val smalest_even_index = smalest_even_index - 1\n        val smalest_even_index\
    \ = smalest_even_index - 1\n        val smalest_even_index = smalest_even_index\
    \ - 1\n        val smalest_even_index = smalest_even_index - 1\n        val smalest_even_index\
    \ = smalest_even_index - 1\n        val smalest_even_index = smalest_even_index\
    \ - 1\n        val smalest_even_index = smalest_even_index - 1\n        val smalest_even_index\
    \ = smalest_even_index - 1\n        val smalest_even_index = smalest_even_index\
    \ - 1\n        val smalest_even_index = smalest_even_index - 1\n        val smalest_even_index\
    \ = smalest_even_index - 1\n        val smalest_even_index = smalest_even_index\
    \ - 1\n        val smalest_even_index = smalest_even_index - 1\n        val smalest_even_index\
    \ = smalest_even_index - 1\n        val smalest_even_index = smalest_even_index\
    \ - 1\n        val smalest_even_index = smalest_even_index - 1\n        val smalest_even_index\
    \ = smalest_even_index - 1\n        val smalest_even_index = smalest_even_index\
    \ - 1\n        val smalest_even_index = smalest_even_index - 1\n        val smalest_even_index\
    \ = smalest_even_index - 1\n        val smalest_even_index = smalest_even_index\
    \ - 1\n        val smalest_even_index = smalest_even_index - 1\n        val smalest_even_index\
    \ = smalest_even_index - 1\n        val smalest_even_index = smalest_even_index\
    \ - 1\n        val smalest_even_index = smalest_even_index - 1\n        val smalest_even_index\
    \ = smalest_even_index - 1\n        val \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp1gglyu3u.scala:58:11 ---------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp1gglyu3u.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m\
    \ = smalest_even_index + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_even_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp1gglyu3u.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m\
    \ = smalest_even_index - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_even_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp1gglyu3u.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m\
    \ = smalest_even_index - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_even_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp1gglyu3u.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m\
    \ = smalest_even_index - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m"
  stdout: ''
  timestamp: 1660009861
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(_ % 2 == 0)\n        val smallest = evens.min\n\
    \        val index = evens.indexOf(smallest)\n        val result = if (index ==\
    \ -1) List(smallest) else List(smallest, index)\n        result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgw_xmo82.scala:26:8\
    \ ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[AnyVal])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009861
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_even = evens(smalest_index)\n        val smalest_even_index =\
    \ evens.indexOf(smalest_even)\n        val smalest_even_value = evens(smalest_even_index)\n\
    \        val smalest_even_index_in_list = evens.indexOf(smalest_even_value)\n\
    \        val smalest_even_value_in_array = evens(smalest_even_index_in_list)\n\
    \        val smalest_even_index_in_array = evens.indexOf(smalest_even_value_in_array)\n\
    \        val smalest_even_value_in_array = evens(smalest_even_index_in_array)\n\
    \        val smalest_even_index_in_array = evens.indexOf(smalest_even_value_in_array)\n\
    \        val smalest_even_value_in_array = evens(smalest_even_index_in_array)\n\
    \        val smalest_even_index_in_array = evens.indexOf(smalest_even_value_in_array)\n\
    \        val smalest_even_value_in_array = evens(smalest_even_index_in_array)\n\
    \        val smalest_even_index_in_array = evens.indexOf(smalest_even_value_in_array)\n\
    \        val smalest_even_value_in_array = evens(smalest_even_index_in_array)\n\
    \        val smalest_even_index_in_array = evens.indexOf(smalest_even_value_in_array)\n\
    \        val smalest_even_value_in_array = evens(smalest_even_index_in_array)\n\
    \        val smalest_even_index_in_array = evens.indexOf(smalest_even_value_in_array)\n\
    \        val smalest_even_value_in_array = evens(smalest_even_index_in_array)\n\
    \        val smalest_even_index_in_array = evens.indexOf(smalest_even_value_in_array)\n\
    \        val smalest_even_value_in_array = evens(smalest_even_index_in_array)\n\
    \        val smalest_even_index_in_array = evens.indexOf(smalest_even_value_in_array)\n\
    \        val smalest_even_value_in_array = evens(smalest_even_index_in_array)\n\
    \        val smalest_even_index_in_array = evens.indexOf(smalest_even_value_in_array)\n\
    \        val smalest_even_value_in_array = evens(smalest_even_index_in_array)\n\
    \        val smalest_even_index_in_array = evens.indexOf(smalest_even_value_in_array)\n\
    \        val smalest_even_value_in_array = evens(smalest_even_index_in_array)\n\
    \        val sm\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq4ynhl4r.scala:51:4 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpq4ynhl4r.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_even_value_in_array\e[0m = evens(smalest_even_index_in_array)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_value_in_array is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_value_in_array\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpq4ynhl4r.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_in_array\e\
    [0m = evens.indexOf(smalest_even_value_in_array)\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_in_array is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_in_array\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpq4ynhl4r.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value_in_array\e\
    [0m = evens(smalest_even_index_in_array)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_value_in_array is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_value_in_array\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpq4ynhl4r.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_in_array\e\
    [0m = evens.indexOf(smalest_even_value_in_array)\n\e[31m\e[31"
  stdout: ''
  timestamp: 1660009862
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_evens = evens.take(smalest_index)\n        val smalest_evens_index\
    \ = evens.indexOf(smalest_evens.min) \n        val smalest_evens_value = smalest_evens.min\n\
    \        val smalest_evens_index = evens.indexOf(smalest_evens_value)\n      \
    \  val smalest_evens_index = evens.indexOf(smalest_evens_value)\n        val smalest_evens_index\
    \ = evens.indexOf(smalest_evens_value)\n        val smalest_evens_index = evens.indexOf(smalest_evens_value)\n\
    \        val smalest_evens_index = evens.indexOf(smalest_evens_value)\n      \
    \  val smalest_evens_index = evens.indexOf(smalest_evens_value)\n        val smalest_evens_index\
    \ = evens.indexOf(smalest_evens_value)\n        val smalest_evens_index = evens.indexOf(smalest_evens_value)\n\
    \        val smalest_evens_index = evens.indexOf(smalest_evens_value)\n      \
    \  val smalest_evens_index = evens.indexOf(smalest_evens_value)\n        val smalest_evens_index\
    \ = evens.indexOf(smalest_evens_value)\n        val smalest_evens_index = evens.indexOf(smalest_evens_value)\n\
    \        val smalest_evens_index = evens.indexOf(smalest_evens_value)\n      \
    \  val smalest_evens_index = evens.indexOf(smalest_evens_value)\n        val smalest_evens_index\
    \ = evens.indexOf(smalest_evens_value)\n        val smalest_evens_index = evens.indexOf(smalest_evens_value)\n\
    \        val smalest_evens_index = evens.indexOf(smalest_evens_value)\n      \
    \  val smalest_evens_index = evens.indexOf(smalest_evens_value)\n        val smalest_evens_index\
    \ = evens.indexOf(smalest_evens_value)\n        val smalest_evens_index = evens.indexOf(smalest_evens_value)\n\
    \        val smalest_evens_index = evens.indexOf(smalest_evens_value)\n      \
    \  val smalest_evens_index = evens.indexOf(smalest_evens_value)\n        val smalest_evens_index\
    \ = evens.indexOf(smalest_evens_value)\n        val smalest_evens_index = evens.indexOf(\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpe5vocnjc.scala:51:48 ---------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens_index\e[0m\
    \ = evens.indexOf(\n\e[31m\e[31m   |\e[0m                                    \
    \            ^\e[0m\n\e[31m   |\e[0m                                       expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpe5vocnjc.scala:28:12 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mval\e[0m \e[36msmalest_evens_index\e[0m = evens.indexOf(smalest_evens_value)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evens_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evens_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpe5vocnjc.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens_index\e[0m\
    \ = evens.indexOf(smalest_evens_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evens_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evens_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpe5vocnjc.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens_index\e[0m\
    \ = evens.indexOf(smalest_evens_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evens_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evens_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpe5vocnjc.scala:31:12 ---------------------------\e\
    [0"
  stdout: ''
  timestamp: 1660009862
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_even\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_even)\n     \
    \   val smalest_value = evens(smalest_index)\n        val smalest_evens = evens.filter(x\
    \ => x % 2 == smalest_value)\n        val smalest_evens_index = smalest_evens.indexOf(smalest_even)\n\
    \        val smalest_evens_value = smalest_evens(smalest_evens_index)\n      \
    \  val smalest_evens_index = smalest_evens.indexOf(smalest_even)\n        val\
    \ smalest_evens_value = smalest_evens(smalest_evens_index)\n        val smalest_evens_index\
    \ = smalest_evens.indexOf(smalest_even)\n        val smalest_evens_value = smalest_evens(smalest_evens_index)\n\
    \        val smalest_evens_index = smalest_evens.indexOf(smalest_even)\n     \
    \   val smalest_evens_value = smalest_evens(smalest_evens_index)\n        val\
    \ smalest_evens_index = smalest_evens.indexOf(smalest_even)\n        val smalest_evens_value\
    \ = smalest_evens(smalest_evens_index)\n        val smalest_evens_index = smalest_evens.indexOf(smalest_even)\n\
    \        val smalest_evens_value = smalest_evens(smalest_evens_index)\n      \
    \  val smalest_evens_index = smalest_evens.indexOf(smalest_even)\n        val\
    \ smalest_evens_value = smalest_evens(smalest_evens_index)\n        val smalest_evens_index\
    \ = smalest_evens.indexOf(smalest_even)\n        val smalest_evens_value = smalest_evens(smalest_evens_index)\n\
    \        val smalest_evens_index = smalest_evens.indexOf(smalest_even)\n     \
    \   val smalest_evens_value = smalest_evens(smalest_evens_index)\n        val\
    \ smalest_evens_index = smalest_evens.indexOf(smalest_even)\n        val smalest_evens_value\
    \ = smalest_evens(smalest_evens_index)\n        val smalest_evens_index = smalest_evens.indexOf(smalest_even)\n\
    \        val smalest_evens_value = smalest_evens(smalest_evens_index)\n\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3w97zdbz.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens_index\e[0m\
    \ = smalest_evens.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evens_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evens_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp3w97zdbz.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens_value\e[0m\
    \ = smalest_evens(smalest_evens_index)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evens_value is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evens_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp3w97zdbz.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens_index\e[0m\
    \ = smalest_evens.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evens_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evens_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp3w97zdbz.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens_value\e[0m\
    \ = smalest_evens(smalest_evens_index)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evens_value is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evens_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E1"
  stdout: ''
  timestamp: 1660009862
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val even = evens.min\n\
    \        val index = evens.indexOf(even)\n        val smalest_value = arr.min\n\
    \        val smalest_index = arr.indexOf(smalest_value)\n        val smalest_even\
    \ = evens.filter(x => x == smalest_value).min\n        val smalest_even_index\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index = if (smalest_even_index\
    \ == -1) -1 else smalest_even_index\n        val smalest_even_value = evens(smalest_even_index)\n\
    \        val smalest_even_value_index = evens.indexOf(smalest_even_value)\n  \
    \      val smalest_even_value_index = if (smalest_even_value_index == -1) -1 else\
    \ smalest_even_value_index\n        val smalest_even_value_even = evens(smalest_even_value_index)\n\
    \        val smalest_even_value_even_index = evens.indexOf(smalest_even_value_even)\n\
    \        val smalest_even_value_even_index = if (smalest_even_value_even_index\
    \ == -1) -1 else smalest_even_value_even_index\n        val smalest_even_value_even_value\
    \ = evens(smalest_even_value_even_index)\n        val smalest_even_value_even_value_index\
    \ = evens.indexOf(smalest_even_value_even_value)\n        val smalest_even_value_even_value_index\
    \ = if (smalest_even_value_even_value_index == -1) -1 else smalest_even_value_even_value_index\n\
    \        val smalest_even_value_even_value_even = evens(smalest_even_value_even_value_index)\n\
    \        val smalest_even_value_even_value_even_index = evens.indexOf(smalest_even_value_even_value_even)\n\
    \        val smalest_even_value_even_value_even_index = if (smalest_even_value_even_value_even_index\
    \ == -1) -1 else smalest_even_value_even_value_even_index\n        val smalest_even_value_even_value_even_value\
    \ = evens(smalest_even_value_even_value_even_index)\n        val smalest_even_value_even_value_even_value_index\
    \ = evens.indexOf(smalest_even_value_even_value_even_value)\n        val smalest_even_value_even_value_even_value_index\
    \ = if (smalest_even_value_even_value_even_value_index == -1) -1 else smalest_even_value_even_value_even_value_index\n\
    \        val smalest_even_value_even_value_even_value_even = evens(smalest_even_value_even_value_even_value_index)\n\
    \        val smalest_even_value_even_value_even_value_\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpkm5m4ea5.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkm5m4ea5.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_even_index\e[0m = \e[33mif\e[0m (smalest_even_index == -\e[31m1\e\
    [0m) -\e[31m1\e[0m \e[33melse\e[0m smalest_even_index\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_even_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpkm5m4ea5.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value_index\e\
    [0m = \e[33mif\e[0m (smalest_even_value_index == -\e[31m1\e[0m) -\e[31m1\e[0m\
    \ \e[33melse\e[0m smalest_even_value_index\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_value_index is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_value_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkm5m4ea5.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value_even_index\e\
    [0m = \e[33mif\e[0m (smalest_even_value_even_index == -\e[31m1\e[0m) -\e[31m1\e\
    [0m \e[33melse\e[0m smalest_even_value_even_index\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_value_even_index is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_value_even_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same gr"
  stdout: ''
  timestamp: 1660009863
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0).sorted\n        val smalest_value\
    \ = evens.head\n        val smalest_index = evens.indexOf(0)\n        val result\
    \ = if (smalest_index == -1) List(smalest_value, smalest_index) else evens.take(smalest_index).sorted\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpw2ruegd5.scala:26:8\
    \ ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[AnyVal])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009862
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(_ % 2 == 0)\n        val smalest_value =\
    \ evens.min\n        val smalest_index = evens.indexOfMin\n        val smalest_even\
    \ = evens(smalest_index)\n        val smalest_even_index = evens.indexOf(smalest_even)\n\
    \        val smalest_even_value = evens(smalest_even_index)\n        val smalest_even_index_list\
    \ = evens.toList\n        val smalest_even_index_list = evens.toList\n       \
    \ val smalest_even_index_list = evens.toList\n        val smalest_even_index_list\
    \ = evens.toList\n        val smalest_even_index_list = evens.toList\n       \
    \ val smalest_even_index_list = evens.toList\n        val smalest_even_index_list\
    \ = evens.toList\n        val smalest_even_index_list = evens.toList\n       \
    \ val smalest_even_index_list = evens.toList\n        val smalest_even_index_list\
    \ = evens.toList\n        val smalest_even_index_list = evens.toList\n       \
    \ val smalest_even_index_list = evens.toList\n        val smalest_even_index_list\
    \ = evens.toList\n        val smalest_even_index_list = evens.toList\n       \
    \ val smalest_even_index_list = evens.toList\n        val smalest_even_index_list\
    \ = evens.toList\n        val smalest_even_index_list = evens.toList\n       \
    \ val smalest_even_index_list = evens.toList\n        val smalest_even_index_list\
    \ = evens.toList\n        val smalest_even_index_list = evens.toList\n       \
    \ val smalest_even_index_list = evens.toList\n        val smalest_even_index_list\
    \ = evens.toList\n        val smalest_even_index_list = evens.toList\n       \
    \ val smalest_even_index_list = evens.toList\n        val smalest_even_index_list\
    \ = evens.toList\n        val smalest_even_index_list = evens.toList\n       \
    \ val smalest_even_index_list = evens.toList\n        val smalest_even_index_list\
    \ = evens.toList\n        val smalest_even_index_list = evens.toList\n       \
    \ val smalest_even_index_list = evens.toList\n        val smalest_even_index_list\
    \ = evens.toList\n        val smalest_even_index_list = evens.toList\n       \
    \ val smalest_even_index_list = evens.toList\n        val smalest_even\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnik01psb.scala:62:4 ----------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnik01psb.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_even_index_list\e[0m = evens.toList\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msmalest_even_index_list\
    \ is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index_list\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpnik01psb.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list\e[0m = evens.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msmalest_even_index_list is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_even_index_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnik01psb.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list\e\
    [0m = evens.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnik01psb.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list\e\
    [0m = evens.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods mus"
  stdout: ''
  timestamp: 1660009864
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_even = evens(smalest_index)\n        val smalest_even_index =\
    \ evens.indexOf(smalest_even)\n        val smalest_even_value = evens(smalest_even_index)\n\
    \        val smalest_even_index_list = evens.indexOf(smalest_even)\n        val\
    \ smalest_even_index_list_list = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = even\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb80je3pc.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_list_list_list_list_list_list_list_list\e\
    [0m = evens.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_list_list_list_list_list_list_list_list\
    \ is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index_list_list_list_list_list_list_list_list_list\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpb80je3pc.scala:40:12 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_list_list_list_list_list_list_list_list_list_list\e\
    [0m = evens.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_list_list_list_list_list_list_list_list_list_list\
    \ is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index_list_list_list_list_list_list_list_list_list_list_list\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpb80je3pc.scala:42:12 ---------------------------\e[0m\e[0m\n\e\
    [31m42 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list\e\
    [0m = evens.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNo"
  stdout: ''
  timestamp: 1660009813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val evensSorted\
    \ = evens.sortWith((x, y) => x < y)\n        val smallestEven = evensSorted.head\n\
    \        val smallestEvenIndex = evensSorted.indexOf(0)\n        val smallestEvenValue\
    \ = smallestEven\n        val smallestEvenIndex = smallestEvenIndex\n        val\
    \ smallestEvenValue = smallestEvenValue\n        val evensSorted = evens.sortWith((x,\
    \ y) => x < y)\n        val smallestEven = evensSorted.head\n        val smallestEvenIndex\
    \ = evensSorted.indexOf(0)\n        val smallestEvenValue = smallestEven\n   \
    \     val smallestEvenIndex = smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEvenValue\n        val evensSorted = evens.sortWith((x, y) => x <\
    \ y)\n        val smallestEven = evensSorted.head\n        val smallestEvenIndex\
    \ = evensSorted.indexOf(0)\n        val smallestEvenValue = smallestEven\n   \
    \     val smallestEvenIndex = smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEvenValue\n        val evensSorted = evens.sortWith((x, y) => x <\
    \ y)\n        val smallestEven = evensSorted.head\n        val smallestEvenIndex\
    \ = evensSorted.indexOf(0)\n        val smallestEvenValue = smallestEven\n   \
    \     val smallestEvenIndex = smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEvenValue\n        val evensSorted = evens.sortWith((x, y) => x <\
    \ y)\n        val smallestEven = evensSorted.head\n        val smallestEvenIndex\
    \ = evensSorted.indexOf(0)\n        val smallestEvenValue = smallestEven\n   \
    \     val smallestEvenIndex = smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEvenValue\n        val evensSorted = evens.sortWith((x, y) => x <\
    \ y)\n        val smallestEven = evensSorted.head\n        val smallestEvenIndex\
    \ = evensSorted.indexOf(0)\n        val smallestEvenValue = smallestEven\n   \
    \     val smallestEvenIndex = smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEvenValue\n        val evensSorted = evens.sortWith((x, y) => x <\
    \ y)\n        val smallestEven = evensSorted.head\n        val smallestEvenIndex\
    \ = evensSorted.indexOf(0)\n        val smallestEvenValue = smallestEven\n   \
    \     val smallestEvenIndex = smallestEvenIndex\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7b33h7dj.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp7b33h7dj.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m =\
    \ smallestEvenValue\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp7b33h7dj.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evens.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => x < y)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp7b33h7dj.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36msmallestEven\e[0m = evensSorted.head\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msmallestEven is already defined as \e[33mvalue\e[0m \e[35msmallestEven\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp7b33h7dj.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m = evensSorted.indexOf(\e\
    [31m0"
  stdout: ''
  timestamp: 1660009863
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_even = evens(smalest_index)\n        val smalest_even_index =\
    \ evens.indexOf(smalest_even)\n        if (smalest_even_index == -1) {\n     \
    \       List[Long]()\n        } else {\n            val smalest_even_value = evens(smalest_even_index)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_value)\n\
    \            val smalest_even_index_value = evens.indexOf(smalest_even_value)\n\
    \            val smalest_\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpj09nv2h0.scala:56:4 ----------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpj09nv2h0.scala:69:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m69 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpj09nv2h0.scala:32:16 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m            \e[33mval\e[0m \e[36msmalest_even_index_value\e[0m =\
    \ evens.indexOf(smalest_even_value)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj09nv2h0.scala:33:16 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = evens.indexOf(smalest_even_value)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj09nv2h0.scala:34:16 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = evens.indexOf(smalest_even_value)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj09nv2h0.scala:35:16 -----------------"
  stdout: ''
  timestamp: 1660009873
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val result = evens.takeWhile(x => x != smalest_value).takeWhile(x => x !=\
    \ smalest_index).reverse\n        if (result.isEmpty) Nil\n        else result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp96yocarq.scala:30)\n\tat Problem.main(tmp96yocarq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009882
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0).sorted\n        val smalest_even\
    \ = evens.head\n        val smalest_index = evens.indexOf(0)\n        val smalest_value\
    \ = smalest_even\n        val smalest_index_in_evens = evens.indexOf(smalest_even)\n\
    \        val smalest_index_in_evens_plus_1 = evens.indexOf(smalest_even + 1)\n\
    \        val smalest_index_in_evens_plus_2 = evens.indexOf(smalest_even + 2)\n\
    \        val smalest_index_in_evens_plus_3 = evens.indexOf(smalest_even + 3)\n\
    \        val smalest_index_in_evens_plus_4 = evens.indexOf(smalest_even + 4)\n\
    \        val smalest_index_in_evens_plus_5 = evens.indexOf(smalest_even + 5)\n\
    \        val smalest_index_in_evens_plus_6 = evens.indexOf(smalest_even + 6)\n\
    \        val smalest_index_in_evens_plus_7 = evens.indexOf(smalest_even + 7)\n\
    \        val smalest_index_in_evens_plus_8 = evens.indexOf(smalest_even + 8)\n\
    \        val smalest_index_in_evens_plus_9 = evens.indexOf(smalest_even + 9)\n\
    \        val smalest_index_in_evens_plus_10 = evens.indexOf(smalest_even + 10)\n\
    \        val smalest_index_in_evens_plus_11 = evens.indexOf(smalest_even + 11)\n\
    \        val smalest_index_in_evens_plus_12 = evens.indexOf(smalest_even + 12)\n\
    \        val smalest_index_in_evens_plus_13 = evens.indexOf(smalest_even + 13)\n\
    \        val smalest_index_in_evens_plus_14 = evens.indexOf(smalest_even + 14)\n\
    \        val smalest_index_in_evens_plus_15 = evens.indexOf(smalest_even + 15)\n\
    \        val smalest_index_in_evens_plus_16 = evens.indexOf(smalest_even + 16)\n\
    \        val smalest_index_in_evens_plus_17 = evens.indexOf(smalest_even + 17)\n\
    \        val smalest_index_in_evens_plus_18 = evens.indexOf(smalest_even + 18)\n\
    \        val smalest_index_in_evens_plus_19 = evens.indexOf(smalest_even + 19)\n\
    \        val smalest_index_in_evens_plus_20 = evens.indexOf(smalest_even + 20)\n\
    \        val smalest_index_in_evens_plus_21 = evens.indexOf(smalest_even \n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxy3ifpsq.scala:48:4 ----------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpxy3ifpsq.scala:48:5 ---------------------\e[0m\e[0m\n\e[31m48 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009878
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        if (evens.isEmpty)\
    \ Nil\n        else {\n            val smallestEven = evens.min\n            val\
    \ smallestIndex = evens.indexOf(smallestEven)\n            val evensAfterSmallestIndex\
    \ = evens.filter(_ != smallestEven)\n            val evensAfterSmallestIndexWithIndex\
    \ = evensAfterSmallestIndex.zipWithIndex\n            evensAfterSmallestIndexWithIndex.filter(_._2\
    \ == smallestIndex).map(_._1)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7bvso25e.scala:33)\n\tat Problem.main(tmp7bvso25e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smallestEven\
    \ = evens.min\n        val smallestIndex = evens.indexOf(smallestEven)\n     \
    \   val result = if (smallestEven != 0) evens.take(smallestIndex) else evens\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphgbyzyp4.scala:29)\n\tat Problem.main(tmphgbyzyp4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smallest =\
    \ evens.min\n        val index = evens.indexOf(smallest)\n        val result =\
    \ List(smallest, index)\n        if (arr.isEmpty) result\n        else result.::(pluck(arr.filter(_\
    \ != smallest)))\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb4fwt5co.scala:26:25\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mif\e[0m (arr.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                         ^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                         Found:    (result : List[AnyVal])\n\e[31m   |\e\
    [0m                         Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpb4fwt5co.scala:27:22 --------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33melse\e[0m result.::(pluck(arr.filter(_\
    \ != smallest)))\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m             Found:    List[Matchable]\n\e[31m   |\e[0m  \
    \           Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009880
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_even = evens(smalest_index)\n        val smalest_even_index =\
    \ evens.indexOf(smalest_even)\n        val smalest_even_value = evens(smalest_even_index)\n\
    \        val smalest_even_index_list = evens.indexOf(smalest_even)\n        val\
    \ smalest_even_index_list_list = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = even\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb80je3pc.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_list_list_list_list_list_list_list_list\e\
    [0m = evens.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_list_list_list_list_list_list_list_list\
    \ is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index_list_list_list_list_list_list_list_list_list\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpb80je3pc.scala:40:12 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_list_list_list_list_list_list_list_list_list_list\e\
    [0m = evens.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_list_list_list_list_list_list_list_list_list_list\
    \ is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index_list_list_list_list_list_list_list_list_list_list_list\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpb80je3pc.scala:42:12 ---------------------------\e[0m\e[0m\n\e\
    [31m42 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list\e\
    [0m = evens.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNo"
  stdout: ''
  timestamp: 1660009813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        if (evens.isEmpty)\
    \ List()\n        else {\n            val smalest_value = evens.min\n        \
    \    val smalest_index = evens.indexOf(smalest_value)\n            val smalest_even_value\
    \ = evens(smalest_index)\n            val smalest_even_index = evens.indexOf(smalest_even_value)\n\
    \            val smalest_even_value_with_index = smalest_value + smalest_even_index\n\
    \            val smalest_even_value_with_index_list = List(smalest_even_value_with_index)\n\
    \            val smalest_even_value_with_index_list_sorted = smalest_even_value_with_index_list.sortWith((x,\
    \ y) => x < y)\n            val smalest_even_value_with_index_list_sorted_with_first_index\
    \ = smalest_even_value_with_index_list_sorted.take(1)\n            val smalest_even_value_with_index_list_sorted_with_first_index_and_index\
    \ = smalest_even_value_with_index_list_sorted_with_first_index._1 + smalest_even_value_with_index_list_sorted_with_first_index._2\n\
    \            val smalest_even_value_with_index_list_sorted_with_first_index_and_index_list\
    \ = List(smalest_even_value_with_index_list_sorted_with_first_index_and_index)\n\
    \            val smalest_even_value_with_index_list_sorted_with_first_index_and_index_list_sorted\
    \ = smalest_even_value_with_index_list_sorted_with_first_index_and_index_list_sorted.sortWith((x,\
    \ y) => x < y)\n            val smalest_even_value_with_index_list_sorted_with_first_index_and_index_list_sorted_with_first_index\
    \ = smalest_even_value_with_index_list_sorted_with_first_index_and_index_list_sorted_with_first_index._1\
    \ + smalest_even_value_with_index_list_sorted_with_first_index_and_index_list_sorted_with_first_index._2\n\
    \            val smalest_even_value_with_index_list_sorted_with_first_index_and_index_list_sorted_with_first_index_list\
    \ = List(smalest_even_value_with_index_list_sorted_with_first_index_and_index_list_sorted_with_first_index)\n\
    \            val smalest_even_value_with_index_list_sorted_with_first_index_and_index_list_sorted_with_first_index_list_sorted\
    \ = smalest_even_value_with_index_list_sorted_with_first_index_and_index_list_sorted_with_first_index_list_sorted.sortWith((x,\
    \ y) => x < y)\n            val smalest_even_value_with_index_list_sorted_with_first_index_and_index_list_sorted_with_first_index_list_sorted_with_first_index\
    \ = smalest_even_value_with_index_list_sorted_with_first_index_and_index_list_sorted_with_first_index_list_sorted_with_first_index._1\
    \ + smalest_even_value_with_index_\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpv51w57x5.scala:53:0 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpv51w57x5.scala:33:146\
    \ -----------------------\e[0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e[0m\
    \ \e[36msmalest_even_value_with_index_list_sorted_with_first_index_and_index\e\
    [0m = smalest_even_value_with_index_list_sorted_with_first_index._1 + smalest_even_value_with_index_list_sorted_with_first_index._2\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  value _1 is not a member\
    \ of List[Long]\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpv51w57x5.scala:35:99\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e\
    [0m \e[36msmalest_even_value_with_index_list_sorted_with_first_index_and_index_list_sorted\e\
    [0m = smalest_even_value_with_index_list_sorted_with_first_index_and_index_list_sorted.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => x < y)\n\e[31m\e[31m   |\e[0m                   \
    \                                                                            \
    \    ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m\
    \  smalest_even_value_with_index_list_sorted_with_first_index_and_index_list_sorted\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpv51w57x5.scala:36:116 --------------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m            \e[33mval\e[0m \e[36msmalest_even_value_with_index_list_sorted_with_first_index_and_index_list_sorted_with_first_index\e\
    [0m = smalest_even_value_with_index_list_sorted_with_first_index_and_index_list_sorted_with_first_index._1\
    \ + smalest_even_value_with_index_list_sorted_with_first_index_and_index_list_sorted_with_first_index._2\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \            "
  stdout: ''
  timestamp: 1660009882
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val evensSorted\
    \ = evens.sortWith((x, y) => x < y)\n        val smallestEven = evensSorted.head\n\
    \        val smallestEvenIndex = evensSorted.indexOf(0)\n        val smallestEvenValue\
    \ = smallestEven\n        val smallestEvenIndexList = List(smallestEvenIndex,\
    \ smallestEvenValue)\n        val smallestEvenIndexSorted = smallestEvenIndexList.sortWith((x,\
    \ y) => x < y)\n        val smallestEvenIndexValue = smallestEvenIndexSorted.head\n\
    \        val smallestEvenIndexIndex = smallestEvenIndexSorted.indexOf(0)\n   \
    \     val smallestEvenIndexValue = smallestEvenIndex\n        val smallestEvenIndexList\
    \ = List(smallestEvenIndexValue, smallestEvenIndexIndex)\n        val smallestEvenIndexSorted\
    \ = smallestEvenIndexList.sortWith((x, y) => x < y)\n        val smallestEvenIndexValue\
    \ = smallestEvenIndexSorted.head\n        val smallestEvenIndexIndex = smallestEvenIndexSorted.indexOf(0)\n\
    \        val smallestEvenIndexValue = smallestEvenIndex\n        val smallestEvenIndexList\
    \ = List(smallestEvenIndexValue, smallestEvenIndexIndex)\n        val smallestEvenIndexSorted\
    \ = smallestEvenIndexList.sortWith((x, y) => x < y)\n        val smallestEvenIndexValue\
    \ = smallestEvenIndexSorted.head\n        val smallestEvenIndexIndex = smallestEvenIndexSorted.indexOf(0)\n\
    \        val smallestEvenIndexValue = smallestEvenIndex\n        val smallestEvenIndexList\
    \ = List(smallestEvenIndexValue, smallestEvenIndexIndex)\n        val smallestEvenIndexSorted\
    \ = smallestEvenIndexList.sortWith((x, y) => x < y)\n        val smallestEvenIndexValue\
    \ = smallestEvenIndexSorted.head\n        val smallestEvenIndexIndex = smallestEvenIndexSorted.indexOf(0)\n\
    \        val smallestEvenIndexValue = smallestEvenIndex\n        val smallestEvenIndexList\
    \ = List(smallestEvenIndexValue, smallestEvenIndexIndex)\n        val smallestEvenIndexSorted\
    \ = smallestEvenIndexList.sortWith((x, y) => x < y)\n        val smallestEvenIndexValue\
    \ = smallestEvenIndexSorted.head\n        val smallestEvenIndexIndex = smallestEvenIndexSorted.indexOf(0)\n\
    \        val smallestEvenIndexValue = smallestEvenIndex\n        val smallestEvenIndexList\
    \ = List(smallestEvenIndexValue, smallestEvenIndexIndex)\n        val smallestEvenIndexSorted\
    \ = smallestEvenIndexList.sortWith((\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpev8dinoc.scala:53:70 ---------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndexSorted\e\
    [0m = smallestEvenIndexList.sortWith((\n\e[31m\e[31m   |\e[0m                \
    \                                                      ^\e[0m\n\e[31m   |\e[0m\
    \                                       expression expected but \e[31m'}'\e[0m\
    \ found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpev8dinoc.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmallestEvenIndexValue\e[0m = smallestEvenIndex\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msmallestEvenIndexValue\
    \ is already defined as \e[33mvalue\e[0m \e[35msmallestEvenIndexValue\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpev8dinoc.scala:32:12 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndexList\e[0m = List(smallestEvenIndexValue,\
    \ smallestEvenIndexIndex)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndexList is already defined as \e[33mvalue\e\
    [0m \e[35msmallestEvenIndexList\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpev8dinoc.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndexSorted\e\
    [0m = smallestEvenIndexList.sortWith((\e[36mx\e[0m, \e[36my\e[0m) => x < y)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndexSorted is already defined as \e[33mvalue\e\
    [0m \e[35msmallestEvenIndexSorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the sa"
  stdout: ''
  timestamp: 1660009882
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_evens = evens.take(smalest_index)\n        val smalest_evens_index\
    \ = evens.indexOf(smalest_evens.min) match {\n            case Some(index) =>\
    \ index\n            case None => 0\n        }\n        val smalest_evens_value\
    \ = smalest_evens(smalest_evens_index)\n        val smalest_evens_index = smalest_evens_index\
    \ + 1\n        val smalest_evens_value = smalest_evens_value\n        val smalest_evens_index\
    \ = smalest_evens_index + 1\n        val smalest_evens_value = smalest_evens_value\n\
    \        val smalest_evens_index = smalest_evens_index + 1\n        val smalest_evens_value\
    \ = smalest_evens_value\n        val smalest_evens_index = smalest_evens_index\
    \ + 1\n        val smalest_evens_value = smalest_evens_value\n        val smalest_evens_index\
    \ = smalest_evens_index + 1\n        val smalest_evens_value = smalest_evens_value\n\
    \        val smalest_evens_index = smalest_evens_index + 1\n        val smalest_evens_value\
    \ = smalest_evens_value\n        val smalest_evens_index = smalest_evens_index\
    \ + 1\n        val smalest_evens_value = smalest_evens_value\n        val smalest_evens_index\
    \ = smalest_evens_index + 1\n        val smalest_evens_value = smalest_evens_value\n\
    \        val smalest_evens_index = smalest_evens_index + 1\n        val smalest_evens_value\
    \ = smalest_evens_value\n        val smalest_evens_index = smalest_evens_index\
    \ + 1\n        val smalest_evens_value = smalest_evens_value\n        val smalest_evens_index\
    \ = smalest_evens_index + 1\n        val smalest_evens_value = smalest_evens_value\n\
    \        val smalest_evens_index = smalest_evens_index + 1\n        val smalest_evens_value\
    \ = smalest_evens_value\n        val smalest_evens_index = smalest_evens_index\
    \ + 1\n        val smalest_evens_value = smalest_evens_value\n        \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqtnjt7k8.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens_index\e[0m\
    \ = smalest_evens_index + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evens_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evens_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpqtnjt7k8.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens_value\e[0m\
    \ = smalest_evens_value\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evens_value is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evens_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpqtnjt7k8.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens_index\e[0m\
    \ = smalest_evens_index + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evens_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evens_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpqtnjt7k8.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens_value\e[0m\
    \ = smalest_evens_value\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evens_value is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evens_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpqtnjt7k8.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_even = evens(smalest_index)\n        val smalest_even_index =\
    \ evens.indexOf(smalest_even)\n        val smalest_even_value = evens(smalest_even_index)\n\
    \        val smalest_even_index_in_list = evens.indexOf(smalest_even_value)\n\
    \        val smalest_even_index_in_list_in_list = evens.indexOf(smalest_even_index_in_list)\n\
    \        val smalest_even_index_in_list_in_list_in_list = evens.indexOf(smalest_even_index_in_list_in_list)\n\
    \        val smalest_even_index_in_list_in_list_in_list_in_list = evens.indexOf(smalest_even_index_in_list_in_list_in_list)\n\
    \        val smalest_even_index_in_list_in_list_in_list_in_list_in_list = evens.indexOf(smalest_even_index_in_list_in_list_in_list_in_list)\n\
    \        val smalest_even_index_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = evens.indexOf(smalest_even_index_in_list_in_list_in_list_in_list_in_list)\n\
    \        val smalest_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = evens.indexOf(smalest_even_index_in_list_in_list_in_list_in_list_in_list_in_list)\n\
    \        val smalest_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = evens.indexOf(smalest_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list)\n\
    \        val smalest_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = evens.indexOf(smalest_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list)\n\
    \        val smalest_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = evens.indexOf(smalest_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list)\n\
    \        val smalest_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = evens.indexOf(smalest_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpusp2ry30.scala:39:4 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpusp2ry30.scala:35:111\
    \ --------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\e\
    [0m = evens.indexOf(smalest_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                       ^\e[0m\n\e[31m   |\e[0mRecursive\
    \ \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  smalest_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpusp2ry30.scala:36:127 --------------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\e\
    [0m = evens.indexOf(smalest_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                       ^\e[0m\n\
    \e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  smalest_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpusp2ry30.scala:37:135 --------------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\e\
    [0m = evens.indexOf(smalest_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list"
  stdout: ''
  timestamp: 1660009882
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val even = arr.filter(x => x % 2 == 0).sortBy(x => x).takeWhile(x\
    \ => x < arr.last).map(x => x).reverse\n        if (even.isEmpty) List()\n   \
    \     else even.headOption\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6dzos7oq.scala:24:18\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33melse\e[0m even.headOption\n\
    \e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \       Found:    \e[1m\e[31mOption\e[0m[Long]\n\e[31m   |\e[0m             Required:\
    \ \e[1m\e[32mList\e[0m[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009882
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smallestEven\
    \ = evens.min\n        val index = evens.indexOf(smallestEven)\n        val smallestEvenValue\
    \ = arr(index)\n        val result: List[Long] = if (evens.isEmpty) Nil else List(smallestEvenValue,\
    \ index)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpr7f6g2rk.scala:31)\n\tat Problem.main(tmpr7f6g2rk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009885
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(_ % 2 == 0).sortBy(_).reverse\n        val\
    \ smallest = evens.head\n        val index = evens.indexOfFirst { _ == smallest\
    \ }\n        if (index == -1) List(smallest, 0)\n        else List(smallest, index)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpeng6n7hy.scala:22:50 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_).reverse\n\e[31m\e[31m   |\e[0m   \
    \                                               ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$2 of expanded function:\n\e[31m   |\e[0m   _$2 => arr.filter(_$1\
    \ => _$1 % 2 == 0).sortBy(_$2).reverse.\n\e[31m\e[31m-- Error: /tmp/tmpeng6n7hy.scala:22:52\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m22 |\e[0m       \
    \ \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                                                    ^\e[0m\n\
    \e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mByte\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660009877
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val even = arr.filter(_ % 2 == 0).sortBy(x => x).take(1)\n    \
    \    if (even.isEmpty) List()\n        else even.head\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0z0slj1_.scala:24:18\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33melse\e[0m even.head\n\
    \e[31m\e[31m   |\e[0m             ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \ Found:    Long\n\e[31m   |\e[0m             Required: \e[1m\e[32mList\e[0m\e\
    [1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val even = evens.min\n\
    \        val index = evens.indexOf(even)\n        val result = if (index == -1)\
    \ Nil else List(even, index)\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph40kia2o.scala:26:8\
    \ ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[AnyVal])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009858
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val even = arr.filter(x => x % 2 == 0)\n        val evenSorted\
    \ = even.sortWith((x, y) => x < y)\n        val smalest_value = evenSorted.head\n\
    \        val smalest_index = evenSorted.indexOf(0)\n        val index = evenSorted.indexOf(smalest_value)\n\
    \        val smalest_even_value = evenSorted.take(index).sum\n        val smalest_even_index_list\
    \ = evenSorted.take(index).zipWithIndex.filter(_._1 == smalest_value)\n      \
    \  val smalest_even_index_list = smalest_even_index_list.sortWith((x, y) => x\
    \ < y)\n        val smalest_even_index_list = smalest_even_index_list.take(1)\n\
    \        val smalest_even_index_list = smalest_even_index_list.last\n        val\
    \ smalest_even_index_list = smalest_even_index_list.last\n        val smalest_even_index_list\
    \ = smalest_even_index_list.last\n        val smalest_even_index_list = smalest_even_index_list.last\n\
    \        val smalest_even_index_list = smalest_even_index_list.last\n        val\
    \ smalest_even_index_list = smalest_even_index_list.last\n        val smalest_even_index_list\
    \ = smalest_even_index_list.last\n        val smalest_even_index_list = smalest_even_index_list.last\n\
    \        val smalest_even_index_list = smalest_even_index_list.last\n        val\
    \ smalest_even_index_list = smalest_even_index_list.last\n        val smalest_even_index_list\
    \ = smalest_even_index_list.last\n        val smalest_even_index_list = smalest_even_index_list.last\n\
    \        val smalest_even_index_list = smalest_even_index_list.last\n        val\
    \ smalest_even_index_list = smalest_even_index_list.last\n        val smalest_even_index_list\
    \ = smalest_even_index_list.last\n        val smalest_even_index_list = smalest_even_index_list.last\n\
    \        val smalest_even_index_list = smalest_even_index_list.last\n        val\
    \ smalest_even_index_list = smalest_even_index_list.last\n        val smalest_even_index_list\
    \ = smalest_even_index_list.last\n        val smalest_even_index_list = smalest_even_index_list.last\n\
    \        val smalest_even_index_list = smalest_even_index_list.last\n        val\
    \ smalest_even_index_list = smalest_even_index_list.last\n        val smalest_even_index_list\
    \ = smalest_even_index_list.\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbyio4j2k.scala:54:4 ----------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpbyio4j2k.scala:29:12 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list\e[0m = smalest_even_index_list.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => x < y)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbyio4j2k.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list\e\
    [0m = smalest_even_index_list.take(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msmalest_even_index_list is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index_list\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpbyio4j2k.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list\e[0m = smalest_even_index_list.last\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbyio4j2k.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list\e\
    [0m = smalest_even_index_list.last\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_even = evens(smalest_index)\n        val smalest_even_index =\
    \ evens.indexOf(smalest_even)\n        val smalest_even_index = smalest_even_index\
    \ + 1\n        val smalest_even_value = evens(smalest_even_index)\n        val\
    \ smalest_even_value = smalest_even_value.toLong\n        val smalest_even_value\
    \ = smalest_even_value.toInt\n        val smalest_even_value = smalest_even_value.toDouble\n\
    \        val smalest_even_value = smalest_even_value.toFloat\n        val smalest_even_value\
    \ = smalest_even_value.toBoolean\n        val smalest_even_value = smalest_even_value.toChar\n\
    \        val smalest_even_value = smalest_even_value.toByte\n        val smalest_even_value\
    \ = smalest_even_value.toShort\n        val smalest_even_value = smalest_even_value.toInt\n\
    \        val smalest_even_value = smalest_even_value.toLong\n        val smalest_even_value\
    \ = smalest_even_value.toFloat\n        val smalest_even_value = smalest_even_value.toDouble\n\
    \        val smalest_even_value = smalest_even_value.toBoolean\n        val smalest_even_value\
    \ = smalest_even_value.toChar\n        val smalest_even_value = smalest_even_value.toByte\n\
    \        val smalest_even_value = smalest_even_value.toShort\n        val smalest_even_value\
    \ = smalest_even_value.toInt\n        val smalest_even_value = smalest_even_value.toLong\n\
    \        val smalest_even_value = smalest_even_value.toFloat\n        val smalest_even_value\
    \ = smalest_even_value.toDouble\n        val smalest_even_value = smalest_even_value.toBoolean\n\
    \        val smalest_even_value = smalest_even_value.toChar\n        val smalest_even_value\
    \ = smalest_even_value.toByte\n        val smalest_even_value = smalest_even_value.toShort\n\
    \        val smalest_even_value = smalest_even_value.toInt\n        val smalest_even_value\
    \ = smalest_even_value.toLong\n        val smalest_even_value = smalest_even_value.toFloat\n\
    \        val smalest_even_value = smalest_even\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxyw3yq4t.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m\
    \ = smalest_even_index + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_even_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpxyw3yq4t.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value\e[0m\
    \ = smalest_even_value.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_value is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_even_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpxyw3yq4t.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value\e[0m\
    \ = smalest_even_value.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_value is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_even_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpxyw3yq4t.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value\e[0m\
    \ = smalest_even_value.toDouble\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_value is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_even_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpxyw3yq4t.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val even = evens.min\n\
    \        val index = evens.indexOf(even)\n        val result = if (index == -1)\
    \ List[Long]() else List(even, index)\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6lj0nitg.scala:26:8\
    \ ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[AnyVal])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0).sortBy(x => x)\n      \
    \  val smalest_value = evens.head\n        val smalest_index = evens.indexOf(0)\n\
    \        val result = if (smalest_index == -1) List(smalest_value, smalest_index)\
    \ else evens.take(smalest_index).sortBy(x => x).reverse\n        result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprf19w048.scala:26:8\
    \ ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[AnyVal])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009884
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_even = evens(smalest_index)\n        val smalest_even_index =\
    \ evens.indexOf(smalest_even)\n        val smalest_even_value = evens(smalest_even_index)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_value)\n  \
    \      val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8dwtjk_q.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = evens.indexOf(smalest_even_index_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8dwtjk_q.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = evens.indexOf(smalest_even_index_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8dwtjk_q.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = evens.indexOf(smalest_even_index_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8dwtjk_q.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = evens.indexOf(smalest_even_index_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31"
  stdout: ''
  timestamp: 1660009815
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smallest =\
    \ evens.min\n        val index = evens.indexOf(smallest)\n        val result =\
    \ (smallest, index)\n        if (arr.isEmpty) result\n        else arr.take(index).concat(result)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5zatynt7.scala:26:25\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mif\e[0m (arr.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                         ^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                         Found:    (result : (Long, Int))\n\e[31m   |\e\
    [0m                         Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp5zatynt7.scala:27:36 --------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33melse\e[0m arr.take(index).concat(result)\n\
    \e[31m\e[31m   |\e[0m                                    ^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                                    Found:    (result : (Long, Int))\n\
    \e[31m   |\e[0m                                    Required: IterableOnce[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009885
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(_ % 2 == 0)\n        val smalest_value =\
    \ evens.min\n        val smalest_index = evens.indexOfMin\n        val smalest_even\
    \ = evens.find(_ == smalest_value)\n        val smalest_even_index = smalest_even.get\n\
    \        val smalest_even_value = smalest_even_index\n        val smalest_even_pos\
    \ = evens.indexOf(smalest_even_value)\n        val smalest_even_pos_value = smalest_even_pos\n\
    \        val smalest_even_pos_index = smalest_even_pos_value\n        val smalest_even_pos_index\
    \ = smalest_even_pos_value\n        val smalest_even_pos_index = smalest_even_pos_value\n\
    \        val smalest_even_pos_index = smalest_even_pos_value\n        val smalest_even_pos_index\
    \ = smalest_even_pos_value\n        val smalest_even_pos_index = smalest_even_pos_value\n\
    \        val smalest_even_pos_index = smalest_even_pos_value\n        val smalest_even_pos_index\
    \ = smalest_even_pos_value\n        val smalest_even_pos_index = smalest_even_pos_value\n\
    \        val smalest_even_pos_index = smalest_even_pos_value\n        val smalest_even_pos_index\
    \ = smalest_even_pos_value\n        val smalest_even_pos_index = smalest_even_pos_value\n\
    \        val smalest_even_pos_index = smalest_even_pos_value\n        val smalest_even_pos_index\
    \ = smalest_even_pos_value\n        val smalest_even_pos_index = smalest_even_pos_value\n\
    \        val smalest_even_pos_index = smalest_even_pos_value\n        val smalest_even_pos_index\
    \ = smalest_even_pos_value\n        val smalest_even_pos_index = smalest_even_pos_value\n\
    \        val smalest_even_pos_index = smalest_even_pos_value\n        val smalest_even_pos_index\
    \ = smalest_even_pos_value\n        val smalest_even_pos_index = smalest_even_pos_value\n\
    \        val smalest_even_pos_index = smalest_even_pos_value\n        val smalest_even_pos_index\
    \ = smalest_even_pos_value\n        val smalest_even_pos_index = smalest_ev\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnpu93tbl.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_pos_index\e\
    [0m = smalest_even_pos_value\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_pos_index is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_pos_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnpu93tbl.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_pos_index\e\
    [0m = smalest_even_pos_value\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_pos_index is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_pos_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnpu93tbl.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_pos_index\e\
    [0m = smalest_even_pos_value\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_pos_index is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_pos_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnpu93tbl.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_pos_index\e\
    [0m = smalest_even_pos_value\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_pos_index is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_pos_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnpu93tbl.scala:35:12 -----"
  stdout: ''
  timestamp: 1660009885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(_ % 2 == 0)\n        val smallest = evens.min\n\
    \        val index = evens.indexOf(smallest)\n        val result: List[Long] =\
    \ if (index > 0) evens.take(index) else evens\n        result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbhisotpp.scala:29)\n\tat Problem.main(tmpbhisotpp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009886
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_even\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_even)\n     \
    \   val smalest_value = evens(smalest_index)\n        val smalest_evens = evens.filter(x\
    \ => x % 2 == smalest_value)\n        val smalest_evens_index = smalest_evens.indexOf(smalest_even)\n\
    \        val smalest_evens_value = smalest_evens(smalest_evens_index)\n      \
    \  val smalest_evens_index = smalest_evens.indexOf(smalest_evens_value)\n    \
    \    val smalest_evens_value = smalest_evens(smalest_evens_index)\n        val\
    \ smalest_evens_index = smalest_evens.indexOf(smalest_evens_value)\n        val\
    \ smalest_evens_value = smalest_evens(smalest_evens_index)\n        val smalest_evens_index\
    \ = smalest_evens.indexOf(smalest_evens_value)\n        val smalest_evens_value\
    \ = smalest_evens(smalest_evens_index)\n        val smalest_evens_index = smalest_evens.indexOf(smalest_evens_value)\n\
    \        val smalest_evens_value = smalest_evens(smalest_evens_index)\n      \
    \  val smalest_evens_index = smalest_evens.indexOf(smalest_evens_value)\n    \
    \    val smalest_evens_value = smalest_evens(smalest_evens_index)\n        val\
    \ smalest_evens_index = smalest_evens.indexOf(smalest_evens_value)\n        val\
    \ smalest_evens_value = smalest_evens(smalest_evens_index)\n        val smalest_evens_index\
    \ = smalest_evens.indexOf(smalest_evens_value)\n        val smalest_evens_value\
    \ = smalest_evens(smalest_evens_index)\n        val smalest_evens_index = smalest_evens.indexOf(smalest_evens_value)\n\
    \        val smalest_evens_value = smalest_evens(smalest_evens_index)\n      \
    \  val smalest_evens_index = smalest_evens.indexOf(smalest_evens_value)\n    \
    \    val smalest_evens_value = smalest_evens(smalest_evens_index)\n        val\
    \ smalest_evens_index = smalest_evens.indexOf(smalest_evens_value)\n        val\
    \ smalest_evens_value = smale\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9upmt090.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens_index\e[0m\
    \ = smalest_evens.indexOf(smalest_evens_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evens_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evens_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp9upmt090.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens_value\e[0m\
    \ = smalest_evens(smalest_evens_index)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evens_value is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evens_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp9upmt090.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens_index\e[0m\
    \ = smalest_evens.indexOf(smalest_evens_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evens_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evens_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp9upmt090.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens_value\e[0m\
    \ = smalest_evens(smalest_evens_index)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evens_value is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evens_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel "
  stdout: ''
  timestamp: 1660009885
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0).sorted\n        val smalest_value\
    \ = evens.head\n        val smalest_index = evens.indexOf(0)\n        if (evens.isEmpty)\
    \ List()\n        else evens.takeWhile(x => x != smalest_value).map(x => (x, smalest_index)).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn16y9llc.scala:26:83\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33melse\e[0m evens.takeWhile(x\
    \ => x != smalest_value).map(x => (x, smalest_index)).toList\n\e[31m\e[31m   |\e\
    [0m             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m             Found:    List[\e[1m\e[31m(\e[0mLong\e[1m\e[31m,\e\
    [0m\e[1m\e[31m \e[0m\e[1m\e[31mInt\e[0m\e[1m\e[31m)\e[0m]\n\e[31m   |\e[0m   \
    \          Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009885
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_even = evens(smalest_index)\n        val smalest_even_index =\
    \ evens.indexOf(smalest_even)\n        val smalest_even_value = evens(smalest_even_index)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_value)\n  \
    \      val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8dwtjk_q.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = evens.indexOf(smalest_even_index_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8dwtjk_q.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = evens.indexOf(smalest_even_index_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8dwtjk_q.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = evens.indexOf(smalest_even_index_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8dwtjk_q.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = evens.indexOf(smalest_even_index_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31"
  stdout: ''
  timestamp: 1660009815
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smallests\
    \ = evens.sortWith((x, y) => x < y)\n        val smallest = smallests.head\n \
    \       val index = smallests.indexOf(0)\n        val result: List[Long] = if\
    \ (smallest == 0) List(smallest) else List(smallest, index)\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdnkdfjov.scala:30)\n\tat Problem.main(tmpdnkdfjov.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009899
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_even = evens(smalest_index)\n        val smalest_even_index =\
    \ evens.indexOf(smalest_even)\n        val smalest_even_value = evens(smalest_even_index)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_value)\n  \
    \      val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8dwtjk_q.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = evens.indexOf(smalest_even_index_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8dwtjk_q.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = evens.indexOf(smalest_even_index_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8dwtjk_q.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = evens.indexOf(smalest_even_index_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8dwtjk_q.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = evens.indexOf(smalest_even_index_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31"
  stdout: ''
  timestamp: 1660009815
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0).sortBy(x => x).reverse\n\
    \        if (evens.isEmpty) Nil\n        else {\n            val smalest_value\
    \ = evens.head\n            val smalest_index = evens.indexOf(0)\n           \
    \ val evens_with_smallest_value = evens.filter(x => x == smalest_value)\n    \
    \        val evens_with_smallest_index = evens_with_smallest_value.indexOf(0)\n\
    \            if (evens_with_smallest_index > smalest_index) evens_with_smallest_value\
    \ :: evens_with_smallest_index\n            else evens_with_smallest_value ::\
    \ smalest_index\n        }\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnvu62qjj.scala:29:85 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mif\e[0m (evens_with_smallest_index\
    \ > smalest_index) evens_with_smallest_value :: evens_with_smallest_index\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                         value :: is not a member of Int\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpnvu62qjj.scala:30:43 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            \e[33melse\e[0m evens_with_smallest_value\
    \ :: smalest_index\n\e[31m\e[31m   |\e[0m                                    \
    \       ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \          value :: is not a member of Int\n2 errors found\n"
  stdout: ''
  timestamp: 1660009900
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_even\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_even)\n     \
    \   val smalest_value = evens(smalest_index)\n        val smalest_evens = evens.filter(x\
    \ => x % 2 == smalest_value)\n        val smalest_evens_index = smalest_evens.indexOf(smalest_even)\n\
    \        val smalest_evens_value = smalest_evens(smalest_evens_index)\n      \
    \  val smalest_evens_index = smalest_evens.indexOf(smalest_evens_value)\n    \
    \    val smalest_evens_value = smalest_evens(smalest_evens_index)\n        val\
    \ smalest_evens_index = smalest_evens.indexOf(smalest_evens_value)\n        val\
    \ smalest_evens_value = smalest_evens(smalest_evens_index)\n        val smalest_evens_index\
    \ = smalest_evens.indexOf(smalest_evens_value)\n        val smalest_evens_value\
    \ = smalest_evens(smalest_evens_index)\n        val smalest_evens_index = smalest_evens.indexOf(smalest_evens_value)\n\
    \        val smalest_evens_value = smalest_evens(smalest_evens_index)\n      \
    \  val smalest_evens_index = smalest_evens.indexOf(smalest_evens_value)\n    \
    \    val smalest_evens_value = smalest_evens(smalest_evens_index)\n        val\
    \ smalest_evens_index = smalest_evens.indexOf(smalest_evens_value)\n        val\
    \ smalest_evens_value = smalest_evens(smalest_evens_index)\n        val smalest_evens_index\
    \ = smalest_evens.indexOf(smalest_evens_value)\n        val smalest_evens_value\
    \ = smalest_evens(smalest_evens_index)\n        val smalest_evens_index = smalest_evens.indexOf(smalest_evens_value)\n\
    \        val smalest_evens_value = smalest_evens(smalest_evens_index)\n      \
    \  val smalest_evens_index = smalest_evens.indexOf(smalest_evens_value)\n    \
    \    val smalest_evens_value = smalest_evens(smalest_evens_index)\n        val\
    \ smalest_evens_index = smalest_evens.indexOf(smalest_evens_value)\n        val\
    \ smalest_evens_value = smale\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9upmt090.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens_index\e[0m\
    \ = smalest_evens.indexOf(smalest_evens_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evens_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evens_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp9upmt090.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens_value\e[0m\
    \ = smalest_evens(smalest_evens_index)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evens_value is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evens_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp9upmt090.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens_index\e[0m\
    \ = smalest_evens.indexOf(smalest_evens_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evens_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evens_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp9upmt090.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens_value\e[0m\
    \ = smalest_evens(smalest_evens_index)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evens_value is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evens_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel "
  stdout: ''
  timestamp: 1660009885
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val even = evens.min\n\
    \        val index = arr.indexOf(even)\n        val smalest_value = evens.filter(x\
    \ => x % 2 == 0).min\n        val smalest_index = arr.indexOf(smalest_value)\n\
    \        val result = List(smalest_value, smalest_index)\n        if (arr.isEmpty)\
    \ {\n            result\n        } else {\n            result\n        }\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzuij1v02.scala:29:12\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m            result\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            Found:    (result\
    \ : List[AnyVal])\n\e[31m   |\e[0m            Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzuij1v02.scala:31:12 --------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            result\n\e[31m\e[31m   |\e[0m           \
    \ ^^^^^^\e[0m\n\e[31m   |\e[0m            Found:    (result : List[AnyVal])\n\e\
    [31m   |\e[0m            Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009899
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val evensSorted\
    \ = evens.sortWith((x, y) => x < y)\n        val smallestEven = evensSorted.head\n\
    \        val smallestEvenIndex = evensSorted.indexOf(0)\n        val smallestEvenValue\
    \ = smallestEven\n        val smallestEvenIndex = smallestEvenIndex\n        val\
    \ index = arr.indexOf(smallestEvenValue)\n        val value = smallestEvenValue\n\
    \        val list = List[Long](smallestEvenValue, smallestEvenIndex)\n       \
    \ if (arr.isEmpty) {\n            list\n        } else {\n            list\n \
    \       }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpprb2frf4.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009894
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val evensSorted\
    \ = evens.sortWith((x, y) => x < y)\n        val smallestEven = evensSorted.head\n\
    \        val smallestEvenIndex = evensSorted.indexOf(0)\n        val smallestEvenIndex\
    \ = if (smallestEvenIndex == -1) -1 else smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEven / 2\n        val smallestEvenIndex = if (smallestEvenIndex ==\
    \ -1) -1 else smallestEvenIndex\n        val smallestEvenValue = smallestEven\
    \ / 2\n        val smallestEvenIndex = if (smallestEvenIndex == -1) -1 else smallestEvenIndex\n\
    \        val smallestEvenValue = smallestEven / 2\n        val smallestEvenIndex\
    \ = if (smallestEvenIndex == -1) -1 else smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEven / 2\n        val smallestEvenIndex = if (smallestEvenIndex ==\
    \ -1) -1 else smallestEvenIndex\n        val smallestEvenValue = smallestEven\
    \ / 2\n        val smallestEvenIndex = if (smallestEvenIndex == -1) -1 else smallestEvenIndex\n\
    \        val smallestEvenValue = smallestEven / 2\n        val smallestEvenIndex\
    \ = if (smallestEvenIndex == -1) -1 else smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEven / 2\n        val smallestEvenIndex = if (smallestEvenIndex ==\
    \ -1) -1 else smallestEvenIndex\n        val smallestEvenValue = smallestEven\
    \ / 2\n        val smallestEvenIndex = if (smallestEvenIndex == -1) -1 else smallestEvenIndex\n\
    \        val smallestEvenValue = smallestEven / 2\n        val smallestEvenIndex\
    \ = if (smallestEvenIndex == -1) -1 else smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEven / 2\n        val smallestEvenIndex = if (smallestEvenIndex ==\
    \ -1) -1 else smallestEvenIndex\n        val smallestEvenValue = smallestEven\
    \ / 2\n        val smallestEvenIndex = if (smallestEvenIndex == -1) -1 else smallestEvenIndex\n\
    \        val smallestEvenValue = smallestEven / 2\n        val smallestEvenIndex\
    \ = if (smallestEvenIndex == -1) -1 else smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEven / 2\n        val smallestEvenIndex = if (smallestEvenIndex ==\
    \ -1) -1 else smallestEvenIndex\n        val smallestEvenValue = smallestEven\
    \ / 2\n        val smallestEvenIndex = if (smallestEven\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmplfln12rl.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmplfln12rl.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmallestEvenIndex\e[0m = \e[33mif\e[0m (smallestEvenIndex == -\e[31m1\e\
    [0m) -\e[31m1\e[0m \e[33melse\e[0m smallestEvenIndex\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmplfln12rl.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ \e[33mif\e[0m (smallestEvenIndex == -\e[31m1\e[0m) -\e[31m1\e[0m \e[33melse\e\
    [0m smallestEvenIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmplfln12rl.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m =\
    \ smallestEven / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmplfln12rl.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ \e[33mif\e[0m (smallestEvenIndex == -\e[31m1\e[0m) -\e[31m1\e[0m \e[33melse\e\
    [0m "
  stdout: ''
  timestamp: 1660009904
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val even = arr.filter(x => x % 2 == 0).sortBy(x => x).takeWhile(x\
    \ => x < arr.last).reverse\n        val index = even.indexOf(0)\n        val smalest_value\
    \ = even.take(index).min\n        val smalest_index = index\n        val result\
    \ = if (smalest_value == 0) List(smalest_value, smalest_index) else even.take(index).zip(even.drop(index)).filter(_._1\
    \ < smalest_value).map(_._1)\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5_w161w1.scala:27:8\
    \ ---------------------\e[0m\e[0m\n\e[31m27 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[AnyVal])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009904
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0).sortBy(x => x).reverse\n\
    \        val smalest_value = evens.head\n        val smalest_index = evens.indexOf(0)\n\
    \        val result = evens.takeWhile(x => x != smalest_value).takeWhile(x =>\
    \ x != smalest_index).reverse\n        result match {\n            case Nil =>\
    \ Nil\n            case x :: xs => x :: pluck(xs)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnkar4jam.scala:32)\n\tat Problem.main(tmpnkar4jam.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009907
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_even = evens(smalest_index)\n        val smalest_even_index =\
    \ evens.indexOf(smalest_even)\n        val smalest_even_value = evens(smalest_even_index)\n\
    \        val smalest_even_index_list = evens.indexOf(smalest_even)\n        val\
    \ smalest_even_index_list_list = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = even\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb80je3pc.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_list_list_list_list_list_list_list_list\e\
    [0m = evens.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_list_list_list_list_list_list_list_list\
    \ is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index_list_list_list_list_list_list_list_list_list\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpb80je3pc.scala:40:12 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_list_list_list_list_list_list_list_list_list_list\e\
    [0m = evens.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_list_list_list_list_list_list_list_list_list_list\
    \ is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index_list_list_list_list_list_list_list_list_list_list_list\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpb80je3pc.scala:42:12 ---------------------------\e[0m\e[0m\n\e\
    [31m42 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list\e\
    [0m = evens.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNo"
  stdout: ''
  timestamp: 1660009813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val even = evens.min\n\
    \        val index = evens.indexOf(even)\n        val result = List(even, index)\n\
    \        if (arr.isEmpty) result\n        else pluck(arr.drop(index))\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjlpzl64r.scala:26:25\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mif\e[0m (arr.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                         ^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                         Found:    (result : List[AnyVal])\n\e[31m   |\e\
    [0m                         Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009901
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_even = evens(smalest_index)\n        val smalest_even_index =\
    \ evens.indexOf(smalest_even)\n        val smalest_even_value = evens(smalest_even_index)\n\
    \        val smalest_even_index_list = evens.indexOf(smalest_even)\n        val\
    \ smalest_even_index_list_index = evens.indexOf(smalest_even)\n        val smalest_even_index_list_value\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_value_index\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_value_index_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_value_index_list_index\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_value_index_list_value\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_value_index_list_value_index\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_value_index_list_value_index_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_value_index_list_value_index_list_index\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_value_index_list_value_index_list_value\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_value_index_list_value_index_list_value_index\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_value_index_list_value_index_list_value_index_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_value_index_list_value_index_list_value_index_list_index\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_value_index_list_value_index_list_value_index_list_value\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_value_index_list_value_index_list_value_index_list_value_index\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_value_index_list_value_index_list_value_index_list_value_index_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_value_index_list_value_index_list_value_index_list_value_index_list_index\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_value_index_list_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpf858ohr6.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpf858ohr6.scala:47:5 ---------------------\e[0m\e[0m\n\e[31m47 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009904
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val even = evens.min\n\
    \        val index = evens.indexOf(even)\n        val smalest_value = evens.take(index).min\n\
    \        val smalest_index = evens.indexOf(smalest_value)\n        val smalest_evens\
    \ = evens.take(smalest_index)\n        val smalest_even = smalest_evens.min\n\
    \        val smalest_even_index = smalest_evens.indexOf(smalest_even)\n      \
    \  val smalest_evens_index = smalest_evens.indexOf(smalest_value)\n        val\
    \ smalest_evens_index = smalest_evens.indexOf(smalest_value)\n        val smalest_evens_index\
    \ = smalest_evens.indexOf(smalest_value)\n        val smalest_evens_index = smalest_evens.indexOf(smalest_value)\n\
    \        val smalest_evens_index = smalest_evens.indexOf(smalest_value)\n    \
    \    val smalest_evens_index = smalest_evens.indexOf(smalest_value)\n        val\
    \ smalest_evens_index = smalest_evens.indexOf(smalest_value)\n        val smalest_evens_index\
    \ = smalest_evens.indexOf(smalest_value)\n        val smalest_evens_index = smalest_evens.indexOf(smalest_value)\n\
    \        val smalest_evens_index = smalest_evens.indexOf(smalest_value)\n    \
    \    val smalest_evens_index = smalest_evens.indexOf(smalest_value)\n        val\
    \ smalest_evens_index = smalest_evens.indexOf(smalest_value)\n        val smalest_evens_index\
    \ = smalest_evens.indexOf(smalest_value)\n        val smalest_evens_index = smalest_evens.indexOf(smalest_value)\n\
    \        val smalest_evens_index = smalest_evens.indexOf(smalest_value)\n    \
    \    val smalest_evens_index = smalest_evens.indexOf(smalest_value)\n        val\
    \ smalest_evens_index = smalest_evens.indexOf(smalest_value)\n        val smalest_evens_index\
    \ = smalest_evens.indexOf(smalest_value)\n        val smalest_evens_index = smalest_evens.indexOf(smalest_value)\n\
    \        val smalest_evens_index = smalest_evens.indexOf(smalest_value)\n    \
    \    val smalest_evens_index = smalest_evens.indexOf(smalest_value)\n        val\
    \ smalest_even\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp62ph8dv1.scala:52:4 ----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp62ph8dv1.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_evens_index\e[0m = smalest_evens.indexOf(smalest_value)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evens_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evens_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp62ph8dv1.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens_index\e[0m\
    \ = smalest_evens.indexOf(smalest_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evens_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evens_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp62ph8dv1.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens_index\e[0m\
    \ = smalest_evens.indexOf(smalest_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evens_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evens_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp62ph8dv1.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens_index\e[0m\
    \ = smalest_evens.indexOf(smalest_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evens_ind"
  stdout: ''
  timestamp: 1660009904
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val even = arr.filter(x => x % 2 == 0).sorted\n        val evenIndex\
    \ = arr.indexWhere(x => x % 2 == 0)\n        val smalest_value = even.head\n \
    \       val smalest_index = evenIndex\n        val result = if (even.isEmpty)\
    \ Nil\n        else even.takeWhile(x => x % 2 == 0).sorted\n        result.takeWhile(x\
    \ => x % 2 == 0).sorted\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmgkhu_04.scala:31)\n\tat Problem.main(tmpmgkhu_04.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_even = evens(smalest_index)\n        val smalest_even_index =\
    \ smalest_index\n        val smalest_even_value = smalest_value\n        val smalest_even_index\
    \ = smalest_index\n        val smalest_even_value = smalest_value\n        val\
    \ smalest_even_index = smalest_index\n        val smalest_even_value = smalest_value\n\
    \        val smalest_even_index = smalest_index\n        val smalest_even_value\
    \ = smalest_value\n        val smalest_even_index = smalest_index\n        val\
    \ smalest_even_value = smalest_value\n        val smalest_even_index = smalest_index\n\
    \        val smalest_even_value = smalest_value\n        val smalest_even_index\
    \ = smalest_index\n        val smalest_even_value = smalest_value\n        val\
    \ smalest_even_index = smalest_index\n        val smalest_even_value = smalest_value\n\
    \        val smalest_even_index = smalest_index\n        val smalest_even_value\
    \ = smalest_value\n        val smalest_even_index = smalest_index\n        val\
    \ smalest_even_value = smalest_value\n        val smalest_even_index = smalest_index\n\
    \        val smalest_even_value = smalest_value\n        val smalest_even_index\
    \ = smalest_index\n        val smalest_even_value = smalest_value\n        val\
    \ smalest_even_index = smalest_index\n        val smalest_even_value = smalest_value\n\
    \        val smalest_even_index = smalest_index\n        val smalest_even_value\
    \ = smalest_value\n        val smalest_even_index = smalest_index\n        val\
    \ smalest_even_value = smalest_value\n        val smalest_even_index = smalest_index\n\
    \        val smalest_even_value = smalest_value\n        val smalest_even_index\
    \ = smalest_index\n        val smalest_even_value = smalest_value\n        val\
    \ smalest_even_index = smalest_index\n        val smalest_even_value = smalest_value\n\
    \        val smalest_even_index = smalest_index\n        val smalest_even_value\
    \ = smalest_value\n        val smalest_\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnt13t900.scala:65:4 ----------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnt13t900.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_even_index\e[0m = smalest_index\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msmalest_even_index\
    \ is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpnt13t900.scala:29:12 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value\e[0m = smalest_value\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msmalest_even_value is already defined as \e[33mvalue\e[0m \e[35msmalest_even_value\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpnt13t900.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m = smalest_index\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpnt13t900.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value\e[0m = smalest_value\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msmalest_even_value is already defined as \e[33mvalue\e[0m \e[35msmalest_even_value\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- "
  stdout: ''
  timestamp: 1660009835
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_even = evens(smalest_index)\n        val smalest_even_index =\
    \ evens.indexOf(smalest_even)\n        val smalest_even_value = evens(smalest_even_index)\n\
    \        val smalest_even_index_list = evens.indexOf(smalest_even)\n        val\
    \ smalest_even_index_list_index = evens.indexOf(smalest_even)\n        val smalest_even_index_list_value\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_value = evens.indexOf(smalest_even)\n\
    \        val smalest_even_index_list_value = evens.indexOf(smalest_even)\n   \
    \     val smalest_even_index_list_value = evens.indexOf(smalest_even)\n      \
    \  val smalest_even_index_list_value = evens.indexOf(smalest_even)\n        val\
    \ smalest_even_index_list_value = evens.indexOf(smalest_even)\n        val smalest_even_index_list_value\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_value = evens.indexOf(smalest_even)\n\
    \        val smalest_even_index_list_value = evens.indexOf(smalest_even)\n   \
    \     val smalest_even_index_list_value = evens.indexOf(smalest_even)\n      \
    \  val smalest_even_index_list_value = evens.indexOf(smalest_even)\n        val\
    \ smalest_even_index_list_value = evens.indexOf(smalest_even)\n        val smalest_even_index_list_value\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_value = evens.indexOf(smalest_even)\n\
    \        val smalest_even_index_list_value = evens.indexOf(smalest_even)\n   \
    \     val smalest_even_index_list_value = evens.indexOf(smalest_even)\n      \
    \  val smalest_even_index_list_value = evens.indexOf(smalest_even)\n        val\
    \ smalest_even_index_list_value = evens.indexOf(smalest_even)\n        val smalest_even_index_list_value\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_value = evens.indexOf(smalest_even)\n\
    \        val smalest_even_index_list_value = evens.indexOf(smalest_even)\n   \
    \     val smalest_even_index_list_value = evens.indexOf(smalest_even)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwuwcyzik.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_value\e\
    [0m = evens.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_list_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwuwcyzik.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_value\e\
    [0m = evens.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_list_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwuwcyzik.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_value\e\
    [0m = evens.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_list_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwuwcyzik.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_value\e\
    [0m = evens.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_list_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ th"
  stdout: ''
  timestamp: 1660009904
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val even = arr.filter(x => x % 2 == 0).sortBy(x => x).takeWhile(x\
    \ => x < arr.last).reverse\n        val index = arr.lastIndexWhere(x => x % 2\
    \ == 0)\n        val smalest_value = even.head\n        val smalest_index = index\n\
    \        val result = if (smalest_value == 0) List(smalest_value, smalest_index)\
    \ else even.takeWhile(x => x < smalest_value).reverse.zip(index).map(x => x._1).reverse\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpol5pxk5l.scala:26:136\
    \ -------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mresult\e\
    [0m = \e[33mif\e[0m (smalest_value == \e[31m0\e[0m) List(smalest_value, smalest_index)\
    \ \e[33melse\e[0m even.takeWhile(\e[36mx\e[0m => x < smalest_value).reverse.zip(index).map(\e\
    [36mx\e[0m => x._1).reverse\n\e[31m\e[31m   |\e[0m                           \
    \                                                                            \
    \                                 ^^^^^\e[0m\n\e[31m   |\e[0m                \
    \                             Found:    (index : Int)\n\e[31m   |\e[0m       \
    \                                      Required: IterableOnce[Any]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpol5pxk5l.scala:27:8 ---------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        result\n\e[31m\e[31m   |\e[0m        ^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    (result : List[AnyVal])\n\e[31m   |\e[0m\
    \        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009906
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(_ % 2 == 0)\n        val smallest = evens.min\n\
    \        val index = evens.indexOf(smallest)\n        val result = if (index ==\
    \ -1) List(smallest) else List(smallest, index)\n        return result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqwz_pkbs.scala:26:15\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mreturn\e[0m result\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \  Found:    (result : List[AnyVal])\n\e[31m   |\e[0m               Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009905
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_evens = evens.filter(x => x % 2 == 0)\n        val smalest_evens_index\
    \ = smalest_evens.indexOf(smalest_value)\n        if (smalest_evens_index == -1)\
    \ {\n            smalest_evens_index = 0\n        }\n        smalest_evens.take(smalest_evens_index).map(x\
    \ => smalest_value).mkString(\",\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp_gyh3306.scala:28:32 -----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            smalest_evens_index = \e[31m0\e[0m\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \     Reassignment to val smalest_evens_index\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp_gyh3306.scala:30:80 --------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        smalest_evens.take(smalest_evens_index).map(\e\
    [36mx\e[0m => smalest_value).mkString(\e[31m\",\"\e[0m)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    String\n\e[31m   |\e[0m        Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009905
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_even = evens(smalest_index)\n        val smalest_even_index =\
    \ evens.indexOf(smalest_even)\n        val smalest_even_value = evens(smalest_even_index)\n\
    \        val smalest_even_index_in_list = evens.indexOf(smalest_even_value)\n\
    \        val smalest_even_value_in_array = evens(smalest_even_index_in_list)\n\
    \        val smalest_even_index_in_array = evens.indexOf(smalest_even_value_in_array)\n\
    \        val smalest_even_value_in_array = evens(smalest_even_index_in_array)\n\
    \        val smalest_even_index_in_list = evens.indexOf(smalest_even_value_in_array)\n\
    \        val smalest_even_value_in_array = evens(smalest_even_index_in_array)\n\
    \        val smalest_even_index_in_array = evens.indexOf(smalest_even_value_in_array)\n\
    \        val smalest_even_value_in_array = evens(smalest_even_index_in_array)\n\
    \        val smalest_even_index_in_list = evens.indexOf(smalest_even_value_in_array)\n\
    \        val smalest_even_value_in_array = evens(smalest_even_index_in_array)\n\
    \        val smalest_even_index_in_array = evens.indexOf(smalest_even_value_in_array)\n\
    \        val smalest_even_value_in_array = evens(smalest_even_index_in_array)\n\
    \        val smalest_even_index_in_list = evens.indexOf(smalest_even_value_in_array)\n\
    \        val smalest_even_value_in_array = evens(smalest_even_index_in_array)\n\
    \        val smalest_even_index_in_array = evens.indexOf(smalest_even_value_in_array)\n\
    \        val smalest_even_value_in_array = evens(smalest_even_index_in_array)\n\
    \        val smalest_even_index_in_list = evens.indexOf(smalest_even_value_in_array)\n\
    \        val smalest_even_value_in_array = evens(smalest_even_index_in_array)\n\
    \        val smalest_even_index_in_array = evens.indexOf(smalest_even_value_in_array)\n\
    \        val smalest_even_value_in_array = evens(smalest_even_index_in_array)\n\
    \        val smalest_even_index_in_list = evens.indexOf(smalest_even_value_in_array)\n\
    \        val smalest_even_value_in_array = evens(smalest_even_index_in_array)\n\
    \        val sm\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0125fyln.scala:51:4 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0125fyln.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_even_value_in_array\e[0m = evens(smalest_even_index_in_array)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_value_in_array is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_value_in_array\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0125fyln.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_in_list\e\
    [0m = evens.indexOf(smalest_even_value_in_array)\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_in_list is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_in_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0125fyln.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value_in_array\e\
    [0m = evens(smalest_even_index_in_array)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_value_in_array is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_value_in_array\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0125fyln.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_in_array\e\
    [0m = evens.indexOf(smalest_even_value_in_array)\n\e[31m\e[31m   "
  stdout: ''
  timestamp: 1660009905
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smallest =\
    \ evens.min\n        val index = evens.indexOf(smallest)\n        val result =\
    \ if (index == -1) List(smallest) else List(smallest, index)\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph_djlshl.scala:26:8\
    \ ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[AnyVal])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009906
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val even = arr.filter(x => x % 2 == 0).sortBy(x => x).takeWhile(x\
    \ => x < arr.last).reverse\n        if (even.isEmpty) List()\n        else even.head\
    \ :: even.drop(even.indexOf(even.head)).map(x => arr.indexOf(x)).sortBy(x => x).takeWhile(x\
    \ => x < arr.last).reverse\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7u2lfx62.scala:24:13\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33melse\e[0m even.head\
    \ :: even.drop(even.indexOf(even.head)).map(x => arr.indexOf(x)).sortBy(x => x).takeWhile(x\
    \ => x < arr.last).reverse\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m             Found:    List[\e[1m\e[31mAnyVal\e[0m]\n\e[31m\
    \   |\e[0m             Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009906
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val evensSorted\
    \ = evens.sorted\n        val smallestEven = evensSorted.head\n        val smallestEvenIndex\
    \ = evensSorted.indexOf(0)\n        val smallestEvenValue = smallestEven\n   \
    \     val smallestEvenIndex = smallestEvenIndex\n        val result = List(smallestEvenValue,\
    \ smallestEvenIndex)\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsuwvcgka.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpsuwvcgka.scala:29:15 --------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mreturn\e[0m result\n\e[31m\e[31m   |\e\
    [0m               ^^^^^^\e[0m\n\e[31m   |\e[0m               Found:    (result\
    \ : List[AnyVal])\n\e[31m   |\e[0m               Required: List[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009906
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(_ % 2 == 0)\n        val even = evens.min\n\
    \        val index = arr.indexOf(even)\n        val smalest_value = arr.takeWhile(_\
    \ < even).min\n        val smalest_index = arr.indexOf(smalest_value)\n      \
    \  val smalest_even = evens.takeWhile(_ < smalest_value).min\n        val smalest_even_index\
    \ = arr.indexOf(smalest_even)\n        val smalest_even_index = arr.indexOf(smalest_even)\n\
    \        val smalest_even_index = arr.indexOf(smalest_even)\n        val smalest_even_index\
    \ = arr.indexOf(smalest_even)\n        val smalest_even_index = arr.indexOf(smalest_even)\n\
    \        val smalest_even_index = arr.indexOf(smalest_even)\n        val smalest_even_index\
    \ = arr.indexOf(smalest_even)\n        val smalest_even_index = arr.indexOf(smalest_even)\n\
    \        val smalest_even_index = arr.indexOf(smalest_even)\n        val smalest_even_index\
    \ = arr.indexOf(smalest_even)\n        val smalest_even_index = arr.indexOf(smalest_even)\n\
    \        val smalest_even_index = arr.indexOf(smalest_even)\n        val smalest_even_index\
    \ = arr.indexOf(smalest_even)\n        val smalest_even_index = arr.indexOf(smalest_even)\n\
    \        val smalest_even_index = arr.indexOf(smalest_even)\n        val smalest_even_index\
    \ = arr.indexOf(smalest_even)\n        val smalest_even_index = arr.indexOf(smalest_even)\n\
    \        val smalest_even_index = arr.indexOf(smalest_even)\n        val smalest_even_index\
    \ = arr.indexOf(smalest_even)\n        val smalest_even_index = arr.indexOf(smalest_even)\n\
    \        val smalest_even_index = arr.indexOf(smalest_even)\n        val smalest_even_index\
    \ = arr.indexOf(smalest_even)\n        val smalest_even_index = arr.indexOf(smalest_even)\n\
    \        val smalest_even_index = arr.indexOf(smalest_even)\n        val smalest_even_index\
    \ = arr.indexOf(smalest_even)\n        val smalest_even_index = arr.indexOf(smalest_even)\n\
    \        val smalest_even_index = arr.indexOf(smalest_even)\n        val smalest_even_index\
    \ = arr.indexOf(smalest_even)\n        val smalest_even_index = arr.indexOf(smalest_even)\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp4fcdzst7.scala:57:11 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp4fcdzst7.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m\
    \ = arr.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_even_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp4fcdzst7.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m\
    \ = arr.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_even_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp4fcdzst7.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m\
    \ = arr.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_even_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp4fcdzst7.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m\
    \ = arr.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even"
  stdout: ''
  timestamp: 1660009907
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val evensSorted\
    \ = evens.sortWith((x, y) => x < y)\n        val evenSmallest = evensSorted.head\n\
    \        val evenSmallestIndex = evensSorted.indexOf(0)\n        val smalestValue\
    \ = evenSmallest\n        val smalestIndex = (evensSorted.indexOf(evenSmallest)\
    \ + evenSmallestIndex) % evensSorted.length\n        val smalestValueAndIndex\
    \ = (smalestValue, smalestIndex)\n        if (evensSorted.isEmpty) {\n       \
    \     List[Long]()\n        } else {\n            List(smalestValueAndIndex)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvopx8ku9.scala:32:17\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m            List(smalestValueAndIndex)\n\
    \e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                 Found:    (smalestValueAndIndex : (Long, Int))\n\e[31m   |\e\
    [0m                 Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009907
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        if (evens.isEmpty)\
    \ List()\n        else evens.minBy(x => x)._2\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2ho6zjgj.scala:24:33 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33melse\e[0m evens.minBy(x => x)._2\n\e[31m\e\
    [31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \      value _2 is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1660009907
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val even = arr.filter(x => x % 2 == 0).sorted\n        val index\
    \ = even.indexOf(0)\n        if (index >= 0) {\n            val value = even(index)\n\
    \            val result = List(value, index)\n            if (even.length == 0)\
    \ result\n            else result.reverse\n        }\n        else List()\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9jhtramg.scala:27:34\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m            \e[33mif\e[0m (even.length\
    \ == \e[31m0\e[0m) result\n\e[31m\e[31m   |\e[0m                             \
    \     ^^^^^^\e[0m\n\e[31m   |\e[0m                                  Found:   \
    \ (result : List[AnyVal])\n\e[31m   |\e[0m                                  Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9jhtramg.scala:28:24\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m            \e[33melse\e[0m result.reverse\n\
    \e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \              Found:    List[\e[1m\e[31mAnyVal\e[0m]\n\e[31m   |\e[0m       \
    \          Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009909
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val even = arr.filter(x => x % 2 == 0).sorted\n        val index\
    \ = even.indexOf(0)\n        val smalest_value = even.take(index).min\n      \
    \  val smalest_index = even.indexOf(smalest_value)\n        val result = smalest_value\
    \ :: smalest_index.toList\n        if (even.isEmpty) result\n        else result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_zz6poh8.scala:26:52 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = smalest_value\
    \ :: smalest_index.toList\n\e[31m\e[31m   |\e[0m                             \
    \         ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m value toList is not a member\
    \ of Int - did you mean smalest_index.toInt?\n1 error found\n"
  stdout: ''
  timestamp: 1660009916
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        if (evens.isEmpty)\
    \ List()\n        else {\n            val smallestEven = evens.min\n         \
    \   val smallestIndex = evens.indexOf(smallestEven)\n            val smallestEvenIndex\
    \ = evens.indexOf(smallestEven)\n            val smallestEvenValue = smallestEven\
    \ / 2\n            val smallestEvenIndex = evens.indexOf(smallestEvenValue)\n\
    \            val smallestEvenIndex = evens.indexOf(smallestEvenValue)\n      \
    \      val smallestEvenValue = smallestEven / 2\n            val smallestEvenIndex\
    \ = evens.indexOf(smallestEvenValue)\n            val smallestEvenValue = smallestEven\
    \ / 2\n            val smallestEvenIndex = evens.indexOf(smallestEvenValue)\n\
    \            val smallestEvenValue = smallestEven / 2\n            val smallestEvenIndex\
    \ = evens.indexOf(smallestEvenValue)\n            val smallestEvenValue = smallestEven\
    \ / 2\n            val smallestEvenIndex = evens.indexOf(smallestEvenValue)\n\
    \            val smallestEvenValue = smallestEven / 2\n            val smallestEvenIndex\
    \ = evens.indexOf(smallestEvenValue)\n            val smallestEvenValue = smallestEven\
    \ / 2\n            val smallestEvenIndex = evens.indexOf(smallestEvenValue)\n\
    \            val smallestEvenValue = smallestEven / 2\n            val smallestEvenIndex\
    \ = evens.indexOf(smallestEvenValue)\n            val smallestEvenValue = smallestEven\
    \ / 2\n            val smallestEvenIndex = evens.indexOf(smallestEvenValue)\n\
    \            val smallestEvenValue = smallestEven / 2\n            val smallestEvenIndex\
    \ = evens.indexOf(smallestEvenValue)\n            val smallestEvenValue = smallestEven\
    \ / 2\n            val smallestEvenIndex = evens.indexOf(smallestEvenValue)\n\
    \            val smallestEvenValue = smallestEven / 2\n            val smallestEvenIndex\
    \ = evens.indexOf(smallestEvenValue)\n            val smallestEvenValue = smallestEven\
    \ / 2\n            val smallestEvenIndex = evens.indexOf(smallestEvenValue)\n\
    \            val smallestEvenValue = smallestEven / 2\n            val smallestEvenIndex\
    \ = evens.indexOf(smallestEvenValue)\n            val smallestEvenValue = smallestEven\
    \ / 2\n            val smallestEvenIndex = evens.indexOf(smallestEvenValue)\n\
    \            val smallestEvenValue = smallestEven / 2\n            val smallestEvenIndex\
    \ = evens.indexOf(smallestEvenValue)\n            val smallestEvenValue = smallestEven\
    \ / 2\n            val smallestEvenIndex = evens.indexOf(smallest\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpo38y4c2t.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpo38y4c2t.scala:76:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m76 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpo38y4c2t.scala:29:16 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m            \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m = evens.indexOf(smallestEvenValue)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpo38y4c2t.scala:30:16 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            \e[33mval\e[0m \e[36msmallestEvenIndex\e\
    [0m = evens.indexOf(smallestEvenValue)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpo38y4c2t.scala:31:16 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33mval\e[0m \e[36msmallestEvenValue\e\
    [0m = smallestEven / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpo38y4c2t.scala:32:16 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e[0m \e[36msmallestEvenIndex\e\
    [0m = evens.indexOf(smallestEvenV"
  stdout: ''
  timestamp: 1660009924
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        if (evens.isEmpty)\
    \ Nil\n        else evens.minBy(x => x)._2\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8fct8dh8.scala:24:33 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33melse\e[0m evens.minBy(x => x)._2\n\e[31m\e\
    [31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \      value _2 is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1660009921
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val even = arr.filter(x => x % 2 == 0).sortBy(x => x).takeWhile(x\
    \ => x < arr.last)\n        if (even.isEmpty) List()\n        else even.head\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpecdbzyck.scala:24:18\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33melse\e[0m even.head\n\
    \e[31m\e[31m   |\e[0m             ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \ Found:    Long\n\e[31m   |\e[0m             Required: \e[1m\e[32mList\e[0m\e\
    [1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009923
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val evensSorted\
    \ = evens.sorted\n        val smallestEven = evensSorted.head\n        val smallestIndex\
    \ = evensSorted.indexOfMin\n        val smallestEvenIndex = evensSorted.indexOf(smallestEven)\n\
    \        val result = if (smallestEvenIndex == -1) List(smallestEven) else List(smallestEven,\
    \ smallestEvenIndex)\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprjs_yv3i.scala:25:40 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36msmallestIndex\e[0m = evensSorted.indexOfMin\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue indexOfMin is not a member of List[Long] - did you mean evensSorted.indexOf?\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprjs_yv3i.scala:28:8 ---------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        result\n\e[31m\e[31m   |\e[0m        ^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    (result : List[AnyVal])\n\e[31m   |\e[0m\
    \        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009925
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        if (evens.isEmpty)\
    \ List()\n        else {\n            val smalest_value = evens.min\n        \
    \    val smalest_index = evens.indexOf(smalest_value)\n            val smalest_even\
    \ = evens(smalest_index)\n            val smalest_even_index = evens.indexOf(smalest_even)\n\
    \            val smalest_even_value = evens(smalest_even_index)\n            val\
    \ smalest_even_index_plus_one = smalest_even_index + 1\n            val smalest_even_value_plus_one\
    \ = evens(smalest_even_index_plus_one)\n            val smalest_even_value_plus_two\
    \ = evens(smalest_even_index_plus_two)\n            val smalest_even_value_plus_three\
    \ = evens(smalest_even_index_plus_three)\n            val smalest_even_value_plus_four\
    \ = evens(smalest_even_index_plus_four)\n            val smalest_even_value_plus_five\
    \ = evens(smalest_even_index_plus_five)\n            val smalest_even_value_plus_six\
    \ = evens(smalest_even_index_plus_six)\n            val smalest_even_value_plus_seven\
    \ = evens(smalest_even_index_plus_seven)\n            val smalest_even_value_plus_eight\
    \ = evens(smalest_even_index_plus_eight)\n            val smalest_even_value_plus_nine\
    \ = evens(smalest_even_index_plus_nine)\n            val smalest_even_value_plus_ten\
    \ = evens(smalest_even_index_plus_ten)\n            val smalest_even_value_plus_eleven\
    \ = evens(smalest_even_index_plus_eleven)\n            val smalest_even_value_plus_twelve\
    \ = evens(smalest_even_index_plus_twelve)\n            val smalest_even_value_plus_thirteen\
    \ = evens(smalest_even_index_plus_thirteen)\n            val smalest_even_value_plus_fourteen\
    \ = evens(smalest_even_index_plus_fourteen)\n            val smalest_even_value_plus_fifteen\
    \ = evens(smalest_even_index_plus_fifteen)\n            val smalest_even_value_plus_sixteen\
    \ = evens(smalest_even_index_plus_sixteen)\n            val smalest_even_value_plus_seventeen\
    \ = evens(smalest_even_index_plus_seventeen)\n            val smalest_even_value_plus_eighteen\
    \ = evens(smalest_even_index_plus_e\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpk85yh707.scala:49:4 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpk85yh707.scala:62:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m62 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpk85yh707.scala:32:52 ------------------------\e[0m\e[0m\n\
    \e[31m32 |\e[0m            \e[33mval\e[0m \e[36msmalest_even_value_plus_two\e\
    [0m = evens(smalest_even_index_plus_two)\n\e[31m\e[31m   |\e[0m              \
    \                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                  Not found: smalest_even_index_plus_two\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk85yh707.scala:33:54\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e[0m\
    \ \e[36msmalest_even_value_plus_three\e[0m = evens(smalest_even_index_plus_three)\n\
    \e[31m\e[31m   |\e[0m                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                Not found: smalest_even_index_plus_three\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk85yh707.scala:34:53\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e[0m\
    \ \e[36msmalest_even_value_plus_four\e[0m = evens(smalest_even_index_plus_four)\n\
    \e[31m\e[31m   |\e[0m                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Not found: smalest_even_index_plus_four\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk85yh707.scala:35:53\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e[0m\
    \ \e[36msmalest_even_value_plus_five\e[0m = evens(smalest_even_index_plus"
  stdout: ''
  timestamp: 1660009927
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        if (evens.isEmpty)\
    \ List()\n        else {\n            val smallestEven = evens.min\n         \
    \   val smallestIndex = arr.indexOf(smallestEven)\n            val smallestValue\
    \ = arr[smallestIndex]\n            val evenIndex = arr.indexOf(smallestEven)\n\
    \            val evenValue = arr[evenIndex]\n            val evenSmallestValue\
    \ = arr[evenIndex].min(evenValue)\n            val evenSmallestIndex = arr.indexOf(evenSmallestValue)\n\
    \            val evenSmallestEvenIndex = arr.indexOf(evenSmallestValue)\n    \
    \        val evenSmallestEvenValue = arr[evenSmallestEvenIndex]\n            val\
    \ evenSmallestEvenIndexValue = arr[evenSmallestEvenIndex].min(evenSmallestEvenValue)\n\
    \            val evenSmallestEvenIndexValueIndex = arr.indexOf(evenSmallestEvenIndexValue)\n\
    \            val evenSmallestEvenIndexValueIndexValue = arr[evenSmallestEvenIndexValueIndex]\n\
    \            val evenSmallestEvenIndexValueIndexValueIndex = arr.indexOf(evenSmallestEvenIndexValueIndexValue)\n\
    \            val evenSmallestEvenIndexValueIndexValueIndexValue = arr[evenSmallestEvenIndexValueIndexValueIndex]\n\
    \            val evenSmallestEvenIndexValueIndexValueIndexValueIndex = arr.indexOf(evenSmallestEvenIndexValueIndexValueIndexValue)\n\
    \            val evenSmallestEvenIndexValueIndexValueIndexValueIndexValue = arr[evenSmallestEvenIndexValueIndexValueIndexValueIndex]\n\
    \            val evenSmallestEvenIndexValueIndexValueIndexValueIndexValueIndex\
    \ = arr.indexOf(evenSmallestEvenIndexValueIndexValueIndexValueIndexValue)\n  \
    \          val evenSmallestEvenIndexValueIndexValueIndexValueIndexValueIndexValue\
    \ = arr[evenSmallestEvenIndexValueIndexValueIndexValueIndexValueIndex]\n     \
    \       val evenSmallestEvenIndexValueIndexValueIndexValueIndexValueIndexValueIndex\
    \ = arr.indexOf(evenSmallestEvenIndexValueIndexValueIndexValueIndexValueIndexValue)\n\
    \            val evenSmallestEvenIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndex\
    \ = arr.indexOf(evenSmallestEvenIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue)\n\
    \            val evenSmallestEvenIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue\
    \ = arr[evenSmallestEvenIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndex]\n\
    \            val evenSmallestEvenIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndex\
    \ = arr.\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpw9ldmz31.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpw9ldmz31.scala:60:0 ----------------------------\e[0m\e[0m\n\e[31m60\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw9ldmz31.scala:27:36 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36msmallestValue\e[0m =\
    \ arr[\e[35msmallestIndex\e[0m]\n\e[31m\e[31m   |\e[0m                       \
    \             ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                            \
    \        Not found: type smallestIndex\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpw9ldmz31.scala:29:32 ------------------------\e[0m\e\
    [0m\n\e[31m29 |\e[0m            \e[33mval\e[0m \e[36mevenValue\e[0m = arr[\e[35mevenIndex\e\
    [0m]\n\e[31m\e[31m   |\e[0m                                ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                Not found: type evenIndex\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw9ldmz31.scala:30:40 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            \e[33mval\e[0m \e[36mevenSmallestValue\e\
    [0m = arr[\e[35mevenIndex\e[0m].min(evenValue)\n\e[31m\e[31m   |\e[0m        \
    \                                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \                           Not found: type evenIndex\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpw9ldmz31.scala:33:44 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e[0m \e[36mevenSmallestEvenValue\e\
    [0m = arr[\e[35mevenSmallestEvenIndex\e[0m]\n\e[31m\e[31m   |\e[0m           \
    \                                 ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                   Not found: type evenSmallestEvenIndex\n\e\
    [31m   |\e["
  stdout: ''
  timestamp: 1660009926
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(_ % 2 == 0)\n        val smalest_value =\
    \ evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n      \
    \  val smalest_even = evens(smalest_index)\n        val smalest_even_index = smalest_index\n\
    \        val smalest_even_value = smalest_value\n        val smalest_even_index\
    \ = smalest_index\n        val smalest_even_value = smalest_value\n        val\
    \ smalest_even_index = smalest_index\n        val smalest_even_value = smalest_value\n\
    \        val smalest_even_index = smalest_index\n        val smalest_even_value\
    \ = smalest_value\n        val smalest_even_index = smalest_index\n        val\
    \ smalest_even_value = smalest_value\n        val smalest_even_index = smalest_index\n\
    \        val smalest_even_value = smalest_value\n        val smalest_even_index\
    \ = smalest_index\n        val smalest_even_value = smalest_value\n        val\
    \ smalest_even_index = smalest_index\n        val smalest_even_value = smalest_value\n\
    \        val smalest_even_index = smalest_index\n        val smalest_even_value\
    \ = smalest_value\n        val smalest_even_index = smalest_index\n        val\
    \ smalest_even_value = smalest_value\n        val smalest_even_index = smalest_index\n\
    \        val smalest_even_value = smalest_value\n        val smalest_even_index\
    \ = smalest_index\n        val smalest_even_value = smalest_value\n        val\
    \ smalest_even_index = smalest_index\n        val smalest_even_value = smalest_value\n\
    \        val smalest_even_index = smalest_index\n        val smalest_even_value\
    \ = smalest_value\n        val smalest_even_index = smalest_index\n        val\
    \ smalest_even_value = smalest_value\n        val smalest_even_index = smalest_index\n\
    \        val smalest_even_value = smalest_value\n        val smalest_even_index\
    \ = smalest_index\n        val smalest_even_value = smalest_value\n        val\
    \ smalest_even_index = smalest_index\n        val smalest_even_value = smalest_value\n\
    \        val smalest_even_index = smalest_index\n        val smalest_even_value\
    \ = smalest_value\n        val smalest_even_index = \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpaik1_8ux.scala:64:32 ---------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m\
    \ = \n\e[31m\e[31m   |\e[0m                                ^\e[0m\n\e[31m   |\e\
    [0m                                expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpaik1_8ux.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_even_index\e[0m = smalest_index\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msmalest_even_index\
    \ is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpaik1_8ux.scala:29:12 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value\e[0m = smalest_value\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msmalest_even_value is already defined as \e[33mvalue\e[0m \e[35msmalest_even_value\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpaik1_8ux.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m = smalest_index\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpaik1_8ux.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value\e[0m = smalest_value\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msmalest_ev"
  stdout: ''
  timestamp: 1660009927
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val evensSorted\
    \ = evens.sortWith((x, y) => x < y)\n        val smallestEven = evensSorted.head\n\
    \        val smallestEvenIndex = evensSorted.indexOf(0)\n        val smallestEvenValue\
    \ = smallestEven\n        val smallestEvenIndex = smallestEvenIndex\n        val\
    \ smallestEvenValue = smallestEvenValue\n        val smallestEvenIndex = smallestEvenIndex\n\
    \        val smallestEvenValue = smallestEvenValue\n        val smallestEvenIndex\
    \ = smallestEvenIndex\n        val smallestEvenValue = smallestEvenValue\n   \
    \     val smallestEvenIndex = smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEvenValue\n        val smallestEvenIndex = smallestEvenIndex\n   \
    \     val smallestEvenValue = smallestEvenValue\n        val smallestEvenIndex\
    \ = smallestEvenIndex\n        val smallestEvenValue = smallestEvenValue\n   \
    \     val smallestEvenIndex = smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEvenValue\n        val smallestEvenIndex = smallestEvenIndex\n   \
    \     val smallestEvenValue = smallestEvenValue\n        val smallestEvenIndex\
    \ = smallestEvenIndex\n        val smallestEvenValue = smallestEvenValue\n   \
    \     val smallestEvenIndex = smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEvenValue\n        val smallestEvenIndex = smallestEvenIndex\n   \
    \     val smallestEvenValue = smallestEvenValue\n        val smallestEvenIndex\
    \ = smallestEvenIndex\n        val smallestEvenValue = smallestEvenValue\n   \
    \     val smallestEvenIndex = smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEvenValue\n        val smallestEvenIndex = smallestEvenIndex\n   \
    \     val smallestEvenValue = smallestEvenValue\n        val smallestEvenIndex\
    \ = smallestEvenIndex\n        val smallestEvenValue = smallestEvenValue\n   \
    \     val smallestEvenIndex = smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEvenValue\n        val smallestEvenIndex = smallestEvenIndex\n   \
    \     val smallestEvenValue = smallestEvenValue\n        val smallestEvenIndex\
    \ = smallestEvenIndex\n        val smallestEvenValue = smallestEvenValue\n   \
    \     val smallestEvenIndex = smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEvenValue\n        val smallestEvenIndex = smallestEvenIndex\n   \
    \     val smallestEvenValue = smallestEvenValue\n        val smallestEvenIndex\
    \ = smallest\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwce64j30.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpwce64j30.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m =\
    \ smallestEvenValue\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpwce64j30.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpwce64j30.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m =\
    \ smallestEvenValue\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpwce64j30.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex\n\e[31m\e[3"
  stdout: ''
  timestamp: 1660009926
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(_ % 2 == 0)\n        val smalest_value =\
    \ evens.min\n        val smalest_index = evens.indexOfMin\n        val smalest_even\
    \ = evens(smalest_index)\n        val smalest_even_index = evens.indexOf(smalest_even)\n\
    \        val smalest_even_value = evens(smalest_even_index)\n        val smalest_even_index_list\
    \ = evens.toList.indexOf(smalest_even)\n        val smalest_even_index_list_value\
    \ = evens.toList.indexOf(smalest_even)\n        val smalest_even_index_list_value\
    \ = evens.toList.indexOf(smalest_even)\n        val smalest_even_index_list_value\
    \ = evens.toList.indexOf(smalest_even)\n        val smalest_even_index_list_value\
    \ = evens.toList.indexOf(smalest_even)\n        val smalest_even_index_list_value\
    \ = evens.toList.indexOf(smalest_even)\n        val smalest_even_index_list_value\
    \ = evens.toList.indexOf(smalest_even)\n        val smalest_even_index_list_value\
    \ = evens.toList.indexOf(smalest_even)\n        val smalest_even_index_list_value\
    \ = evens.toList.indexOf(smalest_even)\n        val smalest_even_index_list_value\
    \ = evens.toList.indexOf(smalest_even)\n        val smalest_even_index_list_value\
    \ = evens.toList.indexOf(smalest_even)\n        val smalest_even_index_list_value\
    \ = evens.toList.indexOf(smalest_even)\n        val smalest_even_index_list_value\
    \ = evens.toList.indexOf(smalest_even)\n        val smalest_even_index_list_value\
    \ = evens.toList.indexOf(smalest_even)\n        val smalest_even_index_list_value\
    \ = evens.toList.indexOf(smalest_even)\n        val smalest_even_index_list_value\
    \ = evens.toList.indexOf(smalest_even)\n        val smalest_even_index_list_value\
    \ = evens.toList.indexOf(smalest_even)\n        val smalest_even_index_list_value\
    \ = evens.toList.indexOf(smalest_even)\n        val smalest_even_index_list_value\
    \ = evens.toList.indexOf(smalest_even)\n        val smalest_even_index_list_value\
    \ = evens.toList.indexOf(smalest_even)\n        val smalest_even_index_list_value\
    \ = evens.toList.indexOf(smalest_even)\n        val smalest_even_index_list_value\
    \ = evens.toList.indexOf(smale\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpg9hu689z.scala:50:4 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpg9hu689z.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_even_index_list_value\e[0m = evens.toList.indexOf(smalest_even)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_list_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpg9hu689z.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_value\e\
    [0m = evens.toList.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_list_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpg9hu689z.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_value\e\
    [0m = evens.toList.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_list_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpg9hu689z.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_value\e\
    [0m = evens.toList.indexOf(smalest_even)\n\e[31m\e["
  stdout: ''
  timestamp: 1660009928
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(_ % 2 == 0)\n        val smallest = evens.min\n\
    \        val index = evens.indexOf(smallest)\n        val result = if (index ==\
    \ -1) List(smallest) else List(smallest, index)\n        return result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqwz_pkbs.scala:26:15\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mreturn\e[0m result\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \  Found:    (result : List[AnyVal])\n\e[31m   |\e[0m               Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009905
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        if (evens.isEmpty)\
    \ List()\n        else {\n            val smalest_value = evens.min\n        \
    \    val smallest_index = evens.indexOf(smalest_value)\n            val smalest_even\
    \ = evens(smallest_index)\n            val smalest_even_index = evens.indexOf(smalest_even)\n\
    \            val smalest_even_index = if (smalest_even_index == smallest_index)\
    \ smalest_even_index else smalest_even_index + 1\n            val smalest_even_value\
    \ = evens(smalest_even_index)\n            val smalest_even_index_value = evens(smalest_even_index_value)\n\
    \            val smalest_even_index_value = if (smalest_even_index_value == smalest_even_index)\
    \ smalest_even_index_value else smalest_even_index_value + 1\n            val\
    \ smalest_even_index_value = if (smalest_even_index_value == smallest_index) smalest_even_index_value\
    \ else smalest_even_index_value + 1\n            val smalest_even_index_value\
    \ = if (smalest_even_index_value == smalest_even_index) smalest_even_index_value\
    \ else smalest_even_index_value + 1\n            val smalest_even_index_value\
    \ = if (smalest_even_index_value == smallest_index) smalest_even_index_value else\
    \ smalest_even_index_value + 1\n            val smalest_even_index_value = if\
    \ (smalest_even_index_value == smalest_even_index) smalest_even_index_value else\
    \ smalest_even_index_value + 1\n            val smalest_even_index_value = if\
    \ (smalest_even_index_value == smallest_index) smalest_even_index_value else smalest_even_index_value\
    \ + 1\n            val smalest_even_index_value = if (smalest_even_index_value\
    \ == smalest_even_index) smalest_even_index_value else smalest_even_index_value\
    \ + 1\n            val smalest_even_index_value = if (smalest_even_index_value\
    \ == smallest_index) smalest_even_index_value else smalest_even_index_value +\
    \ 1\n            val smalest_even_index_value = if (smalest_even_index_value ==\
    \ smalest_even_index) smalest_even_index_value else smalest_even_index_value +\
    \ 1\n            val smalest_even_index_value = if (smalest_even_index_value ==\
    \ smallest_index) smalest_even_index_value else smalest_even_index_value + 1\n\
    \            val smalest_even_index_value = if (smalest_even_index_value == smalest_even_index)\
    \ smalest_even\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6lyaqgi5.scala:56:0 ----------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6lyaqgi5.scala:29:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m            \e[33mval\e\
    [0m \e[36msmalest_even_index\e[0m = \e[33mif\e[0m (smalest_even_index == smallest_index)\
    \ smalest_even_index \e[33melse\e[0m smalest_even_index + \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_even_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp6lyaqgi5.scala:32:16 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = \e[33mif\e[0m (smalest_even_index_value == smalest_even_index) smalest_even_index_value\
    \ \e[33melse\e[0m smalest_even_index_value + \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6lyaqgi5.scala:33:16 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = \e[33mif\e[0m (smalest_even_index_value == smallest_index) smalest_even_index_value\
    \ \e[33melse\e[0m smalest_even_index_value + \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index"
  stdout: ''
  timestamp: 1660009928
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smallest =\
    \ evens.min\n        val index = evens.indexOf(smallest)\n        val result =\
    \ List(smallest, index)\n        if (evens.isEmpty) result\n        else evens.take(1).map(x\
    \ => (x, index)).filter(_._1 == smallest).sortBy(_._1).head._2\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnudqewpu.scala:26:27\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mif\e[0m (evens.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    (result : List[AnyVal])\n\e[31m\
    \   |\e[0m                           Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnudqewpu.scala:27:91 --------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33melse\e[0m evens.take(\e[31m1\e[0m).map(x\
    \ => (x, index)).filter(_._1 == smallest).sortBy(_._1).head._2\n\e[31m\e[31m \
    \  |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m             Found:    Int\n\e[31m   |\e[0m             Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009928
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val evensSorted\
    \ = evens.sortWith((x, y) => x < y)\n        val smalest_value = evensSorted.head\n\
    \        val smalest_index = evensSorted.indexOf(0)\n        val result = evensSorted.takeWhile(x\
    \ => x != smalest_value).takeWhile(x => x != smalest_index).map(x => smalest_value)\n\
    \        if (result.isEmpty) result else result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp5g644u3.scala:30)\n\tat Problem.main(tmpp5g644u3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009930
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val evensSorted\
    \ = evens.sortWith((x, y) => x < y)\n        val smallestEven = evensSorted.head\n\
    \        val smallestIndex = evensSorted.indexOf(0)\n        val smallestEvenIndex\
    \ = evensSorted.indexOf(smallestEven)\n        val smallestEvenIndex = if (smallestEvenIndex\
    \ == -1) -1 else smallestEvenIndex\n        val smallestEvenValue = evensSorted.take(smallestEvenIndex).sum\n\
    \        val smallestEvenValueIndex = evensSorted.indexOf(smallestEvenValue)\n\
    \        val smallestEvenValueIndex = if (smallestEvenValueIndex == -1) -1 else\
    \ smallestEvenValueIndex\n        val smallestEvenValueIndex = if (smallestEvenValueIndex\
    \ == -1) -1 else smallestEvenValueIndex\n        val smallestEvenValueIndex =\
    \ if (smallestEvenValueIndex == -1) -1 else smallestEvenValueIndex\n        val\
    \ smallestEvenValueIndex = if (smallestEvenValueIndex == -1) -1 else smallestEvenValueIndex\n\
    \        val smallestEvenValueIndex = if (smallestEvenValueIndex == -1) -1 else\
    \ smallestEvenValueIndex\n        val smallestEvenValueIndex = if (smallestEvenValueIndex\
    \ == -1) -1 else smallestEvenValueIndex\n        val smallestEvenValueIndex =\
    \ if (smallestEvenValueIndex == -1) -1 else smallestEvenValueIndex\n        val\
    \ smallestEvenValueIndex = if (smallestEvenValueIndex == -1) -1 else smallestEvenValueIndex\n\
    \        val smallestEvenValueIndex = if (smallestEvenValueIndex == -1) -1 else\
    \ smallestEvenValueIndex\n        val smallestEvenValueIndex = if (smallestEvenValueIndex\
    \ == -1) -1 else smallestEvenValueIndex\n        val smallestEvenValueIndex =\
    \ if (smallestEvenValueIndex == -1) -1 else smallestEvenValueIndex\n        val\
    \ smallestEvenValueIndex = if (smallestEvenValueIndex == -1) -1 else smallestEvenValueIndex\n\
    \        val smallestEvenValueIndex = if (smallestEvenValueIndex == -1) -1 else\
    \ smallestEvenValueIndex\n        val smallestEvenValueIndex = if (smallestEvenValueIndex\
    \ == -1) -1 else smallestEvenValueIndex\n        val smallestEvenValueIndex =\
    \ if (smallestEvenValueIndex == -1) -1 else smallestEvenValueIndex\n        val\
    \ smallestEvenValueIndex = if (smallestEvenValueIndex == -1) -1 else smallestEvenValueIndex\n\
    \        val smallestEvenValueIndex = if (smallestEvenValueIndex == -1) -1 else\
    \ smallest\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmd1_fidu.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ \e[33mif\e[0m (smallestEvenIndex == -\e[31m1\e[0m) -\e[31m1\e[0m \e[33melse\e\
    [0m smallestEvenIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpmd1_fidu.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValueIndex\e\
    [0m = \e[33mif\e[0m (smallestEvenValueIndex == -\e[31m1\e[0m) -\e[31m1\e[0m \e\
    [33melse\e[0m smallestEvenValueIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValueIndex is already defined as \e[33mvalue\e\
    [0m \e[35msmallestEvenValueIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmd1_fidu.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValueIndex\e\
    [0m = \e[33mif\e[0m (smallestEvenValueIndex == -\e[31m1\e[0m) -\e[31m1\e[0m \e\
    [33melse\e[0m smallestEvenValueIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValueIndex is already defined as \e[33mvalue\e\
    [0m \e[35msmallestEvenValueIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmd1_fidu.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValueIndex\e\
    [0m = \e[33mif\e[0m (smallestEvenValueIndex == -\e[31m1\e[0m) -\e[31m1\e[0m \e\
    [33melse\e[0"
  stdout: ''
  timestamp: 1660009927
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val even = arr.filter(_ % 2 == 0).sortBy(_).reverse\n        if\
    \ (even.isEmpty) List()\n        else even.head\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpcyn9spdz.scala:22:49 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36meven\e[0m = arr.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_).reverse\n\e[31m\e[31m   |\e[0m   \
    \                                              ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$2 of expanded function:\n\e[31m   |\e[0m   _$2 => arr.filter(_$1\
    \ => _$1 % 2 == 0).sortBy(_$2).reverse.\n\e[31m\e[31m-- Error: /tmp/tmpcyn9spdz.scala:22:51\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m22 |\e[0m       \
    \ \e[33mval\e[0m \e[36meven\e[0m = arr.filter(_ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                                                   ^\e[0m\n\
    \e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mByte\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660009924
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val even = arr.filter(x => x % 2 == 0).sortBy(x => x).takeWhile(x\
    \ => x < arr.last).map(x => x).reverse\n        if (even.isEmpty) List()\n   \
    \     else even.head\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprs_q_prf.scala:24:18\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33melse\e[0m even.head\n\
    \e[31m\e[31m   |\e[0m             ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \ Found:    Long\n\e[31m   |\e[0m             Required: \e[1m\e[32mList\e[0m\e\
    [1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009929
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(_ % 2 == 0)\n        val even = evens.min\n\
    \        val index = evens.indexOf(even)\n        val smalest_value = evens(index)\n\
    \        val smalest_index = index\n        val result = List(smalest_value, smalest_index)\n\
    \        if (evens.isEmpty) result\n        else pluck(arr.filter(_ != smalest_value).take(smalest_index+1))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp984xu0em.scala:28:27\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mif\e[0m (evens.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    (result : List[AnyVal])\n\e[31m\
    \   |\e[0m                           Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009928
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0).sortBy(x => x).reverse\n\
    \        if (evens.isEmpty) Nil\n        else evens.takeWhile(x => x < evens.min).reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpulo486dj.scala:27)\n\tat Problem.main(tmpulo486dj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009932
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0).sorted\n        val smallest\
    \ = evens.head\n        val index = evens.indexOfFirst { x => x % 2 == 0 }\n \
    \       if (evens.isEmpty) List()\n        else if (index == -1) List(smallest)\n\
    \        else List(smallest, index)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpuo2b1dhj.scala:24:26 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mindex\e[0m = evens.indexOfFirst\
    \ { \e[36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e[0m }\n\e[31m\e[31m   |\e[0m\
    \                    ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \    value indexOfFirst is not a member of List[Long]\n1 error found\n"
  stdout: ''
  timestamp: 1660009929
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0).sortBy(x => x).reverse\n\
    \        if (evens.isEmpty) List()\n        else evens.head\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4ro5zigr.scala:24:19\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33melse\e[0m evens.head\n\
    \e[31m\e[31m   |\e[0m             ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \  Found:    Long\n\e[31m   |\e[0m             Required: \e[1m\e[32mList\e[0m\e\
    [1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009929
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val even = arr.filter(x => x % 2 == 0).sortBy(x => x).takeWhile(x\
    \ => x < arr.last).reverse\n        val index = arr.lastIndexWhere(x => x % 2\
    \ == 0)\n        if (even.isEmpty) List()\n        else if (index == arr.length)\
    \ List(arr.last)\n        else even.take(index).sortBy(x => x).reverse.head\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2ou7ardi.scala:26:53\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33melse\e[0m even.take(index).sortBy(x\
    \ => x).reverse.head\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m             Found:    Long\n\e[31m   |\e[0m             Required:\
    \ \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009930
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_even = evens(smalest_index)\n        val smalest_even_index =\
    \ evens.indexOf(smalest_even)\n        val smalest_even_value = evens(smalest_even_index)\n\
    \        val smalest_even_index_in_list = evens.indexOf(smalest_even, smalest_index)\n\
    \        val smalest_even_value_in_list_index = evens.indexOf(smalest_even, smalest_index_in_list)\n\
    \        val smalest_even_value_in_list_value = evens.indexOf(smalest_even, smalest_value_in_list_index)\n\
    \        val smalest_even_value_in_list_value_in_list_index = evens.indexOf(smalest_even,\
    \ smalest_value_in_list_value_in_list_index)\n        val smalest_even_value_in_list_value_in_list_value\
    \ = evens.indexOf(smalest_even, smalest_value_in_list_value_in_list_value_in_list_index)\n\
    \        val smalest_even_value_in_list_value_in_list_value_in_list_index = evens.indexOf(smalest_even,\
    \ smalest_value_in_list_value_in_list_value_in_list_value_in_list_index)\n   \
    \     val smalest_even_value_in_list_value_in_list_value_in_list_value = evens.indexOf(smalest_even,\
    \ smalest_value_in_list_value_in_list_value_in_list_value_in_list_index)\n   \
    \     val smalest_even_value_in_list_value_in_list_value_in_list_value_in_list_index\
    \ = evens.indexOf(smalest_even, smalest_value_in_list_value_in_list_value_in_list_value_in_list_value_in_list_index)\n\
    \        val smalest_even_value_in_list_value_in_list_value_in_list_value_in_list_value\
    \ = evens.indexOf(smalest_even, smalest_value_in_list_value_in_list_value_in_list_value_in_list_value_in_list_index)\n\
    \        val smalest_even_value_in_list_value_in_list_value_in_list_value_in_list_value_in_list_index\
    \ = evens.indexOf(smalest_even, smalest_value_in_list_value_in_list_value_in_list_value_in_list_value_in_list_value_in_list_index)\n\
    \        val smalest_even_value_in_list_value_in_list_value_in_list_value_in_list_value_in_list_value\
    \ = evens.indexOf(smalest_even, smalest_value_in_list_value_in_list_value_in_list_value_in_list_value_in_list_value_in_list_index)\n\
    \        val smalest_even_value_in_\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpn0anycmo.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpn0anycmo.scala:29:75\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36msmalest_even_value_in_list_index\e[0m = evens.indexOf(smalest_even, smalest_index_in_list)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                   ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \                          Not found: smalest_index_in_list\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpn0anycmo.scala:30:75 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value_in_list_value\e\
    [0m = evens.indexOf(smalest_even, smalest_value_in_list_index)\n\e[31m\e[31m \
    \  |\e[0m                                                                    \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \              Not found: smalest_value_in_list_index\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpn0anycmo.scala:31:89 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value_in_list_value_in_list_index\e\
    [0m = evens.indexOf(smalest_even, smalest_value_in_list_value_in_list_index)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Not found: smalest_value_in_list_value_in_list_index\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpn0anycmo.scala:32:89\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e\
    [36msmalest_even_value_in_list_value_in_list_value\e[0m = evens.indexOf(smalest_e"
  stdout: ''
  timestamp: 1660009930
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0).sorted\n        val smallest\
    \ = evens.head\n        val index = evens.indexOfFirst { x => x % 2 == 0 }\n \
    \       val result = if (index >= 0) evens.take(index) else evens\n        result.sortWith(_\
    \ < _)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpu3gyyl7d.scala:24:26 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mindex\e[0m = evens.indexOfFirst\
    \ { \e[36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e[0m }\n\e[31m\e[31m   |\e[0m\
    \                    ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \    value indexOfFirst is not a member of List[Long]\n1 error found\n"
  stdout: ''
  timestamp: 1660009931
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val evensSorted\
    \ = evens.sorted\n        val smallestEven = evensSorted.head\n        val smallestEvenIndex\
    \ = evensSorted.indexOfMin\n        val smallestEvenValue = smallestEven / 2\n\
    \        val smallestEvenIndex = smallestEvenIndex + 1\n        val smallestEvenValue\
    \ = smallestEvenValue * 2\n        val smallestEvenIndex = smallestEvenIndex +\
    \ 1\n        val smallestEvenValue = smallestEvenValue * 2\n        val smallestEvenIndex\
    \ = smallestEvenIndex + 1\n        val smallestEvenValue = smallestEvenValue *\
    \ 2\n        val smallestEvenIndex = smallestEvenIndex + 1\n        val smallestEvenValue\
    \ = smallestEvenValue * 2\n        val smallestEvenIndex = smallestEvenIndex +\
    \ 1\n        val smallestEvenValue = smallestEvenValue * 2\n        val smallestEvenIndex\
    \ = smallestEvenIndex + 1\n        val smallestEvenValue = smallestEvenValue *\
    \ 2\n        val smallestEvenIndex = smallestEvenIndex + 1\n        val smallestEvenValue\
    \ = smallestEvenValue * 2\n        val smallestEvenIndex = smallestEvenIndex +\
    \ 1\n        val smallestEvenValue = smallestEvenValue * 2\n        val smallestEvenIndex\
    \ = smallestEvenIndex + 1\n        val smallestEvenValue = smallestEvenValue *\
    \ 2\n        val smallestEvenIndex = smallestEvenIndex + 1\n        val smallestEvenValue\
    \ = smallestEvenValue * 2\n        val smallestEvenIndex = smallestEvenIndex +\
    \ 1\n        val smallestEvenValue = smallestEvenValue * 2\n        val smallestEvenIndex\
    \ = smallestEvenIndex + 1\n        val smallestEvenValue = smallestEvenValue *\
    \ 2\n        val smallestEvenIndex = smallestEvenIndex + 1\n        val smallestEvenValue\
    \ = smallestEvenValue * 2\n        val smallestEvenIndex = smallestEvenIndex +\
    \ 1\n        val smallestEvenValue = smallestEvenValue * 2\n        val smallestEvenIndex\
    \ = smallestEvenIndex + 1\n        val smallestEvenValue = smallestEvenValue *\
    \ 2\n        val smallestEvenIndex = smallestEvenIndex + 1\n        val smallestEvenValue\
    \ = smallestEvenValue * 2\n        val smallestEvenIndex = smallestEvenIndex +\
    \ 1\n        val smallestEvenValue = smallestEvenValue * 2\n        val smallestEvenIndex\
    \ = smallestEvenIndex + 1\n        val smallestEvenValue = smallestEvenValue *\
    \ 2\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpje1u01sh.scala:63:11 ---------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpje1u01sh.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpje1u01sh.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m =\
    \ smallestEvenValue * \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpje1u01sh.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpje1u01sh.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m =\
    \ smallestEvenValue * \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValue is a"
  stdout: ''
  timestamp: 1660009940
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smallest =\
    \ evens.min\n        val index = evens.indexOf(smallest)\n        val result =\
    \ if (index == -1) List(smallest) else List(smallest, index)\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph_djlshl.scala:26:8\
    \ ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[AnyVal])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009906
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_even = evens(smalest_index)\n        val smalest_even_index =\
    \ evens.indexOf(smalest_even)\n        val smalest_even_value = evens(smalest_even_index)\n\
    \        if (smalest_even_index == -1 || smalest_even_index == evens.size - 1)\
    \ {\n            List[Long]()\n        } else {\n            List(smalest_value,\
    \ smalest_even_index)\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5aq1k_g5.scala:35)\n\tat Problem.main(tmp5aq1k_g5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009947
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val evensSorted\
    \ = evens.sortWith((x, y) => x < y)\n        val evenSmallest = evensSorted.head\n\
    \        val evenSmallestIndex = evensSorted.indexOf(0)\n        val smallestEven\
    \ = evenSmallest\n        val smallestEvenIndex = evenSmallestIndex\n        val\
    \ smallestEvenIndex = evenSmallestIndex\n        val smallestEvenIndex = evenSmallestIndex\n\
    \        val smallestEvenIndex = evenSmallestIndex\n        val smallestEvenIndex\
    \ = evenSmallestIndex\n        val smallestEvenIndex = evenSmallestIndex\n   \
    \     val smallestEvenIndex = evenSmallestIndex\n        val smallestEvenIndex\
    \ = evenSmallestIndex\n        val smallestEvenIndex = evenSmallestIndex\n   \
    \     val smallestEvenIndex = evenSmallestIndex\n        val smallestEvenIndex\
    \ = evenSmallestIndex\n        val smallestEvenIndex = evenSmallestIndex\n   \
    \     val smallestEvenIndex = evenSmallestIndex\n        val smallestEvenIndex\
    \ = evenSmallestIndex\n        val smallestEvenIndex = evenSmallestIndex\n   \
    \     val smallestEvenIndex = evenSmallestIndex\n        val smallestEvenIndex\
    \ = evenSmallestIndex\n        val smallestEvenIndex = evenSmallestIndex\n   \
    \     val smallestEvenIndex = evenSmallestIndex\n        val smallestEvenIndex\
    \ = evenSmallestIndex\n        val smallestEvenIndex = evenSmallestIndex\n   \
    \     val smallestEvenIndex = evenSmallestIndex\n        val smallestEvenIndex\
    \ = evenSmallestIndex\n        val smallestEvenIndex = evenSmallestIndex\n   \
    \     val smallestEvenIndex = evenSmallestIndex\n        val smallestEvenIndex\
    \ = evenSmallestIndex\n        val smallestEvenIndex = evenSmallestIndex\n   \
    \     val smallestEvenIndex = evenSmallestIndex\n        val smallestEvenIndex\
    \ = evenSmallestIndex\n        val smallestEvenIndex = evenSmallestIndex\n   \
    \     val smallestEvenIndex = evenSmallestIndex\n        val smallestEvenIndex\
    \ = evenSmallestIndex\n        val smallestEvenIndex = evenSmallestIndex\n   \
    \     val smallestEvenIndex = evenSmallestIndex\n        val smallestEvenIndex\
    \ = evenSmallestIndex\n        val smallestEvenIndex = evenSmallestIndex\n   \
    \     val smallestEvenIndex = evenSmallestIndex\n        val \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpc54tljia.scala:64:11 ---------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpc54tljia.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ evenSmallestIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpc54tljia.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ evenSmallestIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpc54tljia.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ evenSmallestIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpc54tljia.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ evenSmallestIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   "
  stdout: ''
  timestamp: 1660009944
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0).sortBy(x => x).reverse\n\
    \        val smalest_value = evens.head\n        val smalest_index = evens.indexOf(0)\n\
    \        val smalest_even = evens.takeWhile(x => x % 2 == 0).takeWhile(_ < smalest_value).takeWhile(_\
    \ < smalest_index).last\n        val smalest_even_index = evens.indexOf(smalest_even)\n\
    \        val smalest_even_value = evens(smalest_even_index)\n        val smalest_even_index_list\
    \ = evens.takeWhile(x => x % 2 == 0).takeWhile(_ < smalest_value).takeWhile(_\
    \ < smalest_index).takeWhile(_ < smalest_even_index).reverse\n        val smalest_even_index_list_index\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_value = evens(smalest_even_index_list_index)\n\
    \        val smalest_even_index_list_index_list = evens.takeWhile(x => x % 2 ==\
    \ 0).takeWhile(_ < smalest_value).takeWhile(_ < smalest_index).takeWhile(_ < smalest_even_index_list_index).takeWhile(_\
    \ < smalest_even_index_list_index_list).reverse\n        val smalest_even_index_list_index_list_index\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_index_list_value\
    \ = evens(smalest_even_index_list_index_list_index)\n        val smalest_even_index_list_index_list_index_list\
    \ = evens.takeWhile(x => x % 2 == 0).takeWhile(_ < smalest_value).takeWhile(_\
    \ < smalest_index).takeWhile(_ < smalest_even_index_list_index_list_index).takeWhile(_\
    \ < smalest_even_index_list_index_list_index_list).takeWhile(_ < smalest_even_index_list_index_list_index_list_index).reverse\n\
    \        val smalest_even_index_list_index_list_index_list_index = evens.indexOf(smalest_even)\n\
    \        val smalest_even_index_list_index_list_index_list_value = evens(smalest_even_index_list_index_list_index_list_index)\n\
    \        val smalest_even_index_list_index_list_index_list_index_list = evens.takeWhile(x\
    \ => x % 2 == 0).takeWhile(_ < smalest_value).takeWhile(_ < smalest_index).takeWhile(_\
    \ < smalest_even_index_list_index_list_index_list_index).takeWhile(_ < smalest_even_index_list_index_list_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp74f7p3sa.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp74f7p3sa.scala:31:199\
    \ --------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_even_index_list_index_list\e[0m = evens.takeWhile(\e[36mx\e[0m\
    \ => x % \e[31m2\e[0m == \e[31m0\e[0m).takeWhile(_ < smalest_value).takeWhile(_\
    \ < smalest_index).takeWhile(_ < smalest_even_index_list_index).takeWhile(_ <\
    \ smalest_even_index_list_index_list).reverse\n\e[31m\e[31m   |\e[0m         \
    \                                                                            \
    \                                                                            \
    \                                      ^\e[0m\n\e[31m   |\e[0m           Recursive\
    \ \e[33mvalue\e[0m \e[35msmalest_even_index_list_index_list\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp74f7p3sa.scala:34:221\
    \ --------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_even_index_list_index_list_index_list\e[0m = evens.takeWhile(\e\
    [36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e[0m).takeWhile(_ < smalest_value).takeWhile(_\
    \ < smalest_index).takeWhile(_ < smalest_even_index_list_index_list_index).takeWhile(_\
    \ < smalest_even_index_list_index_list_index_list).takeWhile(_ < smalest_even_index_list_index_list_index_list_index).reverse\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \                                                                            \
    \             ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35msmalest_even_index_list_index_list_index_list\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp74f7p3sa.scala:37:243\
    \ -----------------------\e[0m\e[0m\n\e[31m3"
  stdout: ''
  timestamp: 1660009945
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        if (evens.isEmpty)\
    \ List(-1L)\n        else evens.minBy(x => x)._2\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpe3qnty08.scala:24:33 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33melse\e[0m evens.minBy(x => x)._2\n\e[31m\e\
    [31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \      value _2 is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1660009945
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val evensSorted\
    \ = evens.sortWith((x, y) => x < y)\n        val smallestEven = evensSorted.head\n\
    \        val smallestEvenIndex = evensSorted.indexOf(0)\n        val smallestEvenValue\
    \ = smallestEven / 2\n        val smallestEvenIndex = smallestEvenIndex + 1\n\
    \        val result: List[Long] = List(smallestEvenValue, smallestEvenIndex)\n\
    \        if (evensSorted.isEmpty) {\n            result\n        } else {\n  \
    \          result\n        }\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpklnl0ufe.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009939
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0).sorted\n        if (evens.isEmpty)\
    \ List()\n        else {\n            val smalest_value = evens.head\n       \
    \     val smallest_index = evens.indexOf(0)\n            val smalest_even = evens.filter(x\
    \ => x % 2 == smalest_value).head\n            val smalest_even_index = evens.indexOf(smalest_even)\n\
    \            val smalest_even_index_plus_one = smalest_even_index + 1\n      \
    \      val smalest_even_index_plus_two = smalest_even_index + 2\n            val\
    \ smalest_even_index_plus_three = smalest_even_index + 3\n            val smalest_even_index_plus_four\
    \ = smalest_even_index + 4\n            val smalest_even_index_plus_five = smalest_even_index\
    \ + 5\n            val smalest_even_index_plus_six = smalest_even_index + 6\n\
    \            val smalest_even_index_plus_seven = smalest_even_index + 7\n    \
    \        val smalest_even_index_plus_eight = smalest_even_index + 8\n        \
    \    val smalest_even_index_plus_nine = smalest_even_index + 9\n            val\
    \ smalest_even_index_plus_ten = smalest_even_index + 10\n            val smalest_even_index_plus_eleven\
    \ = smalest_even_index + 11\n            val smalest_even_index_plus_twelve =\
    \ smalest_even_index + 12\n            val smalest_even_index_plus_thirteen =\
    \ smalest_even_index + 13\n            val smalest_even_index_plus_fourteen =\
    \ smalest_even_index + 14\n            val smalest_even_index_plus_fifteen = smalest_even_index\
    \ + 15\n            val smalest_even_index_plus_sixteen = smalest_even_index +\
    \ 16\n            val smalest_even_index_plus_seventeen = smalest_even_index +\
    \ 17\n            val smalest_even_index_plus_eighteen = smalest_even_index +\
    \ 18\n            val smalest_even_index_plus_nineteen = smalest_even_index +\
    \ 19\n            val smalest_even_index_plus_twenty = smalest_even_index + 20\n\
    \            val smalest_even_index_plus_twenty_one = smalest_even_index + 21\n\
    \            val smalest_even_index_plus_twenty_two = smalest_even_index + 22\n\
    \            val smalest_even_index_plus_twenty_three\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjfq9hma0.scala:52:4 ----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjfq9hma0.scala:65:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m65 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpjfq9hma0.scala:64:1 ---------------------\e[0m\e[0m\n\
    \e[31m64 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\
    \e[31m   |\e[0m Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[33m\e[33m-- Warning:\
    \ /tmp/tmpjfq9hma0.scala:53:4 ----------------------------------------\e[0m\e\
    [0m\n\e[33m53 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e\
    [0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m\
    \    Line is indented too far to the left, or a `}` is missing\n1 warning found\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009948
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        if (evens.isEmpty)\
    \ List()\n        else {\n            val smallestEven = evens.min\n         \
    \   val index = evens.indexOf(smallestEven)\n            val smallestEvenValue\
    \ = smallestEven % 2\n            val smalestValue = if (smallestEvenValue ==\
    \ 0) smallestEven else smallestEven + 1\n            val smalestIndex = (index\
    \ + 1) % arr.length\n            List(smalestValue, smalestIndex)\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0nmm96g8.scala:34)\n\tat Problem.main(tmp0nmm96g8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009951
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(_ % 2 == 0)\n        val smallest = evens.min\n\
    \        val index = evens.indexOf(smallest)\n        val result = if (index >\
    \ 0) evens.take(index) else evens\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpt7uygy2y.scala:29)\n\tat Problem.main(tmpt7uygy2y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009952
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val evensSorted\
    \ = evens.sorted\n        val smallestEven = evensSorted.head\n        val smallestEvenIndex\
    \ = evensSorted.indexOf(0)\n        val smallestEvenValue = smallestEven\n   \
    \     val smallestEvenIndex = smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEven\n        val smallestEvenIndex = smallestEvenIndex\n        val\
    \ smallestEvenValue = smallestEven\n        val smallestEvenIndex = smallestEvenIndex\n\
    \        val smallestEvenValue = smallestEven\n        val smallestEvenIndex =\
    \ smallestEvenIndex\n        val smallestEvenValue = smallestEven\n        val\
    \ smallestEvenIndex = smallestEvenIndex\n        val smallestEvenValue = smallestEven\n\
    \        val smallestEvenIndex = smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEven\n        val smallestEvenIndex = smallestEvenIndex\n        val\
    \ smallestEvenValue = smallestEven\n        val smallestEvenIndex = smallestEvenIndex\n\
    \        val smallestEvenValue = smallestEven\n        val smallestEvenIndex =\
    \ smallestEvenIndex\n        val smallestEvenValue = smallestEven\n        val\
    \ smallestEvenIndex = smallestEvenIndex\n        val smallestEvenValue = smallestEven\n\
    \        val smallestEvenIndex = smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEven\n        val smallestEvenIndex = smallestEvenIndex\n        val\
    \ smallestEvenValue = smallestEven\n        val smallestEvenIndex = smallestEvenIndex\n\
    \        val smallestEvenValue = smallestEven\n        val smallestEvenIndex =\
    \ smallestEvenIndex\n        val smallestEvenValue = smallestEven\n        val\
    \ smallestEvenIndex = smallestEvenIndex\n        val smallestEvenValue = smallestEven\n\
    \        val smallestEvenIndex = smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEven\n        val smallestEvenIndex = smallestEvenIndex\n        val\
    \ smallestEvenValue = smallestEven\n        val smallestEvenIndex = smallestEvenIndex\n\
    \        val smallestEvenValue = smallestEven\n        val smallestEvenIndex =\
    \ smallestEvenIndex\n        val smallestEvenValue = smallestEven\n        val\
    \ smallestEvenIndex = smallestEvenIndex\n        val smallestEvenValue = smallestEven\n\
    \        val smallestEvenIndex = smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEven\n        val smallestEvenIndex = smallestEvenIndex\n        val\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp59vof48j.scala:70:11 ---------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp59vof48j.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp59vof48j.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m =\
    \ smallestEven\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp59vof48j.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp59vof48j.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m =\
    \ smallestEven\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mN"
  stdout: ''
  timestamp: 1660009949
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_even = evens(smalest_index)\n        val smalest_even_index =\
    \ smalest_index\n        val smalest_even_value = smalest_value\n        val smalest_even_index\
    \ = smalest_index\n        val smalest_even_value = smalest_value\n        val\
    \ smalest_even_index = smalest_index\n        val smalest_even_value = smalest_value\n\
    \        val smalest_even_index = smalest_index\n        val smalest_even_value\
    \ = smalest_value\n        val smalest_even_index = smalest_index\n        val\
    \ smalest_even_value = smalest_value\n        val smalest_even_index = smalest_index\n\
    \        val smalest_even_value = smalest_value\n        val smalest_even_index\
    \ = smalest_index\n        val smalest_even_value = smalest_value\n        val\
    \ smalest_even_index = smalest_index\n        val smalest_even_value = smalest_value\n\
    \        val smalest_even_index = smalest_index\n        val smalest_even_value\
    \ = smalest_value\n        val smalest_even_index = smalest_index\n        val\
    \ smalest_even_value = smalest_value\n        val smalest_even_index = smalest_index\n\
    \        val smalest_even_value = smalest_value\n        val smalest_even_index\
    \ = smalest_index\n        val smalest_even_value = smalest_value\n        val\
    \ smalest_even_index = smalest_index\n        val smalest_even_value = smalest_value\n\
    \        val smalest_even_index = smalest_index\n        val smalest_even_value\
    \ = smalest_value\n        val smalest_even_index = smalest_index\n        val\
    \ smalest_even_value = smalest_value\n        val smalest_even_index = smalest_index\n\
    \        val smalest_even_value = smalest_value\n        val smalest_even_index\
    \ = smalest_index\n        val smalest_even_value = smalest_value\n        val\
    \ smalest_even_index = smalest_index\n        val smalest_even_value = smalest_value\n\
    \        val smalest_even_index = smalest_index\n        val smalest_even_value\
    \ = smalest_value\n        val smalest_\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnt13t900.scala:65:4 ----------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnt13t900.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_even_index\e[0m = smalest_index\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msmalest_even_index\
    \ is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpnt13t900.scala:29:12 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value\e[0m = smalest_value\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msmalest_even_value is already defined as \e[33mvalue\e[0m \e[35msmalest_even_value\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpnt13t900.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m = smalest_index\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpnt13t900.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value\e[0m = smalest_value\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msmalest_even_value is already defined as \e[33mvalue\e[0m \e[35msmalest_even_value\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- "
  stdout: ''
  timestamp: 1660009835
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0).sortBy(x => x).reverse\n\
    \        val smalest_value = evens.head\n        val smalest_index = evens.indexOf(0)\n\
    \        if (smalest_index > 0) {\n            val smalest_even = evens(smalest_index)\n\
    \            val smalest_even_index = evens.indexOf(smalest_even)\n          \
    \  val smalest_even_value = evens(smalest_even_index)\n            val smalest_even_index_list\
    \ = evens.take(smalest_even_index_list)\n            val smalest_even_index_list\
    \ = smalest_even_index_list.sortBy(x => x).reverse\n            val smalest_even_index_list\
    \ = smalest_even_index_list.take(1)\n            val smalest_even_index_list =\
    \ smalest_even_index_list.toList\n            val smalest_even_index_list = smalest_even_index_list.sortBy(x\
    \ => x).reverse\n            val smalest_even_index_list = smalest_even_index_list.take(1)\n\
    \            val smalest_even_index_list = smalest_even_index_list.toList\n  \
    \          val smalest_even_index_list = smalest_even_index_list.sortBy(x => x).reverse\n\
    \            val smalest_even_index_list = smalest_even_index_list.take(1)\n \
    \           val smalest_even_index_list = smalest_even_index_list.toList\n   \
    \         val smalest_even_index_list = smalest_even_index_list.sortBy(x => x).reverse\n\
    \            val smalest_even_index_list = smalest_even_index_list.take(1)\n \
    \           val smalest_even_index_list = smalest_even_index_list.toList\n   \
    \         val smalest_even_index_list = smalest_even_index_list.sortBy(x => x).reverse\n\
    \            val smalest_even_index_list = smalest_even_index_list.take(1)\n \
    \           val smalest_even_index_list = smalest_even_index_list.toList\n   \
    \         val smalest_even_index_list = smalest_even_index_list.sortBy(x => x).reverse\n\
    \            val smalest_even_index_list = smalest_even_index_list.take(1)\n \
    \           val smalest_even_index_list = smalest_even_index_list.toList\n   \
    \         val smalest_even_index_list = smalest_even_index_list.sortBy(x => x).reverse\n\
    \            val smalest_even_index_list = smalest_even_index_list.take(1)\n \
    \           val smalest_even_index_list = smalest_even_index_list.toList\n   \
    \         val smalest_even_index_list = smalest_even_index_list.sort\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmtjn3kvi.scala:65:0 ----------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmtjn3kvi.scala:30:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m            \e[33mval\e\
    [0m \e[36msmalest_even_index_list\e[0m = smalest_even_index_list.sortBy(\e[36mx\e\
    [0m => x).reverse\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmtjn3kvi.scala:31:16 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33mval\e[0m \e[36msmalest_even_index_list\e\
    [0m = smalest_even_index_list.take(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m      \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0msmalest_even_index_list is already defined as \e[33mvalue\e[0m \e\
    [35msmalest_even_index_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpmtjn3kvi.scala:32:16 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e[0m \e[36msmalest_even_index_list\e\
    [0m = smalest_even_index_list.toList\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmtjn3kvi.scala:33:16 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e[0m \e[36msmalest_even_index_list\e\
    [0m = smalest_even_index_list.sortBy(\e[36mx\e[0m => x).reverse\n\e[31m\e[31m\
    \   |\e[0m   "
  stdout: ''
  timestamp: 1660009951
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val evensSorted\
    \ = evens.sortWith((x, y) => x < y)\n        val smalest_value = evensSorted.head\n\
    \        val smalest_index = evensSorted.indexOf(0)\n        val smalest_even\
    \ = evensSorted.take(smalest_index)\n        val smalest_evenSorted = smalest_even.sortWith((x,\
    \ y) => x < y)\n        val smalest_evenSorted_index = smalest_evenSorted.indexOf(0)\n\
    \        val smalest_evenSorted_value = smalest_evenSorted.take(smalest_evenSorted_index)\n\
    \        val smalest_evenSorted_value_index = smalest_evenSorted_value.indexOf(0)\n\
    \        val smalest_evenSorted_value_value = smalest_evenSorted_value.take(smalest_evenSorted_value_index)\n\
    \        val smalest_evenSorted_value_value_index = smalest_evenSorted_value_value.indexOf(0)\n\
    \        val smalest_evenSorted_value_value_value = smalest_evenSorted_value_value.take(smalest_evenSorted_value_value_index)\n\
    \        val smalest_evenSorted_value_value_value_index = smalest_evenSorted_value_value_value.indexOf(0)\n\
    \        val smalest_evenSorted_value_value_value_value = smalest_evenSorted_value_value_value.take(smalest_evenSorted_value_value_value_index)\n\
    \        val smalest_evenSorted_value_value_value_index = smalest_evenSorted_value_value_value_value.indexOf(0)\n\
    \        val smalest_evenSorted_value_value_value_value = smalest_evenSorted_value_value_value.take(smalest_evenSorted_value_value_value_index)\n\
    \        val smalest_evenSorted_value_value_value_index = smalest_evenSorted_value_value_value_value.indexOf(0)\n\
    \        val smalest_evenSorted_value_value_value_value = smalest_evenSorted_value_value_value_value.take(smalest_evenSorted_value_value_value_index)\n\
    \        val smalest_evenSorted_value_value_value_index = smalest_evenSorted_value_value_value_value.indexOf(0)\n\
    \        val smalest_evenSorted_value_value_value_value = smalest_evenSorted_value_value_value_value.take(smalest_evenSorted_value_value_value_index)\n\
    \        val smalest_evenSorted_value_value_value_index = smalest_evenSorted_value_value_value_value.indexOf(0)\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpiizkryvh.scala:43:11 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpiizkryvh.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36msmalest_evenSorted_value_value_value_index\e\
    [0m = smalest_evenSorted_value_value_value_value.indexOf(\e[31m0\e[0m)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evenSorted_value_value_value_index is already defined\
    \ as \e[33mvalue\e[0m \e[35msmalest_evenSorted_value_value_value_index\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpiizkryvh.scala:37:12 ---------------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m        \e[33mval\e[0m \e[36msmalest_evenSorted_value_value_value_value\e\
    [0m = smalest_evenSorted_value_value_value.take(smalest_evenSorted_value_value_value_index)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evenSorted_value_value_value_value is already defined\
    \ as \e[33mvalue\e[0m \e[35msmalest_evenSorted_value_value_value_value\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpiizkryvh.scala:38:12 ---------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m        \e[33mval\e[0m \e[36msmalest_evenSorted_value_value_value_index\e\
    [0m = smalest_evenSorted_value_value_value_value.indexOf(\e[31m0\e[0m)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest"
  stdout: ''
  timestamp: 1660009949
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val evensSorted\
    \ = evens.sorted\n        val smallestEven = evensSorted.head\n        val smallestIndex\
    \ = evensSorted.indexOfMin\n        val smallestValue = evensSorted.min\n    \
    \    val result = arr.filter(x => x % 2 == 0 && x == smallestEven)\n        val\
    \ resultSorted = result.sorted\n        val smallestEvenInResult = resultSorted.head\n\
    \        val smallestIndexInResult = resultSorted.indexOfMin\n        val smallestValueInResult\
    \ = resultSorted.min\n        if (smallestEvenInResult == smallestEven) {\n  \
    \          val resultWithSmallestIndex = arr.filter(x => x % 2 == 0 && x == smallestEven).map(x\
    \ => x -> smallestIndexInResult)\n            resultWithSmallestIndex.toList\n\
    \        } else {\n            val resultWithSmallestIndex = arr.filter(x => x\
    \ % 2 == 0 && x == smallestEven).map(x => x -> smallestIndexInResult)\n      \
    \      resultWithSmallestIndex.toList\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpq77_kfka.scala:25:40 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36msmallestIndex\e[0m = evensSorted.indexOfMin\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue indexOfMin is not a member of List[Long] - did you mean evensSorted.indexOf?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpq77_kfka.scala:30:49 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36msmallestIndexInResult\e\
    [0m = resultSorted.indexOfMin\n\e[31m\e[31m   |\e[0m                         \
    \           ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue indexOfMin is not\
    \ a member of List[Long] - did you mean resultSorted.indexOf?\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpq77_kfka.scala:34:36 --------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            resultWithSmallestIndex.toList\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \            Found:    List[\e[1m\e[31m(\e[0mLong\e[1m\e[31m,\e[0m\e[1m\e[31m\
    \ \e[0m\e[1m\e[31mNothing\e[0m\e[1m\e[31m)\e[0m]\n\e[31m   |\e[0m            Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpq77_kfka.scala:37:36\
    \ --------------------\e[0m\e[0m\n\e[31m37 |\e[0m            resultWithSmallestIndex.toList\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m            Found:    List[\e[1m\e[31m(\e[0mLong\e[1m\e[31m,\e[0m\e[1m\e\
    [31m \e[0m\e[1m\e[31mNothing\e[0m\e[1m\e[31m)\e[0m]\n\e[31m   |\e[0m         \
    \   Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009951
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val even = arr.filter(x => x % 2 == 0).sortBy(x => x).take(1)\n\
    \        if (even.isEmpty) List()\n        else {\n            val smalest_value\
    \ = even(0)\n            val smalest_index = even.indexOf(smalest_value)\n   \
    \         val smalest_even = even.filter(x => x % 2 == 0).takeWhile(_ < smalest_value)\n\
    \            if (smalest_even.isEmpty) List()\n            else {\n          \
    \      val smallest_even = smalest_even(0)\n                val smallest_index\
    \ = even.indexOf(smallest_even)\n                val smallest_even = even.filter(x\
    \ => x % 2 == 0).takeWhile(_ < smallest_even)\n                if (smallest_even.isEmpty)\
    \ List()\n                else {\n                    val smallest_even = smalest_even(0)\n\
    \                    val smallest_index = even.indexOf(smallest_even)\n      \
    \              val smallest_even = even.filter(x => x % 2 == 0).takeWhile(_ <\
    \ smallest_even)\n                    if (smallest_even.isEmpty) List()\n    \
    \                else {\n                        val smallest_even = smalest_even(0)\n\
    \                        val smallest_index = even.indexOf(smallest_even)\n  \
    \                      val smallest_even = even.filter(x => x % 2 == 0).takeWhile(_\
    \ < smallest_even)\n                        if (smallest_even.isEmpty) List()\n\
    \                        else {\n                            val smallest_even\
    \ = smalest_even(0)\n                            val smallest_index = even.indexOf(smallest_even)\n\
    \                            val smallest_even = even.filter(x => x % 2 == 0).takeWhile(_\
    \ < smallest_even)\n                            if (smallest_even.isEmpty) List()\n\
    \                            else {\n                                val smallest_even\
    \ = smalest_even(0)\n                                val smallest_index = even.indexOf(smallest_even)\n\
    \                                val smallest_even = even.filter(x => x % 2 ==\
    \ 0).takeWhile(_ < smallest_even)\n                                if (smallest_even.isEmpty)\
    \ List()\n                                else {\n                           \
    \         val smallest_even = smalest_even(0)\n                              \
    \      val smallest_index = even.indexOf(smallest_even)\n                    \
    \                val smallest_even = even.filter(x => x % 2 == 0).takeWhile(_\
    \ < smallest_even)\n                                    if (smallest_even.isEmpty)\
    \ List()\n                                    else {\n                       \
    \                 val smallest_even = smalest_even(0)\n                      \
    \                  val smallest_index = even.indexOf(smallest_even)\n        \
    \                                val smallest_even = even.filter(x => x % 2 ==\
    \ 0).takeWhile(_ < smallest_even)\n                                        if\
    \ (smallest_even\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9eslmiu3.scala:64:4 ----------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9eslmiu3.scala:77:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m77 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp9eslmiu3.scala:32:20 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m                \e[33mval\e[0m \e[36msmallest_even\e[0m = even.filter(\e\
    [36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e[0m).takeWhile(_ < smallest_even)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallest_even is already defined as \e[33mvalue\e[0m \e[35msmallest_even\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp9eslmiu3.scala:33:34 ------------------------\e[0m\e[0m\n\
    \e[31m33 |\e[0m                \e[33mif\e[0m (smallest_even.isEmpty) List()\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                    value isEmpty is not a member of Long\n\e[31m\e[31m-- [E161]\
    \ Naming Error: /tmp/tmp9eslmiu3.scala:37:24 ---------------------------\e[0m\e\
    [0m\n\e[31m37 |\e[0m                    \e[33mval\e[0m \e[36msmallest_even\e[0m\
    \ = even.filter(\e[36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e[0m).takeWhile(_\
    \ < smallest_even)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallest_even is already defined as \e[33mvalue\e[0m \e[35msmallest_even\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp9eslmiu3.scala:38:38 ------------------------\e[0m\e[0m\n\
    \e[31m38 |\e[0m                    \e[33mif\e[0m (smallest_even.isEmpty) List()\n\
    \e[31m\e[31m   |\e[0m                        ^^^^"
  stdout: ''
  timestamp: 1660009954
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val evensSorted\
    \ = evens.sortWith((x, y) => x - y)\n        val smallestEven = evensSorted.head\n\
    \        val smallestEvenIndex = evensSorted.indexOf(0)\n        val smallestEvenValue\
    \ = smallestEven\n        val smallestEvenIndex = smallestEvenIndex\n        val\
    \ result = arr.filter(_ != smallestEvenValue)\n        if (result.isEmpty) {\n\
    \            List[Long]()\n        } else {\n            val smallestEvenIndex\
    \ = smallestEvenIndex\n            val smallestEvenValue = smallestEvenValue\n\
    \            val result = arr.filter(_ != smallestEvenValue)\n            val\
    \ smallestEvenIndex = smallestEvenIndex\n            val smallestEvenValue = smallestEvenValue\n\
    \            val result = arr.filter(_ != smallestEvenValue)\n            val\
    \ smallestEvenIndex = smallestEvenIndex\n            val smallestEvenValue = smallestEvenValue\n\
    \            val result = arr.filter(_ != smallestEvenValue)\n            val\
    \ smallestEvenIndex = smallestEvenIndex\n            val smallestEvenValue = smallestEvenValue\n\
    \            val result = arr.filter(_ != smallestEvenValue)\n            val\
    \ smallestEvenIndex = smallestEvenIndex\n            val smallestEvenValue = smallestEvenValue\n\
    \            val result = arr.filter(_ != smallestEvenValue)\n            val\
    \ smallestEvenIndex = smallestEvenIndex\n            val smallestEvenValue = smallestEvenValue\n\
    \            val result = arr.filter(_ != smallestEvenValue)\n            val\
    \ smallestEvenIndex = smallestEvenIndex\n            val smallestEvenValue = smallestEvenValue\n\
    \            val result = arr.filter(_ != smallestEvenValue)\n            val\
    \ smallestEvenIndex = smallestEvenIndex\n            val smallestEvenValue = smallestEvenValue\n\
    \            val result = arr.filter(_ != smallestEvenValue)\n            val\
    \ smallestEvenIndex = smallestEvenIndex\n            val smallestEvenValue = smallestEvenValue\n\
    \            val result = arr.filter(_ != smallestEvenValue)\n            val\
    \ smallestEvenIndex = smallestEvenIndex\n            val smallestEvenValue = smallestEvenValue\n\
    \            val result = arr.filter(_ != smallestEvenValue)\n            val\
    \ smallestEvenIndex = smallestEvenIndex\n            val smallestEvenValue = smallestEvenValue\n\
    \            val result = arr.filter(_ != smallestEvenValue)\n            val\
    \ smallestEvenIndex = smallestEvenIndex\n            val smallestEvenValue = smallestEvenValue\n\
    \            val result = arr.filter(_ != smallestEvenValue)\n            val\
    \ smallest\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptj_ixgrj.scala:69:4 ----------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptj_ixgrj.scala:82:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m82 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmptj_ixgrj.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m = smallestEvenIndex\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e[35msmallestEvenIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmptj_ixgrj.scala:23:51 --------------------\e[0m\e[0m\n\
    \e[31m23 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evens.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => x - y)\n\e[31m\e[31m   |\e[0m                   \
    \                                ^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                                  Found:    Long\n\e[31m   |\e[0m           \
    \                                        Required: Boolean\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmptj_ixgrj.scala:35:16 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e[0m \e[36msmallestEvenIndex\e\
    [0m = smallestEvenIndex\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmptj_ixgrj.scala:36:16 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e[0m \e[36msmallestEvenValue\e\
    [0m = smallestEvenValue\n\e[31m\e[31m   |\e[0m     "
  stdout: ''
  timestamp: 1660009953
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_even = evens(smalest_index)\n        val smalest_even_index =\
    \ evens.indexOf(smalest_even)\n        val smalest_even_value = evens(smalest_even_index)\n\
    \        val smalest_even_index_list = evens.indexOf(smalest_even)\n        val\
    \ smalest_even_index_list_list = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = even\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb80je3pc.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_list_list_list_list_list_list_list_list\e\
    [0m = evens.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_list_list_list_list_list_list_list_list\
    \ is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index_list_list_list_list_list_list_list_list_list\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpb80je3pc.scala:40:12 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_list_list_list_list_list_list_list_list_list_list\e\
    [0m = evens.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_list_list_list_list_list_list_list_list_list_list\
    \ is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index_list_list_list_list_list_list_list_list_list_list_list\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpb80je3pc.scala:42:12 ---------------------------\e[0m\e[0m\n\e\
    [31m42 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list\e\
    [0m = evens.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNo"
  stdout: ''
  timestamp: 1660009813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(_ % 2 == 0)\n        val smalest_value =\
    \ evens.min\n        val smalest_index = evens.indexOfMin\n        val smalest_even\
    \ = evens(smalest_index)\n        val smalest_even_index = evens.indexOf(smalest_even)\n\
    \        val smalest_even_value = evens(smalest_even_index)\n        val smalest_even_index_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list = evens.indexOf(smalest_even)\n\
    \        val smalest_even_index_list_list_list = evens.indexOf(smalest_even)\n\
    \        val smalest_even_index_list_list_list_list = evens.indexOf(smalest_even)\n\
    \        val smalest_even_index_list_list_list_list_list = evens.indexOf(smalest_even)\n\
    \        val smalest_even_index_list_list_list_list_list_list = evens.indexOf(smalest_even)\n\
    \        val smalest_even_index_list_list_list_list_list_list_list = evens.indexOf(smalest_even)\n\
    \        val smalest_even_index_list_list_list_list_list_list_list_list = evens.indexOf(smalest_even)\n\
    \        val smalest_even_index_list_list_list_list_list_list_list_list_list =\
    \ evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpke7x0h8g.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpke7x0h8g.scala:37:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_even_index_list_list_list_list_list_list_list_list_list\e[0m =\
    \ evens.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_list_list_list_list_list_list_list_list\
    \ is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index_list_list_list_list_list_list_list_list_list\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpke7x0h8g.scala:40:12 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_list_list_list_list_list_list_list_list_list_list\e\
    [0m = evens.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_list_list_list_list_list_list_list_list_list_list\
    \ is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index_list_list_list_list_list_list_list_list_list_list_list\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpke7x0h8g.scala:42:12 ---------------------------\e[0m\e[0m\n\e\
    [31m42 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list\e\
    [0m = evens.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_list_list_list_list_list_list_list_list_list_lis"
  stdout: ''
  timestamp: 1660009952
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_even = evens(smalest_index)\n        val smalest_even_index =\
    \ evens.indexOf(smalest_even)\n        val smalest_even_value = evens(smalest_even_index)\n\
    \        val smalest_even_index_list = evens.indexOf(smalest_even)\n        val\
    \ smalest_even_index_list_list = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = even\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb80je3pc.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_list_list_list_list_list_list_list_list\e\
    [0m = evens.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_list_list_list_list_list_list_list_list\
    \ is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index_list_list_list_list_list_list_list_list_list\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpb80je3pc.scala:40:12 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_list_list_list_list_list_list_list_list_list_list\e\
    [0m = evens.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_list_list_list_list_list_list_list_list_list_list\
    \ is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index_list_list_list_list_list_list_list_list_list_list_list\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpb80je3pc.scala:42:12 ---------------------------\e[0m\e[0m\n\e\
    [31m42 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list\e\
    [0m = evens.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNo"
  stdout: ''
  timestamp: 1660009813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0).sorted\n        if (evens.isEmpty)\
    \ List()\n        else {\n            val smallest = evens.head\n            val\
    \ index = arr.indexOf(smallest)\n            val result = List(smallest, index)\n\
    \            if (arr.contains(smallest)) result :+ smallest\n            else\
    \ result\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpav_xxz9h.scala:28:40\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m            \e[33mif\e[0m (arr.contains(smallest))\
    \ result :+ smallest\n\e[31m\e[31m   |\e[0m                                  \
    \      ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                              \
    \          Found:    List[\e[1m\e[31mAnyVal\e[0m]\n\e[31m   |\e[0m           \
    \                             Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpav_xxz9h.scala:29:17 --------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33melse\e[0m result\n\e[31m\e[31m   |\e\
    [0m                 ^^^^^^\e[0m\n\e[31m   |\e[0m                 Found:    (result\
    \ : List[AnyVal])\n\e[31m   |\e[0m                 Required: List[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009951
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val even = arr.filter(x => x % 2 == 0)\n        val evenSorted\
    \ = even.sorted\n        val smallestEven = evenSorted.head\n        val smallestEvenIndex\
    \ = evenSorted.indexOf(0)\n        val smallestEvenValue = smallestEven\n    \
    \    val evenValues = evenSorted.filterNot(x => x == smallestEvenValue)\n    \
    \    val evenValuesSorted = evenValues.sorted\n        val smallestEvenIndex =\
    \ evenValuesSorted.indexOf(0)\n        val smallestEvenValue = smallestEven\n\
    \        val evenValues = evenValuesSorted.filterNot(x => x == smallestEvenValue)\n\
    \        val evenValuesSorted = evenValues.sorted\n        val smallestEvenIndex\
    \ = evenValuesSorted.indexOf(0)\n        val smallestEvenValue = smallestEven\n\
    \        val evenValues = evenValuesSorted.filterNot(x => x == smallestEvenValue)\n\
    \        val evenValuesSorted = evenValues.sorted\n        val smallestEvenIndex\
    \ = evenValuesSorted.indexOf(0)\n        val smallestEvenValue = smallestEven\n\
    \        val evenValues = evenValuesSorted.filterNot(x => x == smallestEvenValue)\n\
    \        val evenValuesSorted = evenValues.sorted\n        val smallestEvenIndex\
    \ = evenValuesSorted.indexOf(0)\n        val smallestEvenValue = smallestEven\n\
    \        val evenValues = evenValuesSorted.filterNot(x => x == smallestEvenValue)\n\
    \        val evenValuesSorted = evenValues.sorted\n        val smallestEvenIndex\
    \ = evenValuesSorted.indexOf(0)\n        val smallestEvenValue = smallestEven\n\
    \        val evenValues = evenValuesSorted.filterNot(x => x == smallestEvenValue)\n\
    \        val evenValuesSorted = evenValues.sorted\n        val smallestEvenIndex\
    \ = evenValuesSorted.indexOf(0)\n        val smallestEvenValue = smallestEven\n\
    \        val evenValues = evenValuesSorted.filterNot(x => x == smallestEvenValue)\n\
    \        val evenValuesSorted = evenValues.sorted\n        val smallestEvenIndex\
    \ = evenValuesSorted.indexOf(0)\n        val smallestEvenValue = smallestEven\n\
    \        val evenValues = evenValuesSorted.filterNot(x => x == smallestEvenValue)\n\
    \        val evenValuesSorted = evenValues.sorted\n        val smallestEvenIndex\
    \ = evenValuesSorted.indexOf(0)\n        val smallestEvenValue = smallestEven\n\
    \        val evenValues = evenValuesSorted.filterNot(x => x == smallestEvenValue)\n\
    \        val evenValuesSorted = \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpuk76awbw.scala:60:30 ---------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m        \e[33mval\e[0m \e[36mevenValuesSorted\e[0m =\
    \ \n\e[31m\e[31m   |\e[0m                              ^\e[0m\n\e[31m   |\e[0m\
    \                              expression expected but \e[31m'}'\e[0m found\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuk76awbw.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmallestEvenIndex\e[0m = evenValuesSorted.indexOf(\e[31m0\e[0m)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e[35msmallestEvenIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpuk76awbw.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m = smallestEven\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e[35msmallestEvenValue\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpuk76awbw.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mevenValues\e[0m = evenValuesSorted.filterNot(\e\
    [36mx\e[0m => x == smallestEvenValue)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenValues is already defined as \e[33mvalue\e[0m \e[35mevenValues\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpuk76awbw.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mevenValuesSorted\e[0m = evenValues.sorted\n\
    \e[31m\e[3"
  stdout: ''
  timestamp: 1660009952
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0).sortBy(x => x)\n      \
    \  val smallest = evens.head\n        val index = evens.indexOf(smallest)\n  \
    \      val result = List(smallest, index)\n        if (arr.isEmpty) result\n \
    \       else result.sortBy(x => x._1).reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqhqx87qe.scala:26:25\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mif\e[0m (arr.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                         ^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                         Found:    (result : List[AnyVal])\n\e[31m   |\e\
    [0m                         Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpqhqx87qe.scala:27:34 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33melse\e[0m result.sortBy(x => x._1).reverse\n\
    \e[31m\e[31m   |\e[0m                                ^^^^\e[0m\n\e[31m   |\e[0m\
    \                                value _1 is not a member of AnyVal\n\e[31m\e\
    [31m-- Error: /tmp/tmpqhqx87qe.scala:27:37 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33melse\e[0m result.sortBy(x => x._1).reverse\n\
    \e[31m\e[31m   |\e[0m                                     ^\e[0m\n\e[31m   |\e\
    [0mambiguous given instances: both \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mShort\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[B] of parameter ord of \e[33mmethod\e\
    [0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n3 errors found\n"
  stdout: ''
  timestamp: 1660009953
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0).sortBy(x => x).reverse\n\
    \        val smallestEven = evens.head\n        val smallestIndex = evens.indexOf(0)\n\
    \        val result = if (smallestIndex == -1) List(smallestEven) else evens.take(smallestIndex).filter(_\
    \ % 2 == 0).sortBy(x => x).reverse\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5l6gon1l.scala:29)\n\tat Problem.main(tmp5l6gon1l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009955
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0).sorted\n        val even\
    \ = evens.head\n        val index = arr.indexOf(even)\n        val result = List(even,\
    \ index)\n        if (arr.isEmpty) result\n        else result.sortBy(-_)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkhf5gfrr.scala:26:25\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mif\e[0m (arr.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                         ^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                         Found:    (result : List[AnyVal])\n\e[31m   |\e\
    [0m                         Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpkhf5gfrr.scala:27:27 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33melse\e[0m result.sortBy(-_)\n\e[31m\e[31m\
    \   |\e[0m                           ^^\e[0m\n\e[31m   |\e[0mvalue unary_- is\
    \ not a member of AnyVal, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- Error: /tmp/tmpkhf5gfrr.scala:27:30 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33melse\e[0m result.sortBy(-_)\n\e[31m\e[31m\
    \   |\e[0m                              ^\e[0m\n\e[31m   |\e[0mambiguous given\
    \ instances: both \e[33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m and \e[33mobject\e[0m \e[35mDeprecatedDoubleOrdering\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[B] of parameter ord of \e[33mmethod\e\
    [0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n3 errors found\n"
  stdout: ''
  timestamp: 1660009955
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val even = arr.filter(x => x % 2 == 0).sorted\n        val evenIndex\
    \ = arr.indexWhere(x => x % 2 == 0)\n        val smalest_value = even.head\n \
    \       val smalest_index = evenIndex\n        val result = if (even.size == 0)\
    \ Nil else List(smalest_value, smalest_index)\n        result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbvx1xwyg.scala:27:8\
    \ ---------------------\e[0m\e[0m\n\e[31m27 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[AnyVal])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009953
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0).sortBy(x => x).map(x =>\
    \ x).reverse\n        val even = evens.head\n        val index = arr.indexOf(even)\n\
    \        val result = List(even, index)\n        if (arr.isEmpty) result\n   \
    \     else pluck(arr.drop(index+1))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdb2ieapj.scala:26:25\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mif\e[0m (arr.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                         ^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                         Found:    (result : List[AnyVal])\n\e[31m   |\e\
    [0m                         Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009954
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0).sortBy(x => x).reverse\n\
    \        val smalest_value = evens.head\n        val smalest_index = evens.indexOf(0)\n\
    \        val result = evens.takeWhile(x => x != smalest_value).takeWhile(x =>\
    \ x != smalest_index).reverse\n        if (result.isEmpty) result else List(smalest_value,\
    \ smalest_index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptunrtdl8.scala:29)\n\tat Problem.main(tmptunrtdl8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009966
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_even = evens(smalest_index)\n        val smalest_even_index =\
    \ evens.indexOf(smalest_even)\n        val smalest_even_value = evens(smalest_even_index)\n\
    \        val smalest_even_index_list = evens.indexOf(smalest_even)\n        val\
    \ smalest_even_index_list_index = evens.indexOf(smalest_even, smalest_even_index_list)\n\
    \        val smalest_even_index_list_value = evens.indexOf(smalest_even, smalest_even_index_list,\
    \ smalest_even_index_list_index)\n        val smalest_even_index_list_value_index\
    \ = evens.indexOf(smalest_even, smalest_even_index_list, smalest_even_index_list_index,\
    \ smalest_even_index_list_value+1)\n        val smalest_even_index_list_value_index_value\
    \ = evens.indexOf(smalest_even, smalest_even_index_list, smalest_even_index_list_index,\
    \ smalest_even_index_list_value+1, smalest_even_index_list_value_index_value+1)\n\
    \        val smalest_even_index_list_value_index_value_index_value = evens.indexOf(smalest_even,\
    \ smalest_even_index_list, smalest_even_index_list_index, smalest_even_index_list_value+1,\
    \ smalest_even_index_list_value_index_value+1, smalest_even_index_list_value_index_value_index_value+1)\n\
    \        val smalest_even_index_list_value_index_value_index_value_index_value\
    \ = evens.indexOf(smalest_even, smalest_even_index_list, smalest_even_index_list_index,\
    \ smalest_even_index_list_value+1, smalest_even_index_list_value_index_value+1,\
    \ smalest_even_index_list_value_index_value_index_value+1, smalest_even_index_list_value_index_value_index_value_index_value_index_value+1)\n\
    \        val smalest_even_index_list_value_index_value_index_value_index_value_index_value_index_value\
    \ = evens.indexOf(smalest_even, smalest_even_index_list, smalest_even_index_list_index,\
    \ smalest_even_index_list_value+1, smalest_even_index_list_value_index_value+1,\
    \ smalest_even_index_list_value_index_value_index_value+1, smalest_even_index_list_value_index_value_index_value_index_value+1,\
    \ smalest_even_index_list_value_index_value_index_value_index_value+1, smalest_even_index_list_value_index_value_index_value_index_value+1,\
    \ smalest_even_index_list_value\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7vkgimun.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp7vkgimun.scala:30:50\
    \ -----------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e\
    [0m \e[36msmalest_even_index_list_value\e[0m = evens.indexOf(smalest_even, smalest_even_index_list,\
    \ smalest_even_index_list_index)\n\e[31m\e[31m   |\e[0m                      \
    \                      ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35mindexOf\e[0m in \e[33mtrait\e[0m \e\
    [35mSeqOps\e[0m with types\n\e[31m   |\e[0m [B >: Long](elem: B): Int\n\e[31m\
    \   |\e[0m [B >: Long](elem: B, from: Int): Int\n\e[31m   |\e[0mmatch arguments\
    \ ((smalest_even : Long), (smalest_even_index_list : Int), (smalest_even_index_list_index\
    \ : Int))\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7vkgimun.scala:32:173 --------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_value_index_value\e\
    [0m = evens.indexOf(smalest_even, smalest_even_index_list, smalest_even_index_list_index,\
    \ smalest_even_index_list_value+\e[31m1\e[0m, smalest_even_index_list_value_index_value+\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \                                                                            \
    \                                                      ^\e[0m\n\e[31m   |\e[0m\
    \    Recursive \e[33mvalue\e[0m \e[35msmalest_even_index_list_value_index_value\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7vkgimun.scala:33:230\
    \ --------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_even_index_list_value_index_value_index_value\e[0m = evens.indexOf(smalest_even,\
    \ smalest_even_index_list, smalest_even_index_list_index, smalest_even_index_list_value+\e\
    [31m1\e[0m, smalest_even_index_list_value_index_value+\e[31m1\e[0m, smalest_even_index_list_value_index_valu"
  stdout: ''
  timestamp: 1660009962
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val evensSorted\
    \ = evens.sortWith((x, y) => x < y)\n        val evensSortedWithIndex = evensSorted.zipWithIndex\n\
    \        val smalest_value = evensSortedWithIndex.head._2\n        val smalest_index\
    \ = evensSortedWithIndex.head._1\n        val smalest_even = evensSorted.filter(x\
    \ => x == smalest_value).head\n        val smalest_evenIndex = evensSorted.indexOf(smalest_even)\n\
    \        val smalest_evenValue = smalest_even\n        val smalest_evenIndex =\
    \ smalest_evenIndex\n        val smalest_evenValue = smalest_evenValue\n     \
    \   val smalest_evenIndex = smalest_evenIndex\n        val smalest_evenValue =\
    \ smalest_evenValue\n        val smalest_evenIndex = smalest_evenIndex\n     \
    \   val smalest_evenValue = smalest_evenValue\n        val smalest_evenIndex =\
    \ smalest_evenIndex\n        val smalest_evenValue = smalest_evenValue\n     \
    \   val smalest_evenIndex = smalest_evenIndex\n        val smalest_evenValue =\
    \ smalest_evenValue\n        val smalest_evenIndex = smalest_evenIndex\n     \
    \   val smalest_evenValue = smalest_evenValue\n        val smalest_evenIndex =\
    \ smalest_evenIndex\n        val smalest_evenValue = smalest_evenValue\n     \
    \   val smalest_evenIndex = smalest_evenIndex\n        val smalest_evenValue =\
    \ smalest_evenValue\n        val smalest_evenIndex = smalest_evenIndex\n     \
    \   val smalest_evenValue = smalest_evenValue\n        val smalest_evenIndex =\
    \ smalest_evenIndex\n        val smalest_evenValue = smalest_evenValue\n     \
    \   val smalest_evenIndex = smalest_evenIndex\n        val smalest_evenValue =\
    \ smalest_evenValue\n        val smalest_evenIndex = smalest_evenIndex\n     \
    \   val smalest_evenValue = smalest_evenValue\n        val smalest_evenIndex =\
    \ smalest_evenIndex\n        val smalest_evenValue = smalest_evenValue\n     \
    \   val smalest_evenIndex = smalest_evenIndex\n        val smalest_evenValue =\
    \ smalest_evenValue\n        val smalest_evenIndex = smalest_evenIndex\n     \
    \   val smalest_evenValue = \n    }\n    def main(args: Array[String]) = {\n \
    \   assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpywq8bvif.scala:59:31 ---------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m        \e[33mval\e[0m \e[36msmalest_evenValue\e[0m =\
    \ \n\e[31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m   |\e[0m\
    \                               expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpywq8bvif.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_evenIndex\e[0m = smalest_evenIndex\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msmalest_evenIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35msmalest_evenIndex\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpywq8bvif.scala:31:12 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m        \e[33mval\e[0m \e[36msmalest_evenValue\e[0m = smalest_evenValue\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0msmalest_evenValue is already defined as \e[33mvalue\e[0m \e[35msmalest_evenValue\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpywq8bvif.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36msmalest_evenIndex\e[0m = smalest_evenIndex\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0msmalest_evenIndex is already defined as \e[33mvalue\e[0m \e[35msmalest_evenIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpywq8bvif.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36msmalest_evenValue\e[0m = smalest_evenValue\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   "
  stdout: ''
  timestamp: 1660009964
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val evensSorted\
    \ = evens.sortWith((x, y) => x < y)\n        val smallestEven = evensSorted.head\n\
    \        val smallestEvenIndex = evensSorted.indexOf(0)\n        val smallestEvenValue\
    \ = smallestEven / 2\n        val smallestEvenIndex = smallestEvenIndex + 1\n\
    \        val smallestEvenValue = smallestEvenValue * 2\n        val smallestEvenIndex\
    \ = smallestEvenIndex + 1\n        val smallestEvenValue = smallestEvenValue *\
    \ 2\n        val smallestEvenIndex = smallestEvenIndex + 1\n        val smallestEvenValue\
    \ = smallestEvenValue * 2\n        val smallestEvenIndex = smallestEvenIndex +\
    \ 1\n        val smallestEvenValue = smallestEvenValue * 2\n        val smallestEvenIndex\
    \ = smallestEvenIndex + 1\n        val smallestEvenValue = smallestEvenValue *\
    \ 2\n        val smallestEvenIndex = smallestEvenIndex + 1\n        val smallestEvenValue\
    \ = smallestEvenValue * 2\n        val smallestEvenIndex = smallestEvenIndex +\
    \ 1\n        val smallestEvenValue = smallestEvenValue * 2\n        val smallestEvenIndex\
    \ = smallestEvenIndex + 1\n        val smallestEvenValue = smallestEvenValue *\
    \ 2\n        val smallestEvenIndex = smallestEvenIndex + 1\n        val smallestEvenValue\
    \ = smallestEvenValue * 2\n        val smallestEvenIndex = smallestEvenIndex +\
    \ 1\n        val smallestEvenValue = smallestEvenValue * 2\n        val smallestEvenIndex\
    \ = smallestEvenIndex + 1\n        val smallestEvenValue = smallestEvenValue *\
    \ 2\n        val smallestEvenIndex = smallestEvenIndex + 1\n        val smallestEvenValue\
    \ = smallestEvenValue * 2\n        val smallestEvenIndex = smallestEvenIndex +\
    \ 1\n        val smallestEvenValue = smallestEvenValue * 2\n        val smallestEvenIndex\
    \ = smallestEvenIndex + 1\n        val smallestEvenValue = smallestEvenValue *\
    \ 2\n        val smallestEvenIndex = smallestEvenIndex + 1\n        val smallestEvenValue\
    \ = smallestEvenValue * 2\n        val smallestEvenIndex = smallestEvenIndex +\
    \ 1\n        val smallestEvenValue = smallestEvenValue * 2\n        val smallestEvenIndex\
    \ = smallestEvenIndex + 1\n        val smallestEvenValue = smallestEvenValue *\
    \ 2\n        val smallestEvenIndex = smallestEvenIndex + 1\n        val smallestEvenValue\
    \ = smallestEven\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbossdlf3.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpbossdlf3.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m =\
    \ smallestEvenValue * \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpbossdlf3.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpbossdlf3.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m =\
    \ smallestEvenValue * \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpbossdlf3.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        "
  stdout: ''
  timestamp: 1660009965
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smallest =\
    \ evens.min\n        val index = evens.indexOf(smallest)\n        val result =\
    \ List(smallest, index)\n        if (arr.isEmpty) result\n        else result.sortBy(x\
    \ => x).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpr84tvxqm.scala:26:25\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mif\e[0m (arr.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                         ^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                         Found:    (result : List[AnyVal])\n\e[31m   |\e\
    [0m                         Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ Error: /tmp/tmpr84tvxqm.scala:27:34 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33melse\e[0m result.sortBy(x => x).reverse\n\
    \e[31m\e[31m   |\e[0m                                  ^\e[0m\n\e[31m   |\e[0mNo\
    \ implicit Ordering defined for AnyVal..\n\e[31m   |\e[0mI found:\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m    scala.math.Ordering.ordered[\e[35mAnyVal\e[0m](\n\e[31m\
    \   |\e[0m      /* missing */summon[scala.math.Ordering.AsComparable[AnyVal]]\n\
    \e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were\
    \ found that match type scala.math.Ordering.AsComparable[AnyVal].\n2 errors found\n"
  stdout: ''
  timestamp: 1660009968
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0).sorted\n        val smalest_value\
    \ = evens.head\n        val smalest_index = evens.indexOf(0)\n        val smalest_evens\
    \ = evens.takeWhile(x => x != smalest_value)\n        val smalest_evens_index\
    \ = evens.indexOf(smalest_value)\n        if (smalest_evens_index > smalest_index)\
    \ {\n            smalest_evens_index\n        } else {\n            smalest_index\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzkjeivpu.scala:28:12\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m            smalest_evens_index\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \         Found:    (smalest_evens_index : Int)\n\e[31m   |\e[0m            Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzkjeivpu.scala:30:12\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m            smalest_index\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \ Found:    (smalest_index : Int)\n\e[31m   |\e[0m            Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009968
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0).sortBy(x => x)\n      \
    \  if (evens.isEmpty) List()\n        else {\n            val smalest_value =\
    \ evens.head\n            val smalest_index = evens.indexOf(0)\n            val\
    \ index = evens.indexOf(smalest_value)\n            val smalest_even = evens(index)\n\
    \            val smalest_even_index = evens.indexOf(smalest_even)\n          \
    \  if (smalest_even_index == index) List(smalest_value, smalest_index)\n     \
    \       else List(smalest_value, smalest_index, smalest_even, smalest_even_index)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9rpc9y6c.scala:35)\n\tat Problem.main(tmp9rpc9y6c.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009971
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(_ % 2 == 0)\n        val even = evens.min\n\
    \        val index = evens.indexOf(even)\n        val smalest_value = evens.min\n\
    \        val smalest_index = evens.indexOf(smalest_value)\n        val smalest_even\
    \ = evens.filter(x => x == smalest_value).min\n        val smalest_even_index\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_value = evens.filter(x\
    \ => x == smalest_even).min\n        val smalest_even_index_value = evens.indexOf(smalest_even_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evens.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = even\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpibefn860.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = evens.indexOf(smalest_even_index_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpibefn860.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = evens.indexOf(smalest_even_index_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpibefn860.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = evens.indexOf(smalest_even_index_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpibefn860.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = evens.indexOf(smalest_even_index_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31"
  stdout: ''
  timestamp: 1660009968
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        if (evens.isEmpty)\
    \ List()\n        else evens.minBy(x => x)._2\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2ho6zjgj.scala:24:33 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33melse\e[0m evens.minBy(x => x)._2\n\e[31m\e\
    [31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \      value _2 is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1660009907
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_evens = evens.filter(x => x % 2 == 0)\n        val smalest_evens_index\
    \ = smalest_evens.indexOf(smalest_value)\n        if (smalest_evens_index == -1)\
    \ {\n            smalest_evens_index = evens.length\n        }\n        smalest_evens.take(smalest_evens_index).map(x\
    \ => x).mkString(\",\")\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmppkt273hi.scala:28:32 -----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            smalest_evens_index = evens.length\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m            Reassignment to val smalest_evens_index\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmppkt273hi.scala:30:68 --------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        smalest_evens.take(smalest_evens_index).map(\e\
    [36mx\e[0m => x).mkString(\e[31m\",\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    String\n\e[31m   |\e[0m        Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009968
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val evensSorted\
    \ = evens.sortWith((x, y) => x < y)\n        val smallestEven = evensSorted.head\n\
    \        val smallestEvenIndex = evensSorted.indexOf(0)\n        val smallestEvenValue\
    \ = smallestEven\n        val smallestEvenIndexList = List(smallestEvenIndex,\
    \ smallestEvenValue)\n        val smallestEvenIndexSorted = smallestEvenIndexList.sortWith((x,\
    \ y) => x < y)\n        val smallestEvenIndexValue = smallestEvenIndexSorted.head\n\
    \        val smallestEvenIndexIndex = smallestEvenIndexSorted.indexOf(0)\n   \
    \     val smallestEvenIndexValue = smallestEvenIndexSorted.head\n        val smallestEvenIndexValueList\
    \ = List(smallestEvenIndexValue, smallestEvenIndexIndex)\n        val smallestEvenIndexValueSorted\
    \ = smallestEvenIndexValueList.sortWith((x, y) => x < y)\n        val smallestEvenIndexValueValue\
    \ = smallestEvenIndexValueSorted.head\n        val smallestEvenIndexValueIndex\
    \ = smallestEvenIndexValueSorted.indexOf(0)\n        val smallestEvenIndexValueValue\
    \ = smallestEvenIndexValueSorted.head\n        val smallestEvenIndexValueValueList\
    \ = List(smallestEvenIndexValueValue, smallestEvenIndexValueIndex)\n        val\
    \ smallestEvenIndexValueValueSorted = smallestEvenIndexValueValueList.sortWith((x,\
    \ y) => x < y)\n        val smallestEvenIndexValueValueValue = smallestEvenIndexValueValueSorted.head\n\
    \        val smallestEvenIndexValueValueIndex = smallestEvenIndexValueValueSorted.indexOf(0)\n\
    \        val smallestEvenIndexValueValueValue = smallestEvenIndexValueValueSorted.head\n\
    \        val smallestEvenIndexValueValueValueList = List(smallestEvenIndexValueValueValue,\
    \ smallestEvenIndexValueValueIndex)\n        val smallestEvenIndexValueValueValueSorted\
    \ = smallestEvenIndexValueValueValueList.sortWith((x, y) => x < y)\n        val\
    \ smallestEvenIndexValueValueValueValue = smallestEvenIndexValueValueValueSorted.head\n\
    \        val smallestEvenIndexValueValueValueIndex = smallestEvenIndexValueValueValueSorted.indexOf(0)\n\
    \        val smallestEvenIndexValueValueValueValue = smallestEvenIndexValueValueValueSorted.head\n\
    \        val smallestEvenIndexValueValueValueValueList = List(smallestEvenIndexValueValueValueValue,\
    \ smallestEvenIndexValueValueValueIndex)\n        val smallestEvenIndexValueValueValueValueSorted\
    \ = smallestEvenIndexValue\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2s5d96gn.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndexValue\e\
    [0m = smallestEvenIndexSorted.head\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndexValue is already defined as \e[33mvalue\e\
    [0m \e[35msmallestEvenIndexValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2s5d96gn.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndexValueValue\e\
    [0m = smallestEvenIndexValueSorted.head\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndexValueValue is already defined as \e[33mvalue\e\
    [0m \e[35msmallestEvenIndexValueValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2s5d96gn.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndexValueValueValue\e\
    [0m = smallestEvenIndexValueValueSorted.head\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndexValueValueValue is already defined as \e\
    [33mvalue\e[0m \e[35msmallestEvenIndexValueValueValue\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2s5d96gn.scala:46:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmallestEvenIndexValueValueValueValue\e[0m = smallestEvenIndexValueValueValueSorted.head\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndexValueValueValueValue is already defined as\
    \ \e[33mvalue\e[0m \e[35m"
  stdout: ''
  timestamp: 1660009971
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smalest_value\
    \ = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n    \
    \    val smalest_even = evens(smalest_index)\n        val smalest_even_index =\
    \ evens.indexOf(smalest_even)\n        val smalest_even_value = evens(smalest_even_index)\n\
    \        val smalest_even_index_list = evens.indexOf(smalest_even)\n        val\
    \ smalest_even_index_list_index = evens.indexOf(smalest_even, smalest_even_index_list)\n\
    \        val smalest_even_index_list_value = evens.indexOf(smalest_even, smalest_even_index_list,\
    \ smalest_even_index_list_index)\n        val smalest_even_index_list_value_index\
    \ = evens.indexOf(smalest_even, smalest_even_index_list, smalest_even_index_list_index,\
    \ smalest_even_index_list_value) \n        val smalest_even_index_list_value_index_list\
    \ = evens.indexOf(smalest_even, smalest_even_index_list, smalest_even_index_list_index,\
    \ smalest_even_index_list_value, smalest_even_index_list_value_index)\n      \
    \  val smalest_even_index_list_value_index_list_index = evens.indexOf(smalest_even,\
    \ smalest_even_index_list, smalest_even_index_list_index, smalest_even_index_list_value,\
    \ smalest_even_index_list_value_index, smalest_even_index_list_value_index_list)\n\
    \        val smalest_even_index_list_value_index_list_value = evens.indexOf(smalest_even,\
    \ smalest_even_index_list, smalest_even_index_list_index, smalest_even_index_list_value,\
    \ smalest_even_index_list_value_index, smalest_even_index_list_value_index_list,\
    \ smalest_even_index_list_value_index_list_index)\n        val smalest_even_index_list_value_index_list_value_index\
    \ = evens.indexOf(smalest_even, smalest_even_index_list, smalest_even_index_list_index,\
    \ smalest_even_index_list_value, smalest_even_index_list_value_index, smalest_even_index_list_value_index_list,\
    \ smalest_even_index_list_value_index_list_index, smalest_even_index_list_value_index_list_value)\n\
    \        val smalest_even_index_list_value_index_list_value_index_list = evens.indexOf(smalest_even,\
    \ smalest_even_index_list, smalest_even_index_list_index, smalest_even_index_list_value,\
    \ smalest_even_index_list_value_index, smalest_even_index_list_value_index_list,\
    \ smalest_even_index_list_\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm8o1uwl0.scala:37:4 ----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpm8o1uwl0.scala:30:50\
    \ -----------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e\
    [0m \e[36msmalest_even_index_list_value\e[0m = evens.indexOf(smalest_even, smalest_even_index_list,\
    \ smalest_even_index_list_index)\n\e[31m\e[31m   |\e[0m                      \
    \                      ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35mindexOf\e[0m in \e[33mtrait\e[0m \e\
    [35mSeqOps\e[0m with types\n\e[31m   |\e[0m [B >: Long](elem: B): Int\n\e[31m\
    \   |\e[0m [B >: Long](elem: B, from: Int): Int\n\e[31m   |\e[0mmatch arguments\
    \ ((smalest_even : Long), (smalest_even_index_list : Int), (smalest_even_index_list_index\
    \ : Int))\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm8o1uwl0.scala:36:266\
    \ -----------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e\
    [36msmalest_even_index_list_value_index_list_value_index_list\e[0m = evens.indexOf(smalest_even,\
    \ smalest_even_index_list, smalest_even_index_list_index, smalest_even_index_list_value,\
    \ smalest_even_index_list_value_index, smalest_even_index_list_value_index_list,\
    \ smalest_even_index_list_\n\e[31m\e[31m   |\e[0m                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \                 Not found: smalest_even_index_list_\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpm8o1uwl0.scala:37:5 ---------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation"
  stdout: ''
  timestamp: 1660009970
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0).sortBy(x => x).reverse\n\
    \        val smalest_value = evens.head\n        val smalest_index = evens.indexOf(0)\n\
    \        val result = if (smalest_index > 0) smalest_value :: smalest_index ::\
    \ Nil else Nil\n        result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9ta4gutg.scala:26:8\
    \ ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[AnyVal])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009969
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(_ % 2 == 0)\n        val smalest_value =\
    \ evens.min\n        val smalest_index = evens.indexOfMin\n        val result\
    \ = arr.filter(_ == smalest_value).sortWith(_ < _)\n        if (result.isEmpty)\
    \ Nil\n        else List(smalest_value, smalest_index)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqk6qr3zh.scala:24:34 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36msmalest_index\e[0m = evens.indexOfMin\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue indexOfMin is not a member of List[Long] - did you mean evens.indexOf?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009970
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val evensSorted\
    \ = evens.sortWith((x, y) => x < y)\n        val smalest_value = evensSorted.head\n\
    \        val smalest_index = evensSorted.indexOf(0)\n        val index = evensSorted.indexOf(smalest_value)\n\
    \        val smalest_even = evensSorted.take(index)\n        val smalest_even_index\
    \ = evensSorted.indexOf(smalest_even)\n        val smalest_even_value = evensSorted.take(smalest_even_index)\n\
    \        val smalest_even_index_value = evensSorted.indexOf(smalest_even_value)\n\
    \        val smalest_even_index_value = evensSorted.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evensSorted.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evensSorted.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evensSorted.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evensSorted.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evensSorted.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evensSorted.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evensSorted.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evensSorted.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evensSorted.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evensSorted.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evensSorted.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evensSorted.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evensSorted.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evensSorted.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evensSorted.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evensSorted.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evensSorted.indexOf(smalest_even_index_value)\n\
    \        val smalest_even_index_value = evensSorted.indexOf(sm\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpok78o21p.scala:50:4 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpok78o21p.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_even_index_value\e[0m = evensSorted.indexOf(smalest_even_index_value)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpok78o21p.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = evensSorted.indexOf(smalest_even_index_value)\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpok78o21p.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = evensSorted.indexOf(smalest_even_index_value)\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpok78o21p.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_value\e\
    [0m = evensSorted.indexOf(smalest_even_index_va"
  stdout: ''
  timestamp: 1660009970
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val even = evens.min\n\
    \        val index = arr.indexOf(even)\n        val smalest_value = evens.find(x\
    \ => x % 2 == 0).get\n        val smalest_index = arr.indexOf(smalest_value)\n\
    \        val result: List[Long] = if (smalest_index == -1) List(smalest_value)\
    \ else List(smalest_value, smalest_index)\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsmonjgxr.scala:31)\n\tat Problem.main(tmpsmonjgxr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val smallest =\
    \ evens.min\n        val index = evens.indexOf(smallest)\n        val result:\
    \ List[Long] = if (index == -1) List(smallest) else List(smallest, index)\n  \
    \      result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk9xoyr2t.scala:30)\n\tat Problem.main(tmpk9xoyr2t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009972
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(_ % 2 == 0)\n        val smalest_value =\
    \ evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n      \
    \  val smalest_even = evens(smalest_index)\n        val smalest_even_index = arr.indexOf(smalest_even)\n\
    \        val smalest_even_value = arr(smalest_even_index)\n        val smalest_even_index_list\
    \ = List(smalest_even_index, smalest_even_index)\n        val smalest_even_index_set\
    \ = smalest_even_index_list.distinct\n        val smalest_even_index_list = smalest_even_index_list.filter(_\
    \ != smalest_even_index)\n        val smalest_even_index_list = smalest_even_index_list.sortWith(_\
    \ < _)\n        val smalest_even_index_list = smalest_even_index_list.take(1)\n\
    \        val smalest_even_index_list = smalest_even_index_list.distinct\n    \
    \    val smalest_even_index_list = smalest_even_index_list.filter(_ != smalest_even_index)\n\
    \        val smalest_even_index_list = smalest_even_index_list.sortWith(_ < _)\n\
    \        val smalest_even_index_list = smalest_even_index_list.take(1)\n     \
    \   val smalest_even_index_list = smalest_even_index_list.distinct\n        val\
    \ smalest_even_index_list = smalest_even_index_list.filter(_ != smalest_even_index)\n\
    \        val smalest_even_index_list = smalest_even_index_list.sortWith(_ < _)\n\
    \        val smalest_even_index_list = smalest_even_index_list.take(1)\n     \
    \   val smalest_even_index_list = smalest_even_index_list.distinct\n        val\
    \ smalest_even_index_list = smalest_even_index_list.filter(_ != smalest_even_index)\n\
    \        val smalest_even_index_list = smalest_even_index_list.sortWith(_ < _)\n\
    \        val smalest_even_index_list = smalest_even_index_list.take(1)\n     \
    \   val smalest_even_index_list = smalest_even_index_list.distinct\n        val\
    \ smalest_even_index_list = smalest_even_index_list.filter(_ != smalest_even_index)\n\
    \        val smalest_even_index_list = smalest_even_index_list.sortWith(_ < _)\n\
    \        val smalest_even_index_list = smalest_even_index_list.take(1)\n     \
    \   val smalest_even_index_list = smalest_even_index_list.distinct\n        val\
    \ smalest_even_index_list = smalest_even\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwqhewvb4.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list\e\
    [0m = smalest_even_index_list.filter(_ != smalest_even_index)\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwqhewvb4.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list\e\
    [0m = smalest_even_index_list.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwqhewvb4.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list\e\
    [0m = smalest_even_index_list.take(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msmalest_even_index_list is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index_list\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpwqhewvb4.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list\e[0m = smalest_even_index_list.distinct\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |"
  stdout: ''
  timestamp: 1660009971
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(_ % 2 == 0).sorted\n        val smalest_value\
    \ = evens.head\n        val smalest_index = evens.indexOf(0)\n        if (smalest_index\
    \ == -1) evens.toList else evens.take(smalest_index).toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsrrzy5l9.scala:28)\n\tat Problem.main(tmpsrrzy5l9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009972
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val even = arr.filter(x => x % 2 == 0).sortBy(x => x).take(1)\n\
    \        if (even.isEmpty) List()\n        else {\n            val smalest_value\
    \ = even.head\n            val smalest_index = even.indexWhere(x => x == smalest_value)\n\
    \            val smalest_value_and_index = smalest_value -> smalest_index\n  \
    \          val smalest_value_and_index_list = List(smalest_value_and_index)\n\
    \            val smalest_value_and_index_list_sorted = smalest_value_and_index_list.sortBy(_._1).reverse\n\
    \            val smalest_value_and_index_list_sorted_takeOne = smalest_value_and_index_list_sorted.take(1)\n\
    \            val smalest_value_and_index_list_sorted_takeOne_1 = smalest_value_and_index_list_sorted_takeOne._1\n\
    \            val smalest_value_and_index_list_sorted_takeOne_2 = smalest_value_and_index_list_sorted_takeOne._2\n\
    \            val smalest_value_and_index_list_sorted_takeOne_3 = smalest_value_and_index_list_sorted_takeOne._3\n\
    \            val smalest_value_and_index_list_sorted_takeOne_4 = smalest_value_and_index_list_sorted_takeOne._4\n\
    \            val smalest_value_and_index_list_sorted_takeOne_5 = smalest_value_and_index_list_sorted_takeOne._5\n\
    \            val smalest_value_and_index_list_sorted_takeOne_6 = smalest_value_and_index_list_sorted_takeOne._6\n\
    \            val smalest_value_and_index_list_sorted_takeOne_7 = smalest_value_and_index_list_sorted_takeOne._7\n\
    \            val smalest_value_and_index_list_sorted_takeOne_8 = smalest_value_and_index_list_sorted_takeOne._8\n\
    \            val smalest_value_and_index_list_sorted_takeOne_9 = smalest_value_and_index_list_sorted_takeOne._9\n\
    \            val smalest_value_and_index_list_sorted_takeOne_10 = smalest_value_and_index_list_sorted_takeOne._10\n\
    \            val smalest_value_and_index_list_sorted_takeOne_11 = smalest_value_and_index_list_sorted_takeOne._11\n\
    \            val smalest_value_and_index_list_sorted_takeOne_12 = smalest_value_and_index_list_sorted_takeOne._12\n\
    \            val smalest_value_and_index_list_sorted_takeOne_13 = smalest_value_and_index_list_sorted_takeOne._13\n\
    \            val smalest_value_and_index_list_sorted_takeOne_14 = smale\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9f9s9mvy.scala:58:0 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9f9s9mvy.scala:31:108\
    \ -----------------------\e[0m\e[0m\n\e[31m31 |\e[0m            \e[33mval\e[0m\
    \ \e[36msmalest_value_and_index_list_sorted_takeOne_1\e[0m = smalest_value_and_index_list_sorted_takeOne._1\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                           value _1 is not a member of List[(Long, Int)]\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp9f9s9mvy.scala:32:108 -----------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e[0m \e[36msmalest_value_and_index_list_sorted_takeOne_2\e\
    [0m = smalest_value_and_index_list_sorted_takeOne._2\n\e[31m\e[31m   |\e[0m  \
    \                                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           value _2 is not a member of List[(Long,\
    \ Int)]\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9f9s9mvy.scala:33:108\
    \ -----------------------\e[0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e[0m\
    \ \e[36msmalest_value_and_index_list_sorted_takeOne_3\e[0m = smalest_value_and_index_list_sorted_takeOne._3\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                           value _3 is not a member of List[(Long, Int)]\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp9f9s9mvy.scala:34:108 -----------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e[0m \e[36msmalest_value_and_index_list_sorted_takeOne_4\e\
    [0m = smalest_value_and_index_list_sorted_takeOne._4\n\e[31m\e[31m   |\e[0m  \
    \                                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           value _4 is not a member of List[(Long,\
    \ Int)]\n\e[31m\e[31m-- [E008] Not Found "
  stdout: ''
  timestamp: 1660009972
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n    // Example 3:\n    // Example 4:\n    // Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n    // so we will choose the first zero, which\
    \ has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <=\
    \ 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long]\
    \ = {\n        val evens = arr.filter(x => x % 2 == 0)\n        val evensSorted\
    \ = evens.sortWith((x, y) => x < y)\n        val smallestEven = evensSorted.head\n\
    \        val smallestEvenIndex = evensSorted.indexOf(0)\n        val smallestEvenValue\
    \ = smallestEven\n        val smallestEvenIndex = smallestEvenIndex\n        val\
    \ smallestEvenValue = smallestEvenValue\n        val evensSorted = evens.sortWith((x,\
    \ y) => x < y)\n        val smallestEven = evensSorted.head\n        val smallestEvenIndex\
    \ = evensSorted.indexOf(0)\n        val smallestEvenValue = smallestEven\n   \
    \     val smallestEvenIndex = smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEvenValue\n        val evensSorted = evens.sortWith((x, y) => x <\
    \ y)\n        val smallestEven = evensSorted.head\n        val smallestEvenIndex\
    \ = evensSorted.indexOf(0)\n        val smallestEvenValue = smallestEven\n   \
    \     val smallestEvenIndex = smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEvenValue\n        val evensSorted = evens.sortWith((x, y) => x <\
    \ y)\n        val smallestEven = evensSorted.head\n        val smallestEvenIndex\
    \ = evensSorted.indexOf(0)\n        val smallestEvenValue = smallestEven\n   \
    \     val smallestEvenIndex = smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEvenValue\n        val evensSorted = evens.sortWith((x, y) => x <\
    \ y)\n        val smallestEven = evensSorted.head\n        val smallestEvenIndex\
    \ = evensSorted.indexOf(0)\n        val smallestEvenValue = smallestEven\n   \
    \     val smallestEvenIndex = smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEvenValue\n        val evensSorted = evens.sortWith((x, y) => x <\
    \ y)\n        val smallestEven = evensSorted.head\n        val smallestEvenIndex\
    \ = evensSorted.indexOf(0)\n        val smallestEvenValue = smallestEven\n   \
    \     val smallestEvenIndex = smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEvenValue\n        val evensSorted = evens.sortWith((x, y) => x <\
    \ y)\n        val smallestEven = evensSorted.head\n        val smallestEvenIndex\
    \ = evensSorted.indexOf(0)\n        val smallestEvenValue = smallestEven\n   \
    \     val smallestEvenIndex = smallestEvenIndex\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7b33h7dj.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp7b33h7dj.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m =\
    \ smallestEvenValue\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp7b33h7dj.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evens.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => x < y)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp7b33h7dj.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36msmallestEven\e[0m = evensSorted.head\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msmallestEven is already defined as \e[33mvalue\e[0m \e[35msmallestEven\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp7b33h7dj.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m = evensSorted.indexOf(\e\
    [31m0"
  stdout: ''
  timestamp: 1660009863
