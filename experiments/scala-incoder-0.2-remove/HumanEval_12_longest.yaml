name: HumanEval_12_longest
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Out of list of strings, return the longest one. Return the first one in\
  \ case of multiple\n    // strings of the same length. Return None in case the input\
  \ list is empty.\n    def longest(strings : List[String]) : Option[String] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(longest((List[String]())).equals(None));\n\
  \    assert(longest((List[String](\"x\", \"y\", \"z\"))).equals(\"x\"));\n    assert(longest((List[String](\"\
  x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"))).equals(\"zzzz\"));\n    }\n\
  \n}\n"
completions: ["        strings.sortWith(_.length < _.length)\n        strings.lastOption",
  "        strings.foldLeft(Option[String]())((longest, current) => {\n          \
    \  val length = current.length\n            if (longest == None || length > longest.length)\n\
    \                Some(current)\n            else\n                None\n     \
    \   })", "        strings.foldLeft(Option.empty[String]){\n            case (Some(longest),\
    \ s) =>\n                val len = s.length\n                if (len > longest.length)\
    \ Some(s) else None\n            case _ => None\n        }", "        strings.foldLeft(Option(\"\
    \")) {\n            (acc, s) =>\n                if (acc.isEmpty || acc.length\
    \ < s.length) Some(s) else acc\n        }", "        if (strings.length == 0)\
    \ None\n        else {\n            val longest = strings.maxBy(_.length)\n  \
    \          if (longest.length == strings.length) Some(longest)\n            else\
    \ longest.headOption\n        }", "        if (strings.length == 0) None\n   \
    \     else {\n            val longest = strings.sortBy(_.length).last\n      \
    \      if (longest.length == strings.length) Some(longest)\n            else longest.headOption\n\
    \        }", "        strings.foldLeft(List[String]()){ (list, str) =>\n     \
    \       val len = str.length\n            if (list.exists(_.length == len)) {\n\
    \                list.find(_.length == len)\n            } else {\n          \
    \      list :+ str\n            }\n        }.maxBy(_.length)", "        strings.sortWith(_\
    \ < _)\n            .lastOption\n            .filter(_ == strings.last)\n    \
    \        .map(_ => strings.last)", "        if (strings.length == 0) None\n  \
    \      else {\n            val longest = strings.foldLeft(\"\")( (acc, s) => if\
    \ (acc.length < s.length) acc else s)\n            longest.length match {\n  \
    \              case 1 => Some(longest)\n                case _ => longest\n  \
    \          }\n        }", "        strings.foldLeft(List[String]())((acc, s) =>\
    \ if (acc.length < s.length) acc else s :: acc)\n            .maxBy(_.length)",
  "        strings.foldLeft(List[String]()){\n            (acc, s) => if (acc.length\
    \ < s.length) acc :+ s else acc\n        }.maxBy(_.length)", "        strings.foldLeft(List[String]())((list,\
    \ string) => {\n            if (list.length < string.length) list :+ string\n\
    \            else list\n        })\n            .sortWith((a, b) => a.length <=>\
    \ b.length)\n            .lastOption", '        strings.sortWith(_ < _).lastOption',
  "        strings.foldLeft(List[String]()){\n            case (acc, s) => if (acc.length\
    \ < s.length) acc :+ s else acc\n        }.maxBy(_.length)", "        strings.foldLeft(List[String]())((acc,\
    \ s) => if (acc.length < s.length) acc else s :: acc)\n            .maxBy(_.length)",
  "        strings.foldLeft(List[String]())((acc, s) => acc match {\n            case\
    \ Nil => Some(s)\n            case x :: xs => if (x.length > s.length) Some(s)\
    \ else x\n        })", "        strings.foldLeft(List[String]())((acc, s) => acc\
    \ match {\n            case Nil => List(s)\n            case x :: xs => if (x.length\
    \ > s.length) x :: xs else x\n        })", '        strings.sortWith(_ < _).lastOption',
  "        strings.sortWith(_ < _)\n            .takeWhile(_ != strings.last)\n  \
    \          .lastOption", '        strings.sortWith(_ < _).lastOption', "     \
    \   strings.foldLeft(List[String]())((acc, s) => if (acc.length < s.length) acc\
    \ else s :: acc)\n            .maxBy(_.length)", "        strings.foldLeft(List[String]())((list,\
    \ s) => {\n            val len = s.length\n            if (len > list.last.length)\
    \ list :+ s\n            else list\n        })\n            .sortWith((a, b) =>\
    \ a.length <= b.length)\n            .headOption", "        if (strings.isEmpty)\
    \ None\n        else {\n            val longest = strings.foldLeft(\"\")( (a,b)\
    \ => if (a.length < b.length) a else b )\n            strings.find(s => s == longest)\
    \ match {\n                case Some(longest) => Some(longest)\n             \
    \   case None => None\n            }\n        }", "        strings.foldLeft(List[String]())((list,\
    \ string) => {\n            val length = string.length\n            if (list.contains(string)\
    \ && list.last.length == length) list.last\n            else list :+ string\n\
    \        })", "        strings.foldLeft(List[String]())((acc, s) => acc match\
    \ {\n            case Nil => Some(s)\n            case x :: xs => if (x.length\
    \ > s.length) Some(s) else x\n        })", "        if (strings.isEmpty) None\n\
    \        else {\n            val longest = strings.maxBy(_.length)\n         \
    \   strings.find(_.length == longest.length) match {\n                case Some(longest)\
    \ => Some(longest)\n                case None => None\n            }\n       \
    \ }", "        strings.foldLeft(None)( (maxLength, string) => {\n            val\
    \ length = string.length\n            if(maxLength.isEmpty || length > maxLength.get.length)\n\
    \                Some(string)\n            else\n                None\n      \
    \  })", "        strings.foldLeft(None)( (maxLength, string) => {\n          \
    \  val length = string.length\n            if (length > maxLength.getOrElse(length))\
    \ {\n                Some(string)\n            } else {\n                None\n\
    \            }\n        })", '        strings.foldLeft(List[String]())((list,
    s) => if (list.size < s.length) list :+ s else None)', "        strings.foldLeft(List[String]()){\
    \ (list, str) =>\n            if (list.length < str.length) list :+ str\n    \
    \        else str\n        }.maxBy(_.length)", "        strings.sortWith(_ < _)\n\
    \        strings.headOption", '        strings.foldLeft(List[String]())( (acc,
    s) => if (acc.length < s.length) acc else Some(s) )', "        strings.foldLeft(List[String]())((acc,\
    \ s) => {\n            if (acc.length < s.length) acc :+ s\n            else Some(acc)\n\
    \        })", "        strings.foldLeft(Option.empty[String])((longest, current)\
    \ => {\n            val length = current.length\n            if (longest == None\
    \ || length > longest.length)\n                Some(current)\n            else\n\
    \                None\n        })", '        strings.foldLeft(List[String]())((acc,
    s) => if (acc.length < s.length) acc else Some(s))', "        strings.foldLeft(Option(\"\
    \"))((max, str) => max match {\n            case Some(maxStr) if maxStr.length\
    \ < str.length => Some(maxStr)\n            case Some(maxStr) => maxStr\n    \
    \        case None => str\n        })", "        if (strings.isEmpty) None\n \
    \       else {\n            val longest = strings.maxBy(_.length)\n          \
    \  if (longest.length == strings.length) Some(longest)\n            else longest.headOption\n\
    \        }", '        strings.foldLeft(List[String]())((acc, s) => if (acc.length
    < s.length) acc else Some(s))', "        strings.foldLeft(List[String]()){\n \
    \           (acc, str) =>\n                val len = str.length\n            \
    \    if (acc.length < len) {\n                    acc :+ str\n               \
    \ } else if (acc.length == len) {\n                    acc :+ acc.last\n     \
    \           } else {\n                    None\n                }\n        }.maxBy(_.length)",
  "        strings.foldLeft(List[String]())((list, str) => {\n            val length\
    \ = str.length\n            if (list.contains(length)) {\n                list.find(_.length\
    \ == length).getOrElse(str)\n            } else {\n                list :+ str\n\
    \            }\n        })", "        strings.foldLeft(List[String]())((acc, s)\
    \ => acc match {\n            case Nil => Some(s)\n            case _ => if (acc.length\
    \ < s.length) Some(s) else acc\n        })", "        strings.foldLeft(None)(\
    \ (longest, s) => {\n            if (longest.isEmpty) Some(s) else longest.map(x\
    \ => if (x.length > s.length) x else s)\n        })", "        strings.length\
    \ match {\n            case 0 => None\n            case 1 => Some(strings.head)\n\
    \            case _ => {\n                val longest = strings.foldLeft(\"\"\
    )( (acc, s) => {\n                    if (acc.length < s.length) acc else s\n\
    \                })\n                Some(longest)\n            }\n        }",
  "        strings.foldLeft(List[String]())((acc, s) => if (acc.length < s.length)\
    \ acc else s :: acc)\n            .maxBy(_.length)", "        strings.foldLeft(List[String]())(\n\
    \            list => list.foldLeft(List[String]())(\n                list => list.foldLeft(List[String]())(\n\
    \                    list => list.foldLeft(List[String]())(\n                \
    \        list => list.foldLeft(List[String]())(\n                            list\
    \ => list.foldLeft(List[String]())(\n                                list => list.foldLeft(List[String]())(\n\
    \                                    list => list.foldLeft(List[String]())(\n\
    \                                        list => list.foldLeft(List[String]())(\n\
    \                                            list => list.foldLeft(List[String]())(\n\
    \                                                list => list.foldLeft(List[String]())(\n\
    \                                                    list => list.foldLeft(List[String]())(\n\
    \                                                        list => list.foldLeft(List[String]())(\n\
    \                                                            list => list.foldLeft(List[String]())(\n\
    \                                                                list => list.foldLeft(List[String]())(\n\
    \                                                                    list => list.foldLeft(List[String]())(\n\
    \                                                                        list\
    \ => list.foldLeft(List[String]())(\n                                        \
    \                                    list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \    list => list.foldLeft(List[String]())(\n                                \
    \                                                    list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \            list => list.foldLeft(List[String]())(\n                        \
    \                                                                    list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                    list => list.foldLeft(List[String]())(\n                \
    \                                                                            \
    \        list => list.foldLeft(List[String]())(\n                            \
    \                                                                            list\
    \ => list.foldLeft(List[String]())(\n                                        \
    \                                                                    list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                    list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                        list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                            list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                                list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                                    list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                                        list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                                            list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                                                list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                                                    list => list.foldLeft(List[String]())(\n",
  "        strings.foldLeft(List[String]())((acc, s) => if (acc.length < s.length)\
    \ acc else s :: acc)\n            .maxBy(_.length)", "        if (strings.length\
    \ == 0) None\n        else {\n            val longest = strings.maxBy(_.length)\n\
    \            if (longest.length == strings.length) Some(longest)\n           \
    \ else longest.headOption\n        }", "        strings.foldLeft(Option.empty[String]){\n\
    \            case (Some(longest), s) =>\n                val newLongest = if (longest.length\
    \ < s.length) s else longest\n                Some(newLongest)\n            case\
    \ _ => None\n        }", "        if (strings.length == 0) None\n        else\
    \ {\n            val longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length\
    \ < s.length) acc else s)\n            strings.find(s => s == longest) match {\n\
    \                case Some(longest) => Some(longest)\n                case None\
    \ => None\n            }\n        }", "        strings.foldLeft(List[String]())((list,\
    \ str) => {\n            if (list.length < str.length) list :+ str\n         \
    \   else str\n        })", '        strings.sortWith(_ < _).lastOption', "   \
    \     strings.foldLeft(List[String]())( (acc, s) => if (acc.length < s.length)\
    \ acc else s :: acc)\n            .maxBy(_.length)", '        strings.sortWith(_
    < _).lastOption', '        strings.sortWith(_ < _).lastOption', "        strings.length\
    \ match {\n            case 0 => None\n            case 1 => Some(strings.head)\n\
    \            case _ => {\n                val longest = strings.sortWith(_ < _).last\n\
    \                Some(longest)\n            }\n        }", "        strings.foldLeft(List[String]())((acc,\
    \ s) => if (acc.length < s.length) acc else s :: acc)\n            .maxBy(_.length)",
  '        strings.foldLeft(None)( (maxLength, string) => maxLength.map(_ max string).getOrElse(string)
    )', "        strings.foldLeft(List[String]())((acc, s) => acc match {\n      \
    \      case Nil => Some(s)\n            case _ => if (acc.length < s.length) Some(s)\
    \ else acc\n        })", "        if (strings.length == 0) None\n        else\
    \ {\n            val longest = strings.sortBy(_.length).last\n            if (longest.length\
    \ == strings.length) Some(longest)\n            else longest.headOption\n    \
    \    }", "        strings.foldLeft(List[String]()){\n            case (acc, s)\
    \ => if (acc.length < s.length) acc :+ s else acc\n        }.maxBy(_.length)",
  "        strings.foldLeft(List[String]()){\n            case (acc, str) => if (acc.length\
    \ < str.length) acc :+ str else acc\n        }.maxBy(_.length)", "        strings.foldLeft(List[String]())((list,\
    \ str) => {\n            if (list.size < str.length) list :+ str\n           \
    \ else str\n        })", "        strings.sortWith(_.length < _.length)\n    \
    \        .headOption", "        strings.foldLeft(List[String]())((acc, s) => if\
    \ (acc.length < s.length) acc else s :: acc)\n            .maxBy(_.length)", " \
    \       strings.sortWith(_ < _)\n            .takeWhile(_ != \"\").maxBy(_.length)",
  "        if (strings.length == 0) None\n        else {\n            val longest\
    \ = strings.sortWith(_ < _).last\n            strings.find(_.length == longest.length)\n\
    \        }", "        strings.foldLeft(List[String]()){\n            case (acc,\
    \ s) => if (acc.length < s.length) acc :+ s else acc\n        }.maxBy(_.length)",
  "        if (strings.isEmpty) None\n        else {\n            val longest = strings.foldLeft(\"\
    \")( (a,b) => if (a.length < b.length) a else b )\n            strings.find(s\
    \ => s == longest) match {\n                case Some(s) => Some(s)\n        \
    \        case None => None\n            }\n        }", '        strings.sortWith(_
    < _).lastOption', '        strings.foldLeft(List[String]())((acc, s) => if (acc.length
    < s.length) acc else Some(s))', "        strings.foldLeft(Option.empty[String]){\
    \ (max, str) =>\n            val len = str.length\n            if(len > max.map(_.length).getOrElse(len))\
    \ {\n                Some(str)\n            } else {\n                max\n  \
    \          }\n        }", "        strings.foldLeft(List[String]())((list, str)\
    \ => {\n            if (list.length >= str.length) list :+ str\n            else\
    \ list\n        })\n            .sortWith((s1, s2) => s1.length < s2.length)\n\
    \            .headOption", "        if (strings.length == 0) None\n        else\
    \ {\n            val longest = strings.foldLeft(\"\")( (a,b) => if (a.length <\
    \ b.length) a else b )\n            strings.find( s => s == longest ).getOrElse(longest)\n\
    \        }", "        strings.foldLeft(List[String]()){\n            case (acc,\
    \ s) => if (acc.length < s.length) acc :+ s else acc\n        }.maxBy(_.length)",
  "        if (strings.isEmpty) None\n        else {\n            val longest = strings.maxBy(_.length)\n\
    \            val sameLength = strings.filter(_.length == longest.length).headOption\n\
    \            if (sameLength.isDefined) sameLength.get\n            else longest\n\
    \        }", "        if (strings.isEmpty) None\n        else strings.foldLeft(\"\
    \")( (acc, s) => if (acc.length < s.length) acc else s)", "        strings.sortWith(_\
    \ < _)\n        strings.headOption", '        strings.sortWith(_ < _).lastOption',
  "        strings.sortWith(_ < _)\n            .takeWhile(_ != \"\")\n          \
    \  .foldLeft(\"\")( (acc, s) => if (acc.length < s.length) acc else s)", "   \
    \     strings.foldLeft(List[String]())((acc, s) => {\n            if (acc.length\
    \ < s.length) acc :+ s\n            else Some(acc)\n        })", '        strings.sortWith(_
    < _).lastOption', "        strings.foldLeft(Option.empty[String])((max, current)\
    \ => {\n            val length = current.length\n            if (max contains\
    \ length) max else Some(current)\n        })", "        if (strings.isEmpty) None\n\
    \        else {\n            val longest = strings.foldLeft(\"\")( (acc, s) =>\
    \ if (acc.length < s.length) acc else s)\n            longest.length match {\n\
    \                case 1 => Some(longest)\n                case _ => longest.headOption\n\
    \            }\n        }", "        if (strings.length == 0) None\n        else\
    \ {\n            val longest = strings.sortWith(_ < _).last\n            val first\
    \ = strings.sortWith(_ < _).head\n            if (longest.length == first.length)\
    \ Some(longest)\n            else longest.headOption\n        }", '        strings.foldLeft(List[String]())((acc,
    s) => if (acc.length < s.length) acc else Some(s))', "        strings.foldLeft(List[String]())((list,\
    \ str) => {\n            if (list.isEmpty || list.length < str.length) list :+\
    \ str\n            else list\n        })\n            .maxBy(_.length)", "   \
    \     strings.foldLeft(List[String]()){\n            case (acc, s) => if (acc.length\
    \ < s.length) acc :+ s else acc\n        }.maxBy(_.length)", "        if (strings.isEmpty)\
    \ None\n        else {\n            val longest = strings.maxBy(_.length)\n  \
    \          if (longest.length == strings.length) Some(longest)\n            else\
    \ longest.headOption\n        }", "        strings.sortWith(_ < _)\n        strings.headOption",
  '        strings.foldLeft(List[String]())( (acc, s) => if (acc.length < s.length)
    acc else Some(s) )', "        strings.foldLeft(None)( (longest, string) => {\n\
    \            val length = string.length\n            if (longest == None || length\
    \ > longest.get.length)\n                Some(string)\n            else\n    \
    \            longest\n        })", "        strings.foldLeft(None)( (longest,\
    \ string) => {\n            if (longest.isEmpty || string.length < longest.length)\
    \ Some(string)\n            else longest\n        })", "        strings.foldLeft(List[String]())((list,\
    \ str) => {\n            if (list.length >= str.length) list :+ str\n        \
    \    else list\n        })\n            .sortWith(_ < _)\n            .lastOption",
  "        strings.foldLeft(List[String]()){\n            case (acc, s) => if (acc.length\
    \ < s.length) acc :+ s else acc\n        }.maxBy(_.length)", "        strings.foldLeft(List[String]()){\n\
    \            case (acc, s) => acc match {\n                case Nil => List(s)\n\
    \                case _ => if (acc.length < s.length) acc else List(s)\n     \
    \       }\n        }.maxBy(_.length)", "        strings.foldLeft(List[String]())((list,\
    \ string) => {\n            val length = string.length\n            if (list.contains(length))\
    \ {\n                list.find(_.length == length).get\n            } else {\n\
    \                list :+ string\n            }\n        })", "        strings.foldLeft(List[String]())(\
    \ (acc, s) => if (acc.length < s.length) acc :+ s else acc )\n            .maxBy(_.length)",
  "        strings.foldLeft(List[String]())((list, str) => {\n            if (list.length\
    \ < str.length) list :+ str\n            else list\n        })\n            .maxBy(_.length)",
  '        strings.sortWith(_ < _).lastOption', "        strings.sortWith(_ < _)\n\
    \            .lastOption\n            .orElse(None)", "        strings.sortWith(_\
    \ < _)\n        strings.headOption", "        strings.foldLeft(List[String]())(\
    \ (acc, s) => acc match {\n            case Nil => Some(s)\n            case x\
    \ :: xs => if (x.length > s.length) Some(s) else x\n        })", "        strings.length\
    \ match {\n            case 0 => None\n            case 1 => Some(strings.head)\n\
    \            case _ => {\n                val longest = strings.foldLeft(\"\"\
    )( (acc, s) => if (acc.length < s.length) acc else s)\n                Some(longest)\n\
    \            }\n        }", "        strings.foldLeft(None)( (longest, string)\
    \ => {\n            if (longest.isEmpty || string.length == longest.length) Some(string)\n\
    \            else longest\n        })", "        strings.foldLeft(None) {\n  \
    \          case (Some(longest), s) => if (longest.length < s.length) Some(s) else\
    \ longest\n            case _ => None\n        }", "        strings.foldLeft(Option.empty[String]){\n\
    \            case (Some(longest), s) => if (longest.length < s.length) Some(s)\
    \ else longest\n            case (None, _) => None\n        }", "        strings.foldLeft(Option.empty[String])\
    \ { (longest, s) =>\n            if (longest.isEmpty || s.length >= longest.length)\
    \ Some(s) else longest\n        }", "        strings.foldLeft(List[String]()){\n\
    \            case (acc, s) => if (acc.length < s.length) acc :+ s else acc\n \
    \       }.maxBy(_.length)", "        strings.sortWith(_.length < _.length)\n \
    \           .headOption", "        strings.foldLeft(List[String]())((list, s)\
    \ => {\n            if (list.length < s.length) list :+ s\n            else list\n\
    \        })\n            .maxBy(_.length)", "        strings.foldLeft(Option(\"\
    \"))((longest, current) => {\n            if (longest.length < current.length)\
    \ Some(current) else None\n        })", "        strings.foldLeft(Option.empty[String]){\n\
    \            case (Some(longest), s) =>\n                if (longest.length <\
    \ s.length) Some(s) else longest\n            case (None , s) => Some(s)\n   \
    \     }", "        strings.foldLeft(None)( (acc, s) => acc match {\n         \
    \   case None => Some(s)\n            case Some(acc) => if (acc.length < s.length)\
    \ Some(s) else acc\n        })", "        if (strings.isEmpty) None\n        else\
    \ {\n            val longest = strings.foldLeft(\"\")( (longest, s) => if (longest.length\
    \ < s.length) longest else s)\n            Some(longest)\n        }", "      \
    \  strings.foldLeft(Option.empty[String]){\n            case (Some(longest), s)\
    \ => if (longest.length < s.length) Some(s) else longest\n            case _ =>\
    \ None\n        }", '        strings.sortWith(_ < _).lastOption', "        strings.sortWith(_\
    \ < _)\n            .reverse\n            .takeWhile(_ != \"\")\n            .maxBy(_.length)",
  '        strings.foldLeft(None)( (longest, string) => if (longest.isEmpty || string.length
    == longest.length) Some(string) else None)', '        strings.foldLeft(List[String]())((acc,
    s) => if (acc.length < s.length) acc else Some(s))', "        strings.foldLeft(List[String]())((list,\
    \ str) => {\n            if (list.length == 0 || list.length == str.length) {\n\
    \                list :+ str\n            } else {\n                list\n   \
    \         }\n        })", "        strings.foldLeft(List[String]()){\n       \
    \     case (acc, s) => if (acc.length < s.length) acc :+ s else acc\n        }.maxBy(_.length)",
  "        strings.foldLeft(List[String]())( (acc, s) => {\n            val l = acc.length\n\
    \            if (l > s.length) Some(s) else acc\n        })", "        strings.foldLeft(List[String]())((acc,\
    \ s) => {\n            if (acc.length < s.length) acc :+ s\n            else acc\n\
    \        })\n            .maxBy(_.length)", "        strings.foldLeft(List[String]()){\n\
    \            (acc, s) => if (acc.length < s.length) acc else Some(s)\n       \
    \ }.maxBy(_.length)", "        if (strings.isEmpty) None\n        else {\n   \
    \         val longest = strings.maxBy(_.length)\n            if (longest.length\
    \ == strings.length) Some(longest)\n            else longest.headOption\n    \
    \    }", "        strings.foldLeft(List[String]())((acc, s) => if (acc.length\
    \ < s.length) acc else s :: acc)\n            .maxBy(_.length)", "        strings.length\
    \ match {\n            case 0 => None\n            case 1 => Some(strings.head)\n\
    \            case _ => {\n                val longest = strings.foldLeft(\"\"\
    )( (acc, s) => {\n                    if (acc.length < s.length) acc else s\n\
    \                })\n                Some(longest)\n            }\n        }",
  "        strings.length match {\n            case 0 => None\n            case 1\
    \ => Some(strings.head)\n            case _ => {\n                val longest\
    \ = strings.foldLeft(\"\")(_ + _.length).length\n                strings.find(_.length\
    \ == longest).map(_.length)\n            }\n        }", "        strings.foldLeft(List[String]()){\n\
    \            case (acc, s) => if (acc.length < s.length) acc :+ s else acc\n \
    \       }.maxBy(_.length)", "        if (strings.length == 0) None\n        else\
    \ {\n            val longest = strings.maxBy(_.length)\n            if (longest.length\
    \ == strings.length) Some(longest)\n            else longest.headOption\n    \
    \    }", "        strings.foldLeft(List[String]())(\n            (acc, s) => if\
    \ (acc.length < s.length) acc else List(s)\n        ).maxBy(_.length)", "    \
    \    strings.foldLeft(Option.empty[String]){\n            case (Some(longest),\
    \ s) => if (longest.length < s.length) Some(s) else longest\n            case\
    \ (Some(longest), None) => longest\n            case (None, _) => None\n     \
    \   }", "        strings.sortWith(_ < _)\n            .takeWhile(_ != strings(0))\n\
    \            .lastOption", "        strings.foldLeft(List.empty[String]){ (acc,\
    \ s) =>\n            val len = s.length\n            if (acc.length < len) {\n\
    \                acc :+ s\n            } else if (acc.length == len) {\n     \
    \           acc :+ acc.last\n            } else {\n                None\n    \
    \        }\n        }.maxBy(_.length)", '        strings.sortBy(_.length).lastOption',
  "        strings.sortWith(_.length < _.length)\n        strings.lastOption", " \
    \       if (strings.length == 0) None\n        else {\n            val longest\
    \ = strings.foldLeft(\"\")( (a,b) => if (a.length < b.length) a else b )\n   \
    \         longest.length == strings.length ? Some(longest) : longest.headOption\n\
    \        }", "        strings.foldLeft(List[String]())((list, string) => {\n \
    \           if (list.length < string.length) list :+ string\n            else\
    \ list\n        })\n            .sortWith((a, b) => a.length <= b.length)\n  \
    \          .lastOption", "        strings.foldLeft(List[String]()){\n        \
    \    (acc, s) =>\n                if (acc.length < s.length) acc :+ s\n      \
    \          else acc\n        }.maxBy(_.length)", "        strings.foldLeft(List[String]())((list,\
    \ s) => {\n            if (list.length >= s.length) list :+ s\n            else\
    \ list\n        })\n            .sortWith(_ < _)\n            .lastOption", " \
    \       strings.length match {\n            case 0 => None\n            case 1\
    \ => Some(strings.head)\n            case _ => {\n                val longest\
    \ = strings.foldLeft(List[String]())((acc, s) => {\n                    if (acc.length\
    \ < s.length) acc :+ s\n                    else acc\n                })\n   \
    \             longest.maxBy(s.length)\n            }\n        }", '        strings.foldLeft(List[String]())(
    (acc, s) => if (acc.length < s.length) acc else Some(s) )', "        strings.foldLeft(List[String]())((list,\
    \ string) => {\n            val length = string.length\n            if (list.contains(string)\
    \ && list.length == length) list else list :+ string\n        })", "        strings.foldLeft(List[String]()){\n\
    \            case (acc, s) => if (acc.length < s.length) acc :+ s else acc\n \
    \       }.maxBy(_.length)", "        strings.foldLeft(List[String]()){\n     \
    \       case (acc, s) => if (acc.length < s.length) acc :+ s else acc\n      \
    \  }.maxBy(_.length)", "        strings.foldLeft(List[String]())((acc, s) => if\
    \ (acc.length < s.length) acc else s :: acc)\n            .maxBy(_.length)", " \
    \       strings.foldLeft(List[String]())((acc, s) => {\n            if (acc.length\
    \ < s.length) acc :+ s\n            else Some(acc)\n        })", "        strings.foldLeft(List[String]())((list,\
    \ string) => {\n            val length = string.length\n            if (length\
    \ < list.last.length) list :+ string\n            else list\n        })\n    \
    \        .sortWith((a, b) => a.length <= b.length)\n            .lastOption",
  "        strings.length match {\n            case 0 => None\n            case _\
    \ => {\n                val longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length\
    \ < s.length) acc else s)\n                Some(longest)\n            }\n    \
    \    }", "        strings.foldLeft(Option.empty[String]){\n            case (Some(longest),\
    \ s) =>\n                val len = s.length\n                if (len > longest.length)\n\
    \                    Some(s)\n                else\n                    None\n\
    \        }", "        strings.length match {\n            case 0 => None\n   \
    \         case 1 => Some(strings.head)\n            case _ => {\n            \
    \    val longest = strings.foldLeft(\"\")(_ + _.length).max\n                strings.find(_.length\
    \ == longest).map(_.head)\n            }\n        }", "        strings.sortWith(_\
    \ < _)\n            .takeWhile(_ != \"\").maxBy(_.length)", '        strings.foldLeft(List[String]())((list,
    str) => if (list.length >= str.length) list else str :: list)', "        strings.foldLeft(List[String]())((acc,\
    \ s) => if (acc.length < s.length) acc else s :: acc)\n            .maxBy(_.length)",
  "        if (strings.length == 0) None\n        else {\n            val longest\
    \ = strings.foldLeft(\"\")( (a,b) => if (a.length < b.length) a else b )\n   \
    \         strings.find(s => s == longest).getOrElse(longest)\n        }", "  \
    \      strings.foldLeft(List[String]())((acc, s) => if (acc.length < s.length)\
    \ acc else s :: acc)\n            .maxBy(_.length)", "        strings.foldLeft(List[String]()){\n\
    \            case (acc, s) => if (acc.length < s.length) acc :+ s else acc\n \
    \       }.maxBy(_.length)", "        strings.foldLeft(List[String]())((acc, s)\
    \ => if (acc.length < s.length) acc else s :: acc)\n            .maxBy(s => s.length)",
  "        strings.foldLeft(List[String]())((acc, s) => acc match {\n            case\
    \ Nil => Some(s)\n            case _ => if (acc.length < s.length) Some(s) else\
    \ acc\n        })", '        strings.foldLeft(List[String]())( (acc, s) => if
    (acc.length < s.length) acc else Some(s) )', '        strings.sortBy(_.length).lastOption',
  "        strings.foldLeft(Option.empty[String]){\n            case (Some(longest),\
    \ s) =>\n                val len = s.length\n                if (len > longest.length)\
    \ Some(s) else None\n            case _ => None\n        }", "        if (strings.length\
    \ == 0) None\n        else {\n            val longest = strings.foldLeft(\"\"\
    )( (acc, s) => if (acc.length < s.length) acc else s)\n            longest.length\
    \ match {\n                case 1 => Some(longest)\n                case _ =>\
    \ longest\n            }\n        }", "        if (strings.length == 0) None\n\
    \        else {\n            val longest = strings.foldLeft(\"\")( (a,b) => if\
    \ (a.length < b.length) a else b )\n            strings.find( s => s == longest).getOrElse(longest)\n\
    \        }", "        strings.foldLeft(List[String]())((list, str) => {\n    \
    \        if (list.length < str.length) list :+ str\n            else list\n  \
    \      })\n            .sortWith((a, b) => a.length <=> b.length)\n          \
    \  .lastOption", "        strings.foldLeft(Option.empty[String])((max, str) =>\
    \ {\n            val len = str.length\n            if (len > max.getOrElse(len))\
    \ {\n                Some(str)\n            } else {\n                None\n \
    \           }\n        })", "        if (strings.length == 0) None\n        else\
    \ strings.sortWith(_ < _).lastOption", "        strings.foldLeft(List[String]())((list,\
    \ s) => {\n            if (list.length == 0) list :+ s\n            else {\n \
    \               if (s.length == list(0)) list :+ s\n                else {\n \
    \                   if (s.length < list(0)) list :+ s\n                    else\
    \ list\n                }\n            }\n        })", "        strings.sortWith(_\
    \ < _)\n            .takeWhile(_ != \"\").maxBy(_.length)", "        if (strings.isEmpty)\
    \ None\n        else {\n            val longest = strings.foldLeft(\"\")( (a,b)\
    \ => if (a.length < b.length) a else b )\n            strings.find(s => s == longest)\
    \ match {\n                case Some(longest) => Some(longest)\n             \
    \   case None => None\n            }\n        }", "        strings.foldLeft(Option.empty[String]){\n\
    \            case (Some(longest), s) => if (s.length() > longest.length) Some(s)\
    \ else longest\n            case _ => None\n        }", "        strings.foldLeft(List[String]())((list,\
    \ str) => {\n            if (list.length >= str.length) list :+ str\n        \
    \    else list\n        })\n            .maxBy(_.length)", "        strings.sortWith(_\
    \ < _)\n            .lastOption\n            .map(_ => strings.head)", "     \
    \   strings.foldLeft(Option(\"\")) { (longest, s) =>\n            val length =\
    \ s.length\n            if (length > longest.get || length == 0)\n           \
    \     Some(s)\n            else\n                longest\n        }", "      \
    \  if (strings.isEmpty) None\n        else {\n            val longest = strings.foldLeft(\"\
    \")( (acc, s) => if (acc.length < s.length) acc else s)\n            longest.length\
    \ == strings.length match {\n                case true => Some(longest)\n    \
    \            case false => None\n            }\n        }", "        strings.foldLeft(List[String]()){\n\
    \            case (acc, s) => if (acc.length < s.length) acc :+ s else acc\n \
    \       }.maxBy(_.length)", "        strings.length match {\n            case\
    \ 0 => None\n            case _ => {\n                val longest = strings.foldLeft(\"\
    \")( (a,b) => a.length >= b.length ? a : b )\n                strings.find(s =>\
    \ s == longest) match {\n                    case Some(s) => Some(s)\n       \
    \             case None => None\n                }\n            }\n        }",
  '        strings.sortBy(_.length).lastOption', '        strings.sortBy(_.length).lastOption',
  "        strings.length match {\n            case 0 => None\n            case 1\
    \ => Some(strings.head)\n            case _ => {\n                val longest\
    \ = strings.foldLeft(\"\")( (longest, s) => {\n                    if (s.length()\
    \ > longest.length) s else longest\n                })\n                Some(longest)\n\
    \            }\n        }", "        strings.foldLeft(List[String]())( (acc, s)\
    \ => if (acc.length < s.length) acc :+ s else acc )\n            .maxBy(_.length)",
  "        strings.foldLeft(None)( (longest, current) => {\n            val length\
    \ = current.length\n            if (length > longest.length) Some(current) else\
    \ None\n        })", '        strings.foldLeft(List[String]())( (acc, s) => if
    (acc.length < s.length) acc else Some(s) )', "        strings.foldLeft(Option.empty[String]){\n\
    \            case (Some(longest), s) =>\n                if (s.length() > longest.length())\n\
    \                    Some(s)\n                else\n                    longest\n\
    \            case (None) =>\n                None\n        }", "        strings.sortWith(_\
    \ < _)\n            .takeWhile(_ != \"\").maxBy(_.length)", "        strings.sortWith(_\
    \ < _)\n        strings.takeWhile(_ <= strings.last).maxBy(_.length)", "     \
    \   strings.foldLeft(List[String]()){\n            (acc, s) =>\n             \
    \   if (acc.length < s.length) acc :+ s\n                else acc\n        }.maxBy(_.length)",
  "        strings.foldLeft(List[String]()){\n            case (acc, str) => if (acc.length\
    \ < str.length) acc else str :: acc\n        }.maxBy(_.length)", "        strings.foldLeft(List[String]())((acc,\
    \ s) => acc match {\n            case Nil => List(s)\n            case _ => if\
    \ (acc.length < s.length) acc else List(s)\n        })", "        strings.foldLeft(List[String]()){\n\
    \            (acc, str) =>\n                if (acc.length < str.length) acc :+\
    \ str\n                else if (acc.length == str.length) acc :+ str\n       \
    \         else acc\n        }.maxBy(_.length)", "        strings.foldLeft(List[String]()){\n\
    \            (acc, s) =>\n                if (acc.length < s.length) acc :+ s\n\
    \                else acc\n        }.maxBy(_.length)", "        if (strings.isEmpty)\
    \ None\n        else {\n            val longest = strings.foldLeft(\"\")( (acc,\
    \ s) => if (acc.length < s.length) acc else s)\n            longest.length match\
    \ {\n                case 1 => Some(longest)\n                case _ => longest\n\
    \            }\n        }", "        strings.foldLeft(Option(\"\")) { (longest,\
    \ s) =>\n            val length = s.length\n            if (length > longest.get\
    \ || length == 0) longest.update(s)\n            else longest\n        }", '        strings.sortBy(_.length).lastOption',
  "        if (strings.length == 0) None\n        else {\n            val longest\
    \ = strings.maxBy(_.length)\n            if (longest.length == strings.length)\
    \ Some(longest)\n            else longest.headOption\n        }", "        strings.foldLeft(List[String]())((acc,\
    \ s) => acc match {\n            case Nil => List(s)\n            case x :: xs\
    \ => if (x.length > s.length) x :: xs else x\n        })", "        strings.foldLeft(Option(\"\
    \")){\n            case (Some(longest), string) =>\n                if (string.length()\
    \ > longest.length()) {\n                    Some(string)\n                } else\
    \ {\n                    longest\n                }\n            case (None, _)\
    \ => None\n        }", "        strings.foldLeft(List[String]())((list, s) =>\
    \ {\n            if (list.length == 0 || s.length == list(0)(0)) {\n         \
    \       list :+ s\n            } else {\n                if (s.length == list(0)(0))\
    \ {\n                    list :+ s\n                } else {\n               \
    \     list\n                }\n            }\n        })", "        strings.foldLeft(List[String]()){\n\
    \            (acc, s) => if (acc.length < s.length) acc :+ s else acc\n      \
    \  }.maxBy(_.length)", '        strings.sortWith(_ < _).lastOption']
stop_tokens:
- "\n    }\n"
