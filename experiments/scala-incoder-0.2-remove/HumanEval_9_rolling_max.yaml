name: HumanEval_9_rolling_max
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // From a given list of integers, generate a list of rolling maximum element\
  \ found until given moment\n    // in the sequence.\n    def rollingMax(numbers\
  \ : List[Long]) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
  \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
  \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
  \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
  \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
  \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
completions: ["        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, Math.max(max.getOrElse(x, 0), x)))\n        max.values.toList",
  "        val maxList = mutable.ListBuffer.empty[Long]\n        val maxIndex = mutable.ListBuffer.empty[Int]\n\
    \        numbers.foreach { number =>\n            val index = maxIndex.indexOf(math.max(maxList))\n\
    \            if (index == -1) {\n                maxList += number\n         \
    \       maxIndex += index\n            } else {\n                maxList += number\n\
    \                maxIndex += index\n            }\n        }\n        maxIndex.toList",
  "        val rollingMax = mutable.ListBuffer.empty[Long]\n        var max = 0L\n\
    \        var index = 0\n        for (number <- numbers) {\n            if (number\
    \ > max) {\n                max = number\n                index = rollingMax.size\n\
    \            }\n            rollingMax += number\n        }\n        rollingMax.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach {\
    \ n =>\n            val maxKey = max.getOrElseUpdate(n, 0L)\n            if (maxKey\
    \ > n) max.put(n, maxKey)\n        }\n        val maxList = new mutable.ListBuffer[Long]()\n\
    \        max.foreach { case (k, v) =>\n            maxList += k\n        }\n \
    \       return maxList.toList", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach(number => {\n            val maxIndex = maxList.lastIndex\n\
    \            if (maxIndex == -1) {\n                maxList += number\n      \
    \      } else {\n                val maxValue = maxList(maxIndex - 1)\n      \
    \          if (number > maxValue) {\n                    maxList += number\n \
    \               }\n            }\n        })\n        maxList.toList", "     \
    \   val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { n =>\n\
    \            if (max.containsKey(n)) {\n                val max = max(n) + 1\n\
    \                max.foreach { m =>\n                    max.remove(m)\n     \
    \           }\n            } else {\n                max.put(n, 1L)\n        \
    \    }\n        }\n        max.values.toList", "        val maxes = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach(x => maxes += x)\n        val rollingMax = maxes.max\n\
    \        val rollingMaxIndex = maxes.indexWhere(x => x == rollingMax)\n      \
    \  val rollingMaxList = maxes.take(rollingMaxIndex + 1)\n        rollingMaxList",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0) + x))\n        max.values.toList.sortWith(_\
    \ < _)", "        val rollingMax = mutable.ListBuffer.empty[Long]\n        val\
    \ rollingMaxIndex = mutable.ListBuffer.empty[Int]\n        numbers.foreach { number\
    \ =>\n            rollingMax.add(number)\n            rollingMaxIndex += number\n\
    \        }\n        rollingMax.foreach { number =>\n            val index = rollingMaxIndex.indexOf(number)\n\
    \            rollingMaxIndex.remove(index)\n            rollingMax.add(number)\n\
    \        }\n        rollingMax.toList", "        val rollingMax = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach { number =>\n            rollingMax.clear()\n       \
    \     rollingMax.append (number)\n            rollingMax.foreach { rollingMax\
    \ =>\n                val maxIndex = rollingMax.lastIndex\n                rollingMax.insert(maxIndex\
    \ + 1, rollingMax.last)\n            }\n        }\n        rollingMax.toList",
  "        val maxRollingMax = mutable.ListBuffer.empty[Long]\n        numbers.foreach\
    \ { number =>\n            val maxRollingMaxIndex = maxRollingMax.lastIndex\n\
    \            val maxRollingMaxValue = maxRollingMax(maxRollingMaxIndex)\n    \
    \        if (number > maxRollingMaxValue) {\n                maxRollingMax.clear()\n\
    \                maxRollingMax.push(number)\n            } else {\n          \
    \      maxRollingMax.push(number)\n            }\n        }\n        maxRollingMax.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        val rollingMax = new\
    \ mutable.ArrayBuffer[Long]()\n        numbers.foreach(n => {\n            val\
    \ maxKey = max.keySet().iterator().next()\n            if (maxKey > n) {\n   \
    \             max.put(n, maxKey)\n            } else {\n                max.put(n,\
    \ maxKey + 1)\n            }\n        })\n        numbers.foreach(n => {\n   \
    \         val maxKey = max.keySet().iterator().next()\n            if (maxKey\
    \ > n) {\n                rollingMax += maxKey\n            }\n        })\n  \
    \      rollingMax.toList", "        val rollingMax = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach { number =>\n            rollingMax += number\n     \
    \   }\n        rollingMax.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        val maxIndex = new mutable.HashMap[Long, Int]()\n        numbers.foreach\
    \ { number =>\n            val index = max.keys.toList.indexOf(number)\n     \
    \       if (index == -1) {\n                max.put(number, number)\n        \
    \        maxIndex.put(number, 0)\n            } else {\n                val maxIndex\
    \ = maxIndex.keys.toList.indexOf(number)\n                val maxValue = max.get(number)\n\
    \                if (maxValue > number) {\n                    max.put(number,\
    \ number)\n                    maxIndex.put(number, maxIndex + 1)\n          \
    \      }\n            }\n        }\n        max.keys.toList.map(x => (x, maxIndex.get(x)))",
  "        val maxList = mutable.ListBuffer.empty[Long]\n        val maxIndex = mutable.ListBuffer.empty[Int]\n\
    \        numbers.foreach { number =>\n            val index = maxIndex.last\n\
    \            val maxValue = maxList.getOrElse(index, math.max(number, 0))\n  \
    \          maxIndex += index\n            maxList += maxValue\n        }\n   \
    \     maxList.toList", "        val rollingMax = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach { number =>\n            rollingMax += number\n     \
    \   }\n        rollingMax.toList", "        val maxRolling = new mutable.ListBuffer[Long]()\n\
    \        val maxRollingIndex = new mutable.ListBuffer[Int]()\n        numbers.foreach(number\
    \ => {\n            val index = maxRolling.size\n            maxRolling.append(number)\n\
    \            maxRollingIndex.append(index)\n        })\n        val maxRollingIndexSize\
    \ = maxRollingIndex.size\n        val maxRollingIndexMax = maxRollingIndex.max\n\
    \        val maxRollingIndexMin = maxRollingIndex.min\n        val maxRollingIndexSum\
    \ = maxRollingIndex.sum\n        val maxRollingIndexSumSize = maxRollingIndexSum.size\n\
    \        val maxRollingIndexSumMax = maxRollingIndexSum.max\n        val maxRollingIndexSumMin\
    \ = maxRollingIndexSum.min\n        val maxRollingIndexSumSum = maxRollingIndexSum.sum\n\
    \        val maxRollingIndexSumSumSize = maxRollingIndexSumSum.size\n        val\
    \ maxRollingIndexSumSumMax = maxRollingIndexSumSum.max\n        val maxRollingIndexSumSumMin\
    \ = maxRollingIndexSumSum.min\n        val maxRollingIndexSumSumSum = maxRollingIndexSumSum.sum\n\
    \        val maxRollingIndexSumSumSumSize = maxRollingIndexSumSumSum.size\n  \
    \      val maxRollingIndexSumSumSumMax = maxRollingIndexSumSumSum.max\n      \
    \  val maxRollingIndexSumSumSumMin = maxRollingIndexSumSumSum.min\n        val\
    \ maxRollingIndexSumSumSumSum = maxRollingIndexSumSumSum.sum\n        val maxRollingIndexSumSumSumSumSize\
    \ = maxRollingIndexSumSumSumSum.size\n        val maxRollingIndexSumSumSumSumMax\
    \ = maxRollingIndexSumSumSumSumMax.size\n        val maxRollingIndexSumSumSumSumMin\
    \ = maxRollingIndexSumSumSumMin.size\n        val maxRollingIndexSumSumSumSumSum\
    \ = maxRollingIndexSumSumSumSum.size\n        val maxRollingIndexSumSumSumSumSumSize\
    \ = maxRollingIndexSumSumSumSumSumSize.size\n        val maxRollingIndexSumSumSumSumSumMax\
    \ = maxRollingIndexSumSumSumSumMax.max\n        val maxRollingIndexSumSumSumSumSumMin\
    \ = maxRollingIndexSumSumSumSumMin.max\n        val maxRollingIndexSumSumSum",
  "        val rollingMax = mutable.ListBuffer.empty[Long]\n        numbers.foreach\
    \ { number =>\n            val maxIndex = rollingMax.lastIndex\n            rollingMax.updated(maxIndex,\
    \ number)\n        }\n        rollingMax.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        val maxList = new mutable.ArrayList[Long]()\n        numbers.foreach\
    \ { number =>\n            val currentMax = max.get(number).getOrElse(number)\n\
    \            val newMax = currentMax + number\n            max.put(number, newMax)\n\
    \            maxList += newMax\n        }\n        maxList.toList", "        val\
    \ maxList = mutable.ListBuffer[Long]()\n        numbers.foreach(x => maxList +=\
    \ x)\n        val maxIndex = maxList.indexOf(0)\n        val maxValue = maxList.take(maxIndex).max\n\
    \        val maxIndexList = maxList.drop(maxIndex).takeWhile(x => x <= maxValue).toList\n\
    \        val maxIndexListSize = maxIndexList.size\n        val maxIndexListSize\
    \ = maxIndexListSize + 1\n        val maxIndexListSize = maxIndexListSize + 1\n\
    \        val maxIndexListSize = maxIndexListSize + 1\n        val maxIndexListSize\
    \ = maxIndexListSize + 1\n        val maxIndexListSize = maxIndexListSize + 1\n\
    \        val maxIndexListSize = maxIndexListSize + 1\n        val maxIndexListSize\
    \ = maxIndexListSize + 1\n        val maxIndexListSize = maxIndexListSize + 1\n\
    \        val maxIndexListSize = maxIndexListSize + 1\n        val maxIndexListSize\
    \ = maxIndexListSize + 1\n        val maxIndexListSize = maxIndexListSize + 1\n\
    \        val maxIndexListSize = maxIndexListSize + 1\n        val maxIndexListSize\
    \ = maxIndexListSize + 1\n        val maxIndexListSize = maxIndexListSize + 1\n\
    \        val maxIndexListSize = maxIndexListSize + 1\n        val maxIndexListSize\
    \ = maxIndexListSize + 1\n        val maxIndexListSize = maxIndexListSize + 1\n\
    \        val maxIndexListSize = maxIndexListSize + 1\n        val maxIndexListSize\
    \ = maxIndexListSize + 1\n        val maxIndexListSize = maxIndexListSize + 1\n\
    \        val maxIndexListSize = maxIndexListSize + 1\n        val maxIndexListSize\
    \ = maxIndexListSize + 1\n        val maxIndexListSize = maxIndexListSize + 1\n\
    \        val maxIndexListSize = maxIndexListSize + 1\n        val maxIndexListSize\
    \ = maxIndexListSize + 1\n        val maxIndexListSize = maxIndexListSize + 1\n\
    \        val maxIndexListSize = maxIndexListSize + 1\n        val maxIndexListSize\
    \ = maxIndexListSize + 1\n        val maxIndexListSize = maxIndexListSize + 1\n\
    \        val maxIndexListSize = maxIndexListSize + 1\n        val maxIndexListSize\
    \ = maxIndexListSize + 1\n        val maxIndexListSize = maxIndexListSize + 1\n\
    \        val maxIndexListSize = maxIndexListSize + 1\n        val maxIndexListSize\
    \ = maxIndexListSize + 1\n        val maxIndexListSize = maxIndexListSize + 1\n\
    \        val maxIndexListSize = maxIndexListSize + 1\n", "        val rollingMax\
    \ = mutable.ListBuffer.empty[Long]\n        numbers.foreach { number =>\n    \
    \        val maxIndex = rollingMax.lastIndex\n            rollingMax.updated(maxIndex\
    \ + 1, number)\n        }\n        rollingMax.toList", "        val max = new\
    \ mutable.HashMap[Long, Long]()\n        numbers.foreach { number =>\n       \
    \     val max = number.max(max)\n        }\n        max.values.toList", "    \
    \    val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(n =>\
    \ {\n            val maxKey = max.maxKey\n            if (maxKey == null || n\
    \ < maxKey) {\n                max += n -> n\n            }\n        })\n    \
    \    max.values.toList", "        val maxRollingNumbers = mutable.ListBuffer[Long]()\n\
    \        numbers.foreach { number =>\n            val maxNumber = number + maxRollingNumbers.last\n\
    \            maxRollingNumbers += maxNumber\n        }\n        maxRollingNumbers.toList",
  "        val rollingMax = mutable.ListBuffer.empty[Long]\n        numbers.foreach\
    \ { number =>\n            rollingMax.append(number) // append the number to the\
    \ rolling max list\n            rollingMax.lastOption // get the last element\
    \ of the rolling max list\n                .map { rollingMax =>\n            \
    \        rollingMax.max // get the max of the rolling max list\n             \
    \   }\n                .foreach { rollingMax =>\n                    rollingMax.foreach\
    \ { rollingMax =>\n                        rollingMax.foreach { rollingMax =>\n\
    \                            rollingMax.foreach { rollingMax =>\n            \
    \                    rollingMax.foreach { rollingMax =>\n                    \
    \                rollingMax.foreach { rollingMax =>\n                        \
    \                rollingMax.foreach { rollingMax =>\n                        \
    \                    rollingMax.foreach { rollingMax =>\n                    \
    \                            rollingMax.foreach { rollingMax =>\n            \
    \                                        rollingMax.foreach { rollingMax =>\n\
    \                                                        rollingMax.foreach {\
    \ rollingMax =>\n                                                            rollingMax.foreach\
    \ { rollingMax =>\n                                                          \
    \      rollingMax.foreach { rollingMax =>\n                                  \
    \                                  rollingMax.foreach { rollingMax =>\n      \
    \                                                                  rollingMax.foreach\
    \ { rollingMax =>\n                                                          \
    \                  rollingMax.foreach { rollingMax =>\n                      \
    \                                                          rollingMax.foreach\
    \ { rollingMax =>\n                                                          \
    \                          rollingMax.foreach { rollingMax =>\n              \
    \                                                                          rollingMax.foreach\
    \ { rollingMax =>\n                                                          \
    \                                  rollingMax.foreach { rollingMax =>\n      \
    \                                                                            \
    \              rollingMax.foreach { rollingMax =>\n                          \
    \                                                                          rollingMax.foreach\
    \ { rollingMax =>\n                                                          \
    \                                              rollingMax.foreach { rollingMax\
    \ =>\n                                                                       \
    \                                     rollingMax.foreach { rollingMax =>\n   \
    \                                                                            \
    \                                 rollingMax.foreach { rollingMax =>\n       \
    \                                                                            \
    \                                 rollingMax.foreach { rollingMax =>\n       \
    \                                                                            \
    \                                     rollingMax.foreach { rollingMax =>\n   \
    \                                                                            \
    \                                             rollingMax.foreach { rollingMax\
    \ =>\n                                                                       \
    \                                                         rollingMax.foreach {\
    \ rollingMax =>\n                                                            \
    \                                                                        rollingMax.foreach\
    \ { rollingMax =>\n                                                          \
    \                                                                            \
    \  rollingMax.foreach { rollingMax =>\n                                      \
    \                                                                            \
    \                          rollingMax.foreach { rolling", "        val max = new\
    \ mutable.HashMap[Long, Long]()\n        val maxList = new mutable.ArrayList[Long]()\n\
    \        numbers.foreach(x => max.put(x, max(x.getOrElse(x, 0L) + 1)));\n    \
    \    max.foreach(x => maxList.add(x));\n        maxList.sortWith((x, y) => y.compareTo(x)\
    \ < 0);\n        maxList.reverse.takeWhile(x => x <= numbers.getOrElse(maxList.size,\
    \ 0L)).map(x => maxList.remove(x)).toList", "        val maxRollingNumbers = mutable.ListBuffer[Long]()\n\
    \        var maxRollingNumber = 0L\n        var currentRollingNumber = 0L\n  \
    \      numbers.foreach{ number =>\n            currentRollingNumber = number\n\
    \            while (currentRollingNumber > maxRollingNumber) {\n             \
    \   maxRollingNumbers += maxRollingNumber\n                maxRollingNumber =\
    \ 0L\n            }\n            currentRollingNumber -= 1\n        }\n      \
    \  maxRollingNumbers += maxRollingNumber\n        return maxRollingNumbers", " \
    \       val max = new mutable.HashMap[Long, Long]()\n        val maxList = new\
    \ mutable.ArrayList[Long]()\n        numbers.foreach { number =>\n           \
    \ val currentMax = max.get(number).getOrElse(number)\n            val currentMaxList\
    \ = maxList.getOrElse(currentMax, new mutable.ArrayList[Long]())\n           \
    \ currentMaxList += number\n            max.put(number, currentMax)\n        \
    \    maxList += currentMaxList\n        }\n        maxList.map(_.max)", "    \
    \    val rollingMax = mutable.ListBuffer.empty[Long]\n        val rollingMaxIndex\
    \ = mutable.ListBuffer.empty[Int]\n        val rollingMaxIndexSize = mutable.ListBuffer.empty[Int]\n\
    \        numbers.foreach { number =>\n            rollingMax.add(number)\n   \
    \         rollingMaxIndexSize += rollingMaxIndex.size + rollingMaxIndex.last\n\
    \            rollingMaxIndex += number\n        }\n        rollingMaxIndex.foreach\
    \ { index =>\n            rollingMaxIndexSize -= index\n        }\n        rollingMaxIndex.foreach\
    \ { index =>\n            rollingMaxIndexSize += index\n        }\n        rollingMaxIndex.foreach\
    \ { index =>\n            rollingMaxIndexSize -= index\n        }\n        rollingMaxIndex.foreach\
    \ { index =>\n            rollingMaxIndexSize += index\n        }\n        rollingMaxIndex.foreach\
    \ { index =>\n            rollingMaxIndexSize -= index\n        }\n        rollingMaxIndex.foreach\
    \ { index =>\n            rollingMaxIndexSize += index\n        }\n        rollingMaxIndex.foreach\
    \ { index =>\n            rollingMaxIndexSize -= index\n        }\n        rollingMaxIndex.foreach\
    \ { index =>\n            rollingMaxIndexSize += index\n        }\n        rollingMaxIndex.foreach\
    \ { index =>\n            rollingMaxIndexSize -= index\n        }\n        rollingMaxIndex.foreach\
    \ { index =>\n            rollingMaxIndexSize += index\n        }\n        rollingMaxIndex.foreach\
    \ { index =>\n            rollingMaxIndexSize -= index\n        }\n        rollingMaxIndex.foreach\
    \ { index =>\n            rollingMaxIndexSize += index\n        }\n        rollingMaxIndex.foreach\
    \ { index =>\n            rollingMaxIndexSize -= index\n        }\n        rollingMaxIndex.foreach\
    \ { index =>\n            rollingMaxIndexSize += index\n        }\n        rollingMaxIndex.foreach\
    \ { index =>\n            rollingMaxIndexSize -= index\n        }\n        rollingMaxIndex.foreach\
    \ { index =>\n            rollingMaxIndexSize += index\n        }\n        rollingMaxIndex.foreach\
    \ { index =>\n            rollingMaxIndexSize -= index\n        }\n        rollingMaxIndex.foreach\
    \ { index =>\n            rollingMaxIndexSize += index\n        }\n        rollingMaxIndex.fore",
  "        val max = new mutable.HashMap[Long, Long]()\n        val maxList = new\
    \ mutable.ArrayList[Long]()\n        numbers.foreach(number => {\n           \
    \ val currentMax = max.get(number).getOrElse(number)\n            val newMax =\
    \ currentMax + number\n            max.put(number, newMax)\n            maxList\
    \ += newMax\n        })\n        maxList.toList", "        val rollingMax = mutable.ListBuffer[Long]()\n\
    \        numbers.foreach(x => rollingMax += x)\n        rollingMax.toList", " \
    \       val max = new mutable.HashMap[Long, Long]()\n        val rollingMax =\
    \ new mutable.ListBuffer[Long]()\n        numbers.foreach(x => max.put(x, max.getOrElse(x,\
    \ 0) + x))\n        max.foreach(x => rollingMax.append(max.get(x).max))\n    \
    \    rollingMax.toList", "        val maxList = mutable.ListBuffer[Long]()\n \
    \       numbers.foreach(x => {\n            val maxIndex = maxList.lastIndex\n\
    \            if (maxIndex == -1) {\n                maxList += x\n           \
    \ } else {\n                val maxValue = maxList(maxIndex - 1)\n           \
    \     if (x > maxValue) {\n                    maxList += x\n                }\n\
    \            }\n        })\n        maxList.toList", "        val rollingMax =\
    \ mutable.ListBuffer[Long]()\n        numbers.foreach { number =>\n          \
    \  rollingMax.append(number)\n            rollingMax.append(number)\n        \
    \    rollingMax.append(number)\n            rollingMax.append(number)\n      \
    \      rollingMax.append(number)\n            rollingMax.append(number)\n    \
    \        rollingMax.append(number)\n            rollingMax.append(number)\n  \
    \          rollingMax.append(number)\n            rollingMax.append(number)\n\
    \            rollingMax.append(number)\n            rollingMax.append(number)\n\
    \            rollingMax.append(number)\n            rollingMax.append(number)\n\
    \            rollingMax.append(number)\n            rollingMax.append(number)\n\
    \            rollingMax.append(number)\n            rollingMax.append(number)\n\
    \            rollingMax.append(number)\n            rollingMax.append(number)\n\
    \            rollingMax.append(number)\n            rollingMax.append(number)\n\
    \            rollingMax.append(number)\n            rollingMax.append(number)\n\
    \            rollingMax.append(number)\n            rollingMax.append(number)\n\
    \            rollingMax.append(number)\n            rollingMax.append(number)\n\
    \            rollingMax.append(number)\n            rollingMax.append(number)\n\
    \            rollingMax.append(number)\n            rollingMax.append(number)\n\
    \            rollingMax.append(number)\n            rollingMax.append(number)\n\
    \            rollingMax.append(number)\n            rollingMax.append(number)\n\
    \            rollingMax.append(number)\n            rollingMax.append(number)\n\
    \            rollingMax.append(number)\n            rollingMax.append(number)\n\
    \            rollingMax.append(number)\n            rollingMax.append(number)\n\
    \            rollingMax.append(number)\n            rollingMax.append(number)\n\
    \            rollingMax.append(number)\n            rollingMax.append(number)\n\
    \            rollingMax.append(number)\n            rollingMax.append(number)\n\
    \            rollingMax.append(number)\n            rollingMax.append(number)\n\
    \            rollingMax.append(number)\n            rollingMax.append(number)\n\
    \            rollingMax.append(number)\n            rollingMax.append(number)\n\
    \            rollingMax.append(number)\n            rollingMax.append(number)\n\
    \            rollingMax.append(number)\n            rollingMax.append(number)\n\
    \            rollingMax.append(number)\n            rollingMax.append(number)\n\
    \            rollingMax.append(number)\n            rollingMax.append(number)\n\
    \            rollingMax.append(number)\n            rollingMax.append(number)\n\
    \            rollingMax.append(number)\n            rollingMax.append(number)\n\
    \            rollingMax.append(number)\n            rollingMax.append(number)\n\
    \            rollingMax.append(number)\n            rollingMax.append(number)",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(n\
    \ => {\n            if (max.containsKey(n)) {\n                val maxValue =\
    \ max.get(n)\n                if (maxValue < n) {\n                    max.put(maxValue,\
    \ n)\n                }\n            } else {\n                max.put(n, n)\n\
    \            }\n        })\n        max.values.toList", "        val rollingMax\
    \ = mutable.ListBuffer.empty[Long]\n        numbers.foreach { number =>\n    \
    \        val rollingMaxElement = number + rollingMax.last\n            rollingMax.append(rollingMaxElement)\n\
    \        }\n        rollingMax.toList", "        val rollingMax = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach { number =>\n            rollingMax.append(number)\n\
    \            if (rollingMax.size > rollingMax.last)\n                rollingMax.dropRight(1)\n\
    \        }\n        rollingMax.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(x => max.put(x, max.getOrElse(x, 0) + x))\n\
    \        max.values.toList", "        val max = new mutable.HashMap[Long, Long]()\n\
    \        val maxList = new mutable.ArrayList[Long]()\n        numbers.foreach(x\
    \ => max.put(x, max(x.getOrElse(x, 0L) + 1)));\n        max.foreach(x => maxList.add(x));\n\
    \        maxList.sortWith((x, y) => y.compareTo(x) < 0);\n        maxList.reverse.takeWhile(x\
    \ => x <= numbers(0)).drop(1)", "        val rollingMax = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach(x => rollingMax.append(x))\n        rollingMax.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0L) + x))\n        val maxList = max.toList.sortBy(_._1).reverse\n\
    \        val maxElement = maxList.head._2\n        val maxElementList = maxList.filter(_._2\
    \ > maxElement)\n        val maxElementListWithMaxElement = maxElementList.map(_._1)\n\
    \        val maxElementListWithoutMaxElement = maxElementList.filter(_._1 == maxElement)\n\
    \        val maxElementListWithoutMaxElementWithMaxElement = maxElementListWithoutMaxElement.map(_._2)\n\
    \        val maxElementListWithoutMaxElementWithoutMaxElement = maxElementListWithoutMaxElementWithMaxElement.filter(_._2\
    \ == maxElement)\n        val maxElementListWithoutMaxElementWithoutMaxElementWithMaxElement\
    \ = maxElementListWithoutMaxElementWithoutMaxElement.filter(_._2 == maxElement)\n\
    \        val maxElementListWithoutMaxElementWithoutMaxElementWithoutMaxElement\
    \ = maxElementListWithoutMaxElementWithoutMaxElementWithMaxElement.filter(_._2\
    \ == maxElement)\n        val maxElementListWithoutMaxElementWithoutMaxElementWithoutMaxElementWithMaxElement\
    \ = maxElementListWithoutMaxElementWithoutMaxElementWithoutMaxElement.filter(_._2\
    \ == maxElement)\n        val maxElementListWithoutMaxElementWithoutMaxElementWithoutMaxElementWithoutMaxElement\
    \ = maxElementListWithoutMaxElementWithoutMaxElementWithoutMaxElementWithMaxElement.filter(_._2\
    \ == maxElement)\n        val maxElementListWithoutMaxElementWithoutMaxElementWithoutMaxElementWithoutMaxElementWithMaxElement\
    \ = maxElementListWithoutMaxElementWithoutMaxElementWithoutMaxElementWithoutMaxElement.filter(_._2\
    \ == maxElement)\n        val maxElementListWithoutMaxElementWithoutMaxElementWithoutMaxElementWithoutMaxElementWithoutMaxElement\
    \ = maxElementListWithoutMaxElementWithoutMaxElementWithoutMaxElementWithoutMaxElement.filter(_._2\
    \ == maxElement)\n        val maxElementListWithoutMaxElementWithoutMaxElementWithoutMaxElementWithoutMaxElementWithoutMaxElementWithMaxElement\
    \ = maxElementListWithoutMaxElementWithoutMaxElementWithoutMaxElementWithoutMaxElementWithoutMaxElement.filter(_._2\
    \ == maxElement)\n        val maxElementListWithoutMaxElementWithoutMaxElementWithoutMaxElementWithoutMaxElementWithoutMaxElementWithoutMaxElement\
    \ = maxElementListWithoutMaxElementWithoutMaxElementWithoutMaxElementWithoutMaxElementWithoutMaxElement.filter(_._2\
    \ == maxElement)\n        val maxElementListWithoutMaxElementWithoutMaxElementWithoutMaxElementWithout",
  "        val max = new mutable.HashMap[Long, Long]()\n        val rollingMax = new\
    \ mutable.ListBuffer[Long]()\n        for (i <- 0 until numbers.size) {\n    \
    \        val value = numbers(i)\n            val max = max.getOrElse(value, 0)\n\
    \            val rollingMax = rollingMax.getOrElse(max, 0)\n            max.update(value,\
    \ rollingMax + 1)\n            rollingMax.update(0, value)\n        }\n      \
    \  rollingMax.toList", "        val max = new mutable.HashMap[Long, Long]()\n\
    \        numbers.foreach(n => {\n            val maxKey = max + (n -> n)\n   \
    \         if (maxKey._2 > n)\n                max += n -> n\n        })\n    \
    \    val maxList = max map { case (k, v) => k -> v }\n        val maxListSorted\
    \ = maxList.sortBy(_._1)\n        val maxListSortedReversed = maxListSorted.reverse\n\
    \        val maxListSortedReversedSorted = maxListSortedReversed.sortBy(_._1)\n\
    \        val maxListSortedReversedSorted2 = maxListSortedReversedSorted.reverse\n\
    \        val maxListSortedReversedSorted3 = maxListSortedReversedSorted2.sortBy(_._1)\n\
    \        val maxListSortedReversedSorted4 = maxListSortedReversedSorted3.reverse\n\
    \        val maxListSortedReversedSorted5 = maxListSortedReversedSorted4.sortBy(_._1)\n\
    \        val maxListSortedReversedSorted6 = maxListSortedReversedSorted5.reverse\n\
    \        val maxListSortedReversedSorted7 = maxListSortedReversedSorted6.sortBy(_._1)\n\
    \        val maxListSortedReversedSorted8 = maxListSortedReversedSorted7.reverse\n\
    \        val maxListSortedReversedSorted9 = maxListSortedReversedSorted8.sortBy(_._1)\n\
    \        val maxListSortedReversedSorted10 = maxListSortedReversedSorted9.reverse\n\
    \        val maxListSortedReversedSorted11 = maxListSortedReversedSorted10.reverse\n\
    \        val maxListSortedReversedSorted12 = maxListSortedReversedSorted11.reverse\n\
    \        val maxListSortedReversedSorted13 = maxListSortedReversedSorted12.reverse\n\
    \        val maxListSortedReversedSorted14 = maxListSortedReversedSorted13.reverse\n\
    \        val maxListSortedReversedSorted15 = maxListSortedReversedSorted14.reverse\n\
    \        val maxListSortedReversedSorted16 = maxListSortedReversedSorted15.reverse\n\
    \        val maxListSortedReversedSorted17 = maxListSortedReversedSorted16.reverse\n\
    \        val maxListSortedReversedSorted18 = maxListSortedReversedSorted17.reverse\n\
    \        val maxListSortedReversedSorted19 = maxListSortedReversedSorted18.reverse\n\
    \        val maxListSortedReversedSorted20 = maxListSortedReversedSorted19.reverse\n\
    \        val maxListSortedReversedSorted21 = maxListSortedReversedSorted20.reverse\n\
    \        val maxListSortedReversedSorted22 = maxListSortedReversedSorted", " \
    \       val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach {\
    \ number =>\n            val max = number.max(max)\n        }\n        max.values.toList",
  "        val rollingMax = mutable.ListBuffer.empty[Long]\n        numbers.foreach\
    \ { number =>\n            rollingMax.append(number)\n            rollingMax.append(number)\n\
    \        }\n        rollingMax.toList", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        val maxIndex = mutable.ListBuffer.empty[Int]\n        numbers.foreach\
    \ { number =>\n            val index = maxIndex.lastOption.orElse(maxIndex.size\
    \ + 1)\n            val maxValue = maxList.get(index - 1).orElse(number)\n   \
    \         if (number > maxValue) {\n                maxList += number\n      \
    \          maxIndex += index\n            }\n        }\n        maxList.toList",
  "        val maxList = mutable.ListBuffer.empty[Long]\n        val maxIndex = -1\n\
    \        val maxValue = numbers.head\n        val maxIndexList = mutable.ListBuffer.empty[Int]\n\
    \        val maxIndexValue = numbers.head\n        numbers.foreach { number =>\n\
    \            if (number > maxValue) {\n                maxValue = number\n   \
    \             maxIndex = 0\n                maxIndexList.clear()\n           \
    \     maxIndexList.clear()\n                maxIndexList.clear()\n           \
    \ }\n            if (number == maxValue) {\n                maxIndex += 1 \n \
    \               maxIndexList += maxIndex\n            }\n            if (number\
    \ > maxValue) {\n                maxValue = number\n                maxIndex =\
    \ maxIndexList(0)\n                maxIndexList.clear()\n                maxIndexList.clear()\n\
    \                maxIndexList.clear()\n            }\n        }\n        maxIndexList.foreach\
    \ { index =>\n            if (maxIndexList.contains(index)) {\n              \
    \  maxIndex += 1 \n                maxIndexList += maxIndex\n            }\n \
    \       }\n        maxIndexList.foreach { index =>\n            if (maxIndexList.contains(index))\
    \ {\n                maxIndex += 1 \n                maxIndexList += maxIndex\n\
    \            }\n        }\n        maxIndexList.foreach { index =>\n         \
    \   if (maxIndexList.contains(index)) {\n                maxIndex += 1 \n    \
    \            maxIndexList += maxIndex\n            }\n        }\n        maxIndexList.foreach\
    \ { index =>\n            if (maxIndexList.contains(index)) {\n              \
    \  maxIndex += 1 \n                maxIndexList += maxIndex\n            }\n \
    \       }\n        maxIndexList.foreach { index =>\n            if (maxIndexList.contains(index))\
    \ {\n                maxIndex += 1 \n                maxIndexList += maxIndex\n\
    \            }\n        }\n        maxIndexList.foreach { index =>\n         \
    \   if (maxIndexList.contains(index)) {\n                maxIndex += 1 \n    \
    \            maxIndexList += maxIndex\n            }\n        }\n        maxIndexList.foreach\
    \ { index =>\n            if (maxIndexList.contains(index)) {\n              \
    \  maxIndex += 1 \n                maxIndexList += maxIndex\n            }\n \
    \       }\n        maxIndexList.foreach { index =>\n            if (maxIndexList.contains(index))\
    \ {\n                maxIndex += 1 \n                maxIndexList += maxIndex\n\
    \            }\n        }\n        maxIndexList.foreach { index =>\n         \
    \   if (maxIndexList.contains(index)) {\n                maxIndex += 1 \n    \
    \            maxIndexList += maxIndex\n            }\n        }\n        maxIndexList.foreach\
    \ { index =>\n            if (maxIndexList.contains(index)) {\n              \
    \  maxIndex += 1 \n                maxIndexList += maxIndex\n            }\n \
    \       }\n        maxIndexList.foreach { index ", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        val rollingMax = new mutable.ListBuffer[Long]()\n        numbers.foreach(x\
    \ => max.put(x, x))\n        while(max.size > 0){\n            val maxKey = max.keys.max\n\
    \            val maxValue = max.get(maxKey)\n            max.remove(maxKey)\n\
    \            rollingMax += maxValue\n        }\n        rollingMax.toList", " \
    \       val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0) + x))\n        val result = new mutable.ListBuffer[Long]()\n\
    \        max.values.foreach(x => if (x > 0) result += x)\n        result.toList",
  "        val rollingMax = mutable.ListBuffer.empty[Long]\n        numbers.foreach\
    \ { number =>\n            rollingMax += number\n        }\n        rollingMax.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        val maxList = new\
    \ mutable.ArrayList[Long]()\n        numbers.foreach(x => {\n            val max\
    \ = max(x) + x\n            max.foreach { y => max.remove(y) }\n            val\
    \ list = maxList.filter(_ > x)\n            list += max\n            maxList.clear()\n\
    \        })\n        maxList.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        val maxList = new mutable.ArrayList[Long]()\n        numbers.foreach(x\
    \ => {\n            if (max.contains(x)) {\n                val max = max(x)\n\
    \                val maxList = maxList.toList\n                maxList += max\n\
    \            } else {\n                val max = x\n                val maxList\
    \ = maxList.toList\n                maxList += max\n                max.foreach\
    \ { y => max.remove(y) }\n                max.foreach { y => max.put(y, y) }\n\
    \                max.foreach { y => max.put(y, y) }\n                max.foreach\
    \ { y => max.put(y, y) }\n                max.foreach { y => max.put(y, y) }\n\
    \                max.foreach { y => max.put(y, y) }\n                max.foreach\
    \ { y => max.put(y, y) }\n                max.foreach { y => max.put(y, y) }\n\
    \                max.foreach { y => max.put(y, y) }\n                max.foreach\
    \ { y => max.put(y, y) }\n                max.foreach { y => max.put(y, y) }\n\
    \                max.foreach { y => max.put(y, y) }\n                max.foreach\
    \ { y => max.put(y, y) }\n                max.foreach { y => max.put(y, y) }\n\
    \                max.foreach { y => max.put(y, y) }\n                max.foreach\
    \ { y => max.put(y, y) }\n                max.foreach { y => max.put(y, y) }\n\
    \                max.foreach { y => max.put(y, y) }\n                max.foreach\
    \ { y => max.put(y, y) }\n                max.foreach { y => max.put(y, y) }\n\
    \                max.foreach { y => max.put(y, y) }\n                max.foreach\
    \ { y => max.put(y, y) }\n                max.foreach { y => max.put(y, y) }\n\
    \                max.foreach { y => max.put(y, y) }\n                max.foreach\
    \ { y => max.put(y, y) }\n                max.foreach { y => max.put(y, y) }\n\
    \                max.foreach { y => max.put(y, y) }\n                max.foreach\
    \ { y => max.put(y, y) }\n                max.foreach { y => max.put(y, y) }\n\
    \                max.foreach { y => max.put(y, y) }\n                max.foreach\
    \ { y => max.put(y, y) }\n                max.foreach { y => max.put(y, y) }\n\
    \                max.foreach { y => max.put(y, y) }\n                ", "    \
    \    val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0) + x))\n        max.values.toList", "        val\
    \ rollingMax = mutable.ListBuffer[Long]()\n        numbers.foreach { number =>\n\
    \            rollingMax += number\n        }\n        rollingMax.toList", "  \
    \      val maxRolling = new mutable.ListBuffer[Long]()\n        numbers.foreach(number\
    \ => {\n            val maxIndex = numbers.indexWhere(x => x > number)\n     \
    \       val maxValue = numbers(maxIndex)\n            val maxRollingIndex = maxIndex\
    \ - maxRolling.size\n            val maxRollingValue = maxRolling.getOrElse(maxRollingIndex,\
    \ 0L)\n            if (maxRollingValue < maxValue) {\n                maxRollingValue\
    \ += number\n                maxRolling.append(maxRollingValue)\n            }\n\
    \        })\n        maxRolling", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(n => {\n            val maxKey = max max n\n\
    \            if (maxKey > n) max += n -> maxKey\n        })\n        max map {\
    \ case (k, v) => v }", "        val max = new mutable.HashMap[Long, Long]()\n\
    \        val rollingMax = new mutable.ArrayBuffer[Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0L) + x))\n        max.foreach(x => rollingMax.append(max.getOrElse(x,\
    \ 0L)))\n        rollingMax", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        var max = 0L\n        var i = 0\n        while (i < numbers.length) {\n\
    \            if (numbers(i) > max) {\n                max = numbers(i)\n     \
    \       }\n            i += 1\n        }\n        val rollingMax = numbers.takeWhile(_\
    \ < max).reverse.takeWhile(_ < max).reverse\n        rollingMax.foreach(x => maxList\
    \ += x)\n        return maxList", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach(x => {\n            val maxIndex = maxList.lastIndex\n\
    \            if (maxIndex == -1) {\n                maxList += x\n           \
    \ } else {\n                val maxValue = maxList(maxIndex) + 1\n           \
    \     if (x > maxValue) {\n                    maxList += x\n                }\n\
    \            }\n        })\n        maxList.toList", "        val rollingMax =\
    \ mutable.ListBuffer.empty[Long]\n        var max = 0L\n        var index = 0\n\
    \        numbers.foreach(n => {\n            max = math.max(max, n)\n        \
    \    rollingMax += max\n            index += 1\n        })\n        rollingMax.toList",
  "        val maxList = mutable.ListBuffer.empty[Long]\n        val maxIndex = mutable.ListBuffer.empty[Int]\n\
    \        numbers.foreach { number =>\n            val index = maxIndex.last\n\
    \            if (number > maxList.getOrElse(index + 1, number)) {\n          \
    \      maxList += number\n                maxIndex += index\n            }\n \
    \       }\n        maxList.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        val rollingMax = new mutable.ArrayList[Long]()\n        numbers.foreach\
    \ { number =>\n            val maxValue = max.getOrElse(number, 0)\n         \
    \   val newMaxValue = number + maxValue\n            max.put(number, newMaxValue)\n\
    \            rollingMax += newMaxValue\n        }\n        rollingMax.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, math.max(max.getOrElse(x, 0), x)))\n        max.values.toList",
  "        val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach {\
    \ number =>\n            val maxIndex = maxList.lastIndex\n            if (maxIndex\
    \ == -1) {\n                maxList += number\n            } else {\n        \
    \        val maxValue = maxList(maxIndex - 1)\n                if (number > maxValue)\
    \ {\n                    maxList += number\n                }\n            }\n\
    \        }\n        maxList.toList", "        val rollingMax = mutable.ListBuffer.empty[Long]\n\
    \        var max = 0L\n        var current = 0L\n        var index = 0\n     \
    \   numbers.foreach { n =>\n            current = n\n            max = n\n   \
    \         rollingMax.append(max)\n            index += 1\n            if (index\
    \ > numbers.size - 1) {\n                rollingMax.append(current)\n        \
    \    }\n        }\n        rollingMax.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(x => max.put(x, max.getOrElse(x, 0) + x))\n\
    \        max.values.toList", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach { number =>\n            val maxNumber = maxList.max\n\
    \            if (number > maxNumber) {\n                maxList += number\n  \
    \          }\n        }\n        maxList.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        val maxList = new mutable.ArrayList[Long]()\n        numbers.foreach(x\
    \ => {\n            val max = max.getOrElse(x, x)\n            val list = maxList.getOrElse(x,\
    \ new mutable.ArrayList[Long]())\n            list.add(max)\n            max.foreach\
    \ { y => max.update(y, y + y) }\n            maxList.addAll(list)\n        })\n\
    \        maxList.map(_.max)", "        val maxes = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach(n => {\n            val maxIndex = maxes.indexWhere(x\
    \ => x > n)\n            if (maxIndex >= 0) {\n                maxes(maxIndex)\
    \ = maxes(maxIndex) + n\n            } else {\n                maxes += n\n  \
    \          }\n        })\n        maxes.toList", "        val maxList = mutable.ListBuffer[Long]()\n\
    \        numbers.foreach { number =>\n            val maxIndex = maxList.lastIndex\n\
    \            if (maxIndex == -1) {\n                maxList += number\n      \
    \      } else {\n                val maxValue = maxList(maxIndex - 1)\n      \
    \          if (number > maxValue) {\n                    maxList += number\n \
    \               }\n            }\n        }\n        maxList.toList", "      \
    \  val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x => max.put(x,\
    \ max.getOrElse(x, 0) + x))\n        val result = new mutable.ListBuffer[Long]()\n\
    \        max.values.foreach(x => result.add(x))\n        result.sortWith(_ < _)",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach {\
    \ number =>\n            val max = number.max(max)\n        }\n        max.values.toList",
  "        val maxList = mutable.ListBuffer[Long]()\n        numbers.foreach(x =>\
    \ {\n            val maxIndex = maxList.lastIndex\n            if (maxIndex ==\
    \ -1) {\n                maxList += x\n            } else {\n                val\
    \ maxValue = maxList(maxIndex) + 1\n                if (x > maxValue) {\n    \
    \                maxList += x\n                }\n            }\n        })\n\
    \        maxList.toList", "        val max = new mutable.HashMap[Long, Long]()\n\
    \        numbers.foreach(x => max.put(x, max.getOrElse(x, 0) + x))\n        val\
    \ maxList = max.toList.sortBy(_._1).reverse.takeWhile(_._2 > 0).reverse\n    \
    \    val maxElement = maxList.head._2\n        val maxElements = maxList.tail.takeWhile(_._2\
    \ > 0).reverse\n        val maxElementsSum = maxElements.sum\n        val maxElementsSumOfElements\
    \ = maxElements.map(x => x._2).sum\n        val maxElementsSumOfElementsSquared\
    \ = maxElements.map(x => x._2 * x._2).sum\n        val maxElementsSumOfElementsSquaredSquared\
    \ = maxElements.map(x => x._2 * x._2).map(x => x * x).sum\n        val maxElementsSumOfElementsSquaredCube\
    \ = maxElements.map(x => x._2 * x._2 * x._2).sum\n        val maxElementsSumOfElementsCube\
    \ = maxElements.map(x => x._2 * x._2 * x._2 * x._2).sum\n        val maxElementsSumOfElementsCubeCube\
    \ = maxElements.map(x => x._2 * x._2 * x._2 * x._2 * x._2).sum\n        val maxElementsSumOfElementsCubeCubeCube\
    \ = maxElements.map(x => x._2 * x._2 * x._2 * x._2 * x._2 * x._2).sum\n      \
    \  val maxElementsSumOfElementsCubeCubeCubeCube = maxElements.map(x => x._2 *\
    \ x._2 * x._2 * x._2 * x._2 * x._2 * x._2).sum\n        val maxElementsSumOfElementsCubeCubeCubeCubeCube\
    \ = maxElements.map(x => x._2 * x._2 * x._2 * x._2 * x._2 * x._2 * x._2 * x._2).sum\n\
    \        val maxElementsSumOfElementsCubeCubeCubeCubeCube = maxElements.map(x\
    \ => x._2 * x._2 * x._2 * x._2 * x._2 * x._2 * x._2 * x._2 * x._2).sum\n     \
    \   val maxElementsSumOfElementsCubeCubeCubeCubeCube = maxElements.map(x => x._2\
    \ * x._2 * x._2 * x._2 * x._2 * x._2 * x._2 * x._2 * x._2).sum\n        val maxElementsSumOfElementsCubeCubeCubeCube",
  "        val maxes = mutable.ListBuffer.empty[Long]\n        var max = 0L\n    \
    \    var index = 0\n        numbers.foreach{n =>\n            if (n > max) {\n\
    \                max = n\n                maxes += max\n            }\n      \
    \      if (n == max) {\n                maxes += max\n            }\n        }\n\
    \        maxes", "        val maxList = mutable.ListBuffer.empty[Long]\n     \
    \   numbers.foreach(x => maxList += x)\n        val maxIndex = maxList.lastIndex\n\
    \        val maxValue = maxList(maxIndex)\n        val maxElements = maxList.drop(maxIndex).takeWhile(x\
    \ => x <= maxValue)\n        val maxElementsIndex = maxElements.lastIndex\n  \
    \      val maxElementsValue = maxElements(maxElementsIndex)\n        val maxElementsElements\
    \ = maxElements.drop(maxElementsIndex).takeWhile(x => x <= maxElementsValue)\n\
    \        val maxElementsElementsIndex = maxElementsElements.lastIndex\n      \
    \  val maxElementsElementsValue = maxElementsElements(maxElementsElementsIndex)\n\
    \        val maxElementsElementsElements = maxElementsElements.drop(maxElementsElementsIndex).takeWhile(x\
    \ => x <= maxElementsElementsValue)\n        val maxElementsElementsElementsIndex\
    \ = maxElementsElementsElements.lastIndex\n        val maxElementsElementsElementsValue\
    \ = maxElementsElementsElements(maxElementsElementsElementsIndex)\n        val\
    \ maxElementsElementsElementsElements = maxElementsElementsElements.drop(maxElementsElementsElementsIndex).takeWhile(x\
    \ => x <= maxElementsElementsElementsValue)\n        val maxElementsElementsElementsElementsIndex\
    \ = maxElementsElementsElementsElements.lastIndex\n        val maxElementsElementsElementsElementsValue\
    \ = maxElementsElementsElementsElements(maxElementsElementsElementsElementsIndex)\n\
    \        val maxElementsElementsElementsElementsElements = maxElementsElementsElementsElements.drop(maxElementsElementsElementsIndex).takeWhile(x\
    \ => x <= maxElementsElementsElementsValue)\n        val maxElementsElementsElementsElementsElementsIndex\
    \ = maxElementsElementsElementsElementsElements.lastIndex\n        val maxElementsElementsElementsElementsElementsValue\
    \ = maxElementsElementsElementsElementsElements(maxElementsElementsElementsElementsElementsIndex)\n\
    \        val maxElementsElementsElementsElementsElementsElements = maxElementsElementsElementsElementsElements.drop(maxElementsElementsElementsIndex).takeWhile(x\
    \ => x <= maxElementsElementsElementsValue)\n        val maxElementsElementsElementsElementsElementsElementsIndex\
    \ = max", "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0) + x))\n        val maxes = max.toList.sortBy(_._1).reverse\n\
    \        val maxesWithMax = maxes.takeWhile(_._2 > numbers.size).reverse\n   \
    \     val maxesWithMaxAndIndex = maxesWithMax.zipWithIndex.filter(_._2 > numbers.size).reverse\n\
    \        val maxesWithMaxAndIndexWithMax = maxesWithMaxAndIndex.map(_._1).reverse\n\
    \        val maxesWithMaxAndIndexWithMaxAndIndex = maxesWithMaxAndIndexWithMax.zipWithIndex.filter(_._2\
    \ > numbers.size).reverse\n        val maxesWithMaxAndIndexWithMaxAndIndexWithMax\
    \ = maxesWithMaxAndIndexWithMaxAndIndex.map(_._1).reverse\n        val maxesWithMaxAndIndexWithMaxAndIndexWithMaxAndIndex\
    \ = maxesWithMaxAndIndexWithMaxAndIndexWithMax.zipWithIndex.filter(_._2 > numbers.size).reverse\n\
    \        val maxesWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMax = maxesWithMaxAndIndexWithMaxAndIndexWithMaxAndIndex.map(_._1).reverse\n\
    \        val maxesWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMaxAndIndex\
    \ = maxesWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMax.zipWithIndex.filter(_._2\
    \ > numbers.size).reverse\n        val maxesWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMax\
    \ = maxesWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMaxAndIndex.map(_._1).reverse\n\
    \        val maxesWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMaxAndIndex\
    \ = maxesWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMax.zipWithIndex.filter(_._2\
    \ > numbers.size).reverse\n        val maxesWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMax\
    \ = maxesWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMaxAndIndex.map(_._1).reverse\n\
    \        val maxesWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMaxAndIndex\
    \ = maxesWithMax", "        val maxList = mutable.ListBuffer.empty[Long]\n   \
    \     val maxIndex = numbers.indexOf(0)\n        val maxValue = numbers(maxIndex)\n\
    \        numbers.foreach { number =>\n            if (number > maxValue) {\n \
    \               maxList += maxValue\n                maxIndex = numbers.indexOf(number)\
    \ + 1\n                maxValue = numbers(maxIndex)\n            }\n        }\n\
    \        maxList += maxValue\n        maxList.toList", "        val maxList =\
    \ mutable.ListBuffer[Long]()\n        val maxIndex = numbers.indexOf(0)\n    \
    \    while(maxIndex != -1) {\n            maxList += numbers(maxIndex)\n     \
    \       maxIndex -= 1\n        }\n        return maxList.toList", "        val\
    \ max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { n =>\n  \
    \          val maxKey = max max n\n            if (maxKey > n) max += n -> maxKey\n\
    \        }\n        max.values.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(x => max.put(x, if (max.contains(x)) max.get(x)\
    \ else x))\n        val result = new mutable.ListBuffer[Long]()\n        val current\
    \ = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x => {\n      \
    \      val max = current.getOrElse(x, 0)\n            val next = if (max.isDefined)\
    \ max.getOrElse(x, 0) + 1 else 1\n            current.put(x, next)\n         \
    \   if (next > numbers.size) result += x\n        })\n        result.toList",
  "        val rollingMax = mutable.ListBuffer.empty[Long]\n        val rollingMaxIndex\
    \ = mutable.ListBuffer.empty[Int]\n        numbers.foreach { number =>\n     \
    \       rollingMax.synchronized {\n                rollingMax.last match {\n \
    \                   case Some(max) =>\n                        rollingMaxIndex.synchronized\
    \ {\n                            rollingMaxIndex.last match {\n              \
    \                  case Some(index) =>\n                                    rollingMaxIndex.synchronized\
    \ {\n                                        rollingMaxIndex.last match {\n  \
    \                                          case Some(index) =>\n             \
    \                                   rollingMaxIndex.synchronized {\n         \
    \                                           rollingMaxIndex.last match {\n   \
    \                                                     case Some(index) =>\n  \
    \                                                          rollingMaxIndex.synchronized\
    \ {\n                                                                rollingMaxIndex.last\
    \ match {\n                                                                  \
    \  case Some(index) =>\n                                                     \
    \                   rollingMaxIndex.synchronized {\n                         \
    \                                                   rollingMaxIndex.last match\
    \ {\n                                                                        \
    \        case Some(index) =>\n                                               \
    \                                     rollingMaxIndex.synchronized {\n       \
    \                                                                            \
    \     rollingMaxIndex.last match {\n                                         \
    \                                                   case Some(index) =>\n    \
    \                                                                            \
    \                rollingMaxIndex.synchronized {\n                            \
    \                                                                        rollingMaxIndex.last\
    \ match {\n                                                                  \
    \                                      case Some(index) =>\n                 \
    \                                                                            \
    \               rollingMaxIndex.synchronized {\n                             \
    \                                                                            \
    \       rollingMaxIndex.last match {\n                                       \
    \                                                                            \
    \ case Some(index) =>\n                                                      \
    \                                                                  rollingMaxIndex.synchronized\
    \ {\n                                                                        \
    \                                                    rollingMaxIndex.last match\
    \ {\n                                                                        \
    \                                                                    case Some(index)\
    \ =>\n                                                                       \
    \                                                                         rollingMaxIndex.synchronized\
    \ {\n                                                                        \
    \                                                                            rollingMaxIndex.last\
    \ match {\n                                                                  \
    \                                                                            \
    \          case Some(index) =>\n                                             \
    \                                                                            \
    \                                   rollingMaxIndex.synchronized {\n         \
    \                                                                            \
    \                                                                           rollingMaxIndex.last\
    \ match {\n                                                                  \
    \                                                                            \
    \                      case Some(index) =>\n                                 \
    \                                                                            \
    \                                                           rollingMaxIndex.synchronized\
    \ {\n                                                                        \
    \                                                                            \
    \                        rollingMaxIndex.last match {\n                      \
    \                                                                            \
    \                                                                            \
    \  case Some(index) =>\n                                                     \
    \                                                                            \
    \                                                   rollingMaxIndex.synchronized\
    \ {\n                                                                        \
    \                                                                            \
    \                                    rollingMaxIndex.last match {\n          \
    \                                                                            \
    \                                                                            \
    \                          case Some(index) =>\n                             \
    \                                                                            \
    \                                                                            \
    \                                           rollingMaxIndex.synchronized {\n \
    \                                                                            \
    \                                                                            \
    \                                           rollingMaxIndex.last match {\n   \
    \                                                                            \
    \                                                                            \
    \                                             case Some(index) =>\n          \
    \                                                                            \
    \                                                                            \
    \                                                                          rollingMaxIndex.",
  "        val maxes = mutable.ListBuffer.empty[Long]\n        numbers.foreach{ n\
    \ =>\n            val maxIndex = maxes.indexWhere(x => x > n)\n            if\
    \ (maxIndex == -1) {\n                maxes += n\n            } else {\n     \
    \           maxes(maxIndex) = maxes(maxIndex) > n ? maxes(maxIndex) : n\n    \
    \        }\n        }\n        maxes.toList", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        val rollingMax = mutable.ListBuffer.empty[Long]\n        numbers.foreach(number\
    \ => {\n            rollingMax += number\n            if (rollingMax.size > maxList.size)\
    \ {\n                maxList += rollingMax.last\n                rollingMax.clear()\n\
    \            }\n        })\n        if (rollingMax.size > 0) {\n            maxList\
    \ += rollingMax.last\n        }\n        maxList.toList", "        val rollingMax\
    \ = mutable.ListBuffer.empty[Long]\n        var max = 0L\n        var index =\
    \ 0\n        numbers.foreach{n =>\n            max = math.max(max, n)\n      \
    \      rollingMax += max\n            index += 1\n        }\n        rollingMax.toList",
  "        val rollingMax = mutable.ListBuffer.empty[Long]\n        numbers.foreach{\
    \ number =>\n            rollingMax.clear()\n            rollingMax.push(number)\n\
    \            while(rollingMax.nonEmpty) {\n                rollingMax.lastOption\
    \ match {\n                    case Some(number) => rollingMax.lastOption match\
    \ {\n                        case Some(number) => rollingMax.lastOption match\
    \ {\n                            case Some(number) => rollingMax.lastOption match\
    \ {\n                                case Some(number) => rollingMax.lastOption\
    \ match {\n                                    case Some(number) => rollingMax.lastOption\
    \ match {\n                                        case Some(number) => rollingMax.lastOption\
    \ match {\n                                            case Some(number) => rollingMax.lastOption\
    \ match {\n                                                case Some(number) =>\
    \ rollingMax.lastOption match {\n                                            \
    \        case Some(number) => rollingMax.lastOption match {\n                \
    \                                        case Some(number) => rollingMax.lastOption\
    \ match {\n                                                            case Some(number)\
    \ => rollingMax.lastOption match {\n                                         \
    \                       case Some(number) => rollingMax.lastOption match {\n \
    \                                                                   case Some(number)\
    \ => rollingMax.lastOption match {\n                                         \
    \                               case Some(number) => rollingMax.lastOption match\
    \ {\n                                                                        \
    \    rollingMax.lastOption match {\n                                         \
    \                                       case Some(number) => rollingMax.lastOption\
    \ match {\n                                                                  \
    \                  case Some(number) => rollingMax.lastOption match {\n      \
    \                                                                            \
    \      case Some(number) => rollingMax.lastOption match {\n                  \
    \                                                                          case\
    \ Some(number) => rollingMax.lastOption match {\n                            \
    \                                                                    case Some(number)\
    \ => rollingMax.lastOption match {\n                                         \
    \                                                           case Some(number)\
    \ => rollingMax.lastOption match {\n                                         \
    \                                                               case Some(number)\
    \ => rollingMax.lastOption match {\n                                         \
    \                                                                   case Some(number)\
    \ => rollingMax.lastOption match {\n                                         \
    \                                                                       case Some(number)\
    \ => rollingMax.lastOption match {\n                                         \
    \                                                                           case\
    \ Some(number) => rollingMax.lastOption match {\n                            \
    \                                                                            \
    \                case Some(number) => rollingMax.lastOption match {\n        \
    \                                                                            \
    \                                        case Some(number) => rollingMax.lastOption\
    \ match {\n                                                                  \
    \                                                              case Some(number)\
    \ => rollingMax.lastOption match {\n                                         \
    \                                                                            \
    \               case Some(number) => rollingMax.lastOption match {\n         \
    \                                                                            \
    \                                                   case Some(number) => roll",
  "        val rollingMax = mutable.ListBuffer[Long]()\n        numbers.foreach {\
    \ number =>\n            val rollingMaxNumber = rollingMax.lastOption.orElse(number)\
    \ + number\n            rollingMax.append(rollingMaxNumber)\n        }\n     \
    \   rollingMax.toList", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        val rollingMaxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach\
    \ { number =>\n            val maxIndex = maxList.lastIndex\n            val maxValue\
    \ = maxList(maxIndex)\n            if (number > maxValue) {\n                maxList\
    \ += number\n                rollingMaxList += maxValue\n            }\n     \
    \   }\n        rollingMaxList.toList", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        var max = 0L\n        var maxIndex = 0\n        var currentMax = 0L\n\
    \        var currentMaxIndex = 0\n        var currentMaxIndex2 = 0\n        var\
    \ currentMaxIndex3 = 0\n        var currentMaxIndex4 = 0\n        var currentMaxIndex5\
    \ = 0\n        var currentMaxIndex6 = 0\n        var currentMaxIndex7 = 0\n  \
    \      var currentMaxIndex8 = 0\n        var currentMaxIndex9 = 0\n        var\
    \ currentMaxIndex10 = 0\n        var currentMaxIndex11 = 0\n        var currentMaxIndex12\
    \ = 0\n        var currentMaxIndex13 = 0\n        var currentMaxIndex14 = 0\n\
    \        var currentMaxIndex15 = 0\n        var currentMaxIndex16 = 0\n      \
    \  var currentMaxIndex17 = 0\n        var currentMaxIndex18 = 0\n        var currentMaxIndex19\
    \ = 0\n        var currentMaxIndex20 = 0\n        var currentMaxIndex21 = 0\n\
    \        var currentMaxIndex22 = 0\n        var currentMaxIndex23 = 0\n      \
    \  var currentMaxIndex24 = 0\n        var currentMaxIndex25 = 0\n        var currentMaxIndex26\
    \ = 0\n        var currentMaxIndex27 = 0\n        var currentMaxIndex28 = 0\n\
    \        var currentMaxIndex29 = 0\n        var currentMaxIndex30 = 0\n      \
    \  var currentMaxIndex31 = 0\n        var currentMaxIndex32 = 0\n        var currentMaxIndex33\
    \ = 0\n        var currentMaxIndex34 = 0\n        var currentMaxIndex35 = 0\n\
    \        var currentMaxIndex36 = 0\n        var currentMaxIndex37 = 0\n      \
    \  var currentMaxIndex38 = 0\n        var currentMaxIndex39 = 0\n        var currentMaxIndex40\
    \ = 0\n        var currentMaxIndex41 = 0\n        var currentMaxIndex42 = 0\n\
    \        var currentMaxIndex43 = 0\n        var currentMaxIndex44 = 0\n      \
    \  var currentMaxIndex45 = 0\n        var currentMaxIndex46 = 0\n        var currentMaxIndex47\
    \ = 0\n        var currentMaxIndex48 = 0\n        var currentMaxIndex49 = 0\n\
    \        var currentMaxIndex50 = 0\n        var currentMaxIndex51 = 0\n      \
    \  var currentMaxIndex52 = 0\n        var currentMaxIndex53 = 0\n        var currentMaxIndex54\
    \ = 0\n        var currentMaxIndex55 = 0\n        var currentMaxIndex56 = 0\n\
    \        var currentMaxIndex57 = 0\n        var currentMaxIndex58 = 0\n      \
    \  var currentMaxIndex59 = 0\n        var currentMaxIndex60 = 0\n        var currentMaxIndex61\
    \ = 0\n        var currentMaxIndex62 = 0\n        var currentMaxIndex63 = 0\n\
    \        var currentMaxIndex64 = 0\n        var currentMaxIndex65 = 0\n      \
    \  var currentMaxIndex66 = 0\n        var currentMaxIndex67 = 0\n        var currentMaxIndex68\
    \ = 0\n        var currentMaxIndex69 = 0\n        var ", "        val maxList\
    \ = mutable.ListBuffer.empty[Long]\n        val maxIndex = mutable.ListBuffer.empty[Int]\n\
    \        numbers.foreach { number =>\n            val index = maxIndex.last\n\
    \            if (number > maxList(index)) {\n                maxList += number\n\
    \                maxIndex += index\n            }\n        }\n        maxList.toList",
  "        val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach {\
    \ number =>\n            val maxIndex = maxList.lastIndex\n            if (maxIndex\
    \ == -1) {\n                maxList += number\n            } else {\n        \
    \        val maxValue = maxList(maxIndex)\n                if (number > maxValue)\
    \ {\n                    maxList += number\n                }\n            }\n\
    \        }\n        maxList.toList", "        val rollingMax = mutable.ListBuffer[Long]()\n\
    \        val currentMax = numbers.head\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxIndex\
    \ = numbers.indexOf(0)\n        val currentMaxIndex = numbers.indexOf(0)\n   \
    \     val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxIndex =\
    \ numbers.indexOf(0)\n        val currentMaxIndex = numbers.indexOf(0)\n     \
    \   val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxIndex\
    \ = numbers.indexOf(0)\n        val currentMaxIndex = numbers.indexOf(0)\n   \
    \     val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxIndex =\
    \ numbers.indexOf(0)\n        val currentMaxIndex = numbers.indexOf(0)\n     \
    \   val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxIndex\
    \ = numbers.indexOf(0)\n        val currentMaxIndex = numbers.indexOf(0)\n   \
    \     val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxIndex =\
    \ numbers.indexOf(0)\n        val currentMaxIndex = numbers.indexOf(0)\n     \
    \   val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxIndex\
    \ = numbers.indexOf(0)\n        val currentMaxIndex = numbers.indexOf(0)\n   \
    \     val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxIndex =\
    \ numbers.indexOf(0)\n        val currentMaxIndex = numbers.indexOf(0)\n     \
    \   val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxIndex\
    \ = numbers.indexOf(0)\n        val currentMaxIndex = numbers.indexOf(0)\n   \
    \     val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxIndex =\
    \ numbers.indexOf(0)\n        val currentMaxIndex = numbers.indexOf(0)\n     \
    \   val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxIndex\
    \ = numbers.indexOf(0)\n        val currentMaxIndex = numbers.indexOf(0)\n   \
    \     val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxIndex =\
    \ numbers.indexOf(0)\n        val currentMaxIndex = numbers.indexOf(0)\n     \
    \   val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxIndex\
    \ = numbers.indexOf(0)\n        val currentMaxIndex = numbers.indexOf(0)\n   \
    \     val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxIndex =\
    \ numbers.indexOf(0)\n        val current", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(x => max.put(x, max.getOrElse(x, 0) + x))\n\
    \        val maxList = max.toList.sortBy(_._1).reverse\n        val maxElement\
    \ = maxList.head._2\n        val maxElements = maxList.tail.filter(_._2 > maxElement)\n\
    \        val maxElementsUntilMoment = maxElements.takeWhile(_._2 < maxElement)\n\
    \        val maxElementsUntilMomentList = maxElementsUntilMoment.toList\n    \
    \    val maxElementsUntilMomentListWithIndex = maxElementsUntilMomentList\n  \
    \          .zipWithIndex\n            .sortBy(_._1)\n            .map(_._2)\n\
    \        val maxElementsUntilMomentListWithIndexList = maxElementsUntilMomentListWithIndex\n\
    \            .zipWithIndex\n            .map(_._1)\n        val maxElementsUntilMomentListWithIndexListWithIndex\
    \ = maxElementsUntilMomentListWithIndexList\n            .zipWithIndex\n     \
    \       .map(_._2)\n        val maxElementsUntilMomentListWithIndexListWithIndexList\
    \ = maxElementsUntilMomentListWithIndexListWithIndex\n            .zipWithIndex\n\
    \            .map(_._1)\n        val maxElementsUntilMomentListWithIndexListWithIndexListWithIndex\
    \ = maxElementsUntilMomentListWithIndexListWithIndexListWithIndex\n          \
    \  .zipWithIndex\n            .map(_._2)\n        val maxElementsUntilMomentListWithIndexListWithIndexListWithIndexList\
    \ = maxElementsUntilMomentListWithIndexListWithIndexListWithIndex\n          \
    \  .zipWithIndex\n            .map(_._1)\n        val maxElementsUntilMomentListWithIndexListWithIndexListWithIndexListWithIndex\
    \ = maxElementsUntilMomentListWithIndexListWithIndexListWithIndexListWithIndex\n\
    \            .zipWithIndex\n            .map(_._2)\n        val maxElementsUntilMomentListWithIndexListWithIndexListWithIndexListWithIndexList\
    \ = maxElementsUntilMomentListWithIndexListWithIndexListWithIndexListWithIndex\n\
    \            .zipWithIndex\n            .map(_._1)\n        val maxElementsUntilMomentListWithIndexListWithIndexListWithIndexListWithIndexListWithIndex\
    \ = maxElementsUntilMomentListWithIndexListWithIndexListWithIndexListWithIndexListWithIndex\n\
    \            .zipWithIndex\n            .map(_._2)\n        val maxElementsUntilMomentListWithIndexListWithIndexListWithIndexListWithIndexListWithIndexListWithIndex\
    \ = maxElementsUntil", "        val max = new mutable.HashMap[Long, Long]()\n\
    \        numbers.foreach { n =>\n            if (max.containsKey(n)) {\n     \
    \           val max = max.updated(n, max(n) + 1)\n            } else {\n     \
    \           val max = max.updated(n, 1)\n            }\n        }\n        val\
    \ maxList = max.values.toList\n        val maxIndex = max.keys.toList\n      \
    \  val maxElement = maxList.max\n        val maxIndex = maxIndex.max\n       \
    \ val maxElementIndex = maxIndex.min\n        val maxElementIndex = maxElementIndex.max\n\
    \        val maxElementIndex = maxElementIndex.min\n        val maxElementIndex\
    \ = maxElementIndex.max\n        val maxElementIndex = maxElementIndex.min\n \
    \       val maxElementIndex = maxElementIndex.max\n        val maxElementIndex\
    \ = maxElementIndex.min\n        val maxElementIndex = maxElementIndex.max\n \
    \       val maxElementIndex = maxElementIndex.min\n        val maxElementIndex\
    \ = maxElementIndex.max\n        val maxElementIndex = maxElementIndex.min\n \
    \       val maxElementIndex = maxElementIndex.max\n        val maxElementIndex\
    \ = maxElementIndex.min\n        val maxElementIndex = maxElementIndex.max\n \
    \       val maxElementIndex = maxElementIndex.min\n        val maxElementIndex\
    \ = maxElementIndex.max\n        val maxElementIndex = maxElementIndex.min\n \
    \       val maxElementIndex = maxElementIndex.max\n        val maxElementIndex\
    \ = maxElementIndex.min\n        val maxElementIndex = maxElementIndex.max\n \
    \       val maxElementIndex = maxElementIndex.min\n        val maxElementIndex\
    \ = maxElementIndex.max\n        val maxElementIndex = maxElementIndex.min\n \
    \       val maxElementIndex = maxElementIndex.max\n        val maxElementIndex\
    \ = maxElementIndex.min\n        val maxElementIndex = maxElementIndex.max\n \
    \       val maxElementIndex = maxElementIndex.min\n        val maxElementIndex\
    \ = maxElementIndex.max\n        val maxElementIndex = maxElementIndex.min\n \
    \       val maxElementIndex = maxElementIndex.max\n        val maxElementIndex\
    \ = maxElementIndex.min\n        val maxElementIndex = maxElementIndex.max\n \
    \       val maxElementIndex = maxElementIndex.min\n        val maxElementIndex\
    \ = maxElementIndex.max\n        val maxElementIndex = maxElementIndex.min\n \
    \       val maxElementIndex = maxElementIndex.max\n        val maxElementIndex\
    \ = maxElementIndex.min\n        val maxElementIndex = maxElementIndex.max\n \
    \       val max", "        val rollingMax = mutable.ListBuffer.empty[Long]\n \
    \       numbers.foreach { number =>\n            val rollingMaxElement = number\
    \ + rollingMax.last\n            rollingMax += rollingMaxElement\n        }\n\
    \        rollingMax.toList", "        val maxRolling = new mutable.ListBuffer[Long]()\n\
    \        var max = 0L\n        var rolling = 0L\n        numbers.foreach(n =>\
    \ {\n            rolling += n\n            max = Math.max(rolling, max)\n    \
    \        maxRolling.append(max)\n        })\n        return maxRolling", "   \
    \     val rollingMax = mutable.ListBuffer.empty[Long]\n        numbers.foreach\
    \ { number =>\n            rollingMax.append(number)\n            rollingMax.lastOption\
    \ match {\n                case Some(lastNumber) =>\n                    rollingMax.lastOption\
    \ match {\n                        case Some(lastNumber) =>\n                \
    \            rollingMax.lastOption match {\n                                case\
    \ Some(lastNumber) =>\n                                    rollingMax.lastOption\
    \ match {\n                                        case Some(lastNumber) =>\n\
    \                                            rollingMax.lastOption match {\n \
    \                                               case Some(lastNumber) =>\n   \
    \                                                 rollingMax.lastOption match\
    \ {\n                                                        case Some(lastNumber)\
    \ =>\n                                                            rollingMax.lastOption\
    \ match {\n                                                                case\
    \ Some(lastNumber) =>\n                                                      \
    \              rollingMax.lastOption match {\n                               \
    \                                         case Some(lastNumber) =>\n         \
    \                                                                   rollingMax.lastOption\
    \ match {\n                                                                  \
    \              case Some(lastNumber) =>\n                                    \
    \                                                rollingMax.lastOption match {\n\
    \                                                                            \
    \            case Some(lastNumber) =>\n                                      \
    \                                                      rollingMax.lastOption match\
    \ {\n                                                                        \
    \                        case Some(lastNumber) =>\n                          \
    \                                                                          rollingMax.lastOption\
    \ match {\n                                                                  \
    \                                      case Some(lastNumber) =>\n            \
    \                                                                            \
    \                    rollingMax.lastOption match {\n                         \
    \                                                                            \
    \           case Some(lastNumber) =>\n                                       \
    \                                                                            \
    \ rollingMax.lastOption match {\n                                            \
    \                                                                            case\
    \ Some(lastNumber) =>\n                                                      \
    \                                                                      rollingMax.lastOption\
    \ match {\n                                                                  \
    \                                                              case Some(lastNumber)\
    \ =>\n                                                                       \
    \                                                             rollingMax.lastOption\
    \ match {\n                                                                  \
    \                                                                      case Some(lastNumber)\
    \ =>\n                                                                       \
    \                                                                     rollingMax.lastOption\
    \ match {\n                                                                  \
    \                                                                            \
    \  case Some(lastNumber) =>\n                                                \
    \                                                                            \
    \                        rollingMax.lastOption match {\n                     \
    \                                                                            \
    \                                                       case Some(lastNumber)\
    \ =>\n                                                                       \
    \                                                                            \
    \         rollingMax.lastOption match {\n                                    \
    \                                                                            \
    \                                                case Some(lastNumber) =>\n  \
    \                                                                            \
    \                                                                            \
    \          rollingMax.lastOption match {\n                                   \
    \                                                                            \
    \                                                         case Some(lastNumber)\
    \ =>\n                                                                       \
    \                                                                            \
    \                         rollingMax.lastOption match {\n                    \
    \                                                                            \
    \                                                                            \
    \    case Some(lastNumber) =>\n                                              \
    \                                                                            \
    \                                                          rollingMax.lastOption\
    \ match {\n                                                                  \
    \                                                                            \
    \                                          case Some(lastNumber) =>\n        \
    \                                                                            \
    \                                                                            \
    \                            rollingMax.lastOption match {\n                 \
    \                                                                            \
    \                                                                            \
    \                       case Some(lastNumber) =>\n", "        val maxList = new\
    \ mutable.ListBuffer[Long]()\n        var max = 0L\n        var index = 0\n  \
    \      for(i <- 0 until numbers.size) {\n            val currentMax = numbers(i)\n\
    \            val currentIndex = i\n            val currentMaxIndex = index\n \
    \           val currentMaxValue = max\n            val currentMaxIndexValue =\
    \ maxList.size\n            val currentMaxValueIndex = maxList.indexOf(max)\n\
    \            val currentMaxValueValue = maxList.getOrElse(currentMaxIndexValue,\
    \ 0)\n            val currentMaxValueIndexValue = maxList.indexOf(currentMaxValue)\n\
    \            val currentMaxValueValueValue = maxList.getOrElse(currentMaxValueIndexValue,\
    \ 0)\n            val currentMaxValueIndexValueValue = maxList.indexOf(currentMaxValueValue)\n\
    \            val currentMaxValueValueValueValue = maxList.getOrElse(currentMaxValueIndexValueValue,\
    \ 0)\n            val currentMaxValueIndexValueValueValue = maxList.indexOf(currentMaxValueValueValue)\n\
    \            val currentMaxValueValueValueValueValue = maxList.getOrElse(currentMaxValueIndexValueValueValue,\
    \ 0)\n            val currentMaxValueIndexValueValueValueValue = maxList.indexOf(currentMaxValueValueValueValue)\n\
    \            val currentMaxValueValueValueValueValueValue = maxList.getOrElse(currentMaxValueIndexValueValueValueValue,\
    \ 0)\n            val currentMaxValueIndexValueValueValueValueValue = maxList.indexOf(currentMaxValueValueValueValueValue)\n\
    \            val currentMaxValueValueValueValueValueValueValue = maxList.getOrElse(currentMaxValueIndexValueValueValueValueValue,\
    \ 0)\n            val currentMaxValueIndexValueValueValueValueValueValue = maxList.indexOf(currentMaxValueValueValueValueValueValue)\n\
    \            val currentMaxValueValueValueValueValueValueValueValue = maxList.getOrElse(currentMaxValueIndexValueValueValueValueValueValue,\
    \ 0)\n            val currentMaxValueIndexValueValueValueValueValueValue = maxList.indexOf(currentMaxValueValueValueValueValueValue)\n\
    \            val currentMaxValueValueValueValueValueValueValueValue = maxList.getOrElse(currentMaxValueIndexValueValueValueValueValueValueValue,\
    \ 0)\n            val currentMaxValueIndexValueValueValueValueValueValueValue\
    \ = maxList.indexOf(currentMaxValueValueValueValueValueValue)\n            val\
    \ currentMaxValueValueValueValueValueValueValueValueValue = maxList.getOrElse(currentMaxValueIndexValueValueValueValueValueValueValueValue,\
    \ 0)\n            val currentMaxValueIndexValueValueValueValueValueValueValueValue\
    \ = maxList.indexOf(currentMaxValueValueValueValueValueValue)\n            val\
    \ currentMaxValueValueValueValue", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(x => max.put(x, max.getOrElse(x, 0) + x))\n\
    \        max.values.toList.sortWith(_ < _)", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(x => max.put(x, Math.max(max.getOrElse(x, 0),\
    \ x)))\n        max.values.toList", "        val rollingMax = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach(x => rollingMax += x)\n        rollingMax.toList", " \
    \       val rollingMax = mutable.ListBuffer[Long]()\n        numbers.foreach {\
    \ number =>\n            rollingMax += number\n        }\n        rollingMax.toList",
  "        val rollingMax = mutable.ListBuffer.empty[Long]\n        var max = 0L\n\
    \        var maxIndex = 0\n        numbers.foreach{ n =>\n            max = Math.max(max,\
    \ n)\n            rollingMax += max\n        }\n        rollingMax.toList", " \
    \       val rollingMax = mutable.ListBuffer.empty[Long]\n        numbers.foreach\
    \ { number =>\n            rollingMax.append(math.max(rollingMax.last, number))\n\
    \        }\n        rollingMax.toList", "        val maxRolling = new mutable.ListBuffer[Long]()\n\
    \        numbers.foreach { number =>\n            val rollingMax = math.max(number,\
    \ maxRolling.last)\n            maxRolling.append(rollingMax)\n        }\n   \
    \     return maxRolling.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(x => max.put(x, max.getOrElse(x, 0L) + x))\n\
    \        val maxList = max.toList\n        val rollingMax = maxList.sliding(numbers.size)\n\
    \        rollingMax.map(x => x.max).reverse", "        val rollingMax = mutable.ListBuffer[Long]()\n\
    \        val rollingMaxIndex = mutable.ListBuffer[Int]()\n        val rollingMaxIndex\
    \ = numbers.zipWithIndex.foreach { case (number, index) =>\n            rollingMax.add(number)\n\
    \            rollingMaxIndex.add(index)\n        }\n        rollingMaxIndex.foreach\
    \ { index =>\n            val rollingMaxIndex = rollingMaxIndex.drop(index)\n\
    \            val rollingMaxIndex = rollingMaxIndex.dropRight(1)\n            val\
    \ rollingMaxIndex = rollingMaxIndex.dropRight(1)\n            val rollingMaxIndex\
    \ = rollingMaxIndex.dropRight(1)\n            val rollingMaxIndex = rollingMaxIndex.dropRight(1)\n\
    \            val rollingMaxIndex = rollingMaxIndex.dropRight(1)\n            val\
    \ rollingMaxIndex = rollingMaxIndex.dropRight(1)\n            val rollingMaxIndex\
    \ = rollingMaxIndex.dropRight(1)\n            val rollingMaxIndex = rollingMaxIndex.dropRight(1)\n\
    \            val rollingMaxIndex = rollingMaxIndex.dropRight(1)\n            val\
    \ rollingMaxIndex = rollingMaxIndex.dropRight(1)\n            val rollingMaxIndex\
    \ = rollingMaxIndex.dropRight(1)\n            val rollingMaxIndex = rollingMaxIndex.dropRight(1)\n\
    \            val rollingMaxIndex = rollingMaxIndex.dropRight(1)\n            val\
    \ rollingMaxIndex = rollingMaxIndex.dropRight(1)\n            val rollingMaxIndex\
    \ = rollingMaxIndex.dropRight(1)\n            val rollingMaxIndex = rollingMaxIndex.dropRight(1)\n\
    \            val rollingMaxIndex = rollingMaxIndex.dropRight(1)\n            val\
    \ rollingMaxIndex = rollingMaxIndex.dropRight(1)\n            val rollingMaxIndex\
    \ = rollingMaxIndex.dropRight(1)\n            val rollingMaxIndex = rollingMaxIndex.dropRight(1)\n\
    \            val rollingMaxIndex = rollingMaxIndex.dropRight(1)\n            val\
    \ rollingMaxIndex = rollingMaxIndex.dropRight(1)\n            val rollingMaxIndex\
    \ = rollingMaxIndex.dropRight(1)\n            val rollingMaxIndex = rollingMaxIndex.dropRight(1)\n\
    \            val rollingMaxIndex = rollingMaxIndex.dropRight(1)\n            val\
    \ rollingMaxIndex = rollingMaxIndex.dropRight(1)\n            val rollingMaxIndex\
    \ = rollingMaxIndex.dropRight(1)\n            val rollingMaxIndex = rollingMaxIndex.drop",
  "        val maxRolling = new mutable.ListBuffer[Long]()\n        val maxRollingIndex\
    \ = new mutable.ListBuffer[Int]()\n        val maxRollingIndexIndex = new mutable.ListBuffer[Int]()\n\
    \        numbers.foreach { number =>\n            if (maxRolling.length < number)\
    \ {\n                maxRolling.append(number)\n                maxRollingIndex.append(0)\n\
    \                maxRollingIndexIndex.append(0)\n            } else {\n      \
    \          val maxRollingIndex = maxRollingIndexIndex.last\n                val\
    \ maxRollingIndexIndex = maxRollingIndexIndex.last\n                if (maxRollingIndexIndex\
    \ < number - maxRollingIndex + 1) {\n                    maxRolling.append(number)\n\
    \                    maxRollingIndex.append(maxRollingIndexIndex + 1)\n      \
    \              maxRollingIndexIndex.append(number - maxRollingIndex + 1)\n   \
    \             } else {\n                    maxRolling.append(maxRolling(maxRollingIndexIndex))\n\
    \                    maxRollingIndex.append(maxRollingIndexIndex + 1)\n      \
    \              maxRollingIndexIndex.append(0)\n                }\n           \
    \ }\n        }\n        maxRolling", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach(x => maxList += x)\n        val maxIndex = maxList.indexOf(maxList.max)\n\
    \        maxList.take(maxIndex + 1).reverse", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(x => max.put(x, max.getOrElse(x, 0) + x))\n\
    \        val maxes = max.toList.sortBy(_._2).reverse.takeWhile(_._2 > 0)\n   \
    \     val result: List[Long] = maxes.map(x => x._1)\n        result", "      \
    \  val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x => max.put(x,\
    \ max.getOrElse(x, 0) + x))\n        max.values.toList", "        val maxList\
    \ = mutable.ListBuffer[Long]()\n        numbers.foreach(x => maxList += x)\n \
    \       val maxIndex = maxList.indexOf(maxList.max)\n        val maxElement =\
    \ maxList.take(maxIndex).max\n        maxList.drop(maxIndex).takeWhile(x => x\
    \ <= maxElement).reverse", "        val rollingMax = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach(rollingMax.append(_))\n        rollingMax.toList", " \
    \       val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0) + x))\n        val result: List[Long] = new\
    \ mutable.ListBuffer[Long]()\n        max.values.foreach(x => if (x > 0) result\
    \ += x)\n        result.toList", "        val maxes = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach { number =>\n            val maxIndex = numbers.indexWhere(x\
    \ => x > number)\n            if (maxIndex > 0) {\n                maxes += numbers(maxIndex\
    \ - 1)\n            }\n        }\n        maxes", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach { n =>\n            val max = max.getOrElseUpdate(n,\
    \ 0L)\n            max.update(n + n, n)\n        }\n        val maxList = max.toList\n\
    \        val maxListWithMax = maxList.map { case (k, v) => k -> v }\n        val\
    \ maxListWithMaxSorted = maxListWithMax.sortBy(_._1)\n        val maxListWithMaxSortedWithMax\
    \ = maxListWithMaxSorted.take(numbers.size).toList\n        maxListWithMaxSortedWithMax",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0) + x))\n        val result = new mutable.ListBuffer[Long]()\n\
    \        max.foreach(x => result += max.getOrElse(x, 0))\n        result.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        val rollingMax = new\
    \ mutable.ArrayList[Long]()\n        numbers.foreach(n => {\n            val maxKey\
    \ = max.minKey()\n            if (maxKey == null || n > maxKey) {\n          \
    \      max.put(n, n)\n            } else {\n                val maxValue = max.getOrElse(n,\
    \ 0L)\n                max.put(n, maxValue + n)\n            }\n        })\n \
    \       rollingMax.clear()\n        max.foreach(n => {\n            val maxKey\
    \ = max.minKey()\n            if (maxKey == null || n > maxKey) {\n          \
    \      rollingMax.add(n)\n            }\n        })\n        rollingMax.toList",
  "        val maxRolling = new mutable.ListBuffer[Long]()\n        var max = 0L\n\
    \        var rolling = 0L\n        numbers.foreach(n => {\n            if (rolling\
    \ == 0) {\n                max = n\n                maxRolling.clear()\n     \
    \           maxRolling.append(max)\n                rolling = 1\n            }\
    \ else {\n                if (n > max) {\n                    max = n\n      \
    \              maxRolling.clear()\n                    maxRolling.append(max)\n\
    \                    rolling = 1\n                } else {\n                 \
    \   rolling += 1\n                }\n            }\n        })\n        return\
    \ maxRolling.toList", "        val max = new mutable.HashMap[Long, Long]()\n \
    \       numbers.foreach { n =>\n            val maxKey = max.maxKey\n        \
    \    if (maxKey == null || n < maxKey) {\n                max.put(n, n)\n    \
    \        } else {\n                val maxValue = max.get(maxKey)\n          \
    \      if (maxValue == null || n > maxValue) {\n                    max.put(maxKey,\
    \ n)\n                }\n            }\n        }\n        max.values.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0) + x))\n        max.values.toList", "     \
    \   val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, if (max.getOrElse(x, 0) > x) max.getOrElse(x, 0) + 1 else 1))\n \
    \       max.values.toList.sortWith(_ < _)", "        val rollingMax = mutable.ListBuffer[Long]()\n\
    \        numbers.foreach { number =>\n            rollingMax.append(number)\n\
    \            rollingMax.lastOption.append(number)\n        }\n        rollingMax.toList",
  "        val rollingMax = mutable.ListBuffer.empty[Long]\n        numbers.foreach(rollingMax.append(_))\n\
    \        rollingMax.toList", "        val maxRolling = new mutable.ListBuffer[Long]()\n\
    \        numbers.foreach { number =>\n            val maxIndex = numbers.indexOf(Math.max(number,\
    \ maxRolling.last))\n            if (maxIndex == -1) {\n                maxRolling.append(number)\n\
    \            } else {\n                maxRolling.append(numbers(maxIndex))\n\
    \            }\n        }\n        return maxRolling.toList", "        val rollingMax\
    \ = mutable.ListBuffer[Long]()\n        numbers.foreach { number =>\n        \
    \    rollingMax.append(number)\n        }\n        rollingMax.reverse.takeWhile(number\
    \ => number <= numbers.last).reverse", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        val maxIndex = mutable.ListBuffer.empty[Int]\n        numbers.foreach\
    \ { number =>\n            val index = maxIndex.lastOption.orElse(maxIndex.size\
    \ + 1)\n            val maxValue = math.max(number, maxList.get(index))\n    \
    \        maxList += maxValue\n            maxIndex += index\n        }\n     \
    \   maxList.toList", "        val maxList = mutable.ListBuffer.empty[Long]\n \
    \       var max = 0L\n        var current = 0L\n        var index = 0\n      \
    \  while(index < numbers.size) {\n            max = numbers(index)\n         \
    \   current = numbers(index + 1)\n            index += 1\n            while(current\
    \ > max) {\n                maxList += max\n                max += 1L\n      \
    \      }\n        }\n        return maxList.toList", "        val maxList = mutable.ListBuffer[Long]()\n\
    \        val rollingMax = mutable.ListBuffer[Long]()\n        val rollingMaxIndex\
    \ = mutable.ListBuffer[Int]()\n        numbers.foreach(x => {\n            rollingMax.append(x)\n\
    \            rollingMaxIndex.append(0)\n        })\n        rollingMax.foreach(x\
    \ => {\n            val maxIndex = rollingMaxIndex.last\n            val maxValue\
    \ = rollingMax.last\n            if (maxValue > x) {\n                maxList.append(maxValue)\n\
    \                maxList.append(x)\n                maxList.append(maxIndex)\n\
    \                maxList.append(maxIndex + 1)\n                maxList.append(maxIndex\
    \ + 2)\n                maxList.append(maxIndex + 3)\n                maxList.append(maxIndex\
    \ + 4)\n                maxList.append(maxIndex + 5)\n                maxList.append(maxIndex\
    \ + 6)\n                maxList.append(maxIndex + 7)\n                maxList.append(maxIndex\
    \ + 8)\n                maxList.append(maxIndex + 9)\n                maxList.append(maxIndex\
    \ + 10)\n                maxList.append(maxIndex + 11)\n                maxList.append(maxIndex\
    \ + 12)\n                maxList.append(maxIndex + 13)\n                maxList.append(maxIndex\
    \ + 14)\n                maxList.append(maxIndex + 15)\n                maxList.append(maxIndex\
    \ + 16)\n                maxList.append(maxIndex + 17)\n                maxList.append(maxIndex\
    \ + 18)\n                maxList.append(maxIndex + 19)\n                maxList.append(maxIndex\
    \ + 20)\n                maxList.append(maxIndex + 21)\n                maxList.append(maxIndex\
    \ + 22)\n                maxList.append(maxIndex + 23)\n                maxList.append(maxIndex\
    \ + 24)\n                maxList.append(maxIndex + 25)\n                maxList.append(maxIndex\
    \ + 26)\n                maxList.append(maxIndex + 27)\n                maxList.append(maxIndex\
    \ + 28)\n                maxList.append(maxIndex + 29)\n                maxList.append(maxIndex\
    \ + 30)\n                maxList.append(maxIndex + 31)\n                maxList.append(maxIndex\
    \ + 32)\n                maxList.append(maxIndex + 33)\n                maxList.append(maxIndex\
    \ + 34)\n                maxList.append(maxIndex + 35)\n                maxList.append(maxIndex\
    \ + 36)\n                maxList.append(maxIndex + 37)\n                maxList.append(maxIndex\
    \ + 38)\n                maxList.append(maxIndex + 39)\n                maxList.append(maxIndex\
    \ + 40)\n                maxList.append(maxIndex + 41)\n                maxList.append(maxIndex\
    \ + 42)\n                maxList.append(maxIndex + 43)\n                maxList.append(maxIndex\
    \ + 44)\n                maxList.append(maxIndex + 45)\n                maxList.append(maxIndex\
    \ + 46)\n                maxList.append(maxIndex", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        val rollingMax = new mutable.ListBuffer[Long]()\n        numbers.foreach\
    \ { number =>\n            val maxKey = max + (number % max.getOrElse(number,\
    \ number))\n            if (maxKey > number) {\n                max.remove(maxKey)\n\
    \                rollingMax += maxKey\n            }\n            max += (number\
    \ % max.getOrElse(number, number))\n        }\n        rollingMax.toList", " \
    \       val rollingMax = mutable.ListBuffer.empty[Long]\n        numbers.foreach(rollingMax.append(_))\n\
    \        rollingMax.toList", "        val rollingMax = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach { number =>\n            rollingMax.append(number)\n\
    \            if (rollingMax.size > rollingMax.last)\n                rollingMax.last\
    \ = max(rollingMax.last, rollingMax.last)\n        }\n        rollingMax.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0) + x))\n        val result: List[Long] = new\
    \ mutable.ListBuffer[Long]()\n        max.foreach {\n            case (k, v) =>\
    \ if (v > 0) result += k\n        }\n        result.toList", "        val max\
    \ = new mutable.HashMap[Long, Long]()\n        val rollingMax = new mutable.ListBuffer[Long]()\n\
    \        numbers.foreach(x => max.put(x, max.getOrElse(x, 0) + x))\n        max.foreach\
    \ { case (k, v) => rollingMax += v }\n        rollingMax.toList", "        val\
    \ maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach(x => maxList\
    \ += x)\n        val maxIndex = maxList.size - 1\n        val maxElement = maxList(maxIndex)\n\
    \        val maxElements = maxList.take(maxIndex + 1)\n        val maxElementsUntilMoment\
    \ = maxList.drop(maxIndex + 1)\n        val rollingMax = maxElements.foldLeft(maxElement)(_\
    \ + _)\n        rollingMax.zip(maxElementsUntilMoment).map(x => x._1 + x._2)",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0L) + x))\n        val maxList = max.toList.sortBy(_._1).reverse\n\
    \        val rollingMax = maxList.takeWhile(_._2 > numbers(0)).map(_._1)\n   \
    \     rollingMax", "        val max = new mutable.HashMap[Long, Long]()\n    \
    \    numbers.foreach(x => max.put(x, max.getOrElse(x, 0) + x))\n        max.values.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(n\
    \ => {\n            if (max.containsKey(n)) {\n                max.update(n, max(max(n),\
    \ n))\n            } else {\n                max.update(n, n)\n            }\n\
    \        })\n        max.values.toList", "        val maxes = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach{ number =>\n            val maxIndex = maxes.indexWhere(_\
    \ > number)\n            if (maxIndex == -1) {\n                maxes += number\n\
    \            } else {\n                maxes(maxIndex) = max(maxes(maxIndex),\
    \ number)\n            }\n        }\n        maxes.toList", "        val rollingMax\
    \ = mutable.ListBuffer.empty[Long]\n        numbers.foreach { number =>\n    \
    \        val maxIndex = rollingMax.lastIndex\n            rollingMax.updated(maxIndex,\
    \ number)\n        }\n        rollingMax.toList", "        val maxes = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach { n =>\n            val maxIndex = maxes.indexWhere(x\
    \ => x > n)\n            if (maxIndex == -1) maxes += n\n            else maxes(maxIndex)\
    \ = max(maxes(maxIndex), n)\n        }\n        maxes.toList", "        val maxRollingNumbers\
    \ = mutable.ListBuffer.empty[Long]\n        var maxRollingNumber = 0L\n      \
    \  var currentMax = 0L\n        numbers.foreach{ number =>\n            currentMax\
    \ = math.max(currentMax, number)\n            maxRollingNumbers += currentMax\n\
    \        }\n        return maxRollingNumbers", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach { x =>\n            val maxKey = max + (x ->\
    \ x)\n            if (maxKey._2 > x)\n                max += (x -> x)\n      \
    \  }\n        max.values.toList", "        val rollingMax = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach(number => rollingMax += math.max(number))\n        rollingMax.toList",
  "        val rollingMax = mutable.ListBuffer.empty[Long]\n        numbers.foreach(rollingMax.append(_))\n\
    \        rollingMax.toList", "        val max = new mutable.HashMap[Long, Long]()\n\
    \        numbers.foreach(n => {\n            val maxKey = max.max.key\n      \
    \      if (maxKey == null || n > maxKey) {\n                max.put(n, n)\n  \
    \          } else {\n                val maxValue = max.max.value\n          \
    \      if (maxValue == null || n > maxValue) {\n                    max.put(n,\
    \ maxValue)\n                } else {\n                    val maxKeyValue = max.max.keyValue\n\
    \                    if (maxKeyValue == null || n > maxKeyValue) {\n         \
    \               max.put(n, maxKeyValue)\n                    } else {\n      \
    \                  val maxKeyValueValue = max.max.keyValueValue\n            \
    \            if (maxKeyValueValue == null || n > maxKeyValueValue) {\n       \
    \                     max.put(n, maxKeyValueValue)\n                        }\
    \ else {\n                            val maxKeyValueValueValue = max.max.keyValueValueValue\n\
    \                            if (maxKeyValueValueValue == null || n > maxKeyValueValueValue)\
    \ {\n                                max.put(n, maxKeyValueValueValue)\n     \
    \                       } else {\n                                val maxKeyValueValueValueValue\
    \ = max.max.keyValueValueValueValue\n                                if (maxKeyValueValueValueValue\
    \ == null || n > maxKeyValueValueValueValue) {\n                             \
    \       max.put(n, maxKeyValueValueValueValue)\n                             \
    \   } else {\n                                    val maxKeyValueValueValueValueValue\
    \ = max.max.keyValueValueValueValueValue\n                                   \
    \ if (maxKeyValueValueValueValueValue == null || n > maxKeyValueValueValueValueValue)\
    \ {\n                                        max.put(n, maxKeyValueValueValueValueValue)\n\
    \                                    } else {\n                              \
    \          val maxKeyValueValueValueValueValueValue = max.max.keyValueValueValueValueValueValue\n\
    \                                        if (maxKeyValueValueValueValueValueValue\
    \ == null || n > maxKeyValueValueValueValueValueValue) {\n                   \
    \                         max.put(n, maxKeyValueValueValueValueValueValue)\n \
    \                                       } else {\n                           \
    \                 val maxKeyValueValueValueValueValueValueValue = max.max.keyValueValueValueValueValueValueValue\n\
    \                                            if (maxKeyValueValueValueValueValueValueValue\
    \ == null || n > maxKeyValueValueValueValueValueValueValue) {\n              \
    \                                  max.put(n, maxKeyValueValueValueValueValueValueValue)\n\
    \                                            } else {\n                      \
    \                          val maxKeyValueValueValueValueValueValueValueValue\
    \ = max.max.keyValueValueValueValueValueValueValueValue\n                    \
    \                            if (maxKeyValueValueValueValueValueValueValueValue\
    \ == null || n > maxKeyValueValueValueValueValueValueValueValue) {\n         \
    \                                           max.put(n, maxKeyValueValueValueValueValueValueValueValue)\n\
    \                                                } else {\n                  \
    \                                  val maxKeyValueValueValueValueValueValueValueValueValue\
    \ = max.max.keyValueValueValueValueValueValueValueValueValue\n               \
    \                                     if (maxKeyValueValueValueValueValueValueValue",
  "        val maxRolling = new mutable.ListBuffer[Long]()\n        numbers.foreach(x\
    \ => {\n            val maxIndex = maxRolling.lastIndex\n            val maxValue\
    \ = maxRolling.last\n            if (x > maxValue) {\n                maxRolling.clear()\n\
    \                maxRolling.append(x)\n            } else if (x == maxValue) {\n\
    \                maxRolling.append(x)\n            } else {\n                maxRolling.insert(maxIndex\
    \ + 1, x)\n            }\n        })\n        maxRolling.toList", "        val\
    \ rollingMax = mutable.ListBuffer.empty[Long]\n        val rollingMaxIndex = mutable.ListBuffer.empty[Int]\n\
    \        numbers.foreach { number =>\n            rollingMax.add(number)\n   \
    \         rollingMaxIndex += number\n        }\n        rollingMax.foreach { number\
    \ =>\n            val index = rollingMaxIndex.indexOf(number)\n            if\
    \ (index != -1) {\n                rollingMaxIndex.remove(index)\n           \
    \     rollingMax.add(number)\n            }\n        }\n        rollingMax.toList",
  "        val maxList = mutable.ListBuffer[Long]()\n        numbers.foreach { number\
    \ =>\n            val maxIndex = maxList.lastIndex\n            if (maxIndex ==\
    \ -1) {\n                maxList += number\n            } else {\n           \
    \     maxList += maxList.last\n            }\n        }\n        maxList.toList",
  "        val rollingMax = mutable.ListBuffer[Long]()\n        numbers.foreach {\
    \ number =>\n            val rollingMaxNumber = rollingMax.last\n            if\
    \ (rollingMaxNumber < number) {\n                rollingMax.append(number)\n \
    \           } else {\n                rollingMax.append(rollingMaxNumber)\n  \
    \          }\n        }\n        rollingMax.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(x => max.put(x, max.getOrElse(x, 0L) + x))\n\
    \        val maxes = max.toList.sortBy(_._2).reverse\n        val maxesWithMax\
    \ = maxes.takeWhile(_._2 > numbers(0)).map(_._1)\n        val maxesWithMaxAndIndex\
    \ = maxes.zipWithIndex.filter(_._2 > numbers(0)).map(_._1)\n        val maxesWithMaxAndIndex\
    \ = maxes.zipWithIndex.filter(_._2 > numbers(0)).map(_._1)\n        val maxesWithMaxAndIndex\
    \ = maxes.zipWithIndex.filter(_._2 > numbers(0)).map(_._1)\n        val maxesWithMaxAndIndex\
    \ = maxes.zipWithIndex.filter(_._2 > numbers(0)).map(_._1)\n        val maxesWithMaxAndIndex\
    \ = maxes.zipWithIndex.filter(_._2 > numbers(0)).map(_._1)\n        val maxesWithMaxAndIndex\
    \ = maxes.zipWithIndex.filter(_._2 > numbers(0)).map(_._1)\n        val maxesWithMaxAndIndex\
    \ = maxes.zipWithIndex.filter(_._2 > numbers(0)).map(_._1)\n        val maxesWithMaxAndIndex\
    \ = maxes.zipWithIndex.filter(_._2 > numbers(0)).map(_._1)\n        val maxesWithMaxAndIndex\
    \ = maxes.zipWithIndex.filter(_._2 > numbers(0)).map(_._1)\n        val maxesWithMaxAndIndex\
    \ = maxes.zipWithIndex.filter(_._2 > numbers(0)).map(_._1)\n        val maxesWithMaxAndIndex\
    \ = maxes.zipWithIndex.filter(_._2 > numbers(0)).map(_._1)\n        val maxesWithMaxAndIndex\
    \ = maxes.zipWithIndex.filter(_._2 > numbers(0)).map(_._1)\n        val maxesWithMaxAndIndex\
    \ = maxes.zipWithIndex.filter(_._2 > numbers(0)).map(_._1)\n        val maxesWithMaxAndIndex\
    \ = maxes.zipWithIndex.filter(_._2 > numbers(0)).map(_._1)\n        val maxesWithMaxAndIndex\
    \ = maxes.zipWithIndex.filter(_._2 > numbers(0)).map(_._1)\n        val maxesWithMaxAndIndex\
    \ = maxes.zipWithIndex.filter(_._2 > numbers(", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach { number =>\n            val maxIndex = maxList.lastIndex\n\
    \            if (maxIndex == -1) {\n                maxList += number\n      \
    \      } else {\n                maxList += maxList[maxIndex] + number\n     \
    \       }\n        }\n        maxList.toList", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach(x => maxList += x)\n        val maxIndex = maxList.lastIndex\n\
    \        val maxElement = maxList(maxIndex)\n        val maxList = maxList.drop(maxIndex)\n\
    \        val maxList2 = maxList.takeRight(numbers.size)\n        val maxList3\
    \ = maxList2.takeRight(numbers.size)\n        val maxList4 = maxList3.takeRight(numbers.size)\n\
    \        val maxList5 = maxList4.takeRight(numbers.size)\n        val maxList6\
    \ = maxList5.takeRight(numbers.size)\n        val maxList7 = maxList6.takeRight(numbers.size)\n\
    \        val maxList8 = maxList7.takeRight(numbers.size)\n        val maxList9\
    \ = maxList8.takeRight(numbers.size)\n        val maxList10 = maxList9.takeRight(numbers.size)\n\
    \        val maxList11 = maxList10.takeRight(numbers.size)\n        val maxList12\
    \ = maxList11.takeRight(numbers.size)\n        val maxList13 = maxList12.takeRight(numbers.size)\n\
    \        val maxList14 = maxList13.takeRight(numbers.size)\n        val maxList15\
    \ = maxList14.takeRight(numbers.size)\n        val maxList16 = maxList15.takeRight(numbers.size)\n\
    \        val maxList17 = maxList16.takeRight(numbers.size)\n        val maxList18\
    \ = maxList17.takeRight(numbers.size)\n        val maxList19 = maxList18.takeRight(numbers.size)\n\
    \        val maxList20 = maxList19.takeRight(numbers.size)\n        val maxList21\
    \ = maxList20.takeRight(numbers.size)\n        val maxList22 = maxList21.takeRight(numbers.size)\n\
    \        val maxList23 = maxList22.takeRight(numbers.size)\n        val maxList24\
    \ = maxList23.takeRight(numbers.size)\n        val maxList25 = maxList24.takeRight(numbers.size)\n\
    \        val maxList26 = maxList25.takeRight(numbers.size)\n        val maxList27\
    \ = maxList26.takeRight(numbers.size)\n        val maxList28 = maxList27.takeRight(numbers.size)\n\
    \        val maxList29 = maxList28.takeRight(numbers.size)\n        val maxList30\
    \ = maxList29.takeRight(numbers.size)\n        val maxList31 = maxList30.takeRight(numbers.size)\n\
    \        val maxList32 = maxList31.takeRight(numbers.size)\n        val maxList33\
    \ = ", "        val rollingMax = mutable.ListBuffer.empty[Long]\n        numbers.foreach(number\
    \ => {\n            rollingMax.append(math.max(number))\n        })\n        rollingMax.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        val maxRoll = new\
    \ mutable.HashMap[Long, Long]()\n        numbers.foreach(n => {\n            if\
    \ (max.containsKey(n)) {\n                val maxValue = max.get(n)\n        \
    \        val maxRoll = maxRoll.updated(n, maxValue + n)\n                max.remove(maxValue)\n\
    \            } else {\n                val maxValue = n\n                val maxRoll\
    \ = maxRoll.updated(n, maxValue + n)\n                max.put(maxValue, maxRoll)\n\
    \            }\n        })\n        max.values.toList", "        val maxRolling\
    \ = new mutable.ListBuffer[Long]()\n        numbers.foreach(number => {\n    \
    \        val maxIndex = numbers.indexOf(Math.max(number))\n            val maxValue\
    \ = numbers(maxIndex)\n            maxRolling += maxValue\n        })\n      \
    \  return maxRolling.toList", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        var max = 0L\n        var i = 0\n        while(i < numbers.length) {\n\
    \            max = numbers(i)\n            while(i < numbers.length && numbers(i)\
    \ < max) {\n                max = numbers(i)\n                i += 1\n       \
    \     }\n            maxList += max\n        }\n        maxList.toList", "   \
    \     val max = new mutable.HashMap[Long, Long]()\n        val maxList = new mutable.ArrayList[Long]()\n\
    \        numbers.foreach(x => max.put(x, max(x.getOrElse(x, 0L) + 1)));\n    \
    \    max.foreach(x => maxList.add(x));\n        val maxList = maxList.sortWith((x,\
    \ y) => x._1 < y._1)\n        val maxList = maxList.takeWhile(x => x <= numbers(numbers.size))\n\
    \        maxList.foreach(x => max.put(x, max(x.getOrElse(x, 0L) + 1)));\n    \
    \    max.foreach(x => maxList.add(x));\n        val maxList = maxList.sortWith((x,\
    \ y) => x._1 < y._1)\n        val maxList = maxList.takeWhile(x => x <= numbers(numbers.size))\n\
    \        maxList.foreach(x => max.put(x, max(x.getOrElse(x, 0L) + 1)));\n    \
    \    max.foreach(x => maxList.add(x));\n        val maxList = maxList.sortWith((x,\
    \ y) => x._1 < y._1)\n        val maxList = maxList.takeWhile(x => x <= numbers(numbers.size))\n\
    \        maxList.foreach(x => max.put(x, max(x.getOrElse(x, 0L) + 1)));\n    \
    \    max.foreach(x => maxList.add(x));\n        val maxList = maxList.sortWith((x,\
    \ y) => x._1 < y._1)\n        val maxList = maxList.takeWhile(x => x <= numbers(numbers.size))\n\
    \        maxList.foreach(x => max.put(x, max(x.getOrElse(x, 0L) + 1)));\n    \
    \    max.foreach(x => maxList.add(x));\n        val maxList = maxList.sortWith((x,\
    \ y) => x._1 < y._1)\n        val maxList = maxList.takeWhile(x => x <= numbers(numbers.size))\n\
    \        maxList.foreach(x => max.put(x, max(x.getOrElse(x, 0L) + 1)));\n    \
    \    max.foreach(x => maxList.add(x));\n        val maxList = maxList.sortWith((x,\
    \ y) => x._1 < y._1)\n        val maxList = maxList.takeWhile(x => x <= numbers(numbers.size))\n\
    \        maxList.foreach(x => max.put(x, max(x.getOrElse(x, 0L) + 1)));\n    \
    \    max.foreach(x => maxList.add(x));\n        val maxList = maxList.sortWith((x,\
    \ y) => x._1 < y._1)\n        val maxList = maxList.takeWhile(x => x <= numbers(numbers.size))\n\
    \        maxList.foreach(x => max.put(x, ", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        val maxList = new mutable.ListBuffer[Long]()\n        numbers.foreach(x\
    \ => max.put(x, max(x.getOrElse(x, 0L) + 1)));\n        max.foreach(x => maxList\
    \ += max(x.getOrElse(x, 0L)));\n        maxList.toList", "        val maxRolling\
    \ = new mutable.ListBuffer[Long]()\n        numbers.foreach(number => {\n    \
    \        val maxIndex = numbers.indexOf(number) + 1\n            val maxValue\
    \ = numbers.take(maxIndex).max\n            maxRolling += maxValue\n        })\n\
    \        return maxRolling.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        val maxIndex = new mutable.HashMap[Long, Int]()\n        numbers.foreach(x\
    \ => max.put(x, x))\n        numbers.foreach(x => {\n            val maxValue\
    \ = max.get(x)\n            val maxIndex = maxIndex.getOrElse(x, 0)\n        \
    \    if (maxValue > max.getOrElse(maxIndex + 1, 0)) {\n                max.put(maxIndex\
    \ + 1, maxValue)\n                maxIndex += 1\n            }\n            maxIndex\
    \ += 1\n        })\n        val maxList = max.values.toList\n        val maxIndex\
    \ = max.keys.toList\n        val maxIndex = maxIndex.sortBy(x => x)\n        val\
    \ maxIndex = maxIndex.take(numbers.size)\n        val maxIndex = maxIndex.map(x\
    \ => x - 1)\n        val maxIndex = maxIndex.map(x => x + 1)\n        val maxIndex\
    \ = maxIndex.map(x => x - numbers.size)\n        val maxIndex = maxIndex.map(x\
    \ => x + numbers.size)\n        val maxIndex = maxIndex.map(x => x - numbers.size)\n\
    \        val maxIndex = maxIndex.map(x => x + numbers.size)\n        val maxIndex\
    \ = maxIndex.map(x => x - numbers.size)\n        val maxIndex = maxIndex.map(x\
    \ => x + numbers.size)\n        val maxIndex = maxIndex.map(x => x - numbers.size)\n\
    \        val maxIndex = maxIndex.map(x => x + numbers.size)\n        val maxIndex\
    \ = maxIndex.map(x => x - numbers.size)\n        val maxIndex = maxIndex.map(x\
    \ => x + numbers.size)\n        val maxIndex = maxIndex.map(x => x - numbers.size)\n\
    \        val maxIndex = maxIndex.map(x => x + numbers.size)\n        val maxIndex\
    \ = maxIndex.map(x => x - numbers.size)\n        val maxIndex = maxIndex.map(x\
    \ => x + numbers.size)\n        val maxIndex = maxIndex.map(x => x - numbers.size)\n\
    \        val maxIndex = maxIndex.map(x => x + numbers.size)\n        val maxIndex\
    \ = maxIndex.map(x => x - numbers.size)\n        val maxIndex = maxIndex.map(x\
    \ => x + numbers.size)\n        val maxIndex = maxIndex.map(x => x - numbers.size)\n\
    \        val maxIndex = maxIndex.map(x => x + numbers.size)\n        val maxIndex\
    \ = maxIndex.map(x => x - numbers.size)\n        val maxIndex = maxIndex.map(x\
    \ => x + numbers.size)\n        val maxIndex = maxIndex.map(x => x - numbers.size)\n\
    \        val maxIndex = maxIndex.map(x => x + numbers.size)\n        val maxIndex\
    \ = ", "        val rollingMax = mutable.ListBuffer[Long]()\n        numbers.foreach(number\
    \ => {\n            val rollingMaxNumber = rollingMax.last\n            if (number\
    \ > rollingMaxNumber) {\n                rollingMax.append(number)\n         \
    \   }\n        })\n        rollingMax.toList", "        val maxes = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach { n =>\n            val maxIndex = maxes.indexWhere(x\
    \ => x > n)\n            if (maxIndex == -1) maxes += n\n            else maxes(maxIndex)\
    \ = max(maxes(maxIndex), n)\n        }\n        maxes.toList", "        val max\
    \ = new mutable.HashMap[Long, Long]()\n        numbers.foreach { n =>\n      \
    \      val maxKey = max max n\n            if (maxKey > n) max += n -> maxKey\n\
    \        }\n        max.values.toList", "        val maxRollingMax = new mutable.ListBuffer[Long]()\n\
    \        val rollingMax = new mutable.ListBuffer[Long]()\n        numbers.foreach(x\
    \ => {\n            rollingMax.append(x)\n            if (rollingMax.size == numbers.size)\
    \ {\n                maxRollingMax.append(rollingMax.max)\n                rollingMax.clear()\n\
    \            }\n        })\n        if (rollingMax.nonEmpty) maxRollingMax.append(rollingMax.max)\n\
    \        maxRollingMax.toList", "        val maxList = new mutable.ListBuffer[Long]()\n\
    \        val maxNumber = numbers.head\n        val maxIndex = numbers.indexOf(0)\n\
    \        numbers.tail.foreach(number => {\n            if (number > maxNumber)\
    \ {\n                maxList += maxNumber\n                maxNumber = number\n\
    \                maxIndex = numbers.indexOf(number)\n            }\n         \
    \   else {\n                maxNumber += number\n            }\n        })\n \
    \       maxList += maxNumber\n        maxList.toList", "        val max = new\
    \ mutable.HashMap[Long, Long]()\n        numbers.foreach { n =>\n            val\
    \ maxKey = max.max.key\n            val maxValue = max.max.value\n           \
    \ val newMaxValue = if (maxKey == n) maxValue else maxValue + 1\n            max.put(maxKey,\
    \ newMaxValue)\n        }\n        max.values.toList", "        val max = new\
    \ mutable.HashMap[Long, Long]()\n        numbers.foreach(x => max.put(x, max.getOrElse(x,\
    \ 0) + x))\n        val maxes = max.toList.sortBy(_._1).reverse\n        val maxesWithMax\
    \ = maxes.takeWhile(_._2 > numbers.size).reverse\n        val maxesWithMaxAndIndex\
    \ = maxes.zipWithIndex.filter(_._2 > numbers.size).reverse\n        val maxesWithMaxAndIndexWithMax\
    \ = maxesWithMaxAndIndex.map(_._1).reverse\n        val maxesWithMaxAndIndexWithMaxAndIndex\
    \ = maxesWithMaxAndIndexWithMax.zipWithIndex.filter(_._2 > numbers.size).reverse\n\
    \        val maxesWithMaxAndIndexWithMaxAndIndexWithMax = maxesWithMaxAndIndexWithMaxAndIndex.map(_._1).reverse\n\
    \        val maxesWithMaxAndIndexWithMaxAndIndexWithMaxAndIndex = maxesWithMaxAndIndexWithMaxAndIndexWithMax.zipWithIndex.filter(_._2\
    \ > numbers.size).reverse\n        val maxesWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMax\
    \ = maxesWithMaxAndIndexWithMaxAndIndexWithMaxAndIndex.map(_._1).reverse\n   \
    \     val maxesWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMaxAndIndex =\
    \ maxesWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMax.zipWithIndex.filter(_._2\
    \ > numbers.size).reverse\n        val maxesWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMax\
    \ = maxesWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMaxAndIndex.map(_._1).reverse\n\
    \        val maxesWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMaxAndIndex\
    \ = maxesWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMax.zipWithIndex.filter(_._2\
    \ > numbers.size).reverse\n        val maxesWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMax\
    \ = maxesWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMaxAndIndex.map(_._1).reverse\n\
    \        val maxesWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMaxAndIndex\
    \ = maxesWithMaxAndIndexWith", "        val max = new mutable.HashMap[Long, Long]()\n\
    \        numbers.foreach(n => {\n            val maxKey = max.minKey\n       \
    \     if (maxKey == null || n < maxKey) {\n                max.put(n, n)\n   \
    \         } else {\n                val maxValue = max.getOrElse(n, n)\n     \
    \           max.put(n, maxValue + n)\n            }\n        })\n        max.values.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach {\
    \ n =>\n            val maxKey = max.max.key\n            if (maxKey == null ||\
    \ n > maxKey) {\n                max.put(n, n)\n            } else {\n       \
    \         max.put(maxKey, max)\n            }\n        }\n        val maxList\
    \ = max.values.toList\n        val maxListLength = maxList.size\n        val maxListLength\
    \ = maxListLength - 1\n        val maxListLength = maxListLength - 1\n       \
    \ val maxListLength = maxListLength - 1\n        val maxListLength = maxListLength\
    \ - 1\n        val maxListLength = maxListLength - 1\n        val maxListLength\
    \ = maxListLength - 1\n        val maxListLength = maxListLength - 1\n       \
    \ val maxListLength = maxListLength - 1\n        val maxListLength = maxListLength\
    \ - 1\n        val maxListLength = maxListLength - 1\n        val maxListLength\
    \ = maxListLength - 1\n        val maxListLength = maxListLength - 1\n       \
    \ val maxListLength = maxListLength - 1\n        val maxListLength = maxListLength\
    \ - 1\n        val maxListLength = maxListLength - 1\n        val maxListLength\
    \ = maxListLength - 1\n        val maxListLength = maxListLength - 1\n       \
    \ val maxListLength = maxListLength - 1\n        val maxListLength = maxListLength\
    \ - 1\n        val maxListLength = maxListLength - 1\n        val maxListLength\
    \ = maxListLength - 1\n        val maxListLength = maxListLength - 1\n       \
    \ val maxListLength = maxListLength - 1\n        val maxListLength = maxListLength\
    \ - 1\n        val maxListLength = maxListLength - 1\n        val maxListLength\
    \ = maxListLength - 1\n        val maxListLength = maxListLength - 1\n       \
    \ val maxListLength = maxListLength - 1\n        val maxListLength = maxListLength\
    \ - 1\n        val maxListLength = maxListLength - 1\n        val maxListLength\
    \ = maxListLength - 1\n        val maxListLength = maxListLength - 1\n       \
    \ val maxListLength = maxListLength - 1\n        val maxListLength = maxListLength\
    \ - 1\n        val maxListLength = maxListLength - 1\n        val maxListLength\
    \ = maxListLength - 1\n        val maxListLength = maxListLength - 1\n       \
    \ val maxListLength = maxListLength - 1\n        val maxListLength = maxListLength\
    \ - 1\n        val maxListLength = maxListLength - 1\n        val maxListLength\
    \ = maxListLength - 1\n        val maxListLength = maxListLength - 1\n       \
    \ val maxListLength = maxListLength - 1\n        val maxListLength = ", "    \
    \    val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0) + x))\n        val maxList = new mutable.ListBuffer[Long]()\n\
    \        for(x <- max.keys) {\n            val maxValue = max.get(x)\n       \
    \     val maxKey = if (maxValue > 0) x else maxValue - 1\n            val maxIndex\
    \ = maxList.indexOf(maxKey)\n            if (maxIndex == -1) maxList += maxKey\n\
    \            else maxList += maxKey :: maxList.drop(maxIndex + 1)\n        }\n\
    \        return maxList.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        val rollingMax = new mutable.ArrayBuffer[Long]()\n        for\
    \ (i <- 0 until numbers.size) {\n            val max = numbers(i)\n          \
    \  if (max.isDefined) {\n                val maxKey = max.key\n              \
    \  if (maxKey > rollingMax.last) {\n                    rollingMax.clear()\n \
    \               }\n                rollingMax += maxKey\n            }\n     \
    \   }\n        rollingMax.toList", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach { number =>\n            val maxIndex = maxList.lastIndex\n\
    \            if (maxIndex == -1) {\n                maxList += number\n      \
    \      } else {\n                maxList += maxList[maxIndex] + number\n     \
    \       }\n        }\n        maxList.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(x => max.put(x, max.getOrElse(x, 0) + x))\n\
    \        max.values.toList", "        val rollingMax = mutable.ListBuffer[Long]()\n\
    \        var max = 0L\n        var i = 0\n        while (i < numbers.length) {\n\
    \            max = numbers(i)\n            rollingMax += max\n            i +=\
    \ 1\n        }\n        rollingMax.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(n => {\n            val maxKey = math.max(max(n),\
    \ n)\n            max.put(maxKey, max(n))\n        })\n        max.values.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(n\
    \ => {\n            if (max.containsKey(n)) {\n                max.update(n, max(n)\
    \ + 1)\n            } else {\n                max.update(n, 1L)\n            }\n\
    \        })\n        val rollingMax = new mutable.HashMap[Long, Long]()\n    \
    \    max.foreach(n => {\n            val maxValue = max(n)\n            val maxKey\
    \ = n - maxValue\n            if (rollingMax.containsKey(maxKey)) {\n        \
    \        rollingMax.update(maxKey, rollingMax(maxKey) + maxValue)\n          \
    \  } else {\n                rollingMax.update(maxKey, maxValue)\n           \
    \ }\n        })\n        rollingMax.keys.toList", "        val rollingMax = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach(rollingMax += _)\n        rollingMax.toList", "     \
    \   val rollingMax = mutable.ListBuffer.empty[Long]\n        numbers.foreach(x\
    \ => rollingMax += x)\n        rollingMax.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        val maxList = new mutable.ListBuffer[Long]()\n        numbers.foreach(x\
    \ => {\n            val maxKey = max.keySet().toList.max\n            if (maxKey\
    \ < x) {\n                max.put(x, x)\n            } else {\n              \
    \  val maxValue = max.get(maxKey)\n                if (maxValue < x) {\n     \
    \               max.put(x, maxValue)\n                } else {\n             \
    \       max.put(x, maxValue + 1)\n                }\n            }\n        })\n\
    \        max.keys.toList.foreach(x => maxList += max.get(x))\n        return maxList.toList",
  "        val maxList = new mutable.ListBuffer[Long]()\n        numbers.foreach {\
    \ number =>\n            val maxIndex = maxList.lastIndex\n            if (maxIndex\
    \ == -1) {\n                maxList += number\n            } else {\n        \
    \        maxList += maxList.last\n            }\n        }\n        maxList.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        val maxList = new\
    \ mutable.ArrayList[Long]()\n        numbers.foreach(x => max.put(x, max(x.getOrElse(x,\
    \ 0L) + 1)));\n        max.values.foreach(x => maxList.add(x));\n        maxList.sortWith((x,\
    \ y) => x > y)", "        val rollingMax = mutable.ListBuffer[Long]()\n      \
    \  numbers.foreach(x => rollingMax.append(x))\n        rollingMax.takeWhile(x\
    \ => x <= numbers(numbers.size-1))", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(x => max.put(x, Math.max(max.getOrElse(x, 0),\
    \ x)))\n        max.values.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(n => {\n            val maxKey = max.minKey\n\
    \            if (maxKey == null || n > maxKey) {\n                max += n ->\
    \ n\n            }\n        })\n        max.values.toList", "        val max =\
    \ new mutable.HashMap[Long, Long]()\n        val maxList = new mutable.ArrayList[Long]()\n\
    \        numbers.foreach(x => {\n            if (max.contains(x)) {\n        \
    \        val max = max(x)\n                val maxList = maxList.toList\n    \
    \            maxList.add(max)\n                max.clear()\n            } else\
    \ {\n                max.put(x, x)\n            }\n        })\n        maxList.toList",
  "        val rollingMax = mutable.ListBuffer.empty[Long]\n        numbers.foreach\
    \ { number =>\n            val rollingMaxNumber = rollingMax.lastOption.getOrElse(number)\
    \ + number\n            rollingMax.append(rollingMaxNumber)\n        }\n     \
    \   rollingMax.toList", "        val max = new mutable.HashMap[Long, Long]()\n\
    \        numbers.foreach(n => {\n            val maxKey = max.getOrElse(n, 0)\n\
    \            max.update(n, maxKey + 1)\n        })\n        val maxList = max.toList.sortBy(_._1).reverse\n\
    \        val maxElement = maxList.head._2\n        val maxList = maxList.tail.sortBy(_._1).reverse\n\
    \        val maxElements = maxList.map(x => x._2)\n        val maxElementsIndex\
    \ = maxList.indexOf(maxElement)\n        val maxElementsIndex = maxElementsIndex\
    \ + 1\n        val maxElementsIndex = maxElementsIndex - 1\n        val maxElementsIndex\
    \ = maxElementsIndex - 1\n        val maxElementsIndex = maxElementsIndex - 1\n\
    \        val maxElementsIndex = maxElementsIndex - 1\n        val maxElementsIndex\
    \ = maxElementsIndex - 1\n        val maxElementsIndex = maxElementsIndex - 1\n\
    \        val maxElementsIndex = maxElementsIndex - 1\n        val maxElementsIndex\
    \ = maxElementsIndex - 1\n        val maxElementsIndex = maxElementsIndex - 1\n\
    \        val maxElementsIndex = maxElementsIndex - 1\n        val maxElementsIndex\
    \ = maxElementsIndex - 1\n        val maxElementsIndex = maxElementsIndex - 1\n\
    \        val maxElementsIndex = maxElementsIndex - 1\n        val maxElementsIndex\
    \ = maxElementsIndex - 1\n        val maxElementsIndex = maxElementsIndex - 1\n\
    \        val maxElementsIndex = maxElementsIndex - 1\n        val maxElementsIndex\
    \ = maxElementsIndex - 1\n        val maxElementsIndex = maxElementsIndex - 1\n\
    \        val maxElementsIndex = maxElementsIndex - 1\n        val maxElementsIndex\
    \ = maxElementsIndex - 1\n        val maxElementsIndex = maxElementsIndex - 1\n\
    \        val maxElementsIndex = maxElementsIndex - 1\n        val maxElementsIndex\
    \ = maxElementsIndex - 1\n        val maxElementsIndex = maxElementsIndex - 1\n\
    \        val maxElementsIndex = maxElementsIndex - 1\n        val maxElementsIndex\
    \ = maxElementsIndex - 1\n        val maxElementsIndex = maxElementsIndex - 1\n\
    \        val maxElementsIndex = maxElementsIndex - 1\n        val maxElementsIndex\
    \ = maxElementsIndex - 1\n        val maxElementsIndex = maxElementsIndex - 1\n\
    \        val maxElementsIndex = maxElementsIndex - 1\n        val maxElementsIndex\
    \ = maxElementsIndex - 1\n        val maxElementsIndex = ", "        val rollingMax\
    \ = mutable.ListBuffer.empty[Long]\n        numbers.foreach { number =>\n    \
    \        val rollingMaxIndex = rollingMax.lastIndex\n            rollingMax.lastOption\
    \ = rollingMax.lastOption.getOrElse(number) + 1\n            if (rollingMax.lastOption.getOrElse(number)\
    \ == number) {\n                rollingMax.lastOption = rollingMax.lastOption.getOrElse(number)\
    \ - 1\n            }\n            if (rollingMax.lastOption.getOrElse(number)\
    \ == 0) {\n                rollingMax.lastOption = rollingMax.lastOption.getOrElse(number)\
    \ - 1\n            }\n            if (rollingMax.lastOption.getOrElse(number)\
    \ == -1) {\n                rollingMax.lastOption = rollingMax.lastOption.getOrElse(number)\
    \ - 1\n            }\n            if (rollingMax.lastOption.getOrElse(number)\
    \ == -2) {\n                rollingMax.lastOption = rollingMax.lastOption.getOrElse(number)\
    \ - 1\n            }\n            if (rollingMax.lastOption.getOrElse(number)\
    \ == -3) {\n                rollingMax.lastOption = rollingMax.lastOption.getOrElse(number)\
    \ - 1\n            }\n            if (rollingMax.lastOption.getOrElse(number)\
    \ == -4) {\n                rollingMax.lastOption = rollingMax.lastOption.getOrElse(number)\
    \ - 1\n            }\n            if (rollingMax.lastOption.getOrElse(number)\
    \ == -5) {\n                rollingMax.lastOption = rollingMax.lastOption.getOrElse(number)\
    \ - 1\n            }\n            if (rollingMax.lastOption.getOrElse(number)\
    \ == -6) {\n                rollingMax.lastOption = rollingMax.lastOption.getOrElse(number)\
    \ - 1\n            }\n            if (rollingMax.lastOption.getOrElse(number)\
    \ == -7) {\n                rollingMax.lastOption = rollingMax.lastOption.getOrElse(number)\
    \ - 1\n            }\n            if (rollingMax.lastOption.getOrElse(number)\
    \ == -8) {\n                rollingMax.lastOption = rollingMax.lastOption.getOrElse(number)\
    \ - 1\n            }\n            if (rollingMax.lastOption.getOrElse(number)\
    \ == -9) {\n                rollingMax.lastOption = rollingMax.lastOption.getOrElse(number)\
    \ - 1\n            }\n            if (rollingMax.lastOption.getOrElse(number)\
    \ == -10) {\n                rollingMax.lastOption = rollingMax.last", "     \
    \   val rollingMax = mutable.ListBuffer.empty[Long]\n        var max = 0L\n  \
    \      var i = 0\n        while(i < numbers.length) {\n            max = numbers(i)\n\
    \            while(max > numbers(i+1)) {\n                max -= numbers(i+1)\n\
    \                i += 1\n            }\n            rollingMax.append(max)\n \
    \           i += 1\n        }\n        rollingMax.toList", "        val maxRolling\
    \ = new mutable.ListBuffer[Long]()\n        val rolling = new mutable.ListBuffer[Long]()\n\
    \        numbers.foreach(x => {\n            rolling.clear()\n            rolling\
    \ += x\n            while (rolling.nonEmpty) {\n                val maxRollingIndex\
    \ = rolling.max\n                maxRolling += maxRollingIndex\n             \
    \   rolling.remove(maxRollingIndex)\n            }\n        })\n        maxRolling",
  "        val maxRollingNumbers = mutable.ListBuffer[Long]()\n        val maxRollingNumbersSize\
    \ = numbers.size + 1\n        val maxRollingNumbersIndex = 0\n        val maxRollingNumbersIndexSize\
    \ = numbers.size + 1\n        val maxRollingNumbersIndexIndex = 0\n        val\
    \ maxRollingNumbersIndexIndexSize = numbers.size + 1\n        val maxRollingNumbersIndexIndexIndexSize\
    \ = 1\n        val maxRollingNumbersIndexIndexIndexIndexSize = 2\n        val\
    \ maxRollingNumbersIndexIndexIndexIndexSize = 3\n        val maxRollingNumbersIndexIndexIndexIndexSize\
    \ = 4\n        val maxRollingNumbersIndexIndexIndexIndexSize = 5\n        val\
    \ maxRollingNumbersIndexIndexIndexIndexSize = 6\n        val maxRollingNumbersIndexIndexIndexIndexSize\
    \ = 7\n        val maxRollingNumbersIndexIndexIndexIndexSize = 8\n        val\
    \ maxRollingNumbersIndexIndexIndexIndexSize = 9\n        val maxRollingNumbersIndexIndexIndexIndexSize\
    \ = 10\n        val maxRollingNumbersIndexIndexIndexIndexSize = 11\n        val\
    \ maxRollingNumbersIndexIndexIndexIndexSize = 12\n        val maxRollingNumbersIndexIndexIndexIndexSize\
    \ = 13\n        val maxRollingNumbersIndexIndexIndexIndexSize = 14\n        val\
    \ maxRollingNumbersIndexIndexIndexIndexSize = 15\n        val maxRollingNumbersIndexIndexIndexIndexSize\
    \ = 16\n        val maxRollingNumbersIndexIndexIndexIndexSize = 17\n        val\
    \ maxRollingNumbersIndexIndexIndexIndexSize = 18\n        val maxRollingNumbersIndexIndexIndexIndexSize\
    \ = 19\n        val maxRollingNumbersIndexIndexIndexIndexSize = 20\n        val\
    \ maxRollingNumbersIndexIndexIndexIndexSize = 21\n        val maxRollingNumbersIndexIndexIndexIndexSize\
    \ = 22\n        val maxRollingNumbersIndexIndexIndexIndexSize = 23\n        val\
    \ maxRollingNumbersIndexIndexIndexIndexSize = 24\n        val maxRollingNumbersIndexIndexIndexIndexSize\
    \ = 25\n        val maxRollingNumbersIndexIndexIndexIndexSize = 26\n        val\
    \ maxRollingNumbersIndexIndexIndexIndexSize = 27\n        val maxRollingNumbersIndexIndexIndexSize\
    \ = 28\n        val maxRollingNumbersIndexIndexIndexSize = 29\n        val maxRollingNumbersIndexIndexIndexSize\
    \ = 30\n        val maxRollingNumbersIndexIndexIndexSize = 31\n        val maxRollingNumber",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(n\
    \ => {\n            val maxKey = max.getOrElseUpdate(n, 0L)\n            if (maxKey\
    \ > n) max.update(n, maxKey)\n        })\n        max.values.toList", "      \
    \  val max = new mutable.HashMap[Long, Long]()\n        val maxList = new mutable.ListBuffer[Long]()\n\
    \        for (i <- numbers) {\n            val max = i\n            if (max.isDefined)\
    \ {\n                val maxKey = max.key\n                if (maxKey > maxList.last)\
    \ {\n                    maxList += maxKey\n                }\n              \
    \  max.remove(maxKey)\n            }\n        }\n        maxList.toList", "  \
    \      val max = new mutable.HashMap[Long, Long]()\n        val maxList = new\
    \ mutable.ArrayList[Long]()\n        numbers.foreach(n => {\n            val maxKey\
    \ = max + (n - 1)\n            if (maxKey > max) {\n                maxList.clear()\n\
    \                maxList.add(n)\n                max = maxKey\n            } else\
    \ {\n                maxList.add(n)\n            }\n        })\n        maxList.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(n\
    \ => {\n            val maxKey = max.getOrElse(n, 0)\n            val maxValue\
    \ = max.getOrElse(n, 0)\n            max.put(n, maxValue + 1)\n        })\n  \
    \      max.values.toList", "        val max = new mutable.HashMap[Long, Long]()\n\
    \        numbers.foreach { n =>\n            val maxKey = max.minKey\n       \
    \     if (maxKey == null || n > maxKey) {\n                max += n -> n\n   \
    \         }\n        }\n        val maxList = max.values.toList\n        val maxIndex\
    \ = maxList.indexWhere(_ > 0)\n        val maxElement = maxList[maxIndex]\n  \
    \      val maxElementIndex = numbers.indexWhere(_ == maxElement)\n        val\
    \ maxElementIndex = maxElementIndex + 1\n        val maxElements = numbers.take(maxElementIndex)\n\
    \        val maxElementsIndex = numbers.indexWhere(_ == maxElement)\n        val\
    \ maxElementsIndex = maxElementsIndex + 1\n        val maxElementsIndex = maxElementsIndex\
    \ + 1\n        val maxElementsIndex = maxElementsIndex + 1\n        val maxElementsIndex\
    \ = maxElementsIndex + 1\n        val maxElementsIndex = maxElementsIndex + 1\n\
    \        val maxElementsIndex = maxElementsIndex + 1\n        val maxElementsIndex\
    \ = maxElementsIndex + 1\n        val maxElementsIndex = maxElementsIndex + 1\n\
    \        val maxElementsIndex = maxElementsIndex + 1\n        val maxElementsIndex\
    \ = maxElementsIndex + 1\n        val maxElementsIndex = maxElementsIndex + 1\n\
    \        val maxElementsIndex = maxElementsIndex + 1\n        val maxElementsIndex\
    \ = maxElementsIndex + 1\n        val maxElementsIndex = maxElementsIndex + 1\n\
    \        val maxElementsIndex = maxElementsIndex + 1\n        val maxElementsIndex\
    \ = maxElementsIndex + 1\n        val maxElementsIndex = maxElementsIndex + 1\n\
    \        val maxElementsIndex = maxElementsIndex + 1\n        val maxElementsIndex\
    \ = maxElementsIndex + 1\n        val maxElementsIndex = maxElementsIndex + 1\n\
    \        val maxElementsIndex = maxElementsIndex + 1\n        val maxElementsIndex\
    \ = maxElementsIndex + 1\n        val maxElementsIndex = maxElementsIndex + 1\n\
    \        val maxElementsIndex = maxElementsIndex + 1\n        val maxElementsIndex\
    \ = maxElementsIndex + 1\n        val maxElementsIndex = maxElementsIndex + 1\n\
    \        val maxElementsIndex = maxElementsIndex + 1\n        val maxElementsIndex\
    \ = maxElementsIndex + 1\n        val maxElementsIndex = maxElementsIndex + 1\n\
    \        val maxElementsIndex = maxElementsIndex + 1\n        val maxElementsIndex\
    \ = maxElementsIndex + 1\n        val maxElementsIndex = max", "        val max\
    \ = new mutable.HashMap[Long, Long]()\n        numbers.foreach(n => max.put(n,\
    \ Math.max(n, max.getOrElse(n,0L))))\n        val maxList = max.values.toList\n\
    \        val rollingMax = maxList.sliding(numbers.size)\n        rollingMax.map(_.max).toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0) + x))\n        val maxes = max.toList.sortBy(_._1).reverse.take(numbers.size)\n\
    \        val maxesWithIndex = maxes.zipWithIndex.filter(_._1 == maxes.max)\n \
    \       val maxesWithIndex = maxesWithIndex.map(_._2)\n        val maxesWithIndex\
    \ = maxesWithIndex.map(x => numbers.indexOf(x) + 1)\n        maxesWithIndex",
  "        val rollingMax = mutable.ListBuffer[Long]()\n        var max = 0L\n   \
    \     var maxIndex = 0\n        numbers.foreach(number => {\n            rollingMax.append(number)\n\
    \            max = math.max(max, number)\n            maxIndex += 1\n        })\n\
    \        rollingMax.takeWhile(number => number != max).reverse.drop(maxIndex).reverse"]
stop_tokens:
- "\n    }\n"
