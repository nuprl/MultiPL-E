language: scala
name: HumanEval_11_string_xor
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until aList.length) xorList += (aList(i) xor bList(i))\n \
    \       xorList.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzcb6_f07.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978704
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val xorList = mutable.ListBuffer[String]()\n\
    \        aList.zip(bList).foreach { case (aChar, bChar) =>\n            xorList\
    \ += aChar ^ bChar\n        }\n        xorList.toList.toString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9n3gajl9.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978704
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aBits = a.toIntArray\n\
    \        val bBits = b.toIntArray\n        val xorBits = aBits xor bBits\n   \
    \     val xorBitsString = xorBits.map(bit => if (bit == 1) \"1\" else \"0\").mkString\n\
    \        xorBitsString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5kr2bq4_.scala:7:22 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp5kr2bq4_.scala:8:22 -------------------------\e[0m\e\
    [0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m      \
    \              value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659978707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Char](b.length)\n\
    \        for(i <- 0 until xorArray.length)\n            xorArray(i) = (aArray(i)\
    \ xor bArray(i)).toChar\n        new String(xorArray)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpv4sppf7h.scala:11:37 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m            xorArray(i) = (aArray(i) xor bArray(i)).toChar\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                           value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659978707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val result = new StringBuilder\n\
    \        var carry = 0\n        for (i <- 0 until aArray.length) {\n         \
    \   val aChar = aArray(i)\n            val bChar = bArray(i)\n            val\
    \ xor = aChar xor bChar\n            val newCarry = xor and carry\n          \
    \  carry = newCarry xor carry\n            result.append(newCarry)\n        }\n\
    \        result.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpr9i9vdqj.scala:14:28 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            \e[33mval\e[0m \e[36mxor\e[0m = aChar xor\
    \ bChar\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659978707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = Array.ofDim[Int](2)\n\
    \        val xorArray2 = Array.ofDim[Int](2)\n        val xorArray3 = Array.ofDim[Int](2)\n\
    \        val xorArray4 = Array.ofDim[Int](2)\n        val xorArray5 = Array.ofDim[Int](2)\n\
    \        val xorArray6 = Array.ofDim[Int](2)\n        val xorArray7 = Array.ofDim[Int](2)\n\
    \        val xorArray8 = Array.ofDim[Int](2)\n        val xorArray9 = Array.ofDim[Int](2)\n\
    \        val xorArray10 = Array.ofDim[Int](2)\n        val xorArray11 = Array.ofDim[Int](2)\n\
    \        val xorArray12 = Array.ofDim[Int](2)\n        val xorArray13 = Array.ofDim[Int](2)\n\
    \        val xorArray14 = Array.ofDim[Int](2)\n        val xorArray15 = Array.ofDim[Int](2)\n\
    \        val xorArray16 = Array.ofDim[Int](2)\n        val xorArray17 = Array.ofDim[Int](2)\n\
    \        val xorArray18 = Array.ofDim[Int](2)\n        val xorArray19 = Array.ofDim[Int](2)\n\
    \        val xorArray20 = Array.ofDim[Int](2)\n        val xorArray21 = Array.ofDim[Int](2)\n\
    \        val xorArray22 = Array.ofDim[Int](2)\n        val xorArray23 = Array.ofDim[Int](2)\n\
    \        val xorArray24 = Array.ofDim[Int](2)\n        val xorArray25 = Array.ofDim[Int](2)\n\
    \        val xorArray26 = Array.ofDim[Int](2)\n        val xorArray27 = Array.ofDim[Int](2)\n\
    \        val xorArray28 = Array.ofDim[Int](2)\n        val xorArray29 = Array.ofDim[Int](2)\n\
    \        val xorArray30 = Array.ofDim[Int](2)\n        val xorArray31 = Array.ofDim[Int](2)\n\
    \        val xorArray32 = Array.ofDim[Int](2)\n        val xorArray33 = Array.ofDim[Int](2)\n\
    \        val xorArray34 = Array.ofDim[Int](2)\n        val xorArray35 = Array.ofDim[Int](2)\n\
    \        val xorArray\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9xc0aymq.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp9xc0aymq.scala:45:5 ---------------------\e[0m\e[0m\n\e[31m45 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toCharArray\n\
    \        val bList = b.toCharArray\n        val xorList = mutable.ArrayBuffer.empty[Char]\n\
    \        var xor = 0\n        var i = 0\n        while (i < aList.length && i\
    \ < bList.length) {\n            xor = xor + ((aList(i) XOR bList(i)) XOR xorList)\n\
    \            i += 1\n        }\n        xor.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpp7b919l3.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mChar\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpp7b919l3.scala:13:35 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            xor = xor + ((aList(i) XOR bList(i)) XOR\
    \ xorList)\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          value XOR is not a member of Char\n2\
    \ errors found\n"
  stdout: ''
  timestamp: 1659978707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toCharArray\n\
    \        val bList = b.toCharArray\n        val xorList = mutable.ArrayBuffer.empty[Char]\n\
    \        for (i <- 0 until aList.length) xorList += aList(i) xor bList(i)\n  \
    \      xorList.toString.reverse\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpt0l_2qd9.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mChar\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978704
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toCharArray\n\
    \        val bList = b.toCharArray\n        val xorResult = mutable.Buffer.empty[Char]\n\
    \        val xorResultList = mutable.Buffer.empty[Char]\n        val xorResultListSize\
    \ = mutable.Buffer.empty[Int]\n        val xorResultListSizeSize = mutable.Buffer.empty[Int]\n\
    \        val xorResultListSizeSizeSize = mutable.Buffer.empty[Int]\n        val\
    \ xorResultListSizeSizeSizeSize = mutable.Buffer.empty[Int]\n        val xorResultListSizeSizeSizeSizeSize\
    \ = mutable.Buffer.empty[Int]\n        val xorResultListSizeSizeSizeSizeSize =\
    \ mutable.Buffer.empty[Int]\n        val xorResultListSizeSizeSizeSizeSizeSize\
    \ = mutable.Buffer.empty[Int]\n        val xorResultListSizeSizeSizeSizeSizeSize\
    \ = mutable.Buffer.empty[Int]\n        val xorResultListSizeSizeSizeSizeSizeSizeSize\
    \ = mutable.Buffer.empty[Int]\n        val xorResultListSizeSizeSizeSizeSizeSizeSizeSize\
    \ = mutable.Buffer.empty[Int]\n        val xorResultListSizeSizeSizeSizeSizeSizeSizeSize\
    \ = mutable.Buffer.empty[Int]\n        val xorResultListSizeSizeSizeSizeSizeSizeSizeSizeSize\
    \ = mutable.Buffer.empty[Int]\n        val xorResultListSizeSizeSizeSizeSizeSizeSizeSizeSizeSize\
    \ = mutable.Buffer.empty[Int]\n        val xorResultListSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSize\
    \ = mutable.Buffer.empty[Int]\n        val xorResultListSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSize\
    \ = mutable.Buffer.empty[Int]\n        val xorResultListSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSize\
    \ = mutable.Buffer.empty[Int]\n        val xorResultListSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSize\
    \ = mutable.Buffer.empty[Int]\n        val xorResultListSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSize\
    \ = mutable.Buffer.empty[Int]\n        val xorResultListSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSize\
    \ = mutable.Buffer.empty[Int]\n        val xorResultListSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSize\
    \ = mutable.Buffer.empty[Int]\n        val xorResultListSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSize\
    \ = mutable.Buffer.empty[Int]\n        val xorResultListSizeSizeSizeSizeSizeSizeSize\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5bs22j44.scala:33:4 ----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5bs22j44.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m\
    \ \e[36mxorResultListSizeSizeSizeSizeSize\e[0m = mutable.Buffer.empty[\e[35mInt\e\
    [0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorResultListSizeSizeSizeSizeSize is already defined as \e\
    [33mvalue\e[0m \e[35mxorResultListSizeSizeSizeSizeSize\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5bs22j44.scala:18:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m\
    \ \e[36mxorResultListSizeSizeSizeSizeSizeSize\e[0m = mutable.Buffer.empty[\e[35mInt\e\
    [0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorResultListSizeSizeSizeSizeSizeSize is already defined as\
    \ \e[33mvalue\e[0m \e[35mxorResultListSizeSizeSizeSizeSizeSize\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5bs22j44.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mxorResultListSizeSizeSizeSizeSizeSizeSizeSize\e[0m = mutable.Buffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorResultListSizeSizeSizeSizeSizeSizeSizeSize is already defined\
    \ as \e[33mvalue\e[0m \e[35mxorResultListSizeSizeSizeSizeSizeSizeSizeSize\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp5bs22j44.scala:25:12 ---------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        \e[33mval\e[0"
  stdout: ''
  timestamp: 1659978707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Char](b.length)\n\
    \        for(i <- 0 until xorArray.length)\n            xorArray(i) = aArray(i)\
    \ xor bArray(i)\n        new String(xorArray)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbk21ti4w.scala:11:36 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659978707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Char](Math.max(aArray.length,\
    \ bArray.length))\n        var i = 0\n        while (i < xorArray.length) {\n\
    \            xorArray(i) = aArray(i) xor bArray(i)\n            i += 1\n     \
    \   }\n        xorArray.toString.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkulycydy.scala:12:36 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659978707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Int](aArray.length)\n\
    \        for(i <- 0 until xorArray.length){\n            xorArray(i) = aArray(i)\
    \ xor bArray(i)\n        }\n        new String(xorArray)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp83kxymmj.scala:11:36 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n\e[31m\e[31m--\
    \ [E134] Type Error: /tmp/tmp83kxymmj.scala:13:12 -----------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mnew\e[0m \e[35mString\e[0m(xorArray)\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mconstructor\e[0m \e[35mString\e[0m in \e[33mclass\e[0m\
    \ \e[35mString\e[0m with types\n\e[31m   |\e[0m (x$0: StringBuilder): String\n\
    \e[31m   |\e[0m (x$0: StringBuffer): String\n\e[31m   |\e[0m (x$0: Array[Byte]):\
    \ String\n\e[31m   |\e[0m (x$0: Array[Byte], x$1: Int, x$2: Int): String\n\e[31m\
    \   |\e[0m (x$0: Array[Byte], x$1: java.nio.charset.Charset): String\n\e[31m \
    \  |\e[0m (x$0: Array[Byte], x$1: String): String\n\e[31m   |\e[0m (x$0: Array[Byte],\
    \ x$1: Int, x$2: Int, x$3: java.nio.charset.Charset): String\n\e[31m   |\e[0m\
    \ (x$0: Array[Byte], x$1: Int, x$2: Int, x$3: String): String\n\e[31m   |\e[0m\
    \ (x$0: Array[Byte], x$1: Int): String\n\e[31m   |\e[0m (x$0: Array[Byte], x$1:\
    \ Int, x$2: Int, x$3: Int): String\n\e[31m   |\e[0m (x$0: Array[Int], x$1: Int,\
    \ x$2: Int): String\n\e[31m   |\e[0m (x$0: Array[Char], x$1: Int, x$2: Int): String\n\
    \e[31m   |\e[0m (x$0: Array[Char]): String\n\e[31m   |\e[0m (x$0: String): String\n\
    \e[31m   |\e[0m (): String\n\e[31m   |\e[0mmatch arguments ((xorArray : Array[Int]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659978707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Char](b.length)\n\
    \        var i = 0\n        while (i < xorArray.length) {\n            xorArray(i)\
    \ = aArray(i) ^ bArray(i)\n            i += 1\n        }\n        new String(xorArray)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvftfdhx9.scala:12:26\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m            xorArray(i) = aArray(i)\
    \ ^ bArray(i)\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          Found:    Int\n\e[31m   |\e[0m \
    \                         Required: Char\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toCharArray.map(_.toInt)\n\
    \        val bList = b.toCharArray.map(_.toInt)\n        val xorList = mutable.ArrayBuffer.empty[Int]\n\
    \        for(i <- 0 until aList.length) xorList += (aList(i) xor bList(i))\n \
    \       xorList.toString.toCharArray\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzh330qi6.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978704
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = aArray.zip(bArray).map(x\
    \ => x._1 xor x._2).mkString(\"\")\n        xorArray\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpr9e1_q6g.scala:9:56 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = aArray.zip(bArray).map(\e\
    [36mx\e[0m => x._1 xor x._2).mkString(\e[31m\"\"\e[0m)\n\e[31m\e[31m  |\e[0m \
    \                                                  ^^^^^^^^\e[0m\n\e[31m  |\e\
    [0m                                          value xor is not a member of Int\n\
    \e[31m\e[31m-- Error: /tmp/tmpr9e1_q6g.scala:9:65 ------------------------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = aArray.zip(bArray).map(\e\
    [36mx\e[0m => x._1 xor x._2).mkString(\e[31m\"\"\e[0m)\n\e[31m\e[31m  |\e[0m \
    \                                                                ^\e[0m\n\e[31m\
    \  |\e[0m                                            No ClassTag available for\
    \ B\n\e[31m  |\e[0m\n\e[31m  |\e[0m                                          \
    \  where:    B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1659978708
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aBits = a.toIntArray\n\
    \        val bBits = b.toIntArray\n        val xorBits = Array.ofDim[Int](Math.max(aBits.length,\
    \ bBits.length))\n        var i = 0\n        while (i < xorBits.length) {\n  \
    \          xorBits(i) = aBits(i).xor(bBits(i))\n            i += 1\n        }\n\
    \        val xorBitsString = xorBits.mkString(\"\")\n        xorBitsString\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9wx3oiqe.scala:7:22 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp9wx3oiqe.scala:8:22 -------------------------\e[0m\e\
    [0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m      \
    \              value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659978708
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val result = new StringBuilder\n\
    \        var i = 0\n        while (i < aArray.length) {\n            result.append(aArray(i)\
    \ ^ bArray(i))\n            i += 1\n        }\n        return result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978708
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Char](Math.max(aArray.length,\
    \ bArray.length))\n        var i = 0\n        while (i < xorArray.length) {\n\
    \            xorArray(i) = aArray(i) xor bArray(i)\n            i += 1\n     \
    \   }\n        new String(xorArray)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpm5o2o3_j.scala:12:36 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659978706
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aBits = a.toIntArray\n\
    \        val bBits = b.toIntArray\n        val xorBits = aBits xor bBits\n   \
    \     val xorBitsString = xorBits.map(_ + 48).map(_.toString).mkString(\"\")\n\
    \        xorBitsString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpstz0qqfb.scala:7:22 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpstz0qqfb.scala:8:22 -------------------------\e[0m\e\
    [0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m      \
    \              value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659978707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toCharArray\n\
    \        val bList = b.toCharArray\n        val result = new StringBuilder\n \
    \       var i = 0\n        while (i < a.length) {\n            result.append(aList(i)\
    \ XOR bList(i))\n            i += 1\n        }\n        return result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwsl5_ngr.scala:12:35 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            result.append(aList(i) XOR bList(i))\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                          value XOR is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659978707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Char](aArray.length)\n\
    \        for(i <- 0 until xorArray.length)\n            xorArray(i) = aArray(i)\
    \ xor bArray(i)\n        new String(xorArray)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_m8x__aj.scala:11:36 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659978707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n\
    \        aList.zip(bList).foreach {\n            case (aChar, bChar) =>\n    \
    \            val xorChar = if (aChar == '1') '0' else '1'\n                xorList\
    \ += xorChar\n        }\n        xorList.toList.reverse.mkString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf0ill7tg.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978703
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Char](b.length)\n\
    \        for(i <- 0 until xorArray.length)\n            xorArray(i) = aArray(i)\
    \ xor bArray(i)\n        new String(xorArray)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbk21ti4w.scala:11:36 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659978707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Char](a.length)\n\
    \        for(i <- 0 until xorArray.length)\n            xorArray(i) = aArray(i)\
    \ xor bArray(i)\n        new String(xorArray)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpd6p91dxa.scala:11:36 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659978706
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val result = new StringBuilder\n      \
    \  for(i <- 0 until aList.length)\n            result.append(aList(i) ^ bList(i))\n\
    \        return result.toString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n\
    \        var xor = 0\n        var i = 0\n        while (i < aList.length) {\n\
    \            xor = xor + aList(i) xor bList(i)\n            i += 1\n        }\n\
    \        xorList.add(xor.toHexString)\n        xorList.toString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0w5pndr9.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp0w5pndr9.scala:13:33 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            xor = xor + aList(i) xor bList(i)\n\e[31m\e\
    [31m   |\e[0m                  ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \            value xor is not a member of Int\n2 errors found\n"
  stdout: ''
  timestamp: 1659978715
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aBits = a.toIntArray\n\
    \        val bBits = b.toIntArray\n        val xorBits = aBits xor bBits\n   \
    \     val xorBitsString = xorBits.map(_ + 48).map(_.toString).mkString(\"\")\n\
    \        xorBitsString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpstz0qqfb.scala:7:22 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpstz0qqfb.scala:8:22 -------------------------\e[0m\e\
    [0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m      \
    \              value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659978707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aBits = a.toIntArray\n\
    \        val bBits = b.toIntArray\n        val xorBits = Array.ofDim[Int](8)\n\
    \        val xorBitsIndex = 0\n        for(i <- 0 until 8) {\n            xorBits(i)\
    \ = aBits(i) xor bBits(i)\n        }\n        val xorBitsString = Integer.toBinaryString(xorBits(7))\n\
    \        val xorBitsString2 = xorBitsString.substring(0,xorBitsString.length-1)\n\
    \        val xorBitsString3 = xorBitsString.substring(xorBitsString.length-1)\n\
    \        xorBitsString2 +xorBitsString3\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxdedzjvd.scala:7:22 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpxdedzjvd.scala:8:22 -------------------------\e[0m\e\
    [0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m      \
    \              value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659978716
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        var resultArray = new Array[Char](b.length)\n\
    \        var i = 0\n        while (i < b.length) {\n            resultArray(i)\
    \ = aArray(i) xor bArray(i)\n            i += 1\n        }\n        return new\
    \ String(resultArray)\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpa46z4r55.scala:12:39 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            resultArray(i) = aArray(i) xor bArray(i)\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                             value xor is not a member of Char\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978716
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aBits = a.toIntArray\n\
    \        val bBits = b.toIntArray\n        val xorBits = Array.ofDim[Int](aBits.length)\n\
    \        val xorBitsLen = aBits.length\n        val xorBitsLenMinusOne = xorBitsLen\
    \ - 1\n        val xorBitsLenMinusOneOne = xorBitsLenMinusOne - 1\n        val\
    \ xorBitsLenMinusOneTwo = xorBitsLenMinusOne - 2\n        val xorBitsLenMinusOneThree\
    \ = xorBitsLenMinusOne - 3\n        val xorBitsLenMinusOneFour = xorBitsLenMinusOne\
    \ - 4\n        val xorBitsLenMinusOneFive = xorBitsLenMinusOne - 5\n        val\
    \ xorBitsLenMinusOneSix = xorBitsLenMinusOne - 6\n        val xorBitsLenMinusOneSeven\
    \ = xorBitsLenMinusOne - 7\n        val xorBitsLenMinusOneEight = xorBitsLenMinusOne\
    \ - 8\n        val xorBitsLenMinusOneNine = xorBitsLenMinusOne - 9\n        val\
    \ xorBitsLenMinusOneTen = xorBitsLenMinusOne - 10\n        val xorBitsLenMinusOneEleven\
    \ = xorBitsLenMinusOne - 11\n        val xorBitsLenMinusOneTwelve = xorBitsLenMinusOne\
    \ - 12\n        val xorBitsLenMinusOneThirteen = xorBitsLenMinusOne - 13\n   \
    \     val xorBitsLenMinusOneFourteen = xorBitsLenMinusOne - 14\n        val xorBitsLenMinusOneFifteen\
    \ = xorBitsLenMinusOne - 15\n        val xorBitsLenMinusOneSixteen = xorBitsLenMinusOne\
    \ - 16\n        val xorBitsLenMinusOneSeventeen = xorBitsLenMinusOne - 17\n  \
    \      val xorBitsLenMinusOneEighteen = xorBitsLenMinusOne - 18\n        val xorBitsLenMinusOneNineteen\
    \ = xorBitsLenMinusOne - 19\n        val xorBitsLenMinusOneTwenty = xorBitsLenMinusOne\
    \ - 20\n        val xorBitsLenMinusOneTwent\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpkxsd_gyh.scala:33:4 ----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkxsd_gyh.scala:7:22\
    \ -------------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e\
    [36maBits\e[0m = a.toIntArray\n\e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e\
    [0m\n\e[31m  |\e[0m                    value toIntArray is not a member of String\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkxsd_gyh.scala:8:22 -------------------------\e\
    [0m\e[0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpkxsd_gyh.scala:33:5 ---------------------\e[0m\e\
    [0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978717
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aBits = a.toIntArray\n\
    \        val bBits = b.toIntArray\n        val xorBits = Array.ofDim[Int](Math.max(aBits.length,\
    \ bBits.length))\n        var i = 0\n        while (i < xorBits.length) {\n  \
    \          xorBits(i) = aBits(i).xor(bBits(i))\n            i += 1\n        }\n\
    \        xorBits.mkString(\"\")\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfttpcjyn.scala:7:22 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpfttpcjyn.scala:8:22 -------------------------\e[0m\e\
    [0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m      \
    \              value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Char](a.length)\n\
    \        for(i <- 0 until xorArray.length)\n            xorArray(i) = (xorArray(i)\
    \ xor aArray(i) xor bArray(i)).toChar\n        new String(xorArray)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpp2soq4hc.scala:11:39 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m            xorArray(i) = (xorArray(i) xor aArray(i)\
    \ xor bArray(i)).toChar\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           value xor is not a member of Char\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659978717
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = Array.ofDim[Int](8)\n\
    \        val xorArray2 = Array.ofDim[Int](8)\n        val xorArray3 = Array.ofDim[Int](8)\n\
    \        val xorArray4 = Array.ofDim[Int](8)\n        val xorArray5 = Array.ofDim[Int](8)\n\
    \        val xorArray6 = Array.ofDim[Int](8)\n        val xorArray7 = Array.ofDim[Int](8)\n\
    \        val xorArray8 = Array.ofDim[Int](8)\n        val xorArray9 = Array.ofDim[Int](8)\n\
    \        val xorArray10 = Array.ofDim[Int](8)\n        val xorArray11 = Array.ofDim[Int](8)\n\
    \        val xorArray12 = Array.ofDim[Int](8)\n        val xorArray13 = Array.ofDim[Int](8)\n\
    \        val xorArray14 = Array.ofDim[Int](8)\n        val xorArray15 = Array.ofDim[Int](8)\n\
    \        val xorArray16 = Array.ofDim[Int](8)\n        val xorArray17 = Array.ofDim[Int](8)\n\
    \        val xorArray18 = Array.ofDim[Int](8)\n        val xorArray19 = Array.ofDim[Int](8)\n\
    \        val xorArray20 = Array.ofDim[Int](8)\n        val xorArray21 = Array.ofDim[Int](8)\n\
    \        val xorArray22 = Array.ofDim[Int](8)\n        val xorArray23 = Array.ofDim[Int](8)\n\
    \        val xorArray24 = Array.ofDim[Int](8)\n        val xorArray25 = Array.ofDim[Int](8)\n\
    \        val xorArray26 = Array.ofDim[Int](8)\n        val xorArray27 = Array.ofDim[Int](8)\n\
    \        val xorArray28 = Array.ofDim[Int](8)\n        val xorArray29 = Array.ofDim[Int](8)\n\
    \        val xorArray30 = Array.ofDim[Int](8)\n        val xorArray31 = Array.ofDim[Int](8)\n\
    \        val xorArray32 = Array.ofDim[Int](8)\n        val xorArray33 = Array.ofDim[Int](8)\n\
    \        val xorArray34 = Array.ofDim[Int](8)\n        val xorArray35 = Array.ofDim[Int](8)\n\
    \        val xorArray\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpa9fp68do.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpa9fp68do.scala:45:5 ---------------------\e[0m\e[0m\n\e[31m45 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val result = new mutable.StringBuilder\n\
    \        val xor = a.zip(b).map(x => x._1 xor x._2)\n        xor.foreach(x =>\
    \ result.append(x.toChar))\n        result.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv9quxtld.scala:9:25 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.StringBuilder\n\e[31m\e[31m  |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m  |\e[0m                         Not found: mutable\n\e[31m  |\e[0m\n\
    \e[31m  |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpv9quxtld.scala:10:41 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mxor\e[0m = a.zip(b).map(\e\
    [36mx\e[0m => x._1 xor x._2)\n\e[31m\e[31m   |\e[0m                          \
    \          ^^^^^^^^\e[0m\n\e[31m   |\e[0m                                    value\
    \ xor is not a member of Char\n2 errors found\n"
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val result = new mutable.StringBuilder\n\
    \        var carry = 0\n        for(i <- 0 until aList.length){\n            val\
    \ aChar = aList(i)\n            val bChar = bList(i)\n            val xor = aChar\
    \ xor bChar\n            val newCarry = xor & carry\n            carry = newCarry\
    \ >> 1\n            result.append(newCarry)\n        }\n        result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbfkzk3un.scala:9:25 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.StringBuilder\n\e[31m\e[31m  |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m  |\e[0m                         Not found: mutable\n\e[31m  |\e[0m\n\
    \e[31m  |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpbfkzk3un.scala:14:28 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            \e[33mval\e[0m \e[36mxor\e[0m = aChar xor\
    \ bChar\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Char\n2 errors found\n"
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Char](a.length)\n\
    \        for(i <- 0 until xorArray.length){\n            xorArray(i) = aArray(i)\
    \ xor bArray(i)\n        }\n        xorArray.toString.reverse\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpq67g8705.scala:11:36 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n\
    \        aList.zip(bList).foreach { case (aChar, bChar) =>\n            xorList\
    \ += (aChar ^ bChar).toString\n        }\n        xorList.toString\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2gh0ja7u.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978715
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val xorResult = mutable.Buffer.empty[String]\n\
    \        val xorResultList = mutable.Buffer.empty[Int]\n        val xorResultList2\
    \ = mutable.Buffer.empty[Int]\n        val xorResultList3 = mutable.Buffer.empty[Int]\n\
    \        val xorResultList4 = mutable.Buffer.empty[Int]\n        val xorResultList5\
    \ = mutable.Buffer.empty[Int]\n        val xorResultList6 = mutable.Buffer.empty[Int]\n\
    \        val xorResultList7 = mutable.Buffer.empty[Int]\n        val xorResultList8\
    \ = mutable.Buffer.empty[Int]\n        val xorResultList9 = mutable.Buffer.empty[Int]\n\
    \        val xorResultList10 = mutable.Buffer.empty[Int]\n        val xorResultList11\
    \ = mutable.Buffer.empty[Int]\n        val xorResultList12 = mutable.Buffer.empty[Int]\n\
    \        val xorResultList13 = mutable.Buffer.empty[Int]\n        val xorResultList14\
    \ = mutable.Buffer.empty[Int]\n        val xorResultList15 = mutable.Buffer.empty[Int]\n\
    \        val xorResultList16 = mutable.Buffer.empty[Int]\n        val xorResultList17\
    \ = mutable.Buffer.empty[Int]\n        val xorResultList18 = mutable.Buffer.empty[Int]\n\
    \        val xorResultList19 = mutable.Buffer.empty[Int]\n        val xorResultList20\
    \ = mutable.Buffer.empty[Int]\n        val xorResultList21 = mutable.Buffer.empty[Int]\n\
    \        val xorResultList22 = mutable.Buffer.empty[Int]\n        val xorResultList23\
    \ = mutable.Buffer.empty[Int]\n        val xorResultList24 = mutable.Buffer.empty[Int]\n\
    \        val xorResultList25 = mutable.Buffer.empty[Int]\n        val xorResultList26\
    \ = mutable.Buffer.empty[Int]\n        val xorResultList27 = mutable.Buffer.empty[Int]\n\
    \        val xorResultList28 = mutable.Buffer.empty[Int]\n        val xorResultList29\
    \ = mutable.Buffer.empty[Int]\n        val xorResultList30 = mutable.Buffer.empty[Int]\n\
    \        val xorResultList31 = mutable.Buffer.empty[Int]\n        val xorResultList32\
    \ = mutable.Buffer.empty[Int]\n        val xorResultList33 = mutable.Buffer.empty[Int]\n\
    \        \n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp55qndqe_.scala:9:24 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorResult\e[0m = mutable.Buffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m  |\e[0m                        ^^^^^^^\e[0m\n\e\
    [31m  |\e[0m                        Not found: mutable\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp55qndqe_.scala:10:28 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mxorResultList\e[0m = mutable.Buffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                            Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp55qndqe_.scala:11:29 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorResultList2\e[0m = mutable.Buffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                             Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp55qndqe_.scala:12:29 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mxorResultList3\e[0m = mutable.Buffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                             Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp55qndqe_.scala:13:29 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mxorResultList4\e[0m = mutable.Buffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                             Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp55qndqe_.scal"
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = Array.ofDim[Int](aArray.length)\n\
    \        for(i <- 0 until xorArray.length) xorArray(i) = aArray(i) xor bArray(i)\n\
    \        xorArray.toString.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpg6azjxj7.scala:10:66 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mfor\e[0m(i <- \e[31m0\e[0m until xorArray.length)\
    \ xorArray(i) = aArray(i) xor bArray(i)\n\e[31m\e[31m   |\e[0m               \
    \                                         ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                        value xor is not a member of Int\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toCharArray\n\
    \        val bList = b.toCharArray\n        val xorResult = mutable.ArrayBuffer.empty[Char]\n\
    \        for(i <- 0 until aList.length) xorResult += (aList(i) xor bList(i))\n\
    \        xorResult.toString\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"\
    1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpl38qj7on.scala:9:24 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorResult\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mChar\e[0m]\n\e[31m\e[31m  |\e[0m                        ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                        Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978715
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val xorResult = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until aList.length){\n            xorResult += aList(i) xor\
    \ bList(i)\n        }\n        xorResult.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm2nzcqps.scala:9:24 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorResult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m  |\e[0m                        ^^^^^^^\e[0m\n\e\
    [31m  |\e[0m                        Not found: mutable\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978715
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val result = new StringBuilder\n\
    \        for(i <- 0 until aArray.length)\n            result.append(aArray(i)\
    \ XOR bArray(i))\n        return result.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpq2zc9nq7.scala:11:36 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m            result.append(aArray(i) XOR bArray(i))\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value XOR is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659978717
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Char](b.length)\n\
    \        var i = 0\n        while (i < xorArray.length) {\n            xorArray(i)\
    \ = aArray(i) ^ bArray(i)\n            i += 1\n        }\n        xorArray.toString.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8jwkw4ey.scala:12:26\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m            xorArray(i) = aArray(i)\
    \ ^ bArray(i)\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          Found:    Int\n\e[31m   |\e[0m \
    \                         Required: Char\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Char](a.length)\n\
    \        for(i <- 0 until xorArray.length) xorArray(i) = 0\n        for(i <- 0\
    \ until aArray.length) xorArray(aArray(i) XOR bArray(i)) = aArray(i) XOR bArray(i)\n\
    \        new String(xorArray)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzb212pnh.scala:11:59 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mfor\e[0m(i <- \e[31m0\e[0m until aArray.length)\
    \ xorArray(aArray(i) XOR bArray(i)) = aArray(i) XOR bArray(i)\n\e[31m\e[31m  \
    \ |\e[0m                                                 ^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                       value XOR is not a member\
    \ of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzb212pnh.scala:11:86\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mfor\e[0m(i\
    \ <- \e[31m0\e[0m until aArray.length) xorArray(aArray(i) XOR bArray(i)) = aArray(i)\
    \ XOR bArray(i)\n\e[31m\e[31m   |\e[0m                                       \
    \                                     ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                                   value XOR is not a member of Char\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toCharArray\n\
    \        val bList = b.toCharArray\n        val xorResult = mutable.ArrayBuffer.empty[Char]\n\
    \        for(i <- 0 until aList.length)\n            for(j <- 0 until bList.length)\n\
    \                xorResult += (aList(i) xor bList(j))\n        xorResult.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyjqgrqy3.scala:9:24 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorResult\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mChar\e[0m]\n\e[31m\e[31m  |\e[0m                        ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                        Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978715
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toCharArray\n\
    \        val bList = b.toCharArray\n        val xorResult = mutable.ArrayBuffer.empty[Char]\n\
    \        for(i <- 0 until aList.length){\n            xorResult += aList(i) xor\
    \ bList(i)\n        }\n        xorResult.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmph5c_iimu.scala:9:24 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorResult\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mChar\e[0m]\n\e[31m\e[31m  |\e[0m                        ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                        Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978715
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val result = new mutable.ListBuffer[String]()\n\
    \        val aLen = aList.length\n        val bLen = bList.length\n        val\
    \ aLenInt = aLen.toInt\n        val bLenInt = bLen.toInt\n        val aLenBits\
    \ = aLenInt.bitLength\n        val bLenBits = bLenInt.bitLength\n        val aLenBitsInt\
    \ = (1L << aLenBits).toInt\n        val bLenBitsInt = (1L << bLenBits).toInt\n\
    \        val aLenBitsInt2 = aLenBitsInt * 2\n        val bLenBitsInt2 = bLenBitsInt\
    \ * 2\n        val aLenBitsInt3 = aLenBitsInt * 3\n        val bLenBitsInt3 =\
    \ bLenBitsInt * 3\n        val aLenBitsInt4 = aLenBitsInt * 4\n        val bLenBitsInt4\
    \ = bLenBitsInt * 4\n        val aLenBitsInt5 = aLenBitsInt * 5\n        val bLenBitsInt5\
    \ = bLenBitsInt * 5\n        val aLenBitsInt6 = aLenBitsInt * 6\n        val bLenBitsInt6\
    \ = bLenBitsInt * 6\n        val aLenBitsInt7 = aLenBitsInt * 7\n        val bLenBitsInt7\
    \ = bLenBitsInt * 7\n        val aLenBitsInt8 = aLenBitsInt * 8\n        val bLenBitsInt8\
    \ = bLenBitsInt * 8\n        val aLenBitsInt9 = aLenBitsInt * 9\n        val bLenBitsInt9\
    \ = bLenBitsInt * 9\n        val aLenBitsInt10 = aLenBitsInt * 10\n        val\
    \ bLenBitsInt10 = bLenBitsInt * 10\n        val aLenBitsInt11 = aLenBitsInt *\
    \ 11\n        val bLenBitsInt11 = bLenBitsInt * 11\n        val aLenBitsInt12\
    \ = aLenBitsInt * 12\n        val bLenBitsInt12 = bLenBitsInt * 12\n        val\
    \ aLenBitsInt13 = aLenBitsInt * 13\n        val bLenBitsInt13 = bLenBitsInt *\
    \ 13\n        val aLenBitsInt14 = aLenBitsInt * 14\n        val bLenBitsInt14\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3fvc_nps.scala:44:4 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3fvc_nps.scala:9:25\
    \ -------------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e\
    [31m  |\e[0m                         ^^^^^^^\e[0m\n\e[31m  |\e[0m            \
    \             Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp3fvc_nps.scala:14:31 ------------------------\e[0m\e[0m\n\e[31m14 |\e\
    [0m        \e[33mval\e[0m \e[36maLenBits\e[0m = aLenInt.bitLength\n\e[31m\e[31m\
    \   |\e[0m                       ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ bitLength is not a member of Int, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe following import might fix the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.BigInt.int2bigInt\n\e\
    [31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3fvc_nps.scala:15:31\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mbLenBits\e[0m = bLenInt.bitLength\n\e[31m\e[31m   |\e[0m                 \
    \      ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue bitLength is not a member\
    \ of Int, but could be made available as an extension method.\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mThe following import might fix the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.BigInt.int2bigInt\n\e[31m   |\e[0m\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp3fvc_nps.scala:44:5 ---------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1659978720
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aBits = a.toIntArray\n\
    \        val bBits = b.toIntArray\n        val xorBits = aBits XOR bBits\n   \
    \     val xorBitsString = xorBits.map(_ + 48).map(_.toString).mkString(\"\")\n\
    \        return xorBitsString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo_8yeaht.scala:7:22 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpo_8yeaht.scala:8:22 -------------------------\e[0m\e\
    [0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m      \
    \              value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659978719
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = Array.ofDim[Int](2)\n\
    \        val xorArray2 = Array.ofDim[Int](2)\n        val xorArray3 = Array.ofDim[Int](2)\n\
    \        val xorArray4 = Array.ofDim[Int](2)\n        val xorArray5 = Array.ofDim[Int](2)\n\
    \        val xorArray6 = Array.ofDim[Int](2)\n        val xorArray7 = Array.ofDim[Int](2)\n\
    \        val xorArray8 = Array.ofDim[Int](2)\n        val xorArray9 = Array.ofDim[Int](2)\n\
    \        val xorArray10 = Array.ofDim[Int](2)\n        val xorArray11 = Array.ofDim[Int](2)\n\
    \        val xorArray12 = Array.ofDim[Int](2)\n        val xorArray13 = Array.ofDim[Int](2)\n\
    \        val xorArray14 = Array.ofDim[Int](2)\n        val xorArray15 = Array.ofDim[Int](2)\n\
    \        val xorArray16 = Array.ofDim[Int](2)\n        val xorArray17 = Array.ofDim[Int](2)\n\
    \        val xorArray18 = Array.ofDim[Int](2)\n        val xorArray19 = Array.ofDim[Int](2)\n\
    \        val xorArray20 = Array.ofDim[Int](2)\n        val xorArray21 = Array.ofDim[Int](2)\n\
    \        val xorArray22 = Array.ofDim[Int](2)\n        val xorArray23 = Array.ofDim[Int](2)\n\
    \        val xorArray24 = Array.ofDim[Int](2)\n        val xorArray25 = Array.ofDim[Int](2)\n\
    \        val xorArray26 = Array.ofDim[Int](2)\n        val xorArray27 = Array.ofDim[Int](2)\n\
    \        val xorArray28 = Array.ofDim[Int](2)\n        val xorArray29 = Array.ofDim[Int](2)\n\
    \        val xorArray30 = Array.ofDim[Int](2)\n        val xorArray31 = Array.ofDim[Int](2)\n\
    \        val xorArray32 = Array.ofDim[Int](2)\n        val xorArray33 = Array.ofDim[Int](2)\n\
    \        val xorArray34 = Array.ofDim[Int](2)\n        val xorArray35 = Array.ofDim[Int](2)\n\
    \        val xorArray\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9xc0aymq.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp9xc0aymq.scala:45:5 ---------------------\e[0m\e[0m\n\e[31m45 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Char](Math.max(aArray.length,\
    \ bArray.length))\n        var i = 0\n        while (i < xorArray.length) {\n\
    \            xorArray(i) = aArray(i) xor bArray(i)\n            i += 1\n     \
    \   }\n        new String(xorArray)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpm5o2o3_j.scala:12:36 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659978706
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aBits = a.toIntArray\n\
    \        val bBits = b.toIntArray\n        val xorBits = aBits xor bBits\n   \
    \     val xorBitsString = xorBits.map(_ + 48).map(_.toString).mkString(\"\")\n\
    \        xorBitsString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpstz0qqfb.scala:7:22 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpstz0qqfb.scala:8:22 -------------------------\e[0m\e\
    [0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m      \
    \              value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659978707
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val result = new StringBuilder\n\
    \        var i = 0\n        while (i < a.length) {\n            result.append(aArray(i)\
    \ ^ bArray(i))\n            i += 1\n        }\n        return result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978728
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aBits = a.toIntArray\n\
    \        val bBits = b.toIntArray\n        val xorBits = Array.ofDim[Int](aBits.length)\n\
    \        for(i <- 0 until xorBits.length) xorBits(i) = aBits(i) xor bBits(i)\n\
    \        new String(xorBits)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"\
    1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpp2qpv4oi.scala:7:22 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpp2qpv4oi.scala:8:22 -------------------------\e[0m\e\
    [0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m      \
    \              value toIntArray is not a member of String\n\e[31m\e[31m-- [E134]\
    \ Type Error: /tmp/tmpp2qpv4oi.scala:11:12 -----------------------------\e[0m\e\
    [0m\n\e[31m11 |\e[0m        \e[33mnew\e[0m \e[35mString\e[0m(xorBits)\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mconstructor\e[0m \e[35mString\e[0m in \e[33mclass\e[0m \e[35mString\e\
    [0m with types\n\e[31m   |\e[0m (x$0: StringBuilder): String\n\e[31m   |\e[0m\
    \ (x$0: StringBuffer): String\n\e[31m   |\e[0m (x$0: Array[Byte]): String\n\e\
    [31m   |\e[0m (x$0: Array[Byte], x$1: Int, x$2: Int): String\n\e[31m   |\e[0m\
    \ (x$0: Array[Byte], x$1: java.nio.charset.Charset): String\n\e[31m   |\e[0m (x$0:\
    \ Array[Byte], x$1: String): String\n\e[31m   |\e[0m (x$0: Array[Byte], x$1: Int,\
    \ x$2: Int, x$3: java.nio.charset.Charset): String\n\e[31m   |\e[0m (x$0: Array[Byte],\
    \ x$1: Int, x$2: Int, x$3: String): String\n\e[31m   |\e[0m (x$0: Array[Byte],\
    \ x$1: Int): String\n\e[31m   |\e[0m (x$0: Array[Byte], x$1: Int, x$2: Int, x$3:\
    \ Int): String\n\e[31m   |\e[0m (x$0: Array[Int], x$1: Int, x$2: Int): String\n\
    \e[31m   |\e[0m (x$0: Array[Char], x$1: Int, x$2: Int): String\n\e[31m   |\e[0m\
    \ (x$0: Array[Char]): String\n\e[31m   |\e[0m (x$0: String): String\n\e[31m  \
    \ |\e[0m (): String\n\e[31m   |\e[0mmatch arguments ((xorBits : Array[Int]))\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659978726
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Int](aArray.length)\n\
    \        var xor = 0\n        var i = 0\n        while (i < aArray.length) {\n\
    \            xor = xor + ((aArray(i) ^ bArray(i)) & 1)\n            xorArray(i)\
    \ = xor\n            i = i + 1\n        }\n        val xorString = new String(xorArray)\n\
    \        return xorString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpt4d8502t.scala:17:28 -----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mxorString\e[0m = \e[33mnew\e\
    [0m \e[35mString\e[0m(xorArray)\n\e[31m\e[31m   |\e[0m                       \
    \     ^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mconstructor\e\
    [0m \e[35mString\e[0m in \e[33mclass\e[0m \e[35mString\e[0m with types\n\e[31m\
    \   |\e[0m (x$0: StringBuilder): String\n\e[31m   |\e[0m (x$0: StringBuffer):\
    \ String\n\e[31m   |\e[0m (x$0: Array[Byte]): String\n\e[31m   |\e[0m (x$0: Array[Byte],\
    \ x$1: Int, x$2: Int): String\n\e[31m   |\e[0m (x$0: Array[Byte], x$1: java.nio.charset.Charset):\
    \ String\n\e[31m   |\e[0m (x$0: Array[Byte], x$1: String): String\n\e[31m   |\e\
    [0m (x$0: Array[Byte], x$1: Int, x$2: Int, x$3: java.nio.charset.Charset): String\n\
    \e[31m   |\e[0m (x$0: Array[Byte], x$1: Int, x$2: Int, x$3: String): String\n\e\
    [31m   |\e[0m (x$0: Array[Byte], x$1: Int): String\n\e[31m   |\e[0m (x$0: Array[Byte],\
    \ x$1: Int, x$2: Int, x$3: Int): String\n\e[31m   |\e[0m (x$0: Array[Int], x$1:\
    \ Int, x$2: Int): String\n\e[31m   |\e[0m (x$0: Array[Char], x$1: Int, x$2: Int):\
    \ String\n\e[31m   |\e[0m (x$0: Array[Char]): String\n\e[31m   |\e[0m (x$0: String):\
    \ String\n\e[31m   |\e[0m (): String\n\e[31m   |\e[0mmatch arguments ((xorArray\
    \ : Array[Int]))\n1 error found\n"
  stdout: ''
  timestamp: 1659978723
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = ArrayBuffer.empty[Int]\n\
    \        var xor = 0\n        var i = 0\n        while (i < aArray.length) {\n\
    \            xor = xor + aArray(i) ^ bArray(i)\n            i = i + 1\n      \
    \  }\n        xor.toString\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"\
    1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6zxwd874.scala:19)\n\tat Problem.main(tmp6zxwd874.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978728
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aBits = a.toIntArray\n\
    \        val bBits = b.toIntArray\n        val xorBits = Array.ofDim[Int](Math.max(aBits.length,\
    \ b.length))\n        val xorBitsIndex = 0\n        for (i <- 0 until xorBits.length)\
    \ {\n            if (aBits(i) != bBits(i)) {\n                xorBits(xorBitsIndex)\
    \ = xorBitsIndex\n                xorBitsIndex += 1\n            }\n        }\n\
    \        xorBits.toString.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwa5jauif.scala:7:22 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpwa5jauif.scala:8:22 -------------------------\e[0m\e\
    [0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m      \
    \              value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpwa5jauif.scala:14:29 ------------------------\e[0m\e\
    [0m\n\e[31m14 |\e[0m                xorBitsIndex += \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         value\
    \ += is not a member of Int - did you mean xorBitsIndex.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1659978728
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aBits = a.toIntArray\n\
    \        val bBits = b.toIntArray\n        val xorBits = Array.ofDim[Int](8)\n\
    \        val xorResult = Array.ofDim[Int](8)\n        val xorResultBits = Array.ofDim[Int](8)\n\
    \        val xorResultBitsLen = Array.ofDim[Int](8)\n        val xorResultBitsLenLen\
    \ = Array.ofDim[Int](8)\n        val xorResultBitsLenLenLen = Array.ofDim[Int](8)\n\
    \        val xorResultBitsLenLenLenLen = Array.ofDim[Int](8)\n        val xorResultBitsLenLenLenLenLen\
    \ = Array.ofDim[Int](8)\n        val xorResultBitsLenLenLenLenLenLen = Array.ofDim[Int](8)\n\
    \        val xorResultBitsLenLenLenLenLenLenLen = Array.ofDim[Int](8)\n      \
    \  val xorResultBitsLenLenLenLenLenLenLenLen = Array.ofDim[Int](8)\n        val\
    \ xorResultBitsLenLenLenLenLenLenLenLenLen = Array.ofDim[Int](8)\n        val\
    \ xorResultBitsLenLenLenLenLenLenLenLenLenLen = Array.ofDim[Int](8)\n        val\
    \ xorResultBitsLenLenLenLenLenLenLenLenLenLen = Array.ofDim[Int](8)\n        val\
    \ xorResultBitsLenLenLenLenLenLenLenLenLenLenLen = Array.ofDim[Int](8)\n     \
    \   val xorResultBitsLenLenLenLenLenLenLenLenLenLenLenLen = Array.ofDim[Int](8)\n\
    \        val xorResultBitsLenLenLenLenLenLenLenLenLenLenLenLenLen = Array.ofDim[Int](8)\n\
    \        val xorResultBitsLenLenLenLenLenLenLenLenLenLenLenLenLen = Array.ofDim[Int](8)\n\
    \        val xorResultBitsLenLenLenLenLenLenLenLenLenLenLenLenLenLen = Array.ofDim[Int](8)\n\
    \        val xorResultBitsLenLenLenLenLenLenLenLenLenLenLenLenLenLen = Array.ofDim[Int](8)\n\
    \        val xorResultBitsLenLenLenLenLenLenLenLenLenLenLenLenLenLenLen = Array.ofDim[Int](8)\n\
    \        val xorResultBitsLenLenLenLenLenLenLenLenLenLenLenLenLenLenLen = Array.ofDim\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkql0x_xy.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mxorResultBitsLenLenLenLenLenLenLenLenLenLen\e\
    [0m = Array.ofDim[\e[35mInt\e[0m](\e[31m8\e[0m)\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mxorResultBitsLenLenLenLenLenLenLenLenLenLen is already defined\
    \ as \e[33mvalue\e[0m \e[35mxorResultBitsLenLenLenLenLenLenLenLenLenLen\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpkql0x_xy.scala:26:12 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36mxorResultBitsLenLenLenLenLenLenLenLenLenLenLenLenLen\e\
    [0m = Array.ofDim[\e[35mInt\e[0m](\e[31m8\e[0m)\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorResultBitsLenLenLenLenLenLenLenLenLenLenLenLenLen is already\
    \ defined as \e[33mvalue\e[0m \e[35mxorResultBitsLenLenLenLenLenLenLenLenLenLenLenLenLen\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpkql0x_xy.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36mxorResultBitsLenLenLenLenLenLenLenLenLenLenLenLenLenLen\e\
    [0m = Array.ofDim[\e[35mInt\e[0m](\e[31m8\e[0m)\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorResultBitsLenLenLenLenLenLenLenLenLenLenLenLenLenLen is\
    \ already defined as \e[33mvalue\e[0m \e[35mxorResultBitsLenLenLenLenLenLenLenLenLenLenLenLenLenLen\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpkql0x_xy.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mxorResultBitsLenLenLenLenLenLenLenLenLenLenLenLenLenL"
  stdout: ''
  timestamp: 1659978728
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toCharArray.map(_.toInt)\n\
    \        val bList = b.toCharArray.map(_.toInt)\n        val xorList = mutable.ListBuffer.empty[Int]\n\
    \        for(i <- 0 until aList.length) xorList += (aList(i) xor bList(i))\n \
    \       xorList.toString.reverse.mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptc9wgge7.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978724
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = ArrayBuffer.empty[Int]\n\
    \        for(i <- 0 until aArray.length) xorArray += (aArray(i) xor bArray(i))\n\
    \        xorArray.toString.toCharArray\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpy35joqu5.scala:10:63 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mfor\e[0m(i <- \e[31m0\e[0m until aArray.length)\
    \ xorArray += (aArray(i) xor bArray(i))\n\e[31m\e[31m   |\e[0m               \
    \                                      ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                                     value xor is not a member of Int\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpy35joqu5.scala:11:8 ---------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        xorArray.toString.toCharArray\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:\
    \    Array[Char]\n\e[31m   |\e[0m        Required: String\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978728
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Char](b.length)\n\
    \        for(i <- 0 until xorArray.length){\n            xorArray(i) = aArray(i)\
    \ ^ bArray(i)\n        }\n        new String(xorArray)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9o6nxny6.scala:11:26\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m            xorArray(i) = aArray(i)\
    \ ^ bArray(i)\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          Found:    Int\n\e[31m   |\e[0m \
    \                         Required: Char\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978728
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Char](aArray.length)\n\
    \        var i = 0\n        while (i < xorArray.length) {\n            xorArray(i)\
    \ = aArray(i) xor bArray(i)\n            i += 1\n        }\n        xorArray.toString.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpu0v78z0c.scala:12:36 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659978728
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toCharArray.map(_.toInt)\n\
    \        val bList = b.toCharArray.map(_.toInt)\n        val result = new mutable.ListBuffer[Int]()\n\
    \        val xor = mutable.ListBuffer[Int]()\n        var i = 0\n        while\
    \ (i < aList.length && i < bList.length) {\n            val aVal = aList(i)\n\
    \            val bVal = bList(i)\n            if (aVal ^ bVal != 0) {\n      \
    \          xor += aVal ^ bVal\n            }\n            i += 1\n        }\n\
    \        result.add(xor.toList)\n        new StringBuilder(result.toList).reverse.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpimiafss1.scala:9:25 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mInt\e[0m]()\n\e[31m\e[31m  |\e[0m               \
    \          ^^^^^^^\e[0m\n\e[31m  |\e[0m                         Not found: mutable\n\
    \e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpimiafss1.scala:10:18\
    \ ------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e\
    [36mxor\e[0m = mutable.ListBuffer[\e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpimiafss1.scala:15:21 -----------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            \e[33mif\e[0m (aVal ^ bVal != \e[31m0\e[0m)\
    \ {\n\e[31m\e[31m   |\e[0m                ^^^^^^\e[0m\n\e[31m   |\e[0m None of\
    \ the overloaded alternatives of \e[33mmethod\e[0m \e[35m^\e[0m in \e[33mclass\e\
    [0m \e[35mInt\e[0m with types\n\e[31m   |\e[0m  (x: Long): Long\n\e[31m   |\e\
    [0m  (x: Int): Int\n\e[31m   |\e[0m  (x: Char): Int\n\e[31m   |\e[0m  (x: Short):\
    \ Int\n\e[31m   |\e[0m  (x: Byte): Int\n\e[31m   |\e[0m match arguments (Boolean)\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659978726
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Char](a.length)\n\
    \        for(i <- 0 until xorArray.length) xorArray(i) = (xorArray(i) xor aArray(i))\
    \ xor (xorArray(i) xor bArray(i))\n        new String(xorArray)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9gozb7h0.scala:10:69 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mfor\e[0m(i <- \e[31m0\e[0m until xorArray.length)\
    \ xorArray(i) = (xorArray(i) xor aArray(i)) xor (xorArray(i) xor bArray(i))\n\e\
    [31m\e[31m   |\e[0m                                                         ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                       value xor is not a\
    \ member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659978729
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toCharArray\n\
    \        val bList = b.toCharArray\n        val xorList = mutable.ArrayBuffer.empty[Char]\n\
    \        for(i <- 0 until aList.length)\n            for(j <- 0 until bList.length)\n\
    \                if(aList(i) == bList(j))\n                    xorList += aList(i)\n\
    \        xorList.toString.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8hs3kjd6.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mChar\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978726
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val xorList = mutable.ListBuffer[Int]()\n\
    \        for(i <- 0 until aList.length){\n            xorList += (aList(i) xor\
    \ bList(i))\n        }\n        xorList.toList.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9832exzo.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978725
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aBits = a.toIntArray\n\
    \        val bBits = b.toIntArray\n        val xorBits = aBits xor bBits\n   \
    \     val xorBitsString = xorBits.map(bit => if (bit == 1) \"1\" else \"0\").mkString\n\
    \        xorBitsString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5kr2bq4_.scala:7:22 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp5kr2bq4_.scala:8:22 -------------------------\e[0m\e\
    [0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m      \
    \              value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659978707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val result = new StringBuilder\n      \
    \  var carry = 0\n        for (i <- 0 until aList.size) {\n            val aChar\
    \ = aList(i)\n            val bChar = bList(i)\n            val xor = aChar xor\
    \ bChar\n            val newCarry = xor and carry\n            carry = newCarry\
    \ xor carry\n            result.append(newCarry)\n        }\n        carry match\
    \ {\n            case 0 => result.toString\n            case _ => result.toString\
    \ + \"1\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3g3bmro8.scala:14:28 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            \e[33mval\e[0m \e[36mxor\e[0m = aChar xor\
    \ bChar\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659978729
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Char](b.length)\n\
    \        for(i <- 0 until xorArray.length)\n            xorArray(i) = (aArray(i)\
    \ XOR bArray(i)).toChar\n        new String(xorArray)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpt_8t5naj.scala:11:37 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m            xorArray(i) = (aArray(i) XOR bArray(i)).toChar\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                           value XOR is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659978728
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Char](aArray.length)\n\
    \        var xor = 0\n        var i = 0\n        while (i < aArray.length) {\n\
    \            xor = xor + aArray(i) XOR bArray(i)\n            xorArray(i) = xor.toChar\n\
    \            i = i + 1\n        }\n        xorArray.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdlrtvxmd.scala:13:34 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            xor = xor + aArray(i) XOR bArray(i)\n\e[31m\e\
    [31m   |\e[0m                  ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \             value XOR is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659978729
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val xorList = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until aList.length){\n            val xor = aList(i) xor bList(i)\n\
    \            xorList += xor.toChar\n        }\n        xorList.toString\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcghq1ab8.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpcghq1ab8.scala:11:31 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m            \e[33mval\e[0m \e[36mxor\e[0m = aList(i)\
    \ xor bList(i)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                      value xor is not a member of Char\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978729
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aBits = a.toIntArray\n\
    \        val bBits = b.toIntArray\n        val xorBits = Array.ofDim[Int](8)\n\
    \        val xorResult = Array.ofDim[Int](8)\n        val xorResultBits = Array.ofDim[Int](8)\n\
    \        val xorResultBitsSum = Array.ofDim[Int](8)\n        val xorResultBitsSumBits\
    \ = Array.ofDim[Int](8)\n        val xorResultBitsSumBitsBits = Array.ofDim[Int](8)\n\
    \        val xorResultBitsSumBitsBitsBits = Array.ofDim[Int](8)\n        val xorResultBitsSumBitsBitsBitsBits\
    \ = Array.ofDim[Int](8)\n        val xorResultBitsSumBitsBitsBitsBitsBits = Array.ofDim[Int](8)\n\
    \        val xorResultBitsSumBitsBitsBitsBitsBitsBits = Array.ofDim[Int](8)\n\
    \        val xorResultBitsSumBitsBitsBitsBitsBitsBitsBits = Array.ofDim[Int](8)\n\
    \        val xorResultBitsSumBitsBitsBitsBitsBitsBitsBitsBits = Array.ofDim[Int](8)\n\
    \        val xorResultBitsSumBitsBitsBitsBitsBitsBitsBitsBitsBits = Array.ofDim[Int](8)\n\
    \        val xorResultBitsSumBitsBitsBitsBitsBitsBitsBitsBitsBitsBits = Array.ofDim[Int](8)\n\
    \        val xorResultBitsSumBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBits = Array.ofDim[Int](8)\n\
    \        val xorResultBitsSumBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBits\
    \ = Array.ofDim[Int](8)\n        val xorResultBitsSumBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBits\
    \ = Array.ofDim[Int](8)\n        val xorResultBitsSumBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBits\
    \ = Array.ofDim[Int](8)\n        val xorResultBitsSumBitsBitsBitsBit\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpg1ubtatu.scala:28:4 ----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpg1ubtatu.scala:7:22\
    \ -------------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e\
    [36maBits\e[0m = a.toIntArray\n\e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e\
    [0m\n\e[31m  |\e[0m                    value toIntArray is not a member of String\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpg1ubtatu.scala:8:22 -------------------------\e\
    [0m\e[0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpg1ubtatu.scala:28:5 ---------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toCharArray\n\
    \        val bList = b.toCharArray\n        val result = new StringBuilder\n \
    \       val xor = new mutable.HashMap[Char, Int]()\n        for(i <- 0 until aList.length)\n\
    \            xor.put(aList(i), xor.getOrElse(aList(i), 0) + bList(i))\n      \
    \  for(i <- 0 until aList.length)\n            result.append(xor.getOrElse(aList(i),\
    \ 0))\n        result.toString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1nqtl7k9.scala:10:22 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mxor\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mChar\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978726
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = Array.ofDim[Int](2)\n\
    \        val xorArray2 = Array.ofDim[Int](2)\n        val xorArray3 = Array.ofDim[Int](2)\n\
    \        val xorArray4 = Array.ofDim[Int](2)\n        val xorArray5 = Array.ofDim[Int](2)\n\
    \        val xorArray6 = Array.ofDim[Int](2)\n        val xorArray7 = Array.ofDim[Int](2)\n\
    \        val xorArray8 = Array.ofDim[Int](2)\n        val xorArray9 = Array.ofDim[Int](2)\n\
    \        val xorArray10 = Array.ofDim[Int](2)\n        val xorArray11 = Array.ofDim[Int](2)\n\
    \        val xorArray12 = Array.ofDim[Int](2)\n        val xorArray13 = Array.ofDim[Int](2)\n\
    \        val xorArray14 = Array.ofDim[Int](2)\n        val xorArray15 = Array.ofDim[Int](2)\n\
    \        val xorArray16 = Array.ofDim[Int](2)\n        val xorArray17 = Array.ofDim[Int](2)\n\
    \        val xorArray18 = Array.ofDim[Int](2)\n        val xorArray19 = Array.ofDim[Int](2)\n\
    \        val xorArray20 = Array.ofDim[Int](2)\n        val xorArray21 = Array.ofDim[Int](2)\n\
    \        val xorArray22 = Array.ofDim[Int](2)\n        val xorArray23 = Array.ofDim[Int](2)\n\
    \        val xorArray24 = Array.ofDim[Int](2)\n        val xorArray25 = Array.ofDim[Int](2)\n\
    \        val xorArray26 = Array.ofDim[Int](2)\n        val xorArray27 = Array.ofDim[Int](2)\n\
    \        val xorArray28 = Array.ofDim[Int](2)\n        val xorArray29 = Array.ofDim[Int](2)\n\
    \        val xorArray30 = Array.ofDim[Int](2)\n        val xorArray31 = Array.ofDim[Int](2)\n\
    \        val xorArray32 = Array.ofDim[Int](2)\n        val xorArray33 = Array.ofDim[Int](2)\n\
    \        val xorArray34 = Array.ofDim[Int](2)\n        val xorArray35 = Array.ofDim[Int](2)\n\
    \        val xorArray\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9xc0aymq.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp9xc0aymq.scala:45:5 ---------------------\e[0m\e[0m\n\e[31m45 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aBits = a.toIntArray\n\
    \        val bBits = b.toIntArray\n        val xorBits = Array.ofDim[Int](8)\n\
    \        val xorResult = Array.ofDim[Int](8)\n        val xorResultBits = Array.ofDim[Int](8)\n\
    \        val xorResultBitsBits = Array.ofDim[Int](8)\n        val xorResultBitsBitsBits\
    \ = Array.ofDim[Int](8)\n        val xorResultBitsBitsBitsBits = Array.ofDim[Int](8)\n\
    \        val xorResultBitsBitsBitsBitsBits = Array.ofDim[Int](8)\n        val\
    \ xorResultBitsBitsBitsBitsBitsBitsBits = Array.ofDim[Int](8)\n        val xorResultBitsBitsBitsBitsBitsBitsBitsBits\
    \ = Array.ofDim[Int](8)\n        val xorResultBitsBitsBitsBitsBitsBitsBitsBitsBits\
    \ = Array.ofDim[Int](8)\n        val xorResultBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBits\
    \ = Array.ofDim[Int](8)\n        val xorResultBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBits\
    \ = Array.ofDim[Int](8)\n        val xorResultBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBits\
    \ = Array.ofDim[Int](8)\n        val xorResultBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBits\
    \ = Array.ofDim[Int](8)\n        val xorResultBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBits\
    \ = Array.ofDim[Int](8)\n        val xorResultBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBits\
    \ = Array.ofDim[Int](8)\n        val xorResultBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBits\
    \ = Array.ofDim[Int](8)\n        val xorResultBitsBitsBitsBits\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwbne2ay7.scala:27:4 ----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwbne2ay7.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mxorResultBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBits\e[0m = Array.ofDim[\e\
    [35mInt\e[0m](\e[31m8\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorResultBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBits\
    \ is already defined as \e[33mvalue\e[0m \e[35mxorResultBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBits\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpwbne2ay7.scala:7:22 -------------------------\e[0m\e[0m\n\
    \e[31m7 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\e[31m\e\
    [31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m            \
    \        value toIntArray is not a member of String\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpwbne2ay7.scala:8:22 -------------------------\e[0m\e[0m\n\
    \e[31m8 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e[31m\e\
    [31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m            \
    \        value toIntArray is not a member of String\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpwbne2ay7.scala:27:5 ---------------------\e[0m\e[0m\n\
    \e[31m27 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:\
    \    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1659978730
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Int](a.length)\n\
    \        for(i <- 0 until xorArray.length)\n            xorArray(i) = aArray(i)\
    \ xor bArray(i)\n        new String(xorArray)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpixhgsofd.scala:11:36 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n\e[31m\e[31m--\
    \ [E134] Type Error: /tmp/tmpixhgsofd.scala:12:12 -----------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mnew\e[0m \e[35mString\e[0m(xorArray)\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mconstructor\e[0m \e[35mString\e[0m in \e[33mclass\e[0m\
    \ \e[35mString\e[0m with types\n\e[31m   |\e[0m (x$0: StringBuilder): String\n\
    \e[31m   |\e[0m (x$0: StringBuffer): String\n\e[31m   |\e[0m (x$0: Array[Byte]):\
    \ String\n\e[31m   |\e[0m (x$0: Array[Byte], x$1: Int, x$2: Int): String\n\e[31m\
    \   |\e[0m (x$0: Array[Byte], x$1: java.nio.charset.Charset): String\n\e[31m \
    \  |\e[0m (x$0: Array[Byte], x$1: String): String\n\e[31m   |\e[0m (x$0: Array[Byte],\
    \ x$1: Int, x$2: Int, x$3: java.nio.charset.Charset): String\n\e[31m   |\e[0m\
    \ (x$0: Array[Byte], x$1: Int, x$2: Int, x$3: String): String\n\e[31m   |\e[0m\
    \ (x$0: Array[Byte], x$1: Int): String\n\e[31m   |\e[0m (x$0: Array[Byte], x$1:\
    \ Int, x$2: Int, x$3: Int): String\n\e[31m   |\e[0m (x$0: Array[Int], x$1: Int,\
    \ x$2: Int): String\n\e[31m   |\e[0m (x$0: Array[Char], x$1: Int, x$2: Int): String\n\
    \e[31m   |\e[0m (x$0: Array[Char]): String\n\e[31m   |\e[0m (x$0: String): String\n\
    \e[31m   |\e[0m (): String\n\e[31m   |\e[0mmatch arguments ((xorArray : Array[Int]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659978730
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val xorList = mutable.ListBuffer.empty[Int]\n\
    \        var xor = 0\n        var i = 0\n        while (i < aList.size) {\n  \
    \          xor = xor + aList(i) xor bList(i)\n            i = i + 1\n        }\n\
    \        xor.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwyuu_jcb.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpwyuu_jcb.scala:13:33 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            xor = xor + aList(i) xor bList(i)\n\e[31m\e\
    [31m   |\e[0m                  ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \            value xor is not a member of Int\n2 errors found\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val xorList = mutable.ListBuffer.empty[Int]\n\
    \        var i = 0\n        while (i < aList.size) {\n            xorList += (aList(i)\
    \ xor bList(i))\n            i += 1\n        }\n        xorList.toString.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpff071dqn.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978731
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = mutable.ArrayBuffer.empty[Int]\n\
    \        for(i <- 0 until aArray.length) xorArray += (aArray(i) xor bArray(i))\n\
    \        xorArray.toString.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdo3jnn1j.scala:9:23 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m  |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                       Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = ArrayBuffer.empty[Int]\n\
    \        for(i <- 0 until aArray.length) xorArray += (aArray(i) xor bArray(i))\n\
    \        xorArray.toString.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwg99mv0v.scala:10:63 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mfor\e[0m(i <- \e[31m0\e[0m until aArray.length)\
    \ xorArray += (aArray(i) xor bArray(i))\n\e[31m\e[31m   |\e[0m               \
    \                                      ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                                     value xor is not a member of Int\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978737
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val result = new StringBuilder\n      \
    \  val xor = new mutable.HashSet[Int]()\n        val xorSet = new mutable.HashSet[Int]()\n\
    \        val xorSet2 = new mutable.HashSet[Int]()\n        val xorSet3 = new mutable.HashSet[Int]()\n\
    \        val xorSet4 = new mutable.HashSet[Int]()\n        val xorSet5 = new mutable.HashSet[Int]()\n\
    \        val xorSet6 = new mutable.HashSet[Int]()\n        val xorSet7 = new mutable.HashSet[Int]()\n\
    \        val xorSet8 = new mutable.HashSet[Int]()\n        val xorSet9 = new mutable.HashSet[Int]()\n\
    \        val xorSet10 = new mutable.HashSet[Int]()\n        val xorSet11 = new\
    \ mutable.HashSet[Int]()\n        val xorSet12 = new mutable.HashSet[Int]()\n\
    \        val xorSet13 = new mutable.HashSet[Int]()\n        val xorSet14 = new\
    \ mutable.HashSet[Int]()\n        val xorSet15 = new mutable.HashSet[Int]()\n\
    \        val xorSet16 = new mutable.HashSet[Int]()\n        val xorSet17 = new\
    \ mutable.HashSet[Int]()\n        val xorSet18 = new mutable.HashSet[Int]()\n\
    \        val xorSet19 = new mutable.HashSet[Int]()\n        val xorSet20 = new\
    \ mutable.HashSet[Int]()\n        val xorSet21 = new mutable.HashSet[Int]()\n\
    \        val xorSet22 = new mutable.HashSet[Int]()\n        val xorSet23 = new\
    \ mutable.HashSet[Int]()\n        val xorSet24 = new mutable.HashSet[Int]()\n\
    \        val xorSet25 = new mutable.HashSet[Int]()\n        val xorSet26 = new\
    \ mutable.HashSet[Int]()\n        val xorSet27 = new mutable.HashSet[Int]()\n\
    \        val xorSet28 = new mutable.HashSet[Int]()\n        val xorSet29 = new\
    \ mutable.HashSet[Int]()\n        val xorSet30 = new mutable.HashSet[Int]()\n\
    \        val xorSet31 = new mutable.HashSet[Int]()\n        val xorSet32 = new\
    \ mutable.HashSet\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppc1_geow.scala:10:22 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mxor\e[0m = \e[33mnew\e[0m\
    \ mutable.HashSet[\e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                   \
    \   ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppc1_geow.scala:11:25\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mxorSet\e[0m = \e[33mnew\e[0m mutable.HashSet[\e[35mInt\e[0m]()\n\e[31m\e[31m\
    \   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \            Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmppc1_geow.scala:12:26 ------------------------\e[0m\e[0m\n\e[31m12 |\e\
    [0m        \e[33mval\e[0m \e[36mxorSet2\e[0m = \e[33mnew\e[0m mutable.HashSet[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmppc1_geow.scala:13:26 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mxorSet3\e[0m = \e[33mnew\e\
    [0m mutable.HashSet[\e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                 \
    \         ^^^^^^^\e[0m\n\e[31m   |\e[0m                          Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppc1_geow.scala:14:26\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mxorSet4\e[0m = \e[33mnew\e[0m mutable.HashSet[\e[35mInt\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmppc1_geow.scala:15:26 --"
  stdout: ''
  timestamp: 1659978737
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toCharArray\n\
    \        val bList = b.toCharArray\n        val result = new mutable.StringBuilder\n\
    \        var i = 0\n        while (i < aList.length && i < bList.length) {\n \
    \           if (aList(i) XOR bList(i) == 0) {\n                result += \"0\"\
    \n            } else {\n                result += \"1\"\n            }\n     \
    \       i += 1\n        }\n        return result.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwjo8i4ty.scala:9:25 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.StringBuilder\n\e[31m\e[31m  |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m  |\e[0m                         Not found: mutable\n\e[31m  |\e[0m\n\
    \e[31m  |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpwjo8i4ty.scala:12:25 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            \e[33mif\e[0m (aList(i) XOR bList(i) == \e\
    [31m0\e[0m) {\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                value XOR is not a member of Char\n2 errors found\n"
  stdout: ''
  timestamp: 1659978737
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = Array.ofDim[Int](8)\n\
    \        for(i <- 0 until 8) {\n            xorArray(i) = (aArray(i) xor bArray(i)).toInt\n\
    \        }\n        val xorString = xorArray.toString.reverse.mkString(\"\")\n\
    \        xorString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpliy3ebjn.scala:11:37 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m            xorArray(i) = (aArray(i) xor bArray(i)).toInt\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                           value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659978738
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toCharArray\n\
    \        val bList = b.toCharArray\n        val xorList = mutable.ArrayBuffer.empty[Char]\n\
    \        for(i <- 0 until aList.length)\n            for(j <- 0 until bList.length)\n\
    \                if(aList(i) == bList(j))\n                    xorList += aList(i)\n\
    \        xorList.toString.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8hs3kjd6.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mChar\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978726
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until aList.length) xorList += aList(i) xor bList(i)\n   \
    \     xorList.toList.reverse.mkString(\"\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdmvpoxdq.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978733
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Char](Math.max(aArray.length,\
    \ bArray.length))\n        val xorResult = new Array[Char](Math.max(aArray.length,\
    \ bArray.length))\n        val xorIndex = 0\n        var i = 0\n        var j\
    \ = 0\n        while (i < aArray.length || j < bArray.length) {\n            if\
    \ (i < aArray.length && j < bArray.length) {\n                if (aArray(i) ==\
    \ '1' && bArray(j) == '1') {\n                    xorArray(xorIndex) = aArray(i)\n\
    \                    xorResult(xorIndex) = bArray(j)\n                    xorIndex\
    \ += 1\n                    i += 1\n                    j += 1\n             \
    \   } else if (aArray(i) == '0' && bArray(j) == '0') {\n                    xorArray(xorIndex)\
    \ = aArray(i)\n                    xorResult(xorIndex) = bArray(j)\n         \
    \           xorIndex += 1\n                    i += 1\n                    j +=\
    \ 1\n                } else {\n                    xorArray(xorIndex) = aArray(i)\n\
    \                    xorResult(xorIndex) = bArray(j)\n                    xorIndex\
    \ += 1\n                    i += 1\n                    j += 1\n             \
    \   }\n            } else if (i < aArray.length) {\n                xorArray(xorIndex)\
    \ = aArray(i)\n                xorResult(xorIndex) = aArray(i)\n             \
    \   xorIndex += 1\n                i += 1\n            } else {\n            \
    \    xorArray(xorIndex) = bArray(j)\n                xorResult(xorIndex) = bArray(j)\n\
    \                xorIndex += 1\n                j += 1\n            }\n      \
    \  }\n        xorArray(xorIndex) = aArray(i)\n        xorResult(xorIndex) = aArray(i)\n\
    \        xorIndex += 1\n        xorResult(xorIndex) = bArray(j)\n        xorIndex\
    \ += 1\n        xorResult(xorIndex) = bArray(j)\n        xorIndex += 1\n     \
    \   xorResult(xorIndex) = aArray(i)\n        xorIndex += 1\n        xorResult(xorIndex)\
    \ = aArray(i)\n        xorIndex += 1\n        xorResult(xorIndex) = bArray(j)\n\
    \        xorIndex += 1\n        xorResult(xorIndex) = bArray(j)\n        xorIndex\
    \ += 1\n        xorResult(xorIndex) = aArray(i)\n        xorIndex += 1\n     \
    \   xorResult(xorIndex) = aArray(i)\n        xorIndex += 1\n        xorResult(xorIndex)\
    \ = bArray(j)\n        xorIndex += 1\n        xorResult(xorIndex) = bArray(j)\n\
    \        xorIndex += 1\n        xorResult(xorIndex) = aArray(i)\n        xorIndex\
    \ += 1\n        xorResult(xorIndex) = a\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp22nuzije.scala:19:29 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                    xorIndex += \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \  value += is not a member of Int - did you mean xorIndex.!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp22nuzije.scala:25:29 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                    xorIndex += \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \  value += is not a member of Int - did you mean xorIndex.!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp22nuzije.scala:31:29 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                    xorIndex += \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \  value += is not a member of Int - did you mean xorIndex.!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp22nuzije.scala:38:25 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                xorIndex += \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             value\
    \ += is not a member of Int - did you mean xorIndex.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp22nuzije.scala:43:25 ------------------------\e[0m\e\
    [0m\n\e[31m43 |\e[0m                xorIndex += \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             value += is not\
    \ a member of Int - did you mean xorIndex.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp22nuzije.scala:49:17 ------------------------\e[0m\e[0m\n\e[31m49\
    \ |\e[0m        xorIndex += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        value += is not a member of Int - did you mean xorIndex.!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp22nuzije.scala:51:17 ------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m        xorIndex += \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value += is not a member of\
    \ Int - did you mean xorIndex.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp22nuzije.sca"
  stdout: ''
  timestamp: 1659978740
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val result = new StringBuilder\n\
    \        var i = 0\n        while (i < aArray.length) {\n            result.append(aArray(i)\
    \ ^ bArray(i))\n            i += 1\n        }\n        return result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978708
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val xorList = mutable.ListBuffer.empty[Int]\n\
    \        for(i <- 0 until aList.length) xorList += (aList(i) xor bList(i))\n \
    \       xorList.mkString(\"\")\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2t8iu1t6.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978735
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val result = new StringBuilder\n\
    \        var carry = 0\n        for (i <- 0 until aArray.length) {\n         \
    \   val aChar = aArray(i)\n            val bChar = bArray(i)\n            val\
    \ xor = (aChar ^ bChar) ^ carry\n            result.append(xor)\n            carry\
    \ = xor >> 8\n        }\n        result.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978739
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aBits = a.toIntArray\n\
    \        val bBits = b.toIntArray\n        val xorBits = aBits xor bBits\n   \
    \     val xorBitsString = xorBits.map(_ + 48).map(_.toString).mkString(\"\")\n\
    \        return xorBitsString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_xiitgdl.scala:7:22 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp_xiitgdl.scala:8:22 -------------------------\e[0m\e\
    [0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m      \
    \              value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659978739
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Char](b.length)\n\
    \        val xorString = new StringBuilder\n        for(i <- 0 until xorArray.length)\n\
    \            xorArray(i) = aArray(i) xor bArray(i)\n        xorString.append(xorArray)\n\
    \        xorString.toString\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"\
    1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0i1stv84.scala:12:36 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659978739
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toCharArray\n\
    \        val bList = b.toCharArray\n        val xorList = mutable.ArrayBuffer.empty[Char]\n\
    \        for (i <- 0 until aList.length)\n            xorList += (aList(i) XOR\
    \ bList(i))\n        xorList.toString.toUpperCase\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyeutua1b.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mChar\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978734
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val xorList = mutable.ListBuffer.empty[Int]\n\
    \        var xor = 0\n        var i = 0\n        while (i < aList.size) {\n  \
    \          xor = xor + aList(i) xor bList(i)\n            i += 1\n        }\n\
    \        xorList.add(xor)\n        xorList.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9rrizzh4.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp9rrizzh4.scala:13:33 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            xor = xor + aList(i) xor bList(i)\n\e[31m\e\
    [31m   |\e[0m                  ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \            value xor is not a member of Int\n2 errors found\n"
  stdout: ''
  timestamp: 1659978739
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val result = new StringBuilder\n      \
    \  var carry = 0\n        var i = 0\n        while (i < aList.length) {\n    \
    \        val aChar = aList(i)\n            val bChar = bList(i)\n            val\
    \ aCharInt = aChar match {\n                case '1' => 1\n                case\
    \ '0' => 0\n                case _ => throw new IllegalArgumentException(\"Invalid\
    \ character \" + aChar)\n            }\n            val bCharInt = bChar match\
    \ {\n                case '1' => 1\n                case '0' => 0\n          \
    \      case _ => throw new IllegalArgumentException(\"Invalid character \" + bChar)\n\
    \            }\n            val aCharInt = aCharInt xor bCharInt\n           \
    \ val aCharChar = aCharInt match {\n                case 1 => '1'\n          \
    \      case 0 => '0'\n                case _ => throw new IllegalArgumentException(\"\
    Invalid character \" + aChar)\n            }\n            val bCharChar = bCharInt\
    \ match {\n                case 1 => '1'\n                case 0 => '0'\n    \
    \            case _ => throw new IllegalArgumentException(\"Invalid character\
    \ \" + bChar)\n            }\n            result.append(aCharChar)\n         \
    \   i += 1\n        }\n        if (carry != 0) {\n            result.append(carry)\n\
    \        }\n        return result.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmptamf3nkf.scala:25:16 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e[0m \e[36maCharInt\e[0m = aCharInt\
    \ xor bCharInt\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0maCharInt is already defined as \e[33mvalue\e[0m \e[35maCharInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n1 error found\n"
  stdout: ''
  timestamp: 1659978736
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = Array.ofDim[Int](8)\n\
    \        for(i <- 0 until 8) {\n            xorArray(i) = aArray(i) xor bArray(i)\n\
    \        }\n        val xorString = xorArray.toString.reverse.mkString(\"\")\n\
    \        xorString.reverse\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"\
    1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp14j3x7mc.scala:11:36 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659978739
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until aList.length)\n            for(j <- 0 until bList.length)\n\
    \                if(aList(i) == bList(j))\n                    xorList += aList(i)\n\
    \        xorList.mkString(\"\")\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5eba1ski.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978737
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Char](aArray.length)\n\
    \        for(i <- 0 until aArray.length){\n            xorArray(i) = aArray(i)\
    \ xor bArray(i)\n        }\n        new String(xorArray)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0af125i7.scala:11:36 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659978740
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toCharArray\n\
    \        val bList = b.toCharArray\n        val xorList = mutable.ListBuffer[Int]()\n\
    \        for (i <- 0 until aList.length) xorList += (aList(i) xor bList(i))\n\
    \        xorList.toString.toCharArray\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpc24z2o1q.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978737
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val result = new mutable.StringBuilder\n\
    \        for( i <- 0 until aList.size ) {\n            val aChar = aList(i)\n\
    \            val bChar = bList(i)\n            if( aChar != bChar ) {\n      \
    \          result.append((aChar ^ bChar))\n            }\n        }\n        return\
    \ result.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbofogi3b.scala:9:25 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.StringBuilder\n\e[31m\e[31m  |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m  |\e[0m                         Not found: mutable\n\e[31m  |\e[0m\n\
    \e[31m  |\e[0m longer explanation available when compiling with `-explain`\n1\
    \ error found\n"
  stdout: ''
  timestamp: 1659978738
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toCharArray\n\
    \        val bList = b.toCharArray\n        val xorResult = mutable.ArrayBuffer.empty[Char]\n\
    \        var i = 0\n        while (i < aList.length && i < bList.length) {\n \
    \           xorResult += (aList(i) XOR bList(i))\n            i += 1\n       \
    \ }\n        xorResult.toString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpy1ied1rb.scala:9:24 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorResult\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mChar\e[0m]\n\e[31m\e[31m  |\e[0m                        ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                        Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978737
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Char](Math.max(aArray.length,\
    \ bArray.length))\n        var i = 0\n        while (i < xorArray.length) {\n\
    \            xorArray(i) = aArray(i) xor bArray(i)\n            i += 1\n     \
    \   }\n        xorArray.toString.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkulycydy.scala:12:36 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659978707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toCharArray.map(_.toInt)\n\
    \        val bList = b.toCharArray.map(_.toInt)\n        val xorList = mutable.ListBuffer.empty[Int]\n\
    \        for(i <- 0 until aList.length) xorList += (aList(i) xor bList(i))\n \
    \       xorList.toString.toCharArray\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgt3rjvwi.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978739
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n\
    \        for (i <- 0 until aList.length) xorList += (aList(i) xor bList(i)).toString\n\
    \        xorList.toList.toString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbouzfd7_.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978739
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Char](aArray.length)\n\
    \        for(i <- 0 until xorArray.length) xorArray(i) = (xorArray(i) xor bArray(i))\n\
    \        new String(xorArray)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpspqp6pqw.scala:10:69 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mfor\e[0m(i <- \e[31m0\e[0m until xorArray.length)\
    \ xorArray(i) = (xorArray(i) xor bArray(i))\n\e[31m\e[31m   |\e[0m           \
    \                                              ^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                                       value xor is not a member of Char\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659978742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Int](aArray.length)\n\
    \        val xorArray2 = new Array[Int](aArray.length)\n        val xorArray3\
    \ = new Array[Int](aArray.length)\n        val xorArray4 = new Array[Int](aArray.length)\n\
    \        val xorArray5 = new Array[Int](aArray.length)\n        val xorArray6\
    \ = new Array[Int](aArray.length)\n        val xorArray7 = new Array[Int](aArray.length)\n\
    \        val xorArray8 = new Array[Int](aArray.length)\n        val xorArray9\
    \ = new Array[Int](aArray.length)\n        val xorArray10 = new Array[Int](aArray.length)\n\
    \        val xorArray11 = new Array[Int](aArray.length)\n        val xorArray12\
    \ = new Array[Int](aArray.length)\n        val xorArray13 = new Array[Int](aArray.length)\n\
    \        val xorArray14 = new Array[Int](aArray.length)\n        val xorArray15\
    \ = new Array[Int](aArray.length)\n        val xorArray16 = new Array[Int](aArray.length)\n\
    \        val xorArray17 = new Array[Int](aArray.length)\n        val xorArray18\
    \ = new Array[Int](aArray.length)\n        val xorArray19 = new Array[Int](aArray.length)\n\
    \        val xorArray20 = new Array[Int](aArray.length)\n        val xorArray21\
    \ = new Array[Int](aArray.length)\n        val xorArray22 = new Array[Int](aArray.length)\n\
    \        val xorArray23 = new Array[Int](aArray.length)\n        val xorArray24\
    \ = new Array[Int](aArray.length)\n        val xorArray25 = new Array[Int](aArray.length)\n\
    \        val xorArray26 = new Array[Int](aArray.length)\n        val xorArray27\
    \ = new Array[Int](aArray.length)\n        val xorArray28 = new Array[Int](aArray.length)\n\
    \        val xorArray29 = new Array[Int](aArray.length)\n        val xorArray30\
    \ = new Array[Int](aArray.length)\n        val xorArray31 = new Array[Int](aArray.length)\n\
    \        val xorArray32 = new Array[Int](aArray.length)\n        val xorArray33\
    \ = new Array[Int](a\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmq43dv20.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpmq43dv20.scala:41:40 --------------------\e[0m\e[0m\n\e[31m41 |\e[0m\
    \        \e[33mval\e[0m \e[36mxorArray33\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mInt\e[0m](a\n\e[31m\e[31m   |\e[0m                                       \
    \ ^\e[0m\n\e[31m   |\e[0m                                        Found:    (a\
    \ : String)\n\e[31m   |\e[0m                                        Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmq43dv20.scala:42:5\
    \ ---------------------\e[0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659978744
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Char](b.length)\n\
    \        for(i <- 0 until xorArray.length)\n            xorArray(i) = (if (aArray(i)\
    \ XOR bArray(i) == 0) '0' else '1')\n        new String(xorArray)\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo92qc3gy.scala:11:41 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m            xorArray(i) = (\e[33mif\e[0m (aArray(i) XOR\
    \ bArray(i) == \e[31m0\e[0m) \e[31m'0'\e[0m \e[33melse\e[0m \e[31m'1'\e[0m)\n\e\
    [31m\e[31m   |\e[0m                               ^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                               value XOR is not a member of Char\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978744
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aBits = a.toIntArray\n\
    \        val bBits = b.toIntArray\n        val xorBits = Array.ofDim[Int](8)\n\
    \        val xorResult = Array.ofDim[Int](8)\n        val xorResultBits = Array.ofDim[Int](8)\n\
    \        val xorResultBitsSum = Array.ofDim[Int](8)\n        val xorResultBitsSumBits\
    \ = Array.ofDim[Int](8)\n        val xorResultBitsSumBitsSum = Array.ofDim[Int](8)\n\
    \        val xorResultBitsSumBitsSumBits = Array.ofDim[Int](8)\n        val xorResultBitsSumBitsSumBitsSum\
    \ = Array.ofDim[Int](8)\n        val xorResultBitsSumBitsSumBitsSumBits = Array.ofDim[Int](8)\n\
    \        val xorResultBitsSumBitsSumBitsSumBitsSum = Array.ofDim[Int](8)\n   \
    \     val xorResultBitsSumBitsSumBitsSumBitsSumBits = Array.ofDim[Int](8)\n  \
    \      val xorResultBitsSumBitsSumBitsSumBitsSumBitsSum = Array.ofDim[Int](8)\n\
    \        val xorResultBitsSumBitsSumBitsSumBitsSumBitsSumBits = Array.ofDim[Int](8)\n\
    \        val xorResultBitsSumBitsSumBitsSumBitsSumBitsSumBitsSum = Array.ofDim[Int](8)\n\
    \        val xorResultBitsSumBitsSumBitsSumBitsSumBitsSumBitsSumBits = Array.ofDim[Int](8)\n\
    \        val xorResultBitsSumBitsSumBitsSumBitsSumBitsSumBitsSumBitsSum = Array.ofDim[Int](8)\n\
    \        val xorResultBitsSumBitsSumBitsSumBitsSumBitsSumBitsSumBitsSumBits =\
    \ Array.ofDim[Int](8)\n        val xorResultBitsSumBitsSumBitsSumBitsSumBitsSumBitsSumBitsSumBitsSum\
    \ = Array.ofDim[Int](8)\n        val xorResultBitsSumBitsSumBitsSumBitsSumBitsSumBitsSumBitsSumBitsSumBitsSum\
    \ = Array.ofDim[Int](8)\n        val xorResultBitsSumBitsSumBitsSumBitsSumBits\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbxdeqhoj.scala:29:4 ----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbxdeqhoj.scala:7:22\
    \ -------------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e\
    [36maBits\e[0m = a.toIntArray\n\e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e\
    [0m\n\e[31m  |\e[0m                    value toIntArray is not a member of String\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbxdeqhoj.scala:8:22 -------------------------\e\
    [0m\e[0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpbxdeqhoj.scala:29:5 ---------------------\e[0m\e\
    [0m\n\e[31m29 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978747
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aBits = a.toIntArray\n\
    \        val bBits = b.toIntArray\n        val xorBits = aBits xor bBits\n   \
    \     val xorBitsString = xorBits.map(_ + 48).map(_.toString).mkString(\"\")\n\
    \        xorBitsString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpstz0qqfb.scala:7:22 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpstz0qqfb.scala:8:22 -------------------------\e[0m\e\
    [0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m      \
    \              value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659978707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val result = new StringBuilder\n\
    \        val xor = a.toCharArray.zip(bArray).map {\n            case (elem1, elem2)\
    \ => elem1 xor elem2\n        }\n        for(elem <- xor) {\n            result.append(elem.toInt)\n\
    \        }\n        return result.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxjny6d7b.scala:11:41 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m            \e[33mcase\e[0m (elem1, elem2) => elem1 xor\
    \ elem2\n\e[31m\e[31m   |\e[0m                                   ^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                   value xor is not a member of\
    \ Char\n\e[31m\e[31m-- Error: /tmp/tmpxjny6d7b.scala:12:9 ------------------------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        }\n\e[31m\e[31m   |\e[0m         ^\e[0m\n\e[31m\
    \   |\e[0m         No ClassTag available for B\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m         where:    B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1659978747
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Char](Math.max(aArray.length,\
    \ bArray.length))\n        var i = 0\n        while (i < xorArray.length) {\n\
    \            xorArray(i) = aArray(i) xor bArray(i)\n            i += 1\n     \
    \   }\n        xorArray.toString.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkulycydy.scala:12:36 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659978707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aBits = a.toIntArray\n\
    \        val bBits = b.toIntArray\n        val xorBits = Array.ofDim[Int](8)\n\
    \        val xorResult = Array.ofDim[Int](8)\n        val xorResultBits = Array.ofDim[Int](8)\n\
    \        val xorResultBitsCount = Array.ofDim[Int](8)\n        val xorResultBitsCountCount\
    \ = Array.ofDim[Int](8)\n        val xorResultBitsCountCountCount = Array.ofDim[Int](8)\n\
    \        val xorResultBitsCountCountCountCount = Array.ofDim[Int](8)\n       \
    \ val xorResultBitsCountCountCountCountCount = Array.ofDim[Int](8)\n        val\
    \ xorResultBitsCountCountCountCountCountCount = Array.ofDim[Int](8)\n        val\
    \ xorResultBitsCountCountCountCountCountCountCount = Array.ofDim[Int](8)\n   \
    \     val xorResultBitsCountCountCountCountCountCountCountCountCount = Array.ofDim[Int](8)\n\
    \        val xorResultBitsCountCountCountCountCountCountCountCountCountCountCountCount\
    \ = Array.ofDim[Int](8)\n        val xorResultBitsCountCountCountCountCountCountCountCountCountCountCountCountCountCount\
    \ = Array.ofDim[Int](8)\n        val xorResultBitsCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCount\
    \ = Array.ofDim[Int](8)\n        val xorResultBitsCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCount\
    \ = Array.ofDim[Int](8)\n        val xorResultBitsCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCount\
    \ = Array.ofDim[Int](8)\n        val xorResultBitsCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCount\
    \ = Array.ofDim[Int](8)\n        val xorResultBitsCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCount\
    \ = Array.ofDim[Int](8)\n        val xorResultBitsCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCount\
    \ = Array.ofDim[Int](8)\n        val xorResultBitsCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCount\
    \ = Array.ofDim\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpggv1w1cd.scala:7:22 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpggv1w1cd.scala:8:22 -------------------------\e[0m\e\
    [0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m      \
    \              value toIntArray is not a member of String\n\e[31m\e[31m-- [E051]\
    \ Reference Error: /tmp/tmpggv1w1cd.scala:28:164 -----------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mxorResultBitsCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCount\e\
    [0m = Array.ofDim\n\e[31m\e[31m   |\e[0m                                     \
    \                                                                            \
    \                                             ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mAmbiguous\
    \ overload. The overloaded alternatives of \e[33mmethod\e[0m \e[35mofDim\e[0m\
    \ in \e[33mobject\e[0m \e[35mArray\e[0m with types\n\e[31m   |\e[0m [T]\n\e[31m\
    \   |\e[0m  (n1: Int, n2: Int, n3: Int, n4: Int, n5: Int)\n\e[31m   |\e[0m   \
    \ (\e[33mimplicit \e[0mevidence$10: scala.reflect.ClassTag[T]): \n\e[31m   |\e\
    [0m      Array[Array[Array[Array[Array[T]]]]]\n\e[31m   |\e[0m [T]\n\e[31m   |\e\
    [0m  (n1: Int, n2: Int, n3: Int, n4: Int)\n\e[31m   |\e[0m    (\e[33mimplicit\
    \ \e[0mevidence$9: scala.reflect.ClassTag[T]): \n\e[31m   |\e[0m      Array[Array[Array[Array[T]]]]\n\
    \e[31m   |\e[0m [T]\n\e[31m   |\e[0m  (n1: Int, n2: Int, n3: Int)\n\e[31m   |\e\
    [0m    (\e[33mimplicit \e[0mevidence$8: scala.reflect.ClassTag[T]): Array[Array[Array[T]]]\n\
    \e[31m   |\e[0m [T]\n\e[31m   |\e[0m  (n1: Int, n2: Int)\n\e[31m   |\e[0m    (\e\
    [33mimplicit \e[0mevidence$7: scala.reflect.ClassTag[T]): Array[Array[T]]\n\e\
    [31m   |\e[0m [T](n1: Int)(\e[33mimplicit \e[0mevidence$6: scala.reflect.ClassTag[T]):\
    \ Array[T]\n\e[31m   |\e[0mall match expe"
  stdout: ''
  timestamp: 1659978749
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toCharArray.map(_.toInt)\n\
    \        val bList = b.toCharArray.map(_.toInt)\n        val xorList = aList.zip(bList).map(x\
    \ => x._1 xor x._2)\n        val xorString = xorList.map(x => x.toChar).mkString\n\
    \        xorString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfiobndza.scala:9:53 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = aList.zip(bList).map(\e\
    [36mx\e[0m => x._1 xor x._2)\n\e[31m\e[31m  |\e[0m                           \
    \                     ^^^^^^^^\e[0m\n\e[31m  |\e[0m                          \
    \                value xor is not a member of Int\n\e[31m\e[31m-- Error: /tmp/tmpfiobndza.scala:9:62\
    \ ------------------------------------------\e[0m\e[0m\n\e[31m9 |\e[0m       \
    \ \e[33mval\e[0m \e[36mxorList\e[0m = aList.zip(bList).map(\e[36mx\e[0m => x._1\
    \ xor x._2)\n\e[31m\e[31m  |\e[0m                                            \
    \                  ^\e[0m\n\e[31m  |\e[0m                                    \
    \        No ClassTag available for B\n\e[31m  |\e[0m\n\e[31m  |\e[0m         \
    \                                   where:    B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1659978749
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aBits = a.toInt\n\
    \        val bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val\
    \ xorBitsString = Integer.toBinaryString(xorBits)\n        val xorBitsStringLength\
    \ = xorBitsString.length\n        val xorBitsStringBuilder = new StringBuilder(xorBitsStringLength)\n\
    \        for ((index, value) <- xorBitsString.zipWithIndex) {\n            if\
    \ (value == 0) {\n                xorBitsStringBuilder.append(0)\n           \
    \ } else {\n                xorBitsStringBuilder.append(1)\n            }\n  \
    \      }\n        xorBitsStringBuilder.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp11k1_fla.scala:9:28 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m  |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m  |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp11k1_fla.scala:20:29 --------------------\e[0m\e\
    [0m\n\e[31m20 |\e[0m        xorBitsStringBuilder.reverse\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    StringBuilder\n\
    \e[31m   |\e[0m        Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978749
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until aList.size) {\n            xorList += aList(i) xor bList(i)\n\
    \        }\n        xorList.toList.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqmv8moqc.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978745
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aBits = a.toIntArray\n\
    \        val bBits = b.toIntArray\n        val xorBits = Array.ofDim[Int](aBits.length)\n\
    \        for( i <- 0 until xorBits.length ) {\n            xorBits(i) = aBits(i)\
    \ xor bBits(i)\n        }\n        val xorString = xorBits.mkString(\"\")\n  \
    \      xorString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp48p78725.scala:7:22 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp48p78725.scala:8:22 -------------------------\e[0m\e\
    [0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m      \
    \              value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659978749
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aBits = a.toCharArray.map(_.toInt)\n\
    \        val bBits = b.toCharArray.map(_.toInt)\n        val xorBits = aBits xor\
    \ bBits\n        val xorBitsString = xorBits.map(_.toChar).mkString(\"\")\n  \
    \      return xorBitsString\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"\
    1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkox4kumm.scala:9:28 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m  |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m  |\e\
    [0m                      value xor is not a member of Array[Int]\n1 error found\n"
  stdout: ''
  timestamp: 1659978749
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val xorList = mutable.ListBuffer[Int]()\n\
    \        var xor = 0\n        var i = 0\n        while (i < aList.length && i\
    \ < bList.length) {\n            xor = xor + ((aList(i) XOR bList(i)) XOR xor)\n\
    \            xorList += xor\n            i += 1\n        }\n        xorList.toList.reverse.mkString(\"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzpg22k0h.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpzpg22k0h.scala:13:35 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            xor = xor + ((aList(i) XOR bList(i)) XOR\
    \ xor)\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                          value XOR is not a member of Char\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978749
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Char](aArray.length)\n\
    \        for(i <- 0 until aArray.length)\n            xorArray(i) = aArray(i)\
    \ xor bArray(i)\n        new String(xorArray)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvgpw7tiy.scala:11:36 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659978749
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Char](b.length)\n\
    \        var xor = 0\n        for (i <- 0 until xorArray.length)\n           \
    \ xor = xor + aArray(i) xor bArray(i)\n        xorArray.toString.reverse\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"),\
    \ (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpv_op9h9j.scala:12:34 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            xor = xor + aArray(i) xor bArray(i)\n\e[31m\e\
    [31m   |\e[0m                  ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \             value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659978750
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toCharArray.map(_.toInt)\n\
    \        val bList = b.toCharArray.map(_.toInt)\n        val xorList = mutable.ListBuffer.empty[Int]\n\
    \        for (i <- 0 until aList.length)\n            for (j <- 0 until bList.length)\n\
    \                xorList += (aList(i) xor bList(j))\n        xorList.toString.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6mphtw6k.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978748
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n\
    \        aList.zip(bList).foreach { case (aChar, bChar) =>\n            xorList\
    \ += (aChar ^ bChar).toString\n        }\n        xorList.toString\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2gh0ja7u.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978715
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Char](Math.max(aArray.length,\
    \ bArray.length))\n        val xorArrayIndex = 0\n        var i = 0\n        while\
    \ (i < xorArray.length) {\n            xorArray(i) = aArray(i) xor bArray(i)\n\
    \            i += 1\n        }\n        new String(xorArray)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpk8uenaot.scala:13:36 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659978750
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = aArray.zip(\n\
    \            bArray\n        ).map(x => x._1 xor x._2).mkString(\"\")\n      \
    \  xorArray\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6uvj305i.scala:11:24 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        ).map(x => x._1 xor x._2).mkString(\e[31m\"\"\
    \e[0m)\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                   value xor is not a member of Int\n\e[31m\e[31m-- Error: /tmp/tmp6uvj305i.scala:11:33\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m11 |\e[0m       \
    \ ).map(x => x._1 xor x._2).mkString(\e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m \
    \                                ^\e[0m\n\e[31m   |\e[0m                     \
    \            No ClassTag available for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m   \
    \                              where:    B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1659978751
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aBits = a.toIntArray\n\
    \        val bBits = b.toIntArray\n        val result = new mutable.StringBuilder\n\
    \        val xorResult = mutable.BitSet(b.length)\n        val xorResultBits =\
    \ mutable.BitSet(b.length)\n        val xorResultBitsSet = mutable.BitSet(b.length)\n\
    \        val xorResultBitsSetSet = mutable.BitSet(b.length)\n        val xorResultBitsSetSetSet\
    \ = mutable.BitSet(b.length)\n        val xorResultBitsSetSetSet = mutable.BitSet(b.length)\n\
    \        val xorResultBitsSetSetSetSet = mutable.BitSet(b.length)\n        val\
    \ xorResultBitsSetSetSetSetSet = mutable.BitSet(b.length)\n        val xorResultBitsSetSetSetSetSet\
    \ = mutable.BitSet(b.length)\n        val xorResultBitsSetSetSetSetSet = mutable.BitSet(b.length)\n\
    \        val xorResultBitsSetSetSetSetSet = mutable.BitSet(b.length)\n       \
    \ val xorResultBitsSetSetSetSetSetSet = mutable.BitSet(b.length)\n        val\
    \ xorResultBitsSetSetSetSetSetSet = mutable.BitSet(b.length)\n        val xorResultBitsSetSetSetSetSetSet\
    \ = mutable.BitSet(b.length)\n        val xorResultBitsSetSetSetSetSetSet = mutable.BitSet(b.length)\n\
    \        val xorResultBitsSetSetSetSetSetSet = mutable.BitSet(b.length)\n    \
    \    val xorResultBitsSetSetSetSetSetSet = mutable.BitSet(b.length)\n        val\
    \ xorResultBitsSetSetSetSetSetSet = mutable.BitSet(b.length)\n        val xorResultBitsSetSetSetSetSetSet\
    \ = mutable.BitSet(b.length)\n        val xorResultBitsSetSetSetSetSetSet = mutable.BitSet(b.length)\n\
    \        val xorResultBitsSetSetSetSetSetSet = mutable.BitSet(b.length)\n    \
    \    val xorResultBitsSetSetSetSetSetSet = mutable.BitSet(b.length)\n        val\
    \ xorResultBitsSetSetSetSetSetSet = mutable.BitSet(b.length)\n        val xorResultBitsSetSetSetSetSetSet\
    \ = mutable.BitSet(b.length)\n        val xorResultBitsSetSetSetSetSetSet = mutable.BitSet(b.length)\n\
    \        val xorResultBitsSetSetSetSetSetSet = mutable.BitSet(b.length)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwjzblwsn.scala:15:12 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mxorResultBitsSetSetSet\e\
    [0m = mutable.BitSet(b.length)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorResultBitsSetSetSet is already defined as \e[33mvalue\e\
    [0m \e[35mxorResultBitsSetSetSet\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwjzblwsn.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mxorResultBitsSetSetSetSetSet\e\
    [0m = mutable.BitSet(b.length)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorResultBitsSetSetSetSetSet is already defined as \e[33mvalue\e\
    [0m \e[35mxorResultBitsSetSetSetSetSet\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwjzblwsn.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mxorResultBitsSetSetSetSetSet\e\
    [0m = mutable.BitSet(b.length)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorResultBitsSetSetSetSetSet is already defined as \e[33mvalue\e\
    [0m \e[35mxorResultBitsSetSetSetSetSet\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwjzblwsn.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mxorResultBitsSetSetSetSetSet\e\
    [0m = mutable.BitSet(b.length)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorResultBitsSetSetSetSetSet is already defined as \e[33mvalue\e\
    [0m \e[35mxorResultBitsSetSetSetSetSet\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of t"
  stdout: ''
  timestamp: 1659978752
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toCharArray\n\
    \        val bList = b.toCharArray\n        val xorResult = mutable.ArrayBuffer.empty[Char]\n\
    \        for(i <- 0 until aList.length){\n            xorResult += (aList(i) xor\
    \ bList(i))\n        }\n        xorResult.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi3houo1y.scala:9:24 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorResult\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mChar\e[0m]\n\e[31m\e[31m  |\e[0m                        ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                        Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978748
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = Array.ofDim[Int](8)\n\
    \        for(i <- 0 until 8) {\n            xorArray(i) = aArray(i) xor bArray(i)\n\
    \        }\n        val xorString = xorArray.toString.reverse.mkString(\"\")\n\
    \        xorString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpiavzjm6w.scala:11:36 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659978752
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toCharArray\n\
    \        val bList = b.toCharArray\n        val xorResult = mutable.ArrayBuffer.empty[Char]\n\
    \        for (i <- 0 until aList.length)\n            for (j <- 0 until bList.length)\n\
    \                if (aList(i) == bList(j))\n                    xorResult += aList(i)\n\
    \        xorResult.toString\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"\
    1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7t8r7jas.scala:9:24 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorResult\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mChar\e[0m]\n\e[31m\e[31m  |\e[0m                        ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                        Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978747
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toCharArray.map(_.toInt)\n\
    \        val bList = b.toCharArray.map(_.toInt)\n        val xorList = aList.zip(bList).map(x\
    \ => x._1 ^ x._2)\n        val xorString = xorList.map(x => x.toChar).mkString(\"\
    \")\n        xorString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4o70tb1h.scala:14)\n\tat Problem.main(tmp4o70tb1h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978754
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aBits = a.toIntArray\n\
    \        val bBits = b.toIntArray\n        val xorBits = Array.ofDim[Int](Math.max(aBits.length,\
    \ bBits.length))\n        var i = 0\n        while (i < xorBits.length) {\n  \
    \          xorBits(i) = aBits(i).xor(bBits(i))\n            i += 1\n        }\n\
    \        xorBits.mkString(\"\")\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfttpcjyn.scala:7:22 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpfttpcjyn.scala:8:22 -------------------------\e[0m\e\
    [0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m      \
    \              value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659978718
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n\
    \        val xorResult = mutable.ListBuffer.empty[String]\n        val xorResultList\
    \ = mutable.ListBuffer.empty[String]\n        val xorResultList2 = mutable.ListBuffer.empty[String]\n\
    \        val xorResultList3 = mutable.ListBuffer.empty[String]\n        val xorResultList4\
    \ = mutable.ListBuffer.empty[String]\n        val xorResultList5 = mutable.ListBuffer.empty[String]\n\
    \        val xorResultList6 = mutable.ListBuffer.empty[String]\n        val xorResultList7\
    \ = mutable.ListBuffer.empty[String]\n        val xorResultList8 = mutable.ListBuffer.empty[String]\n\
    \        val xorResultList9 = mutable.ListBuffer.empty[String]\n        val xorResultList10\
    \ = mutable.ListBuffer.empty[String]\n        val xorResultList11 = mutable.ListBuffer.empty[String]\n\
    \        val xorResultList12 = mutable.ListBuffer.empty[String]\n        val xorResultList13\
    \ = mutable.ListBuffer.empty[String]\n        val xorResultList14 = mutable.ListBuffer.empty[String]\n\
    \        val xorResultList15 = mutable.ListBuffer.empty[String]\n        val xorResultList16\
    \ = mutable.ListBuffer.empty[String]\n        val xorResultList17 = mutable.ListBuffer.empty[String]\n\
    \        val xorResultList18 = mutable.ListBuffer.empty[String]\n        val xorResultList19\
    \ = mutable.ListBuffer.empty[String]\n        val xorResultList20 = mutable.ListBuffer.empty[String]\n\
    \        val xorResultList21 = mutable.ListBuffer.empty[String]\n        val xorResultList22\
    \ = mutable.ListBuffer.empty[String]\n        val xorResultList23 = mutable.ListBuffer.empty[String]\n\
    \        val xorResultList24 = mutable.ListBuffer.empty[String]\n        val xorResultList25\
    \ = mutable.ListBuffer.empty[String]\n        val xorResultList26 = mutable.ListBuffer.empty[String]\n\
    \        val xorResultList27 = mutable.ListBuffer.empty[String]\n        val xorResultList28\
    \ = mutable.ListBuffer.empty[String]\n        val xorResultList29 = mutable.ListBuffer.empty[String]\n\
    \        val xorResultList30 = mutable.ListBuffer.empty[String]\n        val \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpvx4tocu0.scala:41:11 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpvx4tocu0.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpvx4tocu0.scala:10:24 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mxorResult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpvx4tocu0.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorResultList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                            Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpvx4tocu0.scala:12:29 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mxorResultList2\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             Not found: mutable\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvx4tocu0.scala:13:29 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mxorResultList3\e[0m ="
  stdout: ''
  timestamp: 1659978751
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toCharArray\n\
    \        val bList = b.toCharArray\n        val xorList = mutable.ArrayBuffer.empty[Char]\n\
    \        var xor = 0\n        var i = 0\n        while (i < aList.length && i\
    \ < bList.length) {\n            xor = xor + (aList(i) xor bList(i))\n       \
    \     xorList.add(xor)\n            i += 1\n        }\n        xorList.mkString.reverse.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpc01lxljp.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mChar\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpc01lxljp.scala:13:34 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            xor = xor + (aList(i) xor bList(i))\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                    value xor is not a member of Char\n2 errors found\n"
  stdout: ''
  timestamp: 1659978754
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aBits = a.toIntArray\n\
    \        val bBits = b.toIntArray\n        val xorBits = aBits xor bBits\n   \
    \     val xorBitsString = xorBits.map(bit => if (bit == 1) \"1\" else \"0\").mkString\n\
    \        xorBitsString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5kr2bq4_.scala:7:22 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp5kr2bq4_.scala:8:22 -------------------------\e[0m\e\
    [0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m      \
    \              value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659978707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Char](Math.max(aArray.length,\
    \ bArray.length))\n        val xorArrayIndex = 0\n        for(i <- 0 until aArray.length)\n\
    \            for(j <- 0 until bArray.length)\n                if(aArray(i) ==\
    \ bArray(j))\n                    xorArray(xorArrayIndex) |= aArray(i)\n     \
    \           xorArrayIndex += 1\n        new String(xorArray)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfb7g_0ie.scala:14:44 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m                    xorArray(xorArrayIndex) |= aArray(i)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                value |= is not a member of Char - did you mean Char.!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfb7g_0ie.scala:15:30 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m                xorArrayIndex += \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value\
    \ += is not a member of Int - did you mean xorArrayIndex.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1659978757
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = ArrayBuffer.empty[Int]\n\
    \        for(i <- 0 until aArray.length)\n            for(j <- 0 until bArray.length)\n\
    \                xorArray(i) += aArray(i) xor bArray(j)\n        xorArray.toString.toCharArray\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp167pjji7.scala:12:28 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m                xorArray(i) += aArray(i) xor bArray(j)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \            value += is not a member of Int - did you mean Int.!=?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp167pjji7.scala:12:41 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m                xorArray(i) += aArray(i) xor bArray(j)\n\
    \e[31m\e[31m   |\e[0m                               ^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                               value xor is not a member of Int\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp167pjji7.scala:13:8 ---------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        xorArray.toString.toCharArray\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:\
    \    Array[Char]\n\e[31m   |\e[0m        Required: String\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978757
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n\
    \        var i = 0\n        while (i < aList.length && i < bList.length) {\n \
    \           xorList += aList(i) xor bList(i)\n            i += 1\n        }\n\
    \        xorList.mkString(\"\")\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4tkh102i.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978754
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val xorList = mutable.ListBuffer.empty[Int]\n\
    \        for(i <- 0 until aList.length) xorList += (aList(i) xor bList(i))\n \
    \       xorList.toString.reverse\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk1mdluaa.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978754
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val result = new StringBuilder\n\
    \        var i = 0\n        while (i < a.length) {\n            result.append(aArray(i)\
    \ XOR bArray(i))\n            i += 1\n        }\n        return result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpc16ffff8.scala:12:36 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            result.append(aArray(i) XOR bArray(i))\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value XOR is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659978759
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = Array.ofDim[Int](2)\n\
    \        val xorArray2 = Array.ofDim[Int](2)\n        val xorArray3 = Array.ofDim[Int](2)\n\
    \        val xorArray4 = Array.ofDim[Int](2)\n        val xorArray5 = Array.ofDim[Int](2)\n\
    \        val xorArray6 = Array.ofDim[Int](2)\n        val xorArray7 = Array.ofDim[Int](2)\n\
    \        val xorArray8 = Array.ofDim[Int](2)\n        val xorArray9 = Array.ofDim[Int](2)\n\
    \        val xorArray10 = Array.ofDim[Int](2)\n        val xorArray11 = Array.ofDim[Int](2)\n\
    \        val xorArray12 = Array.ofDim[Int](2)\n        val xorArray13 = Array.ofDim[Int](2)\n\
    \        val xorArray14 = Array.ofDim[Int](2)\n        val xorArray15 = Array.ofDim[Int](2)\n\
    \        val xorArray16 = Array.ofDim[Int](2)\n        val xorArray17 = Array.ofDim[Int](2)\n\
    \        val xorArray18 = Array.ofDim[Int](2)\n        val xorArray19 = Array.ofDim[Int](2)\n\
    \        val xorArray20 = Array.ofDim[Int](2)\n        val xorArray21 = Array.ofDim[Int](2)\n\
    \        val xorArray22 = Array.ofDim[Int](2)\n        val xorArray23 = Array.ofDim[Int](2)\n\
    \        val xorArray24 = Array.ofDim[Int](2)\n        val xorArray25 = Array.ofDim[Int](2)\n\
    \        val xorArray26 = Array.ofDim[Int](2)\n        val xorArray27 = Array.ofDim[Int](2)\n\
    \        val xorArray28 = Array.ofDim[Int](2)\n        val xorArray29 = Array.ofDim[Int](2)\n\
    \        val xorArray30 = Array.ofDim[Int](2)\n        val xorArray31 = Array.ofDim[Int](2)\n\
    \        val xorArray32 = Array.ofDim[Int](2)\n        val xorArray33 = Array.ofDim[Int](2)\n\
    \        val xorArray34 = Array.ofDim[Int](2)\n        val xorArray35 = Array.ofDim[Int](2)\n\
    \        val xorArray\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9xc0aymq.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp9xc0aymq.scala:45:5 ---------------------\e[0m\e[0m\n\e[31m45 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aBits = a.toIntArray\n\
    \        val bBits = b.toIntArray\n        val xorBits = aBits XOR bBits\n   \
    \     val xorBitsString = xorBits.map( x => x.toString ).mkString(\"\")\n    \
    \    return xorBitsString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3n6h7hwj.scala:7:22 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp3n6h7hwj.scala:8:22 -------------------------\e[0m\e\
    [0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m      \
    \              value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659978758
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n\
    \        var i = 0\n        while (i < aList.length && i < bList.length) {\n \
    \           xorList += aList(i) xor bList(i)\n            i += 1\n        }\n\
    \        xorList.mkString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkv0p4zwz.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978756
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until aList.length) xorList += aList(i) xor bList(i)\n   \
    \     xorList.toList.reverse.mkString(\"\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdmvpoxdq.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978733
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val result = new StringBuilder\n      \
    \  val xor = new mutable.HashMap[Int, Int]()\n        val xorResult = new mutable.HashMap[Int,\
    \ Int]()\n        val xorResultMap = new mutable.HashMap[Int, Int]()\n       \
    \ val xorResultMap2 = new mutable.HashMap[Int, Int]()\n        val xorResultMap3\
    \ = new mutable.HashMap[Int, Int]()\n        val xorResultMap4 = new mutable.HashMap[Int,\
    \ Int]()\n        val xorResultMap5 = new mutable.HashMap[Int, Int]()\n      \
    \  val xorResultMap6 = new mutable.HashMap[Int, Int]()\n        val xorResultMap7\
    \ = new mutable.HashMap[Int, Int]()\n        val xorResultMap8 = new mutable.HashMap[Int,\
    \ Int]()\n        val xorResultMap9 = new mutable.HashMap[Int, Int]()\n      \
    \  val xorResultMap10 = new mutable.HashMap[Int, Int]()\n        val xorResultMap11\
    \ = new mutable.HashMap[Int, Int]()\n        val xorResultMap12 = new mutable.HashMap[Int,\
    \ Int]()\n        val xorResultMap13 = new mutable.HashMap[Int, Int]()\n     \
    \   val xorResultMap14 = new mutable.HashMap[Int, Int]()\n        val xorResultMap15\
    \ = new mutable.HashMap[Int, Int]()\n        val xorResultMap16 = new mutable.HashMap[Int,\
    \ Int]()\n        val xorResultMap17 = new mutable.HashMap[Int, Int]()\n     \
    \   val xorResultMap18 = new mutable.HashMap[Int, Int]()\n        val xorResultMap19\
    \ = new mutable.HashMap[Int, Int]()\n        val xorResultMap20 = new mutable.HashMap[Int,\
    \ Int]()\n        val xorResultMap21 = new mutable.HashMap[Int, Int]()\n     \
    \   val xorResultMap22 = new mutable.HashMap[Int, Int]()\n        val xorResultMap23\
    \ = new mutable.HashMap[Int, Int]()\n        val xorResultMap24 = new mutable.HashMap[Int,\
    \ Int]()\n        val xorResultMap25 = new mutable.HashMap[Int, Int]()\n     \
    \   val xorResultMap26 = new mutable.HashMap[Int, Int]()\n        val xorResultMap27\
    \ = new mutable.HashMap[Int, Int]()\n        \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzry7vlvs.scala:10:22 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mxor\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mInt\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzry7vlvs.scala:11:28\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mxorResult\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mInt\e[0m, \e[35mInt\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                            Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpzry7vlvs.scala:12:31 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mxorResultMap\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mInt\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m \
    \                              ^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \              Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpzry7vlvs.scala:13:32 ------------------------\e[0m\e[0m\n\e[31m13 |\e\
    [0m        \e[33mval\e[0m \e[36mxorResultMap2\e[0m = \e[33mnew\e[0m mutable.HashMap[\e\
    [35mInt\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                       \
    \         ^^^^^^^\e[0m\n\e[31m   |\e[0m                                Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzry7vlvs.scala:14:32\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mxorResultMap3\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mInt\e[0m, \e[35mInt\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                                ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0"
  stdout: ''
  timestamp: 1659978759
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toCharArray\n\
    \        val bList = b.toCharArray\n        val xorResult = mutable.ArrayBuffer.empty[Char]\n\
    \        for (i <- 0 until aList.length)\n            xorResult += (aList(i) XOR\
    \ bList(i))\n        xorResult.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpitabkznl.scala:9:24 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorResult\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mChar\e[0m]\n\e[31m\e[31m  |\e[0m                        ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                        Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978757
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aBits = a.toIntArray\n\
    \        val bBits = b.toIntArray\n        val xorBits = Array.ofDim[Int](8)\n\
    \        val xorBitsCount = 8\n        val xorBitsMask = 1 << xorBitsCount\n \
    \       val xorBitsShift = xorBitsCount - 1\n        val xorBitsMaskShift = xorBitsMask\
    \ << xorBitsShift\n        val xorBitsMaskShift2 = xorBitsMask << xorBitsShift\n\
    \        val xorBitsMaskShift3 = xorBitsMask << xorBitsShift\n        val xorBitsMaskShift4\
    \ = xorBitsMask << xorBitsShift\n        val xorBitsMaskShift5 = xorBitsMask <<\
    \ xorBitsShift\n        val xorBitsMaskShift6 = xorBitsMask << xorBitsShift\n\
    \        val xorBitsMaskShift7 = xorBitsMask << xorBitsShift\n        val xorBitsMaskShift8\
    \ = xorBitsMask << xorBitsShift\n        val xorBitsMaskShift9 = xorBitsMask <<\
    \ xorBitsShift\n        val xorBitsMaskShift10 = xorBitsMask << xorBitsShift\n\
    \        val xorBitsMaskShift11 = xorBitsMask << xorBitsShift\n        val xorBitsMaskShift12\
    \ = xorBitsMask << xorBitsShift\n        val xorBitsMaskShift13 = xorBitsMask\
    \ << xorBitsShift\n        val xorBitsMaskShift14 = xorBitsMask << xorBitsShift\n\
    \        val xorBitsMaskShift15 = xorBitsMask << xorBitsShift\n        val xorBitsMaskShift16\
    \ = xorBitsMask << xorBitsShift\n        val xorBitsMaskShift17 = xorBitsMask\
    \ << xorBitsShift\n        val xorBitsMaskShift18 = xorBitsMask << xorBitsShift\n\
    \        val xorBitsMaskShift19 = xorBitsMask << xorBitsShift\n        val xorBitsMaskShift20\
    \ = xorBitsMask << xorBitsShift\n        val xorBitsMaskShift21 = xorBitsMask\
    \ << xorBitsShift\n        val xorBitsMaskShift22 = xorBitsMask << xorBitsShift\n\
    \        val xorBitsMaskShift23 = xorBitsMask << xorBitsShift\n        val xorBitsMaskShift24\
    \ = xorBitsMask << xorBit\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyg3u1zl1.scala:7:22 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpyg3u1zl1.scala:8:22 -------------------------\e[0m\e\
    [0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m      \
    \              value toIntArray is not a member of String\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpyg3u1zl1.scala:36:48 ------------------------\e[0m\e\
    [0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mxorBitsMaskShift24\e[0m = xorBitsMask\
    \ << xorBit\n\e[31m\e[31m   |\e[0m                                           \
    \     ^^^^^^\e[0m\n\e[31m   |\e[0m                                           \
    \     Not found: xorBit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyg3u1zl1.scala:37:5\
    \ ---------------------\e[0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659978760
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toCharArray.map(_.toInt)\n\
    \        val bList = b.toCharArray.map(_.toInt)\n        val xorList = mutable.ListBuffer.empty[Int]\n\
    \        for(i <- 0 until aList.length) xorList += (aList(i) xor bList(i))\n \
    \       xorList.toString.toCharArray\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgt3rjvwi.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978739
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toCharArray\n\
    \        val bList = b.toCharArray\n        val result = new StringBuilder\n \
    \       val xor = mutable.BitSet(b.length)\n        for (i <- 0 until a.length)\
    \ {\n            xor.set(aList(i) ^ bList(i))\n            result.append(xor.get(i))\n\
    \        }\n        return result.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpd9lftveh.scala:10:18 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mxor\e[0m = mutable.BitSet(b.length)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978757
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toCharArray\n\
    \        val bList = b.toCharArray\n        val xorList = mutable.ArrayBuffer.empty[Char]\n\
    \        for(i <- 0 until aList.length)\n            for(j <- 0 until bList.length)\n\
    \                if(aList(i) == bList(j))\n                    xorList += aList(i)\n\
    \        xorList.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmperfx06yg.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mChar\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978757
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aBits = a.toIntArray\n\
    \        val bBits = b.toIntArray\n        val xorBits = Array.ofDim[Int](Math.max(aBits.length,\
    \ bBits.length))\n        val xorBitsIndex = 0\n        for(i <- 0 until xorBits.length)\
    \ xorBits(i) = 0\n        for(i <- 0 until aBits.length) xorBits(i) ^= aBits(i)\n\
    \        for(i <- 0 until bBits.length) xorBits(i) ^= bBits(i)\n        val result\
    \ = new StringBuilder(xorBits.length)\n        for(i <- 0 until xorBits.length)\
    \ result.append(xorBits(i))\n        return result.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjs9q8_4h.scala:7:22 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpjs9q8_4h.scala:8:22 -------------------------\e[0m\e\
    [0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m      \
    \              value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659978761
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n\
    \        val xorResult = mutable.ListBuffer.empty[String]\n        for(i <- 0\
    \ until aList.length){\n            val xor = aList(i) xor bList(i)\n        \
    \    xorList += xor.toString(2)\n            xorResult += xor.toString(2)\n  \
    \      }\n        xorList.mkString(\"\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpz8i3fjxo.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpz8i3fjxo.scala:10:24 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mxorResult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpz8i3fjxo.scala:12:31 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            \e[33mval\e[0m \e[36mxor\e[0m = aList(i)\
    \ xor bList(i)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                      value xor is not a member of Char\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978760
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Char](b.length)\n\
    \        for(i <- 0 until xorArray.length)\n            xorArray(i) = (aArray(i)\
    \ XOR bArray(i)).toChar\n        new String(xorArray)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpt_8t5naj.scala:11:37 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m            xorArray(i) = (aArray(i) XOR bArray(i)).toChar\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                           value XOR is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659978728
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Int](aArray.length)\n\
    \        for(i <- 0 until xorArray.length) xorArray(i) = aArray(i) xor bArray(i)\n\
    \        new String(xorArray)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzde5qk_z.scala:10:66 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mfor\e[0m(i <- \e[31m0\e[0m until xorArray.length)\
    \ xorArray(i) = aArray(i) xor bArray(i)\n\e[31m\e[31m   |\e[0m               \
    \                                         ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                       value xor is not a member of Char\n\e\
    [31m\e[31m-- [E134] Type Error: /tmp/tmpzde5qk_z.scala:11:12 -----------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mnew\e[0m \e[35mString\e[0m(xorArray)\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mconstructor\e[0m \e[35mString\e[0m in \e[33mclass\e[0m\
    \ \e[35mString\e[0m with types\n\e[31m   |\e[0m (x$0: StringBuilder): String\n\
    \e[31m   |\e[0m (x$0: StringBuffer): String\n\e[31m   |\e[0m (x$0: Array[Byte]):\
    \ String\n\e[31m   |\e[0m (x$0: Array[Byte], x$1: Int, x$2: Int): String\n\e[31m\
    \   |\e[0m (x$0: Array[Byte], x$1: java.nio.charset.Charset): String\n\e[31m \
    \  |\e[0m (x$0: Array[Byte], x$1: String): String\n\e[31m   |\e[0m (x$0: Array[Byte],\
    \ x$1: Int, x$2: Int, x$3: java.nio.charset.Charset): String\n\e[31m   |\e[0m\
    \ (x$0: Array[Byte], x$1: Int, x$2: Int, x$3: String): String\n\e[31m   |\e[0m\
    \ (x$0: Array[Byte], x$1: Int): String\n\e[31m   |\e[0m (x$0: Array[Byte], x$1:\
    \ Int, x$2: Int, x$3: Int): String\n\e[31m   |\e[0m (x$0: Array[Int], x$1: Int,\
    \ x$2: Int): String\n\e[31m   |\e[0m (x$0: Array[Char], x$1: Int, x$2: Int): String\n\
    \e[31m   |\e[0m (x$0: Array[Char]): String\n\e[31m   |\e[0m (x$0: String): String\n\
    \e[31m   |\e[0m (): String\n\e[31m   |\e[0mmatch arguments ((xorArray : Array[Int]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659978760
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = ArrayBuffer.empty[Int]\n\
    \        for(i <- 0 until aArray.length)\n            for(j <- 0 until bArray.length)\n\
    \                if(aArray(i) XOR bArray(j) == 1)\n                    xorArray.append(1)\n\
    \                else\n                    xorArray.append(0)\n        xorArray.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpf0k85ema.scala:12:29 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m                \e[33mif\e[0m(aArray(i) XOR bArray(j)\
    \ == \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                   value XOR is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659978760
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n\
    \        for (i <- 0 until aList.length) xorList += (aList(i) xor bList(i))\n\
    \        xorList.toList.reverse.mkString(\"\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnqibyj6p.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978758
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aBits = a.toIntArray\n\
    \        val bBits = b.toIntArray\n        val xorBits = Array.ofDim[Int](8)\n\
    \        val xorBitsLen = xorBits.length\n        val xorBitsLenBits = xorBitsLen\
    \ / 8\n        val xorBitsLenBytes = xorBitsLen % 8\n        val xorBitsLenBytesBits\
    \ = xorBitsLenBytes / 8\n        val xorBitsLenBytesBytes = xorBitsLenBytes %\
    \ 8\n        val xorBitsLenBytesBytesBits = xorBitsLenBytesBytes / 8\n       \
    \ val xorBitsLenBytesBytesBytesBits = xorBitsLenBytesBytesBytes / 8\n        val\
    \ xorBitsLenBytesBytesBytesBytesBits = xorBitsLenBytesBytesBytesBytes / 8\n  \
    \      val xorBitsLenBytesBytesBytesBytesBytesBits = xorBitsLenBytesBytesBytesBytesBytes\
    \ / 8\n        val xorBitsLenBytesBytesBytesBytesBytesBytesBits = xorBitsLenBytesBytesBytesBytesBytesBytes\
    \ / 8\n        val xorBitsLenBytesBytesBytesBytesBytesBytesBytesBytesBits = xorBitsLenBytesBytesBytesBytesBytesBytesBytesBytes\
    \ / 8\n        val xorBitsLenBytesBytesBytesBytesBytesBytesBytesBytesBits = xorBitsLenBytesBytesBytesBytesBytesBytesBytesBytesBytes\
    \ / 8\n        val xorBitsLenBytesBytesBytesBytesBytesBytesBytesBytesBits = xorBitsLenBytesBytesBytesBytesBytesBytesBytesBytesBytesBytes\
    \ / 8\n        val xorBitsLenBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBits\
    \ = xorBitsLenBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytes\
    \ / 8\n        val xorBitsLenBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBits\
    \ = xorBitsLenBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytesBytes\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgzlx5r9q.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mxorBitsLenBytesBytesBytesBytesBytesBytesBytesBytesBits\e\
    [0m = xorBitsLenBytesBytesBytesBytesBytesBytesBytesBytesBytes / \e[31m8\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorBitsLenBytesBytesBytesBytesBytesBytesBytesBytesBits is\
    \ already defined as \e[33mvalue\e[0m \e[35mxorBitsLenBytesBytesBytesBytesBytesBytesBytesBytesBits\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpgzlx5r9q.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mxorBitsLenBytesBytesBytesBytesBytesBytesBytesBytesBits\e\
    [0m = xorBitsLenBytesBytesBytesBytesBytesBytesBytesBytesBytesBytes / \e[31m8\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorBitsLenBytesBytesBytesBytesBytesBytesBytesBytesBits is\
    \ already defined as \e[33mvalue\e[0m \e[35mxorBitsLenBytesBytesBytesBytesBytesBytesBytesBytesBits\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpgzlx5r9q.scala:7:22 -------------------------\e[0m\e[0m\n\
    \e[31m7 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\e[31m\e\
    [31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m            \
    \        value toIntArray is not a member of String\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpgzlx5r9q.scala:8:22 -------------------------\e[0m\e[0m\n\
    \e[31m8 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e[31m\e\
    [31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m            \
    \        value toIntArray is not a member of String\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tm"
  stdout: ''
  timestamp: 1659978762
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aBits = a.toIntArray\n\
    \        val bBits = b.toIntArray\n        val xorBits = Array.ofDim[Int](Math.max(aBits.length,\
    \ bBits.length))\n        val xorBitsIndex = 0\n        for (aBit <- aBits) {\n\
    \            val bBit = aBit ^ bBits(xorBitsIndex)\n            xorBits(xorBitsIndex)\
    \ = bBit\n            xorBitsIndex += 1\n        }\n        xorBits.map(_.toChar).mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvubxfw5j.scala:7:22 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpvubxfw5j.scala:8:22 -------------------------\e[0m\e\
    [0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m      \
    \              value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659978764
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until aList.length){\n            val xor = aList(i) xor bList(i)\n\
    \            xorList += xor.toString\n        }\n        xorList.toString\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprdf5xfad.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmprdf5xfad.scala:11:31 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m            \e[33mval\e[0m \e[36mxor\e[0m = aList(i)\
    \ xor bList(i)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                      value xor is not a member of Char\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978762
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until aList.length){\n            xorList += (aList(i) XOR\
    \ bList(i)).toString\n        }\n        xorList.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpn2x8m67q.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978760
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = aArray.zip(\n\
    \            bArray\n        ).map(x => x._1 ^ x._2)\n        val xorString =\
    \ xorArray.toArray.mkString(\"\")\n        xorString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978768
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toCharArray.map(_.toInt)\n\
    \        val bList = b.toCharArray.map(_.toInt)\n        val xorList = mutable.ListBuffer.empty[Int]\n\
    \        for(i <- 0 until aList.length) xorList += (aList(i) xor bList(i))\n \
    \       xorList.toString.toCharArray\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgt3rjvwi.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978739
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val result = new StringBuilder\n      \
    \  val xor = new mutable.HashMap[Int, Int]()\n        val xorArray = new mutable.Array[Int](aList.size\
    \ + bList.size)\n        val xorArrayIndex = 0\n        val xorArrayIndex2 = xorArrayIndex\n\
    \        val xorArrayIndex3 = xorArrayIndex2\n        val xorArrayIndex4 = xorArrayIndex3\n\
    \        val xorArrayIndex5 = xorArrayIndex4\n        val xorArrayIndex6 = xorArrayIndex5\n\
    \        val xorArrayIndex7 = xorArrayIndex6\n        val xorArrayIndex8 = xorArrayIndex7\n\
    \        val xorArrayIndex9 = xorArrayIndex8\n        val xorArrayIndex10 = xorArrayIndex9\n\
    \        val xorArrayIndex11 = xorArrayIndex10\n        val xorArrayIndex12 =\
    \ xorArrayIndex11\n        val xorArrayIndex13 = xorArrayIndex12\n        val\
    \ xorArrayIndex14 = xorArrayIndex13\n        val xorArrayIndex15 = xorArrayIndex14\n\
    \        val xorArrayIndex16 = xorArrayIndex15\n        val xorArrayIndex17 =\
    \ xorArrayIndex16\n        val xorArrayIndex18 = xorArrayIndex17\n        val\
    \ xorArrayIndex19 = xorArrayIndex18\n        val xorArrayIndex20 = xorArrayIndex19\n\
    \        val xorArrayIndex21 = xorArrayIndex20\n        val xorArrayIndex22 =\
    \ xorArrayIndex21\n        val xorArrayIndex23 = xorArrayIndex22\n        val\
    \ xorArrayIndex24 = xorArrayIndex23\n        val xorArrayIndex25 = xorArrayIndex24\n\
    \        val xorArrayIndex26 = xorArrayIndex25\n        val xorArrayIndex27 =\
    \ xorArrayIndex26\n        val xorArrayIndex28 = xorArrayIndex27\n        val\
    \ xorArrayIndex29 = xorArrayIndex28\n        val xorArrayIndex30 = xorArrayIndex29\n\
    \        val xorArrayIndex31 = xorArrayIndex30\n        val xorArrayIndex32 =\
    \ xorArrayIndex31\n        val xorArrayIndex33 = xorArrayIndex32\n        val\
    \ xorArrayIndex34 = xorArrayIndex33\n        val xorArrayIndex35 = xorArrayIndex34\n\
    \        val xorArrayIndex36 = xorArrayIndex35\n        val xorArrayIndex37 =\
    \ xorArrayIndex36\n        val xorArrayIndex38 = xorArrayIndex37\n        val\
    \ xorArrayIndex39 = xorArrayIndex38\n        \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi7776v22.scala:10:22 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mxor\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mInt\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi7776v22.scala:11:27\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mxorArray\e[0m = \e[33mnew\e[0m mutable.Array[\e[35mInt\e[0m](aList.size +\
    \ bList.size)\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi7776v22.scala:52:5 ---------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659978766
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val result = new StringBuilder\n      \
    \  val aLen = aList.length\n        val bLen = bList.length\n        val aIndex\
    \ = 0\n        val bIndex = 0\n        while(aIndex < aLen && bIndex < bLen) {\n\
    \            if(a(aIndex) XOR b(bIndex)) result.append(1)\n            else result.append(0)\n\
    \            aIndex += 1\n            bIndex += 1\n        }\n        return result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfiw8lcl3.scala:15:25 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            \e[33mif\e[0m(a(aIndex) XOR b(bIndex)) result.append(\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m               value XOR is not a member of Char\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpfiw8lcl3.scala:17:19 ------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m            aIndex += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member\
    \ of Int - did you mean aIndex.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfiw8lcl3.scala:18:19\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m            bIndex += \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \           value += is not a member of Int - did you mean bIndex.!=?\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978767
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val xorList = mutable.ListBuffer.empty[Int]\n\
    \        for(i <- 0 until aList.length)\n            for(j <- 0 until bList.length)\n\
    \                xorList += (aList(i) xor (bList(j)))\n        xorList.toList.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdsowv1l2.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978763
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aBits = a.toIntArray\n\
    \        val bBits = b.toIntArray\n        val xorBits = aBits xor bBits\n   \
    \     val xorBitsString = xorBits.map(Integer.toBinaryString).mkString\n     \
    \   xorBitsString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmped_f43e8.scala:7:22 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmped_f43e8.scala:8:22 -------------------------\e[0m\e\
    [0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m      \
    \              value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659978768
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Char](Math.max(aArray.length,\
    \ bArray.length))\n        val xorArrayIndex = 0\n        for (i <- 0 until aArray.length)\n\
    \            for (j <- 0 until bArray.length)\n                xorArray(xorArrayIndex)\
    \ = aArray(i) xor bArray(j)\n        new String(xorArray)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph5vtnu5f.scala:13:52 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m                xorArray(xorArrayIndex) = aArray(i) xor\
    \ bArray(j)\n\e[31m\e[31m   |\e[0m                                          ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                       value xor is not a\
    \ member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659978768
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = mutable.ArrayBuffer.empty[Int]\n\
    \        for(i <- 0 until aArray.length) xorArray += (aArray(i) xor bArray(i))\n\
    \        xorArray.toString.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdo3jnn1j.scala:9:23 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m  |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                       Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978732
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Char](b.length)\n\
    \        for(i <- 0 until xorArray.length) xorArray(i) = aArray(i) xor bArray(i)\n\
    \        new String(xorArray)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqt4yypdx.scala:10:66 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mfor\e[0m(i <- \e[31m0\e[0m until xorArray.length)\
    \ xorArray(i) = aArray(i) xor bArray(i)\n\e[31m\e[31m   |\e[0m               \
    \                                         ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                       value xor is not a member of Char\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978768
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until aList.length)\n            for(j <- 0 until bList.length)\n\
    \                if(aList(i) == bList(j))\n                    xorList += aList(i)\n\
    \        xorList.mkString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpoxekdivl.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978766
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n\
    \        for (i <- 0 until aList.length) xorList += (aList(i) xor bList(i)).toString\n\
    \        xorList.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1umpu229.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978765
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Int](a.length)\n\
    \        var xor = 0\n        for (i <- 0 until xorArray.length) {\n         \
    \   xor = xor + (aArray(i) xor bArray(i))\n        }\n        val result = new\
    \ StringBuilder(xor)\n        for (i <- 0 until xorArray.length) {\n         \
    \   result(i) = xorArray(i)\n        }\n        return result.toString\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmponz_2vnu.scala:12:35 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            xor = xor + (aArray(i) xor bArray(i))\n\e\
    [31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                         value xor is not a member of Char\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmponz_2vnu.scala:16:32 --------------------\e[0m\e\
    [0m\n\e[31m16 |\e[0m            result(i) = xorArray(i)\n\e[31m\e[31m   |\e[0m\
    \                        ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \     Found:    Int\n\e[31m   |\e[0m                        Required: Char\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978769
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val result = new StringBuilder\n      \
    \  val xor = new mutable.HashMap[Int, Int]()\n        val xorResult = new mutable.HashMap[Int,\
    \ Int]()\n        val xorResultMap = new mutable.HashMap[Int, Int]()\n       \
    \ val xorResultMap2 = new mutable.HashMap[Int, Int]()\n        val xorResultMap3\
    \ = new mutable.HashMap[Int, Int]()\n        val xorResultMap4 = new mutable.HashMap[Int,\
    \ Int]()\n        val xorResultMap5 = new mutable.HashMap[Int, Int]()\n      \
    \  val xorResultMap6 = new mutable.HashMap[Int, Int]()\n        val xorResultMap7\
    \ = new mutable.HashMap[Int, Int]()\n        val xorResultMap8 = new mutable.HashMap[Int,\
    \ Int]()\n        val xorResultMap9 = new mutable.HashMap[Int, Int]()\n      \
    \  val xorResultMap10 = new mutable.HashMap[Int, Int]()\n        val xorResultMap11\
    \ = new mutable.HashMap[Int, Int]()\n        val xorResultMap12 = new mutable.HashMap[Int,\
    \ Int]()\n        val xorResultMap13 = new mutable.HashMap[Int, Int]()\n     \
    \   val xorResultMap14 = new mutable.HashMap[Int, Int]()\n        val xorResultMap15\
    \ = new mutable.HashMap[Int, Int]()\n        val xorResultMap16 = new mutable.HashMap[Int,\
    \ Int]()\n        val xorResultMap17 = new mutable.HashMap[Int, Int]()\n     \
    \   val xorResultMap18 = new mutable.HashMap[Int, Int]()\n        val xorResultMap19\
    \ = new mutable.HashMap[Int, Int]()\n        val xorResultMap20 = new mutable.HashMap[Int,\
    \ Int]()\n        val xorResultMap21 = new mutable.HashMap[Int, Int]()\n     \
    \   val xorResultMap22 = new mutable.HashMap[Int, Int]()\n        val xorResultMap23\
    \ = new mutable.HashMap[Int, Int]()\n        val xorResultMap24 = new mutable.HashMap[Int,\
    \ Int]()\n        val xorResultMap25 = new mutable.HashMap[Int, Int]()\n     \
    \   val xorResultMap26 = new mutable.HashMap[Int, Int]()\n        val xorResultMap27\
    \ = new mutable.HashMap[Int, Int]()\n        \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzry7vlvs.scala:10:22 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mxor\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mInt\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzry7vlvs.scala:11:28\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mxorResult\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mInt\e[0m, \e[35mInt\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                            Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpzry7vlvs.scala:12:31 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mxorResultMap\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mInt\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m \
    \                              ^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \              Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpzry7vlvs.scala:13:32 ------------------------\e[0m\e[0m\n\e[31m13 |\e\
    [0m        \e[33mval\e[0m \e[36mxorResultMap2\e[0m = \e[33mnew\e[0m mutable.HashMap[\e\
    [35mInt\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                       \
    \         ^^^^^^^\e[0m\n\e[31m   |\e[0m                                Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzry7vlvs.scala:14:32\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mxorResultMap3\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mInt\e[0m, \e[35mInt\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                                ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0"
  stdout: ''
  timestamp: 1659978759
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n\
    \        aList.zip(bList).foreach { case (aChar, bChar) =>\n            xorList\
    \ += aChar ^ bChar\n        }\n        xorList.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3axa6zs0.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978767
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aBits = a.toIntArray\n\
    \        val bBits = b.toIntArray\n        val xorBits = aBits xor bBits\n   \
    \     val xorBitsString = xorBits.map(bit => if (bit == 1) \"1\" else \"0\").mkString\n\
    \        xorBitsString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5kr2bq4_.scala:7:22 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp5kr2bq4_.scala:8:22 -------------------------\e[0m\e\
    [0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m      \
    \              value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659978707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val xorList = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until aList.size) {\n            xorList += aList(i) xor bList(i)\n\
    \        }\n        xorList.toList.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpln7y8x6v.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978766
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until aList.length) xorList += aList(i) xor bList(i)\n   \
    \     xorList.toList.reverse.mkString(\"\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdmvpoxdq.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978733
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val result = new mutable.ListBuffer[String]()\n\
    \        val xor = a.zip(b).map { case (a,b) => a ^ b }\n        xor.foreach {\
    \ x => result += x.toString }\n        result.mkString(\"\")\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf6hkdiq8.scala:9:25 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m  |\e[0m            \
    \             ^^^^^^^\e[0m\n\e[31m  |\e[0m                         Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978767
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = mutable.ArrayBuffer.empty[Int]\n\
    \        aArray.zip(bArray).foreach { case (aChar, bChar) =>\n            xorArray.append(aChar\
    \ ^ bChar)\n        }\n        xorArray.toString.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplzede03o.scala:9:23 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m  |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                       Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978768
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val xorList = mutable.ListBuffer.empty[Int]\n\
    \        for(i <- 0 until aList.length) xorList += (aList(i) xor bList(i))\n \
    \       xorList.toString.reverse\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk1mdluaa.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978754
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Int](aArray.length)\n\
    \        var xor = 0\n        for (i <- 0 until aArray.length)\n            xor\
    \ = xor + aArray(i) xor bArray(i)\n        xor.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpa9vgfjr9.scala:12:34 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            xor = xor + aArray(i) xor bArray(i)\n\e[31m\e\
    [31m   |\e[0m                  ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \             value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659978771
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val result = new StringBuilder\n      \
    \  val xor = new mutable.HashMap[Int, Int]()\n        val xorResult = new mutable.HashMap[Int,\
    \ Int]()\n        val xorResult2 = new mutable.HashMap[Int, Int]()\n        val\
    \ xorResult3 = new mutable.HashMap[Int, Int]()\n        val xorResult4 = new mutable.HashMap[Int,\
    \ Int]()\n        val xorResult5 = new mutable.HashMap[Int, Int]()\n        val\
    \ xorResult6 = new mutable.HashMap[Int, Int]()\n        val xorResult7 = new mutable.HashMap[Int,\
    \ Int]()\n        val xorResult8 = new mutable.HashMap[Int, Int]()\n        val\
    \ xorResult9 = new mutable.HashMap[Int, Int]()\n        val xorResult10 = new\
    \ mutable.HashMap[Int, Int]()\n        val xorResult11 = new mutable.HashMap[Int,\
    \ Int]()\n        val xorResult12 = new mutable.HashMap[Int, Int]()\n        val\
    \ xorResult13 = new mutable.HashMap[Int, Int]()\n        val xorResult14 = new\
    \ mutable.HashMap[Int, Int]()\n        val xorResult15 = new mutable.HashMap[Int,\
    \ Int]()\n        val xorResult16 = new mutable.HashMap[Int, Int]()\n        val\
    \ xorResult17 = new mutable.HashMap[Int, Int]()\n        val xorResult18 = new\
    \ mutable.HashMap[Int, Int]()\n        val xorResult19 = new mutable.HashMap[Int,\
    \ Int]()\n        val xorResult20 = new mutable.HashMap[Int, Int]()\n        val\
    \ xorResult21 = new mutable.HashMap[Int, Int]()\n        val xorResult22 = new\
    \ mutable.HashMap[Int, Int]()\n        val xorResult23 = new mutable.HashMap[Int,\
    \ Int]()\n        val xorResult24 = new mutable.HashMap[Int, Int]()\n        val\
    \ xorResult25 = new mutable.HashMap[Int, Int]()\n        val xorResult26 = new\
    \ mutable.HashMap[Int, Int]()\n        val xorResult27 = new mutable.HashMap[Int,\
    \ Int]()\n        val xorResult28 = new mutable.HashMap[Int, Int]()\n        val\
    \ xorResult29 = new mutable.HashMap[Int, Int]()\n        val xorResult30 = new\
    \ mutable.HashMap[In\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpom7l2fg1.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ']' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpom7l2fg1.scala:10:22\
    \ ------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e\
    [36mxor\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mInt\e[0m, \e[35mInt\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpom7l2fg1.scala:11:28 ------------------------\e[0m\e\
    [0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorResult\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mInt\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m \
    \                           ^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \        Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpom7l2fg1.scala:12:29 ------------------------\e[0m\e[0m\n\e[31m12 |\e\
    [0m        \e[33mval\e[0m \e[36mxorResult2\e[0m = \e[33mnew\e[0m mutable.HashMap[\e\
    [35mInt\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                       \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                             Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpom7l2fg1.scala:13:29\
    \ ------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e\
    [36mxorResult3\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mInt\e[0m, \e[35mInt\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                             Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpom7l2fg1.scala:14:29 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mxorResult4\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mInt\e"
  stdout: ''
  timestamp: 1659978771
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val result = aList.zip(bList).map(x =>\
    \ x._1 ^ x._2).mkString(\"\")\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978772
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aBits = a.toIntArray\n\
    \        val bBits = b.toIntArray\n        val xorBits = Array.ofDim[Int](Math.max(aBits.length,\
    \ bBits.length))\n        var i = 0\n        while (i < xorBits.length) {\n  \
    \          xorBits(i) = aBits(i) xor bBits(i)\n            i += 1\n        }\n\
    \        xorBits.toString.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4hgqdoy1.scala:7:22 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp4hgqdoy1.scala:8:22 -------------------------\e[0m\e\
    [0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m      \
    \              value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659978771
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Int](a.length)\n\
    \        var xor = 0\n        for (i <- 0 until xorArray.length) {\n         \
    \   xor = xor + (aArray(i) xor bArray(i))\n        }\n        xor.toString\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpn68z_i72.scala:12:35 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            xor = xor + (aArray(i) xor bArray(i))\n\e\
    [31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                         value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659978772
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aBits = a.toIntArray\n\
    \        val bBits = b.toIntArray\n        val xorBits = Array.ofDim[Int](8)\n\
    \        val xorBitsLen = xorBits.length\n        val xorBitsLenBits = xorBitsLen\
    \ / 8\n        val xorBitsLenBytes = xorBitsLen % 8\n        val xorBitsLenBytesBits\
    \ = xorBitsLenBytes / 8\n        val xorBitsLenBytesBitsBits = xorBitsLenBytesBits\
    \ / 8\n        val xorBitsLenBytesBitsBitsBits = xorBitsLenBytesBitsBits / 8\n\
    \        val xorBitsLenBytesBitsBitsBitsBits = xorBitsLenBytesBitsBitsBits / 8\n\
    \        val xorBitsLenBytesBitsBitsBitsBitsBits = xorBitsLenBytesBitsBitsBitsBits\
    \ / 8\n        val xorBitsLenBytesBitsBitsBitsBitsBitsBits = xorBitsLenBytesBitsBitsBitsBitsBits\
    \ / 8\n        val xorBitsLenBytesBitsBitsBitsBitsBitsBitsBits = xorBitsLenBytesBitsBitsBitsBitsBits\
    \ / 8\n        val xorBitsLenBytesBitsBitsBitsBitsBitsBitsBitsBits = xorBitsLenBytesBitsBitsBitsBitsBits\
    \ / 8\n        val xorBitsLenBytesBitsBitsBitsBitsBitsBitsBitsBits = xorBitsLenBytesBitsBitsBitsBitsBits\
    \ / 8\n        val xorBitsLenBytesBitsBitsBitsBitsBitsBitsBitsBitsBits = xorBitsLenBytesBitsBitsBitsBitsBits\
    \ / 8\n        val xorBitsLenBytesBitsBitsBitsBitsBitsBitsBitsBitsBits = xorBitsLenBytesBitsBitsBitsBitsBits\
    \ / 8\n        val xorBitsLenBytesBitsBitsBitsBitsBitsBitsBitsBitsBitsBits = xorBitsLenBytesBitsBitsBitsBits\
    \ / 8\n        val xorBitsLenBytesBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBits\
    \ = xorBitsLenBytesBitsBit\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"\
    1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp924hk730.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mxorBitsLenBytesBitsBitsBitsBitsBitsBitsBitsBits\e\
    [0m = xorBitsLenBytesBitsBitsBitsBitsBits / \e[31m8\e[0m\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorBitsLenBytesBitsBitsBitsBitsBitsBitsBitsBits is already\
    \ defined as \e[33mvalue\e[0m \e[35mxorBitsLenBytesBitsBitsBitsBitsBitsBitsBitsBits\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp924hk730.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mxorBitsLenBytesBitsBitsBitsBitsBitsBitsBitsBitsBits\e\
    [0m = xorBitsLenBytesBitsBitsBitsBitsBits / \e[31m8\e[0m\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorBitsLenBytesBitsBitsBitsBitsBitsBitsBitsBitsBits is already\
    \ defined as \e[33mvalue\e[0m \e[35mxorBitsLenBytesBitsBitsBitsBitsBitsBitsBitsBitsBits\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp924hk730.scala:7:22 -------------------------\e[0m\e[0m\n\
    \e[31m7 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\e[31m\e\
    [31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m            \
    \        value toIntArray is not a member of String\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp924hk730.scala:8:22 -------------------------\e[0m\e[0m\n\
    \e[31m8 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e[31m\e\
    [31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m            \
    \        value toIntArray is not a member of String\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmp924hk730.scala:25:74 ------------------------\e[0m\e[0m\n\
    \e[31m25 |\e[0m        \e[33mval\e[0m \e[36mxorBitsLenBytesBitsBitsBitsBitsBitsB"
  stdout: ''
  timestamp: 1659978773
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Char](b.length)\n\
    \        val xorArrayIndex = 0\n        for (i <- 0 until a.length) {\n      \
    \      xorArray(xorArrayIndex) = aArray(i) xor bArray(i)\n            xorArrayIndex\
    \ += 1\n        }\n        xorArray.toString.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9d9hpblt.scala:12:48 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            xorArray(xorArrayIndex) = aArray(i) xor bArray(i)\n\
    \e[31m\e[31m   |\e[0m                                      ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                      value xor is not a member\
    \ of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9d9hpblt.scala:13:26\
    \ ------------------------\e[0m\e[0m\n\e[31m13 |\e[0m            xorArrayIndex\
    \ += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m        value += is not a member of Int - did you mean xorArrayIndex.!=?\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659978774
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Char](b.length)\n\
    \        for(i <- 0 until xorArray.length)\n            xorArray(i) = (if (aArray(i)\
    \ XOR bArray(i) == 1) '1' else '0')\n        new String(xorArray)\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpl6pis4lh.scala:11:41 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m            xorArray(i) = (\e[33mif\e[0m (aArray(i) XOR\
    \ bArray(i) == \e[31m1\e[0m) \e[31m'1'\e[0m \e[33melse\e[0m \e[31m'0'\e[0m)\n\e\
    [31m\e[31m   |\e[0m                               ^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                               value XOR is not a member of Char\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978773
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n\
    \        aList.zip(bList).foreach { case (aChar, bChar) =>\n            xorList\
    \ += aChar ^ bChar\n        }\n        xorList.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3axa6zs0.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978767
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = mutable.ArrayBuffer.empty[Int]\n\
    \        var xor = 0\n        for (i <- 0 until aArray.length)\n            xor\
    \ = xor + aArray(i) xor bArray(i)\n        xor.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpoenyvn_j.scala:9:23 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m  |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                       Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpoenyvn_j.scala:12:34 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            xor = xor + aArray(i) xor bArray(i)\n\e[31m\e\
    [31m   |\e[0m                  ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \             value xor is not a member of Int\n2 errors found\n"
  stdout: ''
  timestamp: 1659978774
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Char](b.length)\n\
    \        for(i <- 0 until xorArray.length)\n            xorArray(i) = aArray(i)\
    \ xor bArray(i)\n        new String(xorArray)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbk21ti4w.scala:11:36 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659978707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aBits = a.toIntArray\n\
    \        val bBits = b.toIntArray\n        val xorBits = Array.ofDim[Int](8)\n\
    \        val xorBitsLen = xorBits.length\n        val xorBitsLenInBits = xorBitsLen\
    \ / 8\n        val xorBitsLenInBytes = xorBitsLenInBits / 8\n        val xorBitsLenInBytesInBits\
    \ = xorBitsLenInBytes * 8\n        val xorBitsLenInBytesInBitsInBytes = xorBitsLenInBytesInBits\
    \ / 8\n        val xorBitsLenInBytesInBitsInBytesInBits = xorBitsLenInBytesInBitsInBytes\
    \ * 8\n        val xorBitsLenInBytesInBitsInBytesInBitsInBytes = xorBitsLenInBytesInBitsInBytesInBits\
    \ / 8\n        val xorBitsLenInBytesInBitsInBytesInBitsInBytesInBits = xorBitsLenInBytesInBitsInBytesInBitsInBytes\
    \ * 8\n        val xorBitsLenInBytesInBitsInBytesInBitsInBytesInBitsInBytes =\
    \ xorBitsLenInBytesInBitsInBytesInBitsInBytesInBits / 8\n        val xorBitsLenInBytesInBitsInBytesInBitsInBytesInBitsInBytesInBits\
    \ = xorBitsLenInBytesInBitsInBytesInBitsInBytesInBitsInBytes * 8\n        val\
    \ xorBitsLenInBytesInBitsInBytesInBitsInBytesInBitsInBytesInBitsInBytes = xorBitsLenInBytesInBitsInBytesInBitsInBytesInBitsInBytesInBitsInBytes\
    \ * 8\n        val xorBitsLenInBytesInBitsInBytesInBitsInBytesInBitsInBytesInBitsInBytesInBits\
    \ = xorBitsLenInBytesInBitsInBytesInBitsInBytesInBitsInBytesInBitsInBytes * 8\n\
    \        val xorBitsLenInBytesInBitsInBytesInBitsInBytesInBitsInBytesInBitsInBytesInBitsInBytes\
    \ = xorBitsLenInBytesInBitsInBytesInBitsInBytesInBitsInBytesInBitsInBytesInBitsInBytes\
    \ * 8\n        val xorBitsLenInBytesInBitsInBytesInBitsInBytesInBitsInBytesInBitsInBytesInBitsInBytesInBitsInBytes\
    \ = xorBitsLenInBytesInBitsInBytesInBitsInBytesInBitsIn\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpuwe5_5v5.scala:7:22 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpuwe5_5v5.scala:8:22 -------------------------\e[0m\e\
    [0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m      \
    \              value toIntArray is not a member of String\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmpuwe5_5v5.scala:20:84 ---------------------------\e[0m\e\
    [0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mxorBitsLenInBytesInBitsInBytesInBitsInBytesInBitsInBytesInBitsInBytes\e\
    [0m = xorBitsLenInBytesInBitsInBytesInBitsInBytesInBitsInBytesInBitsInBytes *\
    \ \e[31m8\e[0m\n\e[31m\e[31m   |\e[0m                                        \
    \                                            ^\e[0m\n\e[31m   |\e[0mRecursive\
    \ \e[33mvalue\e[0m \e[35mxorBitsLenInBytesInBitsInBytesInBitsInBytesInBitsInBytesInBitsInBytes\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpuwe5_5v5.scala:22:97\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mxorBitsLenInBytesInBitsInBytesInBitsInBytesInBitsInBytesInBitsInBytesInBitsInBytes\e\
    [0m = xorBitsLenInBytesInBitsInBytesInBitsInBytesInBitsInBytesInBitsInBytesInBitsInBytes\
    \ * \e[31m8\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \                                                           ^\e[0m\n\e[31m   |\e\
    [0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  xorBitsLenInBytesInBitsInBytesInBitsInBytesInBitsInBytesInBitsInBytesInBitsInBytes\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpuwe5_5v5.scala:23:110 -----------------------\e[0m\e[0m\n\e[31m23 |\e\
    [0m        \e[33mval\e[0m \e[36mxorB"
  stdout: ''
  timestamp: 1659978775
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n\
    \        val bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n\
    \        aList.zip(bList).foreach { case (aChar, bChar) =>\n            xorList\
    \ += aChar ^ bChar\n        }\n        xorList.toString.reverse\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0opnk15q.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978773
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Char](b.length)\n\
    \        var xor = 0\n        for (i <- 0 until xorArray.length)\n           \
    \ xor = xor + aArray(i) xor bArray(i)\n        xorArray.toString.reverse\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"),\
    \ (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpv_op9h9j.scala:12:34 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            xor = xor + aArray(i) xor bArray(i)\n\e[31m\e\
    [31m   |\e[0m                  ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \             value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659978750
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = Array.ofDim[Int](2)\n\
    \        val xorArray2 = Array.ofDim[Int](2)\n        val xorArray3 = Array.ofDim[Int](2)\n\
    \        val xorArray4 = Array.ofDim[Int](2)\n        val xorArray5 = Array.ofDim[Int](2)\n\
    \        val xorArray6 = Array.ofDim[Int](2)\n        val xorArray7 = Array.ofDim[Int](2)\n\
    \        val xorArray8 = Array.ofDim[Int](2)\n        val xorArray9 = Array.ofDim[Int](2)\n\
    \        val xorArray10 = Array.ofDim[Int](2)\n        val xorArray11 = Array.ofDim[Int](2)\n\
    \        val xorArray12 = Array.ofDim[Int](2)\n        val xorArray13 = Array.ofDim[Int](2)\n\
    \        val xorArray14 = Array.ofDim[Int](2)\n        val xorArray15 = Array.ofDim[Int](2)\n\
    \        val xorArray16 = Array.ofDim[Int](2)\n        val xorArray17 = Array.ofDim[Int](2)\n\
    \        val xorArray18 = Array.ofDim[Int](2)\n        val xorArray19 = Array.ofDim[Int](2)\n\
    \        val xorArray20 = Array.ofDim[Int](2)\n        val xorArray21 = Array.ofDim[Int](2)\n\
    \        val xorArray22 = Array.ofDim[Int](2)\n        val xorArray23 = Array.ofDim[Int](2)\n\
    \        val xorArray24 = Array.ofDim[Int](2)\n        val xorArray25 = Array.ofDim[Int](2)\n\
    \        val xorArray26 = Array.ofDim[Int](2)\n        val xorArray27 = Array.ofDim[Int](2)\n\
    \        val xorArray28 = Array.ofDim[Int](2)\n        val xorArray29 = Array.ofDim[Int](2)\n\
    \        val xorArray30 = Array.ofDim[Int](2)\n        val xorArray31 = Array.ofDim[Int](2)\n\
    \        val xorArray32 = Array.ofDim[Int](2)\n        val xorArray33 = Array.ofDim[Int](2)\n\
    \        val xorArray34 = Array.ofDim[Int](2)\n        val xorArray35 = Array.ofDim[Int](2)\n\
    \        val xorArray\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9xc0aymq.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp9xc0aymq.scala:45:5 ---------------------\e[0m\e[0m\n\e[31m45 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Char](b.length)\n\
    \        for(i <- 0 until xorArray.length){\n            xorArray(i) = aArray(i)\
    \ ^ bArray(i)\n        }\n        xorArray.toString.toUpperCase\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp63bw8zrr.scala:11:26\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m            xorArray(i) = aArray(i)\
    \ ^ bArray(i)\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          Found:    Int\n\e[31m   |\e[0m \
    \                         Required: Char\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978775
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aBits = a.toIntArray\n\
    \        val bBits = b.toIntArray\n        val xorBits = Array.ofDim[Int](Math.max(aBits.length,\
    \ bBits.length))\n        val xorBitsIndex = 0\n        for (i <- 0 until aBits.length)\
    \ xorBits(xorBitsIndex) = aBits(i) xor bBits(i)\n        val xorBitsString = xorBits.mkString(\"\
    \")\n        val xorBitsStringLength = xorBitsString.length\n        val xorBitsStringBuilder\
    \ = new StringBuilder(xorBitsStringLength)\n        for (i <- 0 until xorBitsStringLength)\
    \ xorBitsStringBuilder.append(xorBitsString(i))\n        xorBitsStringBuilder.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpu5bgqhfl.scala:7:22 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpu5bgqhfl.scala:8:22 -------------------------\e[0m\e\
    [0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m      \
    \              value toIntArray is not a member of String\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpu5bgqhfl.scala:16:29 --------------------\e[0m\e\
    [0m\n\e[31m16 |\e[0m        xorBitsStringBuilder.reverse\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    StringBuilder\n\
    \e[31m   |\e[0m        Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659978776
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Char](aArray.length)\n\
    \        for(i <- 0 until xorArray.length) xorArray(i) = aArray(i) xor bArray(i)\n\
    \        new String(xorArray)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmxmyxvu_.scala:10:66 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mfor\e[0m(i <- \e[31m0\e[0m until xorArray.length)\
    \ xorArray(i) = aArray(i) xor bArray(i)\n\e[31m\e[31m   |\e[0m               \
    \                                         ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                       value xor is not a member of Char\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978775
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toCharArray.map(_.toInt)\n\
    \        val bList = b.toCharArray.map(_.toInt)\n        val xorList = mutable.ListBuffer.empty[Int]\n\
    \        for (aIndex <- 0 until aList.length) {\n            for (bIndex <- 0\
    \ until bList.length) {\n                xorList += (a(aIndex) ^ b(bIndex))\n\
    \            }\n        }\n        xorList.toString.toCharArray\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx6jbmgu0.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978774
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val result = new mutable.ArrayBuffer(a.length)\n\
    \        var i = 0\n        while (i < a.length) {\n            result(i) = aArray(i)\
    \ xor bArray(i)\n            i += 1\n        }\n        new String(result.toArray)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp68iwddb2.scala:9:25 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ArrayBuffer(a.length)\n\e[31m\e[31m  |\e[0m                      \
    \   ^^^^^^^\e[0m\n\e[31m  |\e[0m                         Not found: mutable\n\e\
    [31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978774
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aList = a.toCharArray.map(_.toInt)\n\
    \        val bList = b.toCharArray.map(_.toInt)\n        val xorList = mutable.ListBuffer.empty[Int]\n\
    \        for(i <- 0 until aList.length) xorList += (aList(i) xor bList(i))\n \
    \       xorList.toString.reverse\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4ov8xhsc.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978775
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = aArray.zip(Array.fill(aArray.length)(0)).zip(bArray.zip(Array.fill(bArray.length)(0)))\n\
    \            .map(x => x._1 ^ x._2)\n            .map(x => x.toChar)\n       \
    \ new String(xorArray)\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpspxgewg_.scala:10:27 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m            .map(x => x._1 ^ x._2)\n\e[31m\e[31m   |\e\
    [0m                      ^^^^^^\e[0m\n\e[31m   |\e[0m                      value\
    \ ^ is not a member of (Int, Int)\n\e[31m\e[31m-- Error: /tmp/tmpspxgewg_.scala:10:34\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m10 |\e[0m       \
    \     .map(x => x._1 ^ x._2)\n\e[31m\e[31m   |\e[0m                          \
    \        ^\e[0m\n\e[31m   |\e[0m                                  No ClassTag\
    \ available for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m                          \
    \        where:    B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1659978776
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val xorArray = new Array[Int](a.length)\n\
    \        var xor = 0\n        for (i <- 0 until xorArray.length)\n           \
    \ xorArray(i) = aArray(i) xor bArray(i)\n        val xorString = new StringBuilder\n\
    \        for (i <- 0 until xorArray.length)\n            xorString.append(xorArray(i))\n\
    \        xorString.toString\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"\
    1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp18u8ct9m.scala:12:36 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659978775
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n\
    \        val bArray = b.toCharArray\n        val result = new StringBuilder\n\
    \        var carry = 0\n        for (i <- 0 until aArray.length) {\n         \
    \   val aChar = aArray(i)\n            val bChar = bArray(i)\n            val\
    \ xor = aChar ^ bChar\n            val newCarry = xor & carry\n            carry\
    \ = newCarry >> 1\n            result.append(newCarry)\n        }\n        if\
    \ (carry != 0) {\n            result.append(carry)\n        }\n        return\
    \ result.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsc8c02i_.scala:25)\n\tat Problem.main(tmpsc8c02i_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978776
