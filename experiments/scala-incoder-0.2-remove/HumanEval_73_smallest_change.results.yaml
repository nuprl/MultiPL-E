language: scala
name: HumanEval_73_smallest_change
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val result = new Array[Long](n)\n        var\
    \ i = 0\n        var j = 0\n        var k = 0\n        var minChange = 0\n   \
    \     var maxChange = 0\n        while (i < n && j < n) {\n            if (arr(i)\
    \ < arr(j)) {\n                result(i) = arr(i)\n                i += 1\n  \
    \          } else {\n                result(j) = arr(j)\n                j +=\
    \ 1\n            }\n        }\n        val maxChange = i - 1\n        val minChange\
    \ = j - 1\n        while (i < n) {\n            if (arr(i) < arr(j)) {\n     \
    \           result(i) = arr(i)\n                i += 1\n            } else {\n\
    \                result(j) = arr(j)\n                j += 1\n            }\n \
    \       }\n        val maxChange = i - 1\n        val minChange = j - 1\n    \
    \    if (maxChange < minChange) {\n            minChange = maxChange\n       \
    \ }\n        if (minChange > maxChange) {\n            maxChange = minChange\n\
    \        }\n        if (maxChange == minChange) {\n            minChange = 0\n\
    \        }\n        if (minChange == 0) {\n            minChange = 1\n       \
    \ }\n        if (minChange == 1) {\n            minChange = 2\n        }\n   \
    \     if (minChange == 2) {\n            minChange = 3\n        }\n        if\
    \ (minChange == 3) {\n            minChange = 4\n        }\n        if (minChange\
    \ == 4) {\n            minChange = 5\n        }\n        if (minChange == 5) {\n\
    \            minChange = 6\n        }\n        if (minChange == 6) {\n       \
    \     minChange = 7\n        }\n        if (minChange == 7) {\n            minChange\
    \ = 8\n        }\n        if (minChange == 8) {\n            minChange = 9\n \
    \       }\n        if (minChange == 9) {\n            minChange = 10\n       \
    \ }\n        if (minChange == 10) {\n            minChange = 11\n        }\n \
    \       if (minChange == 11) {\n            minChange = 12\n        }\n      \
    \  if (minChange == 12) {\n            minChange = 13\n        }\n        if (minChange\
    \ == 13) {\n            minChange = 14\n        }\n        if (minChange == 14)\
    \ {\n            minChange = 15\n        }\n        if (minChange == 15) {\n \
    \           minChange = 16\n        }\n        if (minChange == 16) {\n      \
    \      minChange = 17\n        }\n        if (minChange == 17) {\n           \
    \ minChange = 18\n        }\n        if (minChange == 18) {\n            minChange\
    \ = 19\n        }\n        if (minChange == 19) {\n            minChange = 20\n\
    \        }\n        if (minChange == 20) {\n            minChange = 21\n     \
    \   }\n        if (minChange == 21) {\n            \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnyq_600y.scala:126:0 ---------------------------\e\
    [0m\e[0m\n\e[31m126 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnyq_600y.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxChange\e[0m = i - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxChange is already defined as \e[33mvariable\e[0m \e[35mmaxChange\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpnyq_600y.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36mminChange\e[0m = j - \e[31m1\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mminChange\
    \ is already defined as \e[33mvariable\e[0m \e[35mminChange\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnyq_600y.scala:37:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxChange\e[0m = i - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxChange is already defined as \e[33mvariable\e[0m \e[35mmaxChange\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpnyq_600y.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36mminChange\e[0m = j - \e[31m1\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mminChange\
    \ is already defined as \e[33mvariable\e[0m \e[35mminChange\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnyq_600y.scala:125:1\
    \ --------------------\e[0m\e[0m\n\e[31m125 |\e[0m}\n\e[31m\e[31m    |\e[0m ^\e\
    [0m\n\e[31m    |\e[0m Found:    Unit\n\e[31m    |\e["
  stdout: ''
  timestamp: 1660010354
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val palindromic = arr.toSet.toList\n        val changes = mutable.HashSet[Long]()\n\
    \        val change = mutable.HashMap[Long, Long]()\n        val changed = mutable.HashSet[Long]()\n\
    \        val changeCount = 0\n        val changeCounts = mutable.HashMap[Long,\
    \ Long]()\n        val changeCountMap = mutable.HashMap[Long, Long]()\n      \
    \  val changeCountMap2 = mutable.HashMap[Long, Long]()\n        val changeCountMap3\
    \ = mutable.HashMap[Long, Long]()\n        val changeCountMap4 = mutable.HashMap[Long,\
    \ Long]()\n        val changeCountMap5 = mutable.HashMap[Long, Long]()\n     \
    \   val changeCountMap6 = mutable.HashMap[Long, Long]()\n        val changeCountMap7\
    \ = mutable.HashMap[Long, Long]()\n        val changeCountMap8 = mutable.HashMap[Long,\
    \ Long]()\n        val changeCountMap9 = mutable.HashMap[Long, Long]()\n     \
    \   val changeCountMap10 = mutable.HashMap[Long, Long]()\n        val changeCountMap11\
    \ = mutable.HashMap[Long, Long]()\n        val changeCountMap12 = mutable.HashMap[Long,\
    \ Long]()\n        val changeCountMap13 = mutable.HashMap[Long, Long]()\n    \
    \    val changeCountMap14 = mutable.HashMap[Long, Long]()\n        val changeCountMap15\
    \ = mutable.HashMap[Long, Long]()\n        val changeCountMap16 = mutable.HashMap[Long,\
    \ Long]()\n        val changeCountMap17 = mutable.HashMap[Long, Long]()\n    \
    \    val changeCountMap18 = mutable.HashMap[Long, Long]()\n        val changeCountMap19\
    \ = mutable.HashMap[Long, Long]()\n        val changeCountMap20 = mutable.HashMap[Long,\
    \ Long]()\n        val changeCountMap21 = mutable.HashMap[Long, Long]()\n    \
    \    val changeCountMap22 = mutable.HashMap[Long, Long]()\n        val changeCountMap23\
    \ = mutable.HashMap[Long, Long]()\n        val changeCountMap24 = mutable.HashMap[Long,\
    \ Long]()\n        val changeCountMap25 = mutable.HashMap[Long, Long]()\n    \
    \    val changeCountMap26 = mutable.HashMap[Long, Long]()\n        val change\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpb6tpmiog.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb6tpmiog.scala:11:22\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mchanges\e[0m = mutable.HashSet[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m \
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb6tpmiog.scala:12:21\
    \ ------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e\
    [36mchange\e[0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpb6tpmiog.scala:13:22 ------------------------\e[0m\e[0m\n\e[31m13 |\e\
    [0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.HashSet[\e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpb6tpmiog.scala:15:27 ------------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mchangeCounts\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                           Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb6tpmiog.scala:16:29\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mchangeCountMap\e[0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    "
  stdout: ''
  timestamp: 1660010352
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val changes = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeCount = mutable.ArrayBuffer.empty[Long]\n        val changeCounts\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMax = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeCountMaxs = mutable.ArrayBuffer.empty[Long]\n        val changeCountMin\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMins = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeCountMinMax = mutable.ArrayBuffer.empty[Long]\n        val\
    \ changeCountMinMaxs = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMin\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMins = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeCountMinMaxMinMax = mutable.ArrayBuffer.empty[Long]\n     \
    \   val changeCountMinMaxMinMaxs = mutable.ArrayBuffer.empty[Long]\n        val\
    \ changeCountMinMaxMinMaxMin = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMinMaxMins\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMinMaxMinMax\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMinMaxMinMaxs\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMinMaxMinMaxMax\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMinMaxMinMaxMaxs\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMinMaxMinMaxMaxMax\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMinMaxMinMaxMaxMaxs\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMinMaxMinMaxMaxMaxMax\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMinMaxMinMaxMaxMaxMaxs\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMinMaxMinMaxMaxMaxMaxMax\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMinMaxMinMaxMaxMaxMaxs\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMinMaxMinMaxMaxMaxMaxMax\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpmmg8db2k.scala:38:55 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mchangeCountMinMaxMinMaxMinMaxMaxMaxMaxMax\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                                \
    \       ^\e[0m\n\e[31m   |\e[0m                                       expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpmmg8db2k.scala:37:12 ---------------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m        \e[33mval\e[0m \e[36mchangeCountMinMaxMinMaxMinMaxMaxMaxMaxs\e\
    [0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchangeCountMinMaxMinMaxMinMaxMaxMaxMaxs is already defined\
    \ as \e[33mvalue\e[0m \e[35mchangeCountMinMaxMinMaxMinMaxMaxMaxMaxs\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpmmg8db2k.scala:11:22 ------------------------\e[0m\e[0m\n\e[31m11 |\e\
    [0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e\
    [0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpmmg8db2k.scala:12:22 ------------------------\e[0m\e\
    [0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpmmg8db2k.scala:13:21 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^"
  stdout: ''
  timestamp: 1660010353
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val changes = mutable.ArrayBuffer.empty[Long]\n\
    \        var i = 0\n        var j = 0\n        while (i < n / 2 && j < n) {\n\
    \            if (arr(i) == arr(j)) {\n                changes += (arr(i) - m)\n\
    \                i += 1\n                j += 1\n            } else if (arr(i)\
    \ > arr(j)) {\n                changes += (arr(j) - m)\n                j += 1\n\
    \            } else {\n                changes += (arr(i) - m)\n             \
    \   i += 1\n            }\n        }\n        changes.min\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpq1c0iiiy.scala:11:18 ---------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpq1c0iiiy.scala:12:22 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010350
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.last\n        val result = new Array[Long](n)\n        var\
    \ i = 0\n        var j = 0\n        var k = 0\n        var minChange = 0\n   \
    \     var maxChange = 0\n        var maxChangeIndex = 0\n        var minChangeIndex\
    \ = 0\n        var change = 0\n        while (i < n) {\n            while (j <\
    \ n) {\n                if (arr(i) == arr(j)) {\n                    k++\n   \
    \                 j++\n                }\n                else {\n           \
    \         k = 0\n                    j++\n                }\n            }\n \
    \           change = k\n            minChange = change\n            maxChange\
    \ = change\n            maxChangeIndex = i\n            minChangeIndex = j\n \
    \           while (j < n) {\n                if (arr(i) != arr(j)) {\n       \
    \             change = change + 1\n                    j++\n                }\n\
    \                else {\n                    j++\n                }\n        \
    \    }\n            if (change < minChange) {\n                minChange = change\n\
    \                minChangeIndex = i\n            }\n            if (change > maxChange)\
    \ {\n                maxChange = change\n                maxChangeIndex = i\n\
    \            }\n            i += 1\n        }\n        if (maxChange < minChange)\
    \ {\n            return minChange\n        }\n        else {\n            return\
    \ maxChange\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpiobiehps.scala:24:23 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpiobiehps.scala:28:23 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpiobiehps.scala:39:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m                    j++\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E018] Syntax Error: /tmp/tmpiobiehps.scala:42:23 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpiobiehps.scala:23:21 ------------------------\e[0m\e[0m\n\e[31m23 |\e\
    [0m                    k++\n\e[31m\e[31m   |\e[0m                    ^^^\e[0m\n\
    \e[31m   |\e[0m                    value ++ is not a member of Int\n5 errors found\n"
  stdout: ''
  timestamp: 1660010353
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val arr = arr.sortBy(_).reverse\n        val changes = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeIndex = mutable.ArrayBuffer.empty[Int]\n        val changeIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        var i = 0\n        var j = 0\n   \
    \     var k = 0\n        while (i < n) {\n            if (arr(i) == arr(n)) {\n\
    \                changeIndex += i\n                changeIndex += n\n        \
    \        changes += arr(i)\n                changes += arr(n)\n              \
    \  changes += arr(n - 1)\n                changes += arr(n - 2)\n            \
    \    changes += arr(n - 3)\n                changes += arr(n - 4)\n          \
    \      changes += arr(n - 5)\n                changes += arr(n - 6)\n        \
    \        changes += arr(n - 7)\n                changes += arr(n - 8)\n      \
    \          changes += arr(n - 9)\n                changes += arr(n - 10)\n   \
    \             changes += arr(n - 11)\n                changes += arr(n - 12)\n\
    \                changes += arr(n - 13)\n                changes += arr(n - 14)\n\
    \                changes += arr(n - 15)\n                changes += arr(n - 16)\n\
    \                changes += arr(n - 17)\n                changes += arr(n - 18)\n\
    \                changes += arr(n - 19)\n                changes += arr(n - 20)\n\
    \                changes += arr(n - 21)\n                changes += arr(n - 22)\n\
    \                changes += arr(n - 23)\n                changes += arr(n - 24)\n\
    \                changes += arr(n - 25)\n                changes += arr(n - 26)\n\
    \                changes += arr(n - 27)\n                changes += arr(n - 28)\n\
    \                changes += arr(n - 29)\n                changes += arr(n - 30)\n\
    \                changes += arr(n - 31)\n                changes += arr(n - 32)\n\
    \                changes += arr(n - 33)\n                changes += arr(n - 34)\n\
    \                changes += arr(n - 35)\n                changes += arr(n - 36)\n\
    \                changes += arr(n - 37)\n                changes += arr(n - 38)\n\
    \                changes += arr(n - 39)\n                changes += arr(n - 40)\n\
    \                changes += arr(n - 41)\n                changes += arr(n - 42)\n\
    \                changes += arr(n - 43)\n                changes += arr(n - 44)\n\
    \                changes += arr(n - 45)\n                changes += arr(n - \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp3vxwqsf8.scala:70:34 ---------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m                changes += arr(n - \n\e[31m\e[31m   |\e\
    [0m                                  ^\e[0m\n\e[31m   |\e[0m                 \
    \                 expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E040] Syntax Error: /tmp/tmp3vxwqsf8.scala:84:0 ----------------------------\e\
    [0m\e[0m\n\e[31m84 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3vxwqsf8.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mchangeIndex\e[0m = mutable.ArrayBuffer.empty[\e[35mInt\e[0m]\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mchangeIndex is already defined as \e[33mvalue\e[0m \e[35mchangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E081] Type\
    \ Error: /tmp/tmp3vxwqsf8.scala:10:29 -----------------------------\e[0m\e[0m\n\
    \e[31m10 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$1 of expanded function:\n\e[31m   |\e[0m   _$1 => arr.sortBy(_$1).reverse.\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp3vxwqsf8.scala:10:18 ---------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp3vxwqsf8.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m         "
  stdout: ''
  timestamp: 1660010350
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val changes = mutable.ListBuffer[Long]()\n\
    \        var i = 0\n        var j = 0\n        while(i < arr.length && j < arr.length)\
    \ {\n            if(arr(i) == arr(j)) {\n                i += 1\n            \
    \    j += 1\n            } else {\n                changes += (arr(i) - arr(j))\n\
    \                i += 1\n                j += 1\n            }\n        }\n  \
    \      changes.min\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkfwqdtno.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010350
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val changes = mutable.ArrayBuffer.empty[Long]\n\
    \        var i = 0\n        var j = 0\n        while (i < n && j < m) {\n    \
    \        if (arr(i) < arr(j)) {\n                changes += arr(i)\n         \
    \       i += 1\n            } else {\n                changes += arr(j)\n    \
    \            j += 1\n            }\n        }\n        if (i < n) {\n        \
    \    changes += arr(i)\n        }\n        if (j < m) {\n            changes +=\
    \ arr(j)\n        }\n        changes.min\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpbjbsdtkb.scala:11:18 ---------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpbjbsdtkb.scala:12:22 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010349
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val m = arr.length\n\
    \        val n = arr.head\n        val arr = arr.tail\n        val changes = mutable.ArrayBuffer.empty[Long]\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var k1 = n -\
    \ 1\n        var k2 = n - 1\n        while (i < m && j < n) {\n            if\
    \ (arr(i) == arr(j)) {\n                changes += k\n                i += 1\n\
    \                j += 1\n                k += 1\n            } else if (arr(i)\
    \ < arr(j)) {\n                i += 1\n                k += 1\n            } else\
    \ {\n                j += 1\n                k1 -= 1\n                k2 -= 1\n\
    \            }\n        }\n        if (i < m) {\n            changes += k\n  \
    \      }\n        if (j < n) {\n            changes += k1\n        }\n       \
    \ if (k < k1) {\n            changes += k2\n        }\n        changes.min\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpgn06xcya.scala:11:18 ---------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpgn06xcya.scala:12:22 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010350
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val result = new Array[Long](n)\n        val\
    \ changes = new Array[Long](n)\n        var i = 0\n        var j = 0\n       \
    \ var k = 0\n        var change = 0\n        var changeCount = 0\n        var\
    \ changeIndex = 0\n        var isChange = false\n        var isChanged = false\n\
    \        var isChangeIndex = 0\n        var isChanged = false\n        var isChangeIndex\
    \ = 0\n        var isChanged = false\n        var isChangeIndex = 0\n        var\
    \ isChanged = false\n        var isChangeIndex = 0\n        var isChanged = false\n\
    \        var isChangeIndex = 0\n        var isChanged = false\n        var isChangeIndex\
    \ = 0\n        var isChanged = false\n        var isChangeIndex = 0\n        var\
    \ isChanged = false\n        var isChangeIndex = 0\n        var isChanged = false\n\
    \        var isChangeIndex = 0\n        var isChanged = false\n        var isChangeIndex\
    \ = 0\n        var isChanged = false\n        var isChangeIndex = 0\n        var\
    \ isChanged = false\n        var isChangeIndex = 0\n        var isChanged = false\n\
    \        var isChangeIndex = 0\n        var isChanged = false\n        var isChangeIndex\
    \ = 0\n        var isChanged = false\n        var isChangeIndex = 0\n        var\
    \ isChanged = false\n        var isChangeIndex = 0\n        var isChanged = false\n\
    \        var isChangeIndex = 0\n        var isChanged = false\n        var isChangeIndex\
    \ = 0\n        var isChanged = false\n        var isChangeIndex = 0\n        var\
    \ isChanged = false\n        var isChangeIndex = 0\n        var isChanged = false\n\
    \        var isChangeIndex = 0\n        var isChanged = false\n        var isChangeIndex\
    \ = 0\n        var isChanged = false\n        var isChangeIndex = 0\n        var\
    \ isChanged = false\n        var isChangeIndex = 0\n        var isChanged = false\n\
    \        var isChangeIndex = 0\n        var isChanged = false\n        var isChangeIndex\
    \ = 0\n        var isChanged = false\n        var isChangeIndex = 0\n        var\
    \ isChanged = false\n        var isChangeIndex = 0\n        var isChanged = false\n\
    \        var isChangeIndex = 0\n        var isChanged = false\n        var isChangeIndex\
    \ = 0\n        var isChanged = false\n        var isChangeIndex = 0\n        var\
    \ isChanged = false\n        var isChangeIndex = 0\n        var isChanged = false\n\
    \        var isChangeIndex = 0\n        var isChanged = false\n        var isChangeIndex\
    \ = 0\n        var isChanged = false\n        var isChangeIndex = 0\n        var\
    \ isChanged = false\n        var isChangeIndex = 0\n        var isChanged = false\n\
    \        var isChangeIndex = 0\n        var isChanged = false\n\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpok0o1ddz.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mvar\e[0m \e[36misChanged\e[0m = \e[31mfalse\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0misChanged\
    \ is already defined as \e[33mvariable\e[0m \e[35misChanged\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpok0o1ddz.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mvar\e[0m\
    \ \e[36misChangeIndex\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misChangeIndex is already defined as \e[33mvariable\e[0m \e\
    [35misChangeIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpok0o1ddz.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mvar\e[0m \e[36misChanged\e[0m = \e[31mfalse\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0misChanged\
    \ is already defined as \e[33mvariable\e[0m \e[35misChanged\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpok0o1ddz.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mvar\e[0m\
    \ \e[36misChangeIndex\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misChangeIndex is already defined as \e[33mvariable\e[0m \e\
    [35misChangeIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpok0o1ddz.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mvar\e[0m \e[36misChanged\e[0m = \e[31mfalse\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0misChanged\
    \ is already defined as \e[33mvariable\e[0m \e[35misChanged\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overload"
  stdout: ''
  timestamp: 1660010353
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val p = new Array[Long](n + 1)\n        var\
    \ i = 0\n        var j = 0\n        var k = 0\n        var minChange = 0\n   \
    \     var minChangeIndex = 0\n        while(i < n) {\n            while(j < n)\
    \ {\n                if(arr(i) == arr(j)) {\n                    p(i) = arr(i)\n\
    \                    j++\n                }\n                else {\n        \
    \            p(i) = arr(j)\n                    j++\n                }\n     \
    \       }\n            k = i\n            while(k >= 0) {\n                if(arr(k)\
    \ == p(i)) {\n                    k--\n                }\n                else\
    \ {\n                    break\n                }\n            }\n           \
    \ if(i == k) {\n                minChange = arr(i) - arr(j)\n                minChangeIndex\
    \ = i\n            }\n            i += 1\n        }\n        minChange\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp_bz_r6x2.scala:21:23 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp_bz_r6x2.scala:25:23 ---------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp_bz_r6x2.scala:31:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m                    k--\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp_bz_r6x2.scala:34:20 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                    break\n\e[31m\e[31m   |\e[0m    \
    \                ^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: break\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_bz_r6x2.scala:38:28\
    \ --------------------\e[0m\e[0m\n\e[31m38 |\e[0m                minChange = arr(i)\
    \ - arr(j)\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                            Found:    Long\n\e[31m   |\e[0m\
    \                            Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660010353
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val changes = mutable.ListBuffer[Long]()\n\
    \        val change = mutable.ListBuffer[Long]()\n        val changed = mutable.ListBuffer[Long]()\n\
    \        val changeCount = mutable.ListBuffer[Long]()\n        val changeCounts\
    \ = mutable.ListBuffer[Long]()\n        val changeCounts_ = mutable.ListBuffer[Long]()\n\
    \        val changeCounts_1 = mutable.ListBuffer[Long]()\n        val changeCounts_2\
    \ = mutable.ListBuffer[Long]()\n        val changeCounts_3 = mutable.ListBuffer[Long]()\n\
    \        val changeCounts_4 = mutable.ListBuffer[Long]()\n        val changeCounts_5\
    \ = mutable.ListBuffer[Long]()\n        val changeCounts_6 = mutable.ListBuffer[Long]()\n\
    \        val changeCounts_7 = mutable.ListBuffer[Long]()\n        val changeCounts_8\
    \ = mutable.ListBuffer[Long]()\n        val changeCounts_9 = mutable.ListBuffer[Long]()\n\
    \        val changeCounts_10 = mutable.ListBuffer[Long]()\n        val changeCounts_11\
    \ = mutable.ListBuffer[Long]()\n        val changeCounts_12 = mutable.ListBuffer[Long]()\n\
    \        val changeCounts_13 = mutable.ListBuffer[Long]()\n        val changeCounts_14\
    \ = mutable.ListBuffer[Long]()\n        val changeCounts_15 = mutable.ListBuffer[Long]()\n\
    \        val changeCounts_16 = mutable.ListBuffer[Long]()\n        val changeCounts_17\
    \ = mutable.ListBuffer[Long]()\n        val changeCounts_18 = mutable.ListBuffer[Long]()\n\
    \        val changeCounts_19 = mutable.ListBuffer[Long]()\n        val changeCounts_20\
    \ = mutable.ListBuffer[Long]()\n        val changeCounts_21 = mutable.ListBuffer[Long]()\n\
    \        val changeCounts_22 = mutable.ListBuffer[Long]()\n        val changeCounts_23\
    \ = mutable.ListBuffer[Long]()\n        val changeCounts_24 = mutable.ListBuffer[Long]()\n\
    \        val changeCounts_25 = mutable.ListBuffer[Long]()\n        val changeCounts_26\
    \ = mutable.ListBuffer[Long]()\n        val changeCounts_27 = mutable.ListBuffer[Long]()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpaxvrexf0.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpaxvrexf0.scala:12:21 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpaxvrexf0.scala:13:22 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpaxvrexf0.scala:14:26 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mchangeCount\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpaxvrexf0.scala:15:27 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mchangeCounts\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpaxvrexf0.scala:16:28 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m  "
  stdout: ''
  timestamp: 1660010354
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val p = new Array[Long](n)\n        val r =\
    \ new Array[Long](n)\n        val s = new Array[Long](n)\n        val t = new\
    \ Array[Long](n)\n        val u = new Array[Long](n)\n        val v = new Array[Long](n)\n\
    \        val w = new Array[Long](n)\n        val x = new Array[Long](n)\n    \
    \    val y = new Array[Long](n)\n        val z = new Array[Long](n)\n        val\
    \ a = new Array[Long](n)\n        val b = new Array[Long](n)\n        val c =\
    \ new Array[Long](n)\n        val d = new Array[Long](n)\n        val e = new\
    \ Array[Long](n)\n        val f = new Array[Long](n)\n        val g = new Array[Long](n)\n\
    \        val h = new Array[Long](n)\n        val i = new Array[Long](n)\n    \
    \    val j = new Array[Long](n)\n        val k = new Array[Long](n)\n        val\
    \ l = new Array[Long](n)\n        val m = new Array[Long](n)\n        val n =\
    \ new Array[Long](n)\n        val o = new Array[Long](n)\n        val p = new\
    \ Array[Long](n)\n        val q = new Array[Long](n)\n        val r = new Array[Long](n)\n\
    \        val s = new Array[Long](n)\n        val t = new Array[Long](n)\n    \
    \    val u = new Array[Long](n)\n        val v = new Array[Long](n)\n        val\
    \ w = new Array[Long](n)\n        val x = new Array[Long](n)\n        val y =\
    \ new Array[Long](n)\n        val z = new Array[Long](n)\n        val a = new\
    \ Array[Long](n)\n        val b = new Array[Long](n)\n        val c = new Array[Long](n)\n\
    \        val d = new Array[Long](n)\n        val e = new Array[Long](n)\n    \
    \    val f = new Array[Long](n)\n        val g = new Array[Long](n)\n        val\
    \ h = new Array[Long](n)\n        val i = new Array[Long](n)\n        val j =\
    \ new Array[Long](n)\n        val k = new Array[Long](n)\n        val l = new\
    \ Array[Long](n)\n        val m = new Array[Long](n)\n        val n = new Array[Long](n)\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmph8jeld3k.scala:61:11 ---------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmph8jeld3k.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = \e[33mnew\e[0m\
    \ \e[35mArray\e[0m[\e[35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmph8jeld3k.scala:34:12 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mn is already defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmph8jeld3k.scala:36:12 ---------------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m        \e[33mval\e[0m \e[36mp\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mp is already defined as \e[33mvalue\e[0m \e[35mp\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmph8jeld3k.scala:38:12 ---------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Err"
  stdout: ''
  timestamp: 1660010353
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val palindromic = arr.tail.reverse\n      \
    \  val changes = mutable.ListBuffer[Long]()\n        val change = mutable.ListBuffer[Long]()\n\
    \        val changed = mutable.ListBuffer[Long]()\n        val changed = mutable.ListBuffer[Long]()\n\
    \        val changed = mutable.ListBuffer[Long]()\n        val changed = mutable.ListBuffer[Long]()\n\
    \        val changed = mutable.ListBuffer[Long]()\n        val changed = mutable.ListBuffer[Long]()\n\
    \        val changed = mutable.ListBuffer[Long]()\n        val changed = mutable.ListBuffer[Long]()\n\
    \        val changed = mutable.ListBuffer[Long]()\n        val changed = mutable.ListBuffer[Long]()\n\
    \        val changed = mutable.ListBuffer[Long]()\n        val changed = mutable.ListBuffer[Long]()\n\
    \        val changed = mutable.ListBuffer[Long]()\n        val changed = mutable.ListBuffer[Long]()\n\
    \        val changed = mutable.ListBuffer[Long]()\n        val changed = mutable.ListBuffer[Long]()\n\
    \        val changed = mutable.ListBuffer[Long]()\n        val changed = mutable.ListBuffer[Long]()\n\
    \        val changed = mutable.ListBuffer[Long]()\n        val changed = mutable.ListBuffer[Long]()\n\
    \        val changed = mutable.ListBuffer[Long]()\n        val changed = mutable.ListBuffer[Long]()\n\
    \        val changed = mutable.ListBuffer[Long]()\n        val changed = mutable.ListBuffer[Long]()\n\
    \        val changed = mutable.ListBuffer[Long]()\n        val changed = mutable.ListBuffer[Long]()\n\
    \        val changed = mutable.ListBuffer[Long]()\n        val changed = mutable.ListBuffer[Long]()\n\
    \        val changed = mutable.ListBuffer[Long]()\n        val changed = mutable.ListBuffer[Long]()\n\
    \        val changed = mutable.ListBuffer[Long]()\n        val changed = mutable.ListBuffer[Long]()\n\
    \        val changed = mutable.ListBuffer[Long]()\n        val changed = mutable.ListBuffer[Long]()\n\
    \        val changed = mutable.ListBuffer[Long]()\n        val changed = mutable.ListBuffer\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0_n4x2wj.scala:15:12 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchanged is already defined as \e[33mvalue\e[0m \e[35mchanged\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0_n4x2wj.scala:16:12 ---------------------------\e[0m\e[0m\n\e\
    [31m16 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchanged is already defined as \e[33mvalue\e[0m \e[35mchanged\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0_n4x2wj.scala:17:12 ---------------------------\e[0m\e[0m\n\e\
    [31m17 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchanged is already defined as \e[33mvalue\e[0m \e[35mchanged\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0_n4x2wj.scala:18:12 ---------------------------\e[0m\e[0m\n\e\
    [31m18 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchanged is already defined as \e[33mvalue\e[0m \e[35mchanged\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0_n4x2wj.scala:19:12 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660010353
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = math.min(len / 2, len /\
    \ 2)\n        var i = 0\n        var j = 0\n        var change = 0\n        var\
    \ temp = 0\n        while (i < len) {\n            while (j < len) {\n       \
    \         temp = arr(i)\n                arr(i) = arr(j)\n                arr(j)\
    \ = temp\n                change += 1\n                j += 1\n            }\n\
    \            i += 1\n            j = len - minChange\n        }\n        change\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8bx13_pc.scala:9:18 ----------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m  |\e[0m                  ^\e[0m\n\e[31m  |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010350
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = arr.take(len/2)\n     \
    \   val maxChange = arr.drop(len/2)\n        val change = minChange.zip(maxChange).map(x\
    \ => x._1 - x._2)\n        val minChangeCount = change.min\n        val maxChangeCount\
    \ = change.max\n        val changeCount = minChangeCount + maxChangeCount\n  \
    \      val changeCountSum = change.sum\n        val changeCountProduct = change.product\n\
    \        val changeCountProductSum = changeCountProduct.sum\n        val changeCountProductProduct\
    \ = changeCountProduct.product\n        val changeCountProductProductSum = changeCountProductProduct.sum\n\
    \        val changeCountProductProductProduct = changeCountProductProduct.product\n\
    \        val changeCountProductProductProductSum = changeCountProductProductProduct.sum\n\
    \        val changeCountProductProductProductProduct = changeCountProductProductProduct.product\n\
    \        val changeCountProductProductProductProductSum = changeCountProductProductProductProduct.sum\n\
    \        val changeCountProductProductProductProductProduct = changeCountProductProductProductProduct.product\n\
    \        val changeCountProductProductProductProductProductSum = changeCountProductProductProductProductProduct.sum\n\
    \        val changeCountProductProductProductProductProductProduct = changeCountProductProductProductProductProduct.product\n\
    \        val changeCountProductProductProductProductProductProductSum = changeCountProductProductProductProductProductProduct.sum\n\
    \        val changeCountProductProductProductProductProductProductProduct = changeCountProductProductProductProductProductProduct.product\n\
    \        val changeCountProductProductProductProductProductProductProductSum =\
    \ changeCountProductProductProductProductProductProductProduct.sum\n        val\
    \ changeCountProductProductProductProductProductProductProductProduct = changeCountProductProductProductProductProductProductProductProduct.product\n\
    \        val changeCountProductProductProductProductProductProductProductProductSum\
    \ = changeCountProductProductProductProductProductProductProductProductProduct.sum\n\
    \        val changeCountProductProductProductProductProductProductProductProductProduct\
    \ = changeCountProductProductProductProductProductProductProductProductProductProduct.product\n\
    \        val changeCountProductProductProductProductProductProductProductProductProductSum\
    \ = changeCountProductProductProductProductProductProductProductProductProductProduct.sum\n\
    \        val changeCountProductProductProductProductProductProductProductProductProductProduct\
    \ = changeCountProductProductProductProductProductProductProductProductProductProductProduct.product\n\
    \        val changeCountProductProductProductProductProductProductProductProductProductProductSum\
    \ = changeCountProductProductProductProductProductProductProductProductProductProductProductProduct.sum\n\
    \        val changeCountProductProductProductProductProductProductProduct\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7w06kfhl.scala:39:4 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7w06kfhl.scala:9:18\
    \ ----------------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m  |\e[0m                  ^\e[0m\n\e\
    [31m  |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7w06kfhl.scala:32:82\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mchangeCountProductProductProductProductProductProductProductProduct\e\
    [0m = changeCountProductProductProductProductProductProductProductProduct.product\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                          ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e\
    [35mchangeCountProductProductProductProductProductProductProductProduct\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7w06kfhl.scala:36:96\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e\
    [36mchangeCountProductProductProductProductProductProductProductProductProductProduct\e\
    [0m = changeCountProductProductProductProductProductProductProductProductProductProductProduct.product\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: changeCountProductProductProductProductProductProductProductProductProductProductProduct\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7w06kfhl.scala:37:99\
    \ ------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e\
    [36mchangeCountProdu"
  stdout: ''
  timestamp: 1660010353
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        val minChangeIndex\
    \ = -1\n        val minChangeIndex2 = -1\n        val minChangeIndex3 = -1\n \
    \       val minChangeIndex4 = -1\n        val minChangeIndex5 = -1\n        val\
    \ minChangeIndex6 = -1\n        val minChangeIndex7 = -1\n        val minChangeIndex8\
    \ = -1\n        val minChangeIndex9 = -1\n        val minChangeIndex10 = -1\n\
    \        val minChangeIndex11 = -1\n        val minChangeIndex12 = -1\n      \
    \  val minChangeIndex13 = len\n        val minChangeIndex14 = len\n        val\
    \ minChangeIndex15 = len\n        val minChangeIndex16 = len\n        val minChangeIndex17\
    \ = len\n        val minChangeIndex18 = len\n        val minChangeIndex19 = len\n\
    \        val minChangeIndex20 = len\n        val minChangeIndex21 = len\n    \
    \    val minChangeIndex22 = len\n        val minChangeIndex23 = len\n        val\
    \ minChangeIndex24 = len\n        val minChangeIndex25 = len\n        val minChangeIndex26\
    \ = len\n        val minChangeIndex27 = len\n        val minChangeIndex28 = len\n\
    \        val minChangeIndex29 = len\n        val minChangeIndex30 = len\n    \
    \    val minChangeIndex31 = len\n        val minChangeIndex32 = len\n        val\
    \ minChangeIndex33 = len\n        val minChangeIndex34 = len\n        val minChangeIndex35\
    \ = len\n        val minChangeIndex36 = len\n        val minChangeIndex37 = len\n\
    \        val minChangeIndex38 = len\n        val minChangeIndex39 = len\n    \
    \    val minChangeIndex40 = len\n        val minChangeIndex41 = len\n        val\
    \ minChangeIndex42 = len\n        val minChangeIndex43 = len\n        val minChangeIndex44\
    \ = len\n        val minChangeIndex45 = len\n        val minChangeIndex46 = len\n\
    \        val minChangeIndex47 = len\n        val minChangeIndex48 = len\n    \
    \    val minChangeIndex49 = len\n        val minChangeIndex50 = len\n        val\
    \ minChangeIndex51 = len\n        val minChangeIndex52 = len\n        val minChangeIndex53\
    \ = len\n        val minChangeIndex54 = len\n        val minChangeIndex55 = len\n\
    \        val minChangeIndex56 = len\n        \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp01f7ef_t.scala:9:18 ----------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m  |\e[0m                  ^\e[0m\n\e[31m  |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp01f7ef_t.scala:69:5 ---------------------\e[0m\e\
    [0m\n\e[31m69 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010352
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val changes = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_fbzlmse.scala:15:12 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchanged is already defined as \e[33mvalue\e[0m \e[35mchanged\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_fbzlmse.scala:16:12 ---------------------------\e[0m\e[0m\n\e\
    [31m16 |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchange is already defined as \e[33mvalue\e[0m \e[35mchange\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_fbzlmse.scala:17:12 ---------------------------\e[0m\e[0m\n\e\
    [31m17 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchanged is already defined as \e[33mvalue\e[0m \e[35mchanged\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_fbzlmse.scala:18:12 ---------------------------\e[0m\e[0m\n\e\
    [31m18 |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchange is already defined as \e[33mvalue\e[0m \e[35mchange\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_fbzlmse.scala:19:12 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e"
  stdout: ''
  timestamp: 1660010353
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = arr.take(len/2).foldLeft(0){\n\
    \            (acc, x) => if (x == 0) acc else acc + minChange(arr.drop(len/2 -\
    \ 1))\n        }\n        minChange\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp3wv5m7p7.scala:9:18 ----------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m  |\e[0m                  ^\e[0m\n\e[31m  |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010349
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        var minChange = len\n        var minChangeIndex\
    \ = 0\n        var minChangeIndex2 = 0\n        var minChangeIndex3 = 0\n    \
    \    var minChangeIndex4 = 0\n        var minChangeIndex5 = 0\n        var minChangeIndex6\
    \ = 0\n        var minChangeIndex7 = 0\n        var minChangeIndex8 = 0\n    \
    \    var minChangeIndex9 = 0\n        var minChangeIndex10 = 0\n        var minChangeIndex11\
    \ = 0\n        var minChangeIndex12 = 0\n        var minChangeIndex13 = 0\n  \
    \      var minChangeIndex14 = 0\n        var minChangeIndex15 = 0\n        var\
    \ minChangeIndex16 = 0\n        var minChangeIndex17 = 0\n        var minChangeIndex18\
    \ = 0\n        var minChangeIndex19 = 0\n        var minChangeIndex20 = 0\n  \
    \      var minChangeIndex21 = 0\n        var minChangeIndex22 = 0\n        var\
    \ minChangeIndex23 = 0\n        var minChangeIndex24 = 0\n        var minChangeIndex25\
    \ = 0\n        var minChangeIndex26 = 0\n        var minChangeIndex27 = 0\n  \
    \      var minChangeIndex28 = 0\n        var minChangeIndex29 = 0\n        var\
    \ minChangeIndex30 = 0\n        var minChangeIndex31 = 0\n        var minChangeIndex32\
    \ = 0\n        var minChangeIndex33 = 0\n        var minChangeIndex34 = 0\n  \
    \      var minChangeIndex35 = 0\n        var minChangeIndex36 = 0\n        var\
    \ minChangeIndex37 = 0\n        var minChangeIndex38 = 0\n        var minChangeIndex39\
    \ = 0\n        var minChangeIndex40 = 0\n        var minChangeIndex41 = 0\n  \
    \      var minChangeIndex42 = 0\n        var minChangeIndex43 = 0\n        var\
    \ minChangeIndex44 = 0\n        var minChangeIndex45 = 0\n        var minChangeIndex46\
    \ = 0\n        var minChangeIndex47 = 0\n        var minChangeIndex48 = 0\n  \
    \      var minChangeIndex49 = 0\n        var minChangeIndex50 = 0\n        var\
    \ minChangeIndex51 = 0\n        var minChangeIndex52 = 0\n        var minChangeIndex53\
    \ = 0\n        var minChangeIndex54 = 0\n        var minChangeIndex55 = 0\n  \
    \      var minChangeIndex56 = 0\n        var minChangeIndex57 = 0\n        var\
    \ minChangeIndex58 = 0\n        var minChangeIndex59 = 0\n        var minChangeIndex60\
    \ = 0\n        var minChangeIndex61 = 0\n        var minChangeIndex62 = 0\n  \
    \      var minChangeIndex63 = 0\n        var minChangeIndex64 = 0\n        var\
    \ minChangeIndex65 = 0\n        var minChangeIndex66 = 0\n        var minChangeIndex67\
    \ = 0\n        var minChangeIndex68 = 0\n        var minChangeIndex69 = 0\n  \
    \      var minChangeIndex70 = 0\n        var minChangeIndex\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9_ujst7l.scala:83:4 ----------------------------\e\
    [0m\e[0m\n\e[31m83 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9_ujst7l.scala:9:18\
    \ ----------------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m  |\e[0m                  ^\e[0m\n\e\
    [31m  |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9_ujst7l.scala:83:5\
    \ ---------------------\e[0m\e[0m\n\e[31m83 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010353
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val changes = mutable.ListBuffer[Long]()\n\
    \        val palindromic = mutable.ListBuffer[Long]()\n        val reversed =\
    \ arr.reverse\n        val reversedReversed = reversed.reverse\n        val reversedReversedReversed\
    \ = reversedReversed.reverse\n        val reversedReversedReversedReversed = reversedReversedReversed.reverse\n\
    \        val reversedReversedReversedReversedReversed = reversedReversedReversedReversed.reverse\n\
    \        val reversedReversedReversedReversedReversedReversed = reversedReversedReversedReversedReversed.reverse\n\
    \        val reversedReversedReversedReversedReversedReversedReversed = reversedReversedReversedReversedReversedReversed.reverse\n\
    \        val reversedReversedReversedReversedReversedReversedReversedReversedReversed\
    \ = reversedReversedReversedReversedReversedReversedReversedReversed.reverse\n\
    \        val reversedReversedReversedReversedReversedReversedReversedReversedReversedReversed\
    \ = reversedReversedReversedReversedReversedReversedReversedReversedReversed.reverse\n\
    \        val reversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed\
    \ = reversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed.reverse\n\
    \        val reversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed\
    \ = reversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed.reverse\n\
    \        val reversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed\
    \ = reversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed.reverse\n\
    \        val reversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed\
    \ = reversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed.reverse\n\
    \        val reversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed\
    \ = reversedReversedReversedReversedReversedReversed\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpd7_tyzr1.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mreversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed\e\
    [0m = reversedReversedReversedReversedReversedReversed\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mreversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  reversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpd7_tyzr1.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpd7_tyzr1.scala:12:26 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mpalindromic\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpd7_tyzr1.scala:20:87 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mreversedReversedReversedReversedReversedReversedReversedReversedReversed\e\
    [0m = reversedReversedReversedReversedReversedReversedReversedReversed.reverse\n\
    \e[31m\e[31m   "
  stdout: ''
  timestamp: 1660010353
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val ans = n\n        val arr = arr.tail\n \
    \       val len = arr.length\n        val arr2 = arr.toList\n        val arr3\
    \ = arr2.reverse\n        val arr4 = arr3.toList\n        val arr5 = arr4.toList\n\
    \        val arr6 = arr5.toList\n        val arr7 = arr6.reverse\n        val\
    \ arr8 = arr7.toList\n        val arr9 = arr8.toList\n        val arr10 = arr9.reverse\n\
    \        val arr11 = arr10.toList\n        val arr12 = arr11.toList\n        val\
    \ arr13 = arr12.reverse\n        val arr14 = arr13.toList\n        val arr15 =\
    \ arr14.toList\n        val arr16 = arr15.reverse\n        val arr17 = arr16.toList\n\
    \        val arr18 = arr17.toList\n        val arr19 = arr18.reverse\n       \
    \ val arr20 = arr19.toList\n        val arr21 = arr20.toList\n        val arr22\
    \ = arr21.reverse\n        val arr23 = arr22.toList\n        val arr24 = arr23.toList\n\
    \        val arr25 = arr24.reverse\n        val arr26 = arr25.toList\n       \
    \ val arr27 = arr26.reverse\n        val arr28 = arr27.toList\n        val arr29\
    \ = arr28.reverse\n        val arr30 = arr29.toList\n        val arr31 = arr30.reverse\n\
    \        val arr32 = arr31.toList\n        val arr33 = arr32.reverse\n       \
    \ val arr34 = arr33.toList\n        val arr35 = arr34.reverse\n        val arr36\
    \ = arr35.toList\n        val arr37 = arr36.reverse\n        val arr38 = arr37.toList\n\
    \        val arr39 = arr38.reverse\n        val arr40 = arr39.toList\n       \
    \ val arr41 = arr40.reverse\n        val arr42 = arr41.toList\n        val arr43\
    \ = arr42.reverse\n        val arr44 = arr43.toList\n        val arr45 = arr44.reverse\n\
    \        val arr46 = arr45.toList\n        val arr47 = arr46.reverse\n       \
    \ val arr48 = arr47.toList\n        val arr49 = arr48.reverse\n        val arr50\
    \ = arr49.toList\n        val arr51 = arr50.reverse\n        val arr52 = arr51.toList\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpt4zfc_k2.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpt4zfc_k2.scala:66:5 ---------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010353
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val changes = arr.filter(_\
    \ != m)\n        val changed = changes.size - 1\n        val change = changes.min\n\
    \        val changed = changes.size - 1\n        val changed = changes.size -\
    \ 1\n        val changed = changes.size - 1\n        val changed = changes.size\
    \ - 1\n        val changed = changes.size - 1\n        val changed = changes.size\
    \ - 1\n        val changed = changes.size - 1\n        val changed = changes.size\
    \ - 1\n        val changed = changes.size - 1\n        val changed = changes.size\
    \ - 1\n        val changed = changes.size - 1\n        val changed = changes.size\
    \ - 1\n        val changed = changes.size - 1\n        val changed = changes.size\
    \ - 1\n        val changed = changes.size - 1\n        val changed = changes.size\
    \ - 1\n        val changed = changes.size - 1\n        val changed = changes.size\
    \ - 1\n        val changed = changes.size - 1\n        val changed = changes.size\
    \ - 1\n        val changed = changes.size - 1\n        val changed = changes.size\
    \ - 1\n        val changed = changes.size - 1\n        val changed = changes.size\
    \ - 1\n        val changed = changes.size - 1\n        val changed = changes.size\
    \ - 1\n        val changed = changes.size - 1\n        val changed = changes.size\
    \ - 1\n        val changed = changes.size - 1\n        val changed = changes.size\
    \ - 1\n        val changed = changes.size - 1\n        val changed = changes.size\
    \ - 1\n        val changed = changes.size - 1\n        val changed = changes.size\
    \ - 1\n        val changed = changes.size - 1\n        val changed = changes.size\
    \ - 1\n        val changed = changes.size - 1\n        val changed = changes.size\
    \ - 1\n        val changed = changes.size - 1\n        val changed = changes.size\
    \ - 1\n        val changed = changes.size - 1\n        val changed = changes.size\
    \ - 1\n        val changed = changes.size - 1\n        val changed = changes.size\
    \ - 1\n        val changed = changes.size - 1\n        val changed = changes.size\
    \ - 1\n        val changed = changes.size - 1\n        val changed = changes.size\
    \ - 1\n        val changed = changes.size - 1\n        val changed = changes.size\
    \ - 1\n        val changed = changes.size - 1\n        val changed = changes.size\
    \ - 1\n        val changed = changes.size - 1\n        val changed = changes.size\
    \ - 1\n        val changed = changes.size - 1\n        val changed = changes.size\
    \ - 1\n        val changed = changes.size - 1\n        val changed = changes.size\
    \ - 1\n        val changed = changes.\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_rz5bfg6.scala:74:4 ----------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_rz5bfg6.scala:15:12 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = changes.size - \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mchanged is already defined as \e[33mvalue\e[0m \e[35mchanged\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_rz5bfg6.scala:16:12 ---------------------------\e[0m\e[0m\n\e[31m16\
    \ |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = changes.size - \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mchanged is already defined as \e[33mvalue\e[0m \e[35mchanged\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_rz5bfg6.scala:17:12 ---------------------------\e[0m\e[0m\n\e[31m17\
    \ |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = changes.size - \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mchanged is already defined as \e[33mvalue\e[0m \e[35mchanged\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_rz5bfg6.scala:18:12 ---------------------------\e[0m\e[0m\n\e[31m18\
    \ |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = changes.size - \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mchanged is already defined as \e[33mvalue\e[0m \e[35mchanged\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_rz5bfg6.scala:19:12 ---------------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m       "
  stdout: ''
  timestamp: 1660010353
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.init\n        val changes = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        while (i < m\
    \ && j < n) {\n            if (arr(i) < arr(j)) {\n                changes +=\
    \ arr(i)\n                changes += arr(j)\n                changes += arr(k)\n\
    \                changes += arr(k)\n                changes += arr(j)\n      \
    \          changes += arr(i)\n                changes += arr(j)\n            \
    \    changes += arr(k)\n                changes += arr(k)\n                changes\
    \ += arr(j)\n                changes += arr(i)\n                changes += arr(j)\n\
    \                changes += arr(k)\n                changes += arr(k)\n      \
    \          changes += arr(j)\n                changes += arr(i)\n            \
    \    changes += arr(j)\n                changes += arr(k)\n                changes\
    \ += arr(k)\n                changes += arr(j)\n                changes += arr(i)\n\
    \                changes += arr(j)\n                changes += arr(k)\n      \
    \          changes += arr(k)\n                changes += arr(j)\n            \
    \    changes += arr(i)\n                changes += arr(j)\n                changes\
    \ += arr(k)\n                changes += arr(k)\n                changes += arr(j)\n\
    \                changes += arr(i)\n                changes += arr(j)\n      \
    \          changes += arr(k)\n                changes += arr(k)\n            \
    \    changes += arr(j)\n                changes += arr(i)\n                changes\
    \ += arr(j)\n                changes += arr(k)\n                changes += arr(k)\n\
    \                changes += arr(j)\n                changes += arr(i)\n      \
    \          changes += arr(j)\n                changes += arr(k)\n            \
    \    changes += arr(k)\n                changes += arr(j)\n                changes\
    \ += arr(i)\n                changes += arr(j)\n                changes += arr(k)\n\
    \                changes += arr(k)\n                changes += arr(j)\n      \
    \          changes += arr(i)\n                changes += arr(j)\n            \
    \    changes += arr(k)\n                changes += arr(k)\n                changes\
    \ += arr(j)\n                changes += arr(i)\n                changes += arr(j)\n\
    \                changes += arr(k)\n                changes += arr(k)\n      \
    \          changes += arr(j)\n                changes += arr(i)\n            \
    \    changes += arr(j)\n                changes += arr(k)\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjuog0typ.scala:97:0 ----------------------------\e\
    [0m\e[0m\n\e[31m97 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpjuog0typ.scala:11:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.init\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e\
    [31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjuog0typ.scala:12:22\
    \ ------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e\
    [36mchanges\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjuog0typ.scala:13:22\
    \ ------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e\
    [36mchanged\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjuog0typ.scala:14:21\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mchange\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjuog0typ.scala:18:8\
    \ ---------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mwhile\e[0m (i\
    \ < m && j < n) {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m      \
    \  Found:    Unit\n\e[31m   |\e[0m        Required: Long\n\e[31m19 |\e[0m    \
    \        \e[33mif\e[0m (arr(i) < arr(j)) {\n\e[31m20 |\e[0m                c"
  stdout: ''
  timestamp: 1660010361
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val palindromicArray = arr.toList.reverse\n        val changes = mutable.ListBuffer.empty[Long]\n\
    \        val change = mutable.ListBuffer.empty[Long]\n        val changeCount\
    \ = mutable.ListBuffer.empty[Long]\n        val changeCounts = mutable.ListBuffer.empty[Long]\n\
    \        val changeCountSum = mutable.ListBuffer.empty[Long]\n        val changeCountSums\
    \ = mutable.ListBuffer.empty[Long]\n        val changeCountSumsSum = mutable.ListBuffer.empty[Long]\n\
    \        val changeCountSumsSums = mutable.ListBuffer.empty[Long]\n        val\
    \ changeCountSumsSumsSum = mutable.ListBuffer.empty[Long]\n        val changeCountSumsSumsSums\
    \ = mutable.ListBuffer.empty[Long]\n        val changeCountSumsSumsSumsSum = mutable.ListBuffer.empty[Long]\n\
    \        val changeCountSumsSumsSumsSums = mutable.ListBuffer.empty[Long]\n  \
    \      val changeCountSumsSumsSumsSumsSum = mutable.ListBuffer.empty[Long]\n \
    \       val changeCountSumsSumsSumsSumsSums = mutable.ListBuffer.empty[Long]\n\
    \        val changeCountSumsSumsSumsSumsSumsSum = mutable.ListBuffer.empty[Long]\n\
    \        val changeCountSumsSumsSumsSumsSumsSums = mutable.ListBuffer.empty[Long]\n\
    \        val changeCountSumsSumsSumsSumsSumsSumsSum = mutable.ListBuffer.empty[Long]\n\
    \        val changeCountSumsSumsSumsSumsSumsSumsSums = mutable.ListBuffer.empty[Long]\n\
    \        val changeCountSumsSumsSumsSumsSumsSumsSumsSum = mutable.ListBuffer.empty[Long]\n\
    \        val changeCountSumsSumsSumsSumsSumsSumsSumsSums = mutable.ListBuffer.empty[Long]\n\
    \        val changeCountSumsSumsSumsSumsSumsSumsSumsSumsSum = mutable.ListBuffer.empty[Long]\n\
    \        val changeCountSumsSumsSumsSumsSumsSumsSumsSumsSums = mutable.ListBuffer.empty[Long]\n\
    \        val changeCountSumsSumsSumsSumsSumsSumsSumsSumsSumsSum = mutable.\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppmiq_9dg.scala:34:4 ----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmppmiq_9dg.scala:11:22 ------------------------\e[0m\e[0m\n\e[31m11\
    \ |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmppmiq_9dg.scala:12:21 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmppmiq_9dg.scala:13:26 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mchangeCount\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmppmiq_9dg.scala:14:27 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mchangeCounts\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmppmiq_9dg.scala:15:29 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mchangeCountSum\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        "
  stdout: ''
  timestamp: 1660010360
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        val maxChange\
    \ = len\n        val changes = mutable.ListBuffer[Long]()\n        val changed\
    \ = mutable.ListBuffer[Long]()\n        val change = mutable.ListBuffer[Long]()\n\
    \        val changed = mutable.ListBuffer[Long]()\n        val change = mutable.ListBuffer[Long]()\n\
    \        val changed = mutable.ListBuffer[Long]()\n        val change = mutable.ListBuffer[Long]()\n\
    \        val changed = mutable.ListBuffer[Long]()\n        val change = mutable.ListBuffer[Long]()\n\
    \        val changed = mutable.ListBuffer[Long]()\n        val change = mutable.ListBuffer[Long]()\n\
    \        val changed = mutable.ListBuffer[Long]()\n        val change = mutable.ListBuffer[Long]()\n\
    \        val changed = mutable.ListBuffer[Long]()\n        val change = mutable.ListBuffer[Long]()\n\
    \        val changed = mutable.ListBuffer[Long]()\n        val change = mutable.ListBuffer[Long]()\n\
    \        val changed = mutable.ListBuffer[Long]()\n        val change = mutable.ListBuffer[Long]()\n\
    \        val changed = mutable.ListBuffer[Long]()\n        val change = mutable.ListBuffer[Long]()\n\
    \        val changed = mutable.ListBuffer[Long]()\n        val change = mutable.ListBuffer[Long]()\n\
    \        val changed = mutable.ListBuffer[Long]()\n        val change = mutable.ListBuffer[Long]()\n\
    \        val changed = mutable.ListBuffer[Long]()\n        val change = mutable.ListBuffer[Long]()\n\
    \        val changed = mutable.ListBuffer[Long]()\n        val change = mutable.ListBuffer[Long]()\n\
    \        val changed = mutable.ListBuffer[Long]()\n        val change = mutable.ListBuffer[Long]()\n\
    \        val changed = mutable.ListBuffer[Long]()\n        val change = mutable.ListBuffer[Long]()\n\
    \        val changed = mutable.ListBuffer[Long]()\n        val change = mutable.ListBuffer[Long]()\n\
    \        val changed = mutable.ListBuffer[Long]()\n        val change = mutable.ListBuffer[Long]()\n\
    \        val changed = \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpocvmm8db.scala:50:21 ---------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = \n\e[31m\e\
    [31m   |\e[0m                     ^\e[0m\n\e[31m   |\e[0m                    \
    \ expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpocvmm8db.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchanged is already defined as \e[33mvalue\e[0m \e[35mchanged\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpocvmm8db.scala:17:12 ---------------------------\e[0m\e[0m\n\e\
    [31m17 |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchange is already defined as \e[33mvalue\e[0m \e[35mchange\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpocvmm8db.scala:18:12 ---------------------------\e[0m\e[0m\n\e\
    [31m18 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchanged is already defined as \e[33mvalue\e[0m \e[35mchanged\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpocvmm8db.scala:19:12 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchange is already defined as \e[33mvalue\e[0m \e[35mchange\e\
    [0m\n\e[3"
  stdout: ''
  timestamp: 1660010362
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.dropRight(1)\n        val arr2\
    \ = arr.toList\n        val arr3 = arr2.reverse\n        val arr4 = arr3.toList\n\
    \        val arr5 = arr4.dropRight(1)\n        val arr6 = arr5.toList\n      \
    \  val arr7 = arr6.reverse\n        val arr8 = arr7.toList\n        val arr9 =\
    \ arr8.reverse\n        val arr10 = arr9.toList\n        val arr11 = arr10.reverse\n\
    \        val arr12 = arr11.toList\n        val arr13 = arr12.reverse\n       \
    \ val arr14 = arr13.toList\n        val arr15 = arr14.reverse\n        val arr16\
    \ = arr15.toList\n        val arr17 = arr16.reverse\n        val arr18 = arr17.toList\n\
    \        val arr19 = arr18.reverse\n        val arr20 = arr19.toList\n       \
    \ val arr21 = arr20.reverse\n        val arr22 = arr21.toList\n        val arr23\
    \ = arr22.reverse\n        val arr24 = arr23.toList\n        val arr25 = arr24.reverse\n\
    \        val arr26 = arr25.toList\n        val arr27 = arr26.reverse\n       \
    \ val arr28 = arr27.toList\n        val arr29 = arr28.reverse\n        val arr30\
    \ = arr29.toList\n        val arr31 = arr30.reverse\n        val arr32 = arr31.toList\n\
    \        val arr33 = arr32.reverse\n        val arr34 = arr33.toList\n       \
    \ val arr35 = arr34.reverse\n        val arr36 = arr35.toList\n        val arr37\
    \ = arr36.reverse\n        val arr38 = arr37.toList\n        val arr39 = arr38.reverse\n\
    \        val arr40 = arr39.toList\n        val arr41 = arr40.reverse\n       \
    \ val arr42 = arr41.toList\n        val arr43 = arr42.reverse\n        val arr44\
    \ = arr43.toList\n        val arr45 = arr44.reverse\n        val arr46 = arr45.toList\n\
    \        val arr47 = arr46.reverse\n        val arr48 = arr47.toList\n       \
    \ val arr49 = arr48.reverse\n        val arr50 = arr49.toList\n        val arr51\
    \ = arr50.reverse\n        val arr52 = arr51.toList\n        val arr53 = arr52.reverse\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpd3emhp6j.scala:64:11 ---------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpd3emhp6j.scala:11:18 ---------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.dropRight(\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m  \
    \                Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpd3emhp6j.scala:65:5 ---------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010361
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        var i = 0\n\
    \        var j = 0\n        var k = 0\n        while (i < len) {\n           \
    \ while (j < len) {\n                if (arr(i) != arr(j)) {\n               \
    \     minChange = minChange - 1\n                    k = j\n                }\n\
    \                j = j + 1\n            }\n            i = i + 1\n           \
    \ j = k\n        }\n        minChange\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpdi6bz6w2.scala:9:18 ----------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m  |\e[0m                  ^\e[0m\n\e[31m  |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpdi6bz6w2.scala:18:30 -----------------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m                    minChange = minChange - \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Reassignment to val minChange\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010359
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.last\n        val palindromicArray = arr.filter(_ != m)\n\
    \        val changes = palindromicArray.count(_ == m)\n        val changesToMakePalindromic\
    \ = changes - 1\n        val changesToMakePalindromicToMakePalindromicArray =\
    \ changesToMakePalindromic - 1\n        val changesToMakePalindromicToMakePalindromicArrayToMakePalindromicArray\
    \ = changesToMakePalindromicToMakePalindromicArray - 1\n        val changesToMakePalindromicToMakePalindromicArrayToMakePalindromicArrayToMakePalindromicArray\
    \ = changesToMakePalindromicToMakePalindromicArrayToMakePalindromicArray - 1\n\
    \        val changesToMakePalindromicToMakePalindromicArrayToMakePalindromicArrayToMakePalindromicArrayToMakePalindromicArray\
    \ = changesToMakePalindromicToMakePalindromicArrayToMakePalindromicArrayToMakePalindromicArray\
    \ - 1\n        val changesToMakePalindromicToMakePalindromicArrayToMakePalindromicArrayToMakePalindromicArrayToMakePalindromicArrayToMakePalindromicArray\
    \ = changesToMakePalindromicToMakePalindromicArrayToMakePalindromicArrayToMakePalindromicArrayToMakePalindromicArray\
    \ - 1\n        val changesToMakePalindromicToMakePalindromicArrayToMakePalindromicArrayToMakePalindromicArrayToMakePalindromicArrayToMakePalindromicArrayToMakePalindromicArray\
    \ = changesToMakePalindromicToMakePalindromicArrayToMakePalindromicArrayToMakePalindromicArrayToMakePalindromicArrayToMakePalindromicArray\
    \ - 1\n        val changesToMakePalindromicToMakePalindromicArrayToMakePalindromicArrayToMakePalindromicArrayToMakePalindromicArrayToMakePalindromicArrayToMakePalindromicArrayToMakePalindromicArray\
    \ = changesToMakePalindromicToMakePalindromicArrayToMakePalindromicArrayToMakePalindromicArrayToMakePalindro\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgteguf40.scala:20:193 -----------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mchangesToMakePalindromicToMakePalindromicArrayToMakePalindromicArrayToMakePalindromicArrayToMakePalindromicArrayToMakePalindromicArrayToMakePalindromicArrayToMakePalindromicArray\e\
    [0m = changesToMakePalindromicToMakePalindromicArrayToMakePalindromicArrayToMakePalindromicArrayToMakePalindro\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \                                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: changesToMakePalindromicToMakePalindromicArrayToMakePalindromicArrayToMakePalindromicArrayToMakePalindro\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgteguf40.scala:21:5\
    \ ---------------------\e[0m\e[0m\n\e[31m21 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010361
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val palindromic = arr.tail.reverse.forall(x\
    \ => x == m)\n        if (palindromic)\n            return 1\n        if (n ==\
    \ 1)\n            return 0\n        val changes = mutable.ArrayBuffer.empty[Long]\n\
    \        val change = smallestChange(arr.tail)\n        changes += change\n  \
    \      val change2 = smallestChange(arr.init)\n        changes += change2\n  \
    \      val change3 = smallestChange(arr.init.reverse)\n        changes += change3\n\
    \        val change4 = smallestChange(arr.init.reverse.reverse)\n        changes\
    \ += change4\n        val change5 = smallestChange(arr.init.reverse.reverse.reverse)\n\
    \        changes += change5\n        val change6 = smallestChange(arr.init.reverse.reverse.reverse.reverse)\n\
    \        changes += change6\n        val change7 = smallestChange(arr.init.reverse.reverse.reverse.reverse.reverse.reverse)\n\
    \        changes += change7\n        val change8 = smallestChange(arr.init.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse)\n\
    \        changes += change8\n        val change9 = smallestChange(arr.init.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse)\n\
    \        changes += change9\n        val change10 = smallestChange(arr.init.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp23nzzba9.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp23nzzba9.scala:16:22\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mchanges\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp23nzzba9.scala:36:5\
    \ ---------------------\e[0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010361
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val result = new Array[Long](n)\n        var\
    \ i = 0\n        var j = 0\n        var k = 0\n        var minChange = 0\n   \
    \     while (i < n && j < n) {\n            if (arr(i) < arr(j)) {\n         \
    \       result(i) = arr(i)\n                i += 1\n            } else {\n   \
    \             result(j) = arr(j)\n                j += 1\n            }\n    \
    \    }\n        while (i < n) {\n            result(i) = arr(i)\n            i\
    \ += 1\n        }\n        while (j < n) {\n            result(j) = arr(j)\n \
    \           j += 1\n        }\n        val reverse = new Array[Long](n)\n    \
    \    var i = 0\n        var j = 0\n        while (i < n) {\n            reverse(i)\
    \ = arr(n - 1 - i)\n            i += 1\n        }\n        while (j < n) {\n \
    \           reverse(j) = arr(n - 1 - j)\n            j += 1\n        }\n     \
    \   var i = 0\n        var j = 0\n        var k = 0\n        while (i < n && j\
    \ < n) {\n            if (result(i) == reverse(k)) {\n                minChange\
    \ = minChange + 1\n                i += 1\n                k += 1\n          \
    \  } else {\n                minChange = minChange + 1\n                j += 1\n\
    \            }\n        }\n        minChange\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfbygcwgh.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mvar\e[0m \e[36mi\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mi is already defined\
    \ as \e[33mvariable\e[0m \e[35mi\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfbygcwgh.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mvar\e[0m \e[36mj\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mj is already defined\
    \ as \e[33mvariable\e[0m \e[35mj\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfbygcwgh.scala:44:12 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mvar\e[0m \e[36mi\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mi is already defined\
    \ as \e[33mvariable\e[0m \e[35mi\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfbygcwgh.scala:45:12 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mvar\e[0m \e[36mj\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mj is already defined\
    \ as \e[33mvariable\e[0m \e[35mj\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfbygcwgh.scala:46:12 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mvar\e[0m \e[36mk\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mk is already defined\
    \ as \e[33mvariable\e[0m \e[35mk\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1660010360
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val maxChange = len / 2\n        val change\
    \ = mutable.ListBuffer[Long]()\n        var i = 0\n        var j = 0\n       \
    \ var k = 0\n        var changeCount = 0\n        var changeCountMax = 0\n   \
    \     var changeCountMin = 0\n        while (i < len) {\n            while (j\
    \ < len) {\n                if (arr(i) == arr(j)) {\n                    j +=\
    \ 1\n                } else {\n                    changeCount += 1\n        \
    \            change.add(arr(i))\n                    i += 1\n                \
    \    break\n                }\n            }\n            while (k < maxChange)\
    \ {\n                if (arr(i) == arr(len - k)) {\n                    k += 1\n\
    \                } else {\n                    changeCount += 1\n            \
    \        change.add(arr(i))\n                    i += 1\n                    break\n\
    \                }\n            }\n            while (k < maxChange) {\n     \
    \           if (arr(i) == arr(len - k)) {\n                    k += 1\n      \
    \          } else {\n                    changeCount += 1\n                  \
    \  change.add(arr(i))\n                    i += 1\n                    break\n\
    \                }\n            }\n            while (k < maxChange) {\n     \
    \           if (arr(i) == arr(len - k)) {\n                    k += 1\n      \
    \          } else {\n                    changeCount += 1\n                  \
    \  change.add(arr(i))\n                    i += 1\n                    break\n\
    \                }\n            }\n            while (k < maxChange) {\n     \
    \           if (arr(i) == arr(len - k)) {\n                    k += 1\n      \
    \          } else {\n                    changeCount += 1\n                  \
    \  change.add(arr(i))\n                    i += 1\n                    break\n\
    \                }\n            }\n            while (k < maxChange) {\n     \
    \           if (arr(i) == arr(len - k)) {\n                    k += 1\n      \
    \          } else {\n                    changeCount += 1\n                  \
    \  change.add(arr(i))\n                    i += 1\n                    break\n\
    \                }\n            }\n            while (k < maxChange) {\n     \
    \           if (arr(i) == arr(len - k)) {\n                    k += 1\n      \
    \          } else {\n                    changeCount += 1\n                  \
    \  change.add(arr(i))\n                    i += 1\n                    break\n\
    \                }\n            }\n            while (k < maxChange) {\n     \
    \           if (arr(i) == arr(len - k)) {\n                    k += 1\n      \
    \          } else {\n                    changeCount += 1\n                  \
    \  change.add(arr(i))\n                    i += 1\n                    break\n\
    \                }\n            }\n            while (k < maxChange) {\n     \
    \           if (arr(i) == arr(len - k)) {\n                    k += 1\n      \
    \          } else {\n                    changeCount += 1\n                  \
    \  change.add(arr(i))\n                    i += 1\n                    break\n\
    \                }\n            }\n            while (k < maxChange) {\n     \
    \           if (arr(i) == arr(len - k)) {\n                    k += 1\n      \
    \          } else {\n                    changeCount += 1\n                  \
    \  change.add(arr(i))\n                    i += 1\n                    break\n\
    \                }\n            }\n            while (k < maxChange) {\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpivemolfz.scala:134:0 ---------------------------\e\
    [0m\e[0m\n\e[31m134 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpivemolfz.scala:9:18\
    \ ----------------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m  |\e[0m                  ^\e[0m\n\e\
    [31m  |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpivemolfz.scala:12:21\
    \ ------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e\
    [36mchange\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpivemolfz.scala:27:20\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m                    break\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^\e[0m\n\e[31m   |\e[0m         \
    \           Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpivemolfz.scala:37:20 ------------------------\e[0m\e[0m\n\e[31m37 |\e\
    [0m                    break\n\e[31m\e[31m   |\e[0m                    ^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Not found: break\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpivemolfz.scala:47:20 ------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m                    break\n\e[31m\e[31m   |\e[0m    \
    \                ^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: break\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpivemolfz.scala:57:20\
    \ ------------------------\e[0m\e[0m\n\e[31m57 |\e[0m                    break\n\
    \e[31m\e[31m   |"
  stdout: ''
  timestamp: 1660010360
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val len = arr.length\n\
    \        val maxChange = len / 2\n        val minChange = len - maxChange\n  \
    \      val changes = mutable.ListBuffer[Long]()\n        var i = 0\n        while\
    \ (i < maxChange) {\n            val j = i\n            while (j < minChange &&\
    \ arr(j) != arr(j + 1))\n                j++\n            changes += j - i\n \
    \           i += 1\n        }\n        changes.min\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpfyuc56fg.scala:17:19 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m                j++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31munindent\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfyuc56fg.scala:12:22\
    \ ------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e\
    [36mchanges\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010361
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val minChange = math.max((arr.last, arr.head))\n        val changes =\
    \ mutable.ArrayBuffer(arr.last)\n        val reversed = arr.map(x => reverse(x))\n\
    \        val reversedReversed = reversed.map(x => reverse(x))\n        val reversedReversedReversed\
    \ = reversedReversed.map(x => reverse(x))\n        val reversedReversedReversedReversed\
    \ = reversedReversedReversed.map(x => reverse(x))\n        val reversedReversedReversedReversedReversed\
    \ = reversedReversedReversedReversed.map(x => reverse(x))\n        val reversedReversedReversedReversedReversedReversed\
    \ = reversedReversedReversedReversedReversed.map(x => reverse(x))\n        val\
    \ reversedReversedReversedReversedReversedReversedReversed = reversedReversedReversedReversedReversedReversed.map(x\
    \ => reverse(x))\n        val reversedReversedReversedReversedReversedReversedReversedReversed\
    \ = reversedReversedReversedReversedReversedReversedReversed.map(x => reverse(x))\n\
    \        val reversedReversedReversedReversedReversedReversedReversedReversedReversed\
    \ = reversedReversedReversedReversedReversedReversedReversedReversed.map(x =>\
    \ reverse(x))\n        val reversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed\
    \ = reversedReversedReversedReversedReversedReversedReversedReversedReversedReversed.map(x\
    \ => reverse(x))\n        val reversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed\
    \ = reversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed.map(x\
    \ => reverse(x))\n        val reversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed\
    \ = reversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed.map(x\
    \ => reverse(x))\n        val reversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed\
    \ = reversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed.map(x\
    \ => reverse(x))\n        val reversedReversedReversedReversedReversed\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpolrbdk94.scala:26:4 ----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpolrbdk94.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mreversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed\e\
    [0m = reversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed.map(\e\
    [36mx\e[0m => reverse(x))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mreversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  reversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E134] Type Error: /tmp/tmpolrbdk94.scala:10:29 -----------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mminChange\e[0m = math.max((arr.last,\
    \ arr.head))\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmax\e\
    [0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x:\
    \ Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e\
    [31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\
    \e[31m   |\e[0mmatch arguments ((Long, Long))\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpolrbdk94.scala:11:22 ------------------------\e[0m\e[0m\n\e[31m11\
    \ |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.Arr"
  stdout: ''
  timestamp: 1660010363
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val changes = mutable.ListBuffer[Long]()\n\
    \        var i = 0\n        var j = 0\n        while(i < arr.length) {\n     \
    \       while(j < arr.length && arr(i) == arr(j)) {\n                j += 1\n\
    \            }\n            changes += j - i\n            i += 1\n           \
    \ j = 0\n        }\n        changes.min\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpuus9jsnf.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010361
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        val minChangeIndex\
    \ = 0\n        val minChangeIndexArr = 0\n        var i = 0\n        var j = 0\n\
    \        var k = 0\n        var temp = 0\n        var tempArr = 0\n        var\
    \ tempArrIndex = 0\n        var tempArrIndexArr = 0\n        var tempArrIndex2\
    \ = 0\n        var tempArrIndexArr2 = len\n        var tempArrIndex3 = 0\n   \
    \     var tempArrIndexArr3 = len\n        var tempArrIndex4 = 0\n        var tempArrIndexArr4\
    \ = len\n        var tempArrIndex5 = 0\n        var tempArrIndexArr5 = len\n \
    \       var tempArrIndex6 = 0\n        var tempArrIndexArr6 = len\n        var\
    \ tempArrIndex7 = 0\n        var tempArrIndexArr7 = len\n        var tempArrIndex8\
    \ = 0\n        var tempArrIndexArr8 = len\n        var tempArrIndex9 = 0\n   \
    \     var tempArrIndexArr9 = len\n        var tempArrIndex10 = 0\n        var\
    \ tempArrIndexArr10 = len\n        var tempArrIndex11 = 0\n        var tempArrIndexArr11\
    \ = len\n        var tempArrIndex12 = 0\n        var tempArrIndexArr12 = len\n\
    \        var tempArrIndex13 = 0\n        var tempArrIndexArr13 = len\n       \
    \ var tempArrIndex14 = 0\n        var tempArrIndexArr14 = len\n        var tempArrIndex15\
    \ = 0\n        var tempArrIndexArr15 = len\n        var tempArrIndex16 = 0\n \
    \       var tempArrIndexArr16 = len\n        var tempArrIndex17 = 0\n        var\
    \ tempArrIndexArr17 = len\n        var tempArrIndex18 = 0\n        var tempArrIndexArr18\
    \ = len\n        var tempArrIndex19 = 0\n        var tempArrIndexArr19 = len\n\
    \        var tempArrIndex20 = 0\n        var tempArrIndexArr20 = len\n       \
    \ var tempArrIndex21 = 0\n        var tempArrIndexArr21 = len\n        var tempArrIndex22\
    \ = 0\n        var tempArrIndexArr22 = len\n        var tempArrIndex23 = 0\n \
    \       var tempArrIndexArr23 = len\n        var tempArrIndex24 = 0\n        var\
    \ tempArrIndexArr24 = len\n        var tempArrIndex25 = 0\n        var tempArrIndexArr25\
    \ = len\n        var tempArrIndex26 = 0\n        var tempArrIndexArr26 = len\n\
    \        var tempArrIndex27 = 0\n        var tempArrIndexArr27 = len\n       \
    \ var tempArrIndex28 = 0\n        var tempArrIndexArr28 = len\n        var tempArrIndex29\
    \ = 0\n        var tempArrIndexArr29 = len\n        var tempArrIndex30 = 0\n\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpw1mbbrb8.scala:9:18 ----------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m  |\e[0m                  ^\e[0m\n\e[31m  |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpw1mbbrb8.scala:79:5 ---------------------\e[0m\e\
    [0m\n\e[31m79 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010363
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val result = new Array[Long](n)\n        val\
    \ change = new Array[Long](n)\n        val changed = new Array[Long](n)\n    \
    \    val changeIndex = new Array[Int](n)\n        val changeIndex2 = new Array[Int](n)\n\
    \        val changeIndex3 = new Array[Int](n)\n        val changeIndex4 = new\
    \ Array[Int](n)\n        val changeIndex5 = new Array[Int](n)\n        val changeIndex6\
    \ = new Array[Int](n)\n        val changeIndex7 = new Array[Int](n)\n        val\
    \ changeIndex8 = new Array[Int](n)\n        val changeIndex9 = new Array[Int](n)\n\
    \        val changeIndex10 = new Array[Int](n)\n        val changeIndex11 = new\
    \ Array[Int](n)\n        val changeIndex12 = new Array[Int](n)\n        val changeIndex13\
    \ = new Array[Int](n)\n        val changeIndex14 = new Array[Int](n)\n       \
    \ val changeIndex15 = new Array[Int](n)\n        val changeIndex16 = new Array[Int](n)\n\
    \        val changeIndex17 = new Array[Int](n)\n        val changeIndex18 = new\
    \ Array[Int](n)\n        val changeIndex19 = new Array[Int](n)\n        val changeIndex20\
    \ = new Array[Int](n)\n        val changeIndex21 = new Array[Int](n)\n       \
    \ val changeIndex22 = new Array[Int](n)\n        val changeIndex23 = new Array[Int](n)\n\
    \        val changeIndex24 = new Array[Int](n)\n        val changeIndex25 = new\
    \ Array[Int](n)\n        val changeIndex26 = new Array[Int](n)\n        val changeIndex27\
    \ = new Array[Int](n)\n        val changeIndex28 = new Array[Int](n)\n       \
    \ val changeIndex29 = new Array[Int](n)\n        val changeIndex30 = new Array[Int](n)\n\
    \        val changeIndex31 = new Array[Int](n)\n        val changeIndex32 = new\
    \ Array[Int](n)\n        val changeIndex33 = new Array[Int](n)\n        val changeIndex34\
    \ = new Array[Int](n)\n        val changeIndex35 = new Array[Int](n)\n       \
    \ val changeIndex36 = new Array[Int](n)\n        val changeIndex37 = new Array[Int](n)\n\
    \        val changeIndex38 = new Array[Int](n)\n        val changeIndex39 = new\
    \ Array[Int](n)\n\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqarstxgl.scala:54:5\
    \ ---------------------\e[0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010363
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val p = new Array[Long](n)\n        var i =\
    \ 0\n        var j = 0\n        var k = 0\n        var minChange = 0\n       \
    \ var minChangeIndex = 0\n        var minChangeIndex2 = 0\n        var minChangeIndex3\
    \ = 0\n        var minChangeIndex4 = 0\n        var minChangeIndex5 = 0\n    \
    \    var minChangeIndex6 = 0\n        var minChangeIndex7 = 0\n        var minChangeIndex8\
    \ = 0\n        var minChangeIndex9 = 0\n        var minChangeIndex10 = 0\n   \
    \     var minChangeIndex11 = 0\n        var minChangeIndex12 = 0\n        var\
    \ minChangeIndex13 = 0\n        var minChangeIndex14 = 0\n        var minChangeIndex15\
    \ = 0\n        var minChangeIndex16 = 0\n        var minChangeIndex17 = 0\n  \
    \      var minChangeIndex18 = 0\n        var minChangeIndex19 = 0\n        var\
    \ minChangeIndex20 = 0\n        var minChangeIndex21 = 0\n        var minChangeIndex22\
    \ = 0\n        var minChangeIndex23 = 0\n        var minChangeIndex24 = 0\n  \
    \      var minChangeIndex25 = 0\n        var minChangeIndex26 = 0\n        var\
    \ minChangeIndex27 = 0\n        var minChangeIndex28 = 0\n        var minChangeIndex29\
    \ = 0\n        var minChangeIndex30 = 0\n        var minChangeIndex31 = 0\n  \
    \      var minChangeIndex32 = 0\n        var minChangeIndex33 = 0\n        var\
    \ minChangeIndex34 = 0\n        var minChangeIndex35 = 0\n        var minChangeIndex36\
    \ = 0\n        var minChangeIndex37 = 0\n        var minChangeIndex38 = 0\n  \
    \      var minChangeIndex39 = 0\n        var minChangeIndex40 = 0\n        var\
    \ minChangeIndex41 = 0\n        var minChangeIndex42 = 0\n        var minChangeIndex43\
    \ = 0\n        var minChangeIndex44 = 0\n        var minChangeIndex45 = 0\n  \
    \      var minChangeIndex46 = 0\n        var minChangeIndex47 = 0\n        var\
    \ minChangeIndex48 = 0\n        var minChangeIndex49 = 0\n        var minChangeIndex50\
    \ = 0\n        var minChangeIndex51 = 0\n        var minChangeIndex52 = 0\n  \
    \      var minChangeIndex53 = 0\n        var minChangeIndex54 = 0\n        var\
    \ minChangeIndex55 = 0\n        var minChangeIndex56 = 0\n        var minChangeIndex57\
    \ = 0\n        var minChangeIndex58 = 0\n        var minChangeIndex59 = 0\n  \
    \      var minChangeIndex60 = 0\n        var minChangeIndex61 = 0\n        var\
    \ minChangeIndex62 = 0\n        var minChangeIndex63 = 0\n        var minChangeIndex64\
    \ = 0\n        var minChangeIndex65 = 0\n        var minChangeIndex66 = 0\n  \
    \      var minChangeIndex67 = 0\n        var minChangeIndex68 = 0\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb0zvesx5.scala:84:5\
    \ ---------------------\e[0m\e[0m\n\e[31m84 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010364
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.sort\n\
    \        val len = arr.length\n        val min = len / 2\n        val max = len\
    \ - min\n        var i = 0\n        var j = 0\n        var k = 0\n        var\
    \ min = len / 2\n        var max = len - min\n        var changes = 0\n      \
    \  while (i < len) {\n            while (j < len) {\n                if (arr(i)\
    \ == arr(j)) {\n                    j++\n                    k++\n           \
    \     }\n                else {\n                    j++\n                }\n\
    \            }\n            while (k < len) {\n                if (arr(i) == arr(k))\
    \ {\n                    k++\n                }\n                else {\n    \
    \                k++\n                }\n            }\n            if (i == j)\
    \ {\n                changes++\n            }\n            else if (i == k) {\n\
    \                changes++\n            }\n            else if (j == k) {\n  \
    \              changes++\n            }\n            else if (arr(i) < arr(j))\
    \ {\n                changes++\n            }\n            else if (arr(i) > arr(k))\
    \ {\n                changes++\n            }\n            else if (arr(i) ==\
    \ arr(k)) {\n                changes++\n            }\n            else if (arr(i)\
    \ < arr(k)) {\n                changes++\n            }\n            else if (arr(i)\
    \ > arr(k)) {\n                changes++\n            }\n            i++\n   \
    \         j++\n            k++\n        }\n        changes\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp8g7fa4s6.scala:23:23 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                    k++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp8g7fa4s6.scala:26:23 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp8g7fa4s6.scala:31:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m                    k++\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E018] Syntax Error: /tmp/tmp8g7fa4s6.scala:34:23 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                    k++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp8g7fa4s6.scala:38:25 ---------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m                changes++\n\e[31m\e[31m   |\e[0m                     \
    \    ^\e[0m\n\e[31m   |\e[0m                         expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp8g7fa4s6.scala:41:25\
    \ ---------------------------\e[0m\e[0m\n\e[31m41 |\e[0m                changes++\n\
    \e[31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m   |\e[0m        \
    \                 expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e"
  stdout: ''
  timestamp: 1660010364
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val changes = mutable.ArrayBuffer.empty[Long]\n\
    \        val change = mutable.ArrayBuffer.empty[Long]\n        var i = 0\n   \
    \     var j = 0\n        var k = 0\n        var l = 0\n        while (i < n) {\n\
    \            while (j < n) {\n                if (arr(i) == arr(j)) {\n      \
    \              changes += arr(i)\n                    j += 1\n               \
    \ } else {\n                    j += 1\n                }\n            }\n   \
    \         i += 1\n            changes += m\n            i += 1\n            changes\
    \ += arr(i)\n            i += 1\n            changes += arr(i)\n            i\
    \ += 1\n            changes += arr(i)\n            i += 1\n            changes\
    \ += arr(i)\n            i += 1\n            changes += arr(i)\n            i\
    \ += 1\n            changes += arr(i)\n            i += 1\n            changes\
    \ += arr(i)\n            i += 1\n            changes += arr(i)\n            i\
    \ += 1\n            changes += arr(i)\n            i += 1\n            changes\
    \ += arr(i)\n            i += 1\n            changes += arr(i)\n            i\
    \ += 1\n            changes += arr(i)\n            i += 1\n            changes\
    \ += arr(i)\n            i += 1\n            changes += arr(i)\n            i\
    \ += 1\n            changes += arr(i)\n            i += 1\n            changes\
    \ += arr(i)\n            i += 1\n            changes += arr(i)\n            i\
    \ += 1\n            changes += arr(i)\n            i += 1\n            changes\
    \ += arr(i)\n            i += 1\n            changes += arr(i)\n            i\
    \ += 1\n            changes += arr(i)\n            i += 1\n            changes\
    \ += arr(i)\n            i += 1\n            changes += arr(i)\n            i\
    \ += 1\n            changes += arr(i)\n            i += 1\n            changes\
    \ += arr(i)\n            i += 1\n            changes += arr(i)\n            i\
    \ += 1\n            changes += arr(i)\n            i += 1\n            changes\
    \ += arr(i)\n            i += 1\n            changes += arr(i)\n            i\
    \ += 1\n            changes += arr(i)\n            i += 1\n            changes\
    \ += arr(i)\n            i += 1\n            changes += arr(i)\n            i\
    \ += 1\n            changes += arr(i)\n            i += 1\n            changes\
    \ += arr(i)\n            i += 1\n            changes += arr(i)\n            i\
    \ += 1\n            changes += arr(i)\n            i += 1\n            changes\
    \ += arr(i)\n            i += 1\n            changes += arr(i)\n            i\
    \ += 1\n            changes += arr(i)\n            i += 1\n            changes\
    \ += arr(i)\n            i += 1\n            changes += arr(i)\n            i\
    \ += 1\n            changes += arr(i)\n            i += 1\n            changes\
    \ += arr(i)\n            i += 1\n            changes += arr(i)\n            i\
    \ += 1\n            changes += arr(i)\n            i += 1\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpyjf4b6fm.scala:133:0 ---------------------------\e\
    [0m\e[0m\n\e[31m133 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpyjf4b6fm.scala:11:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e\
    [31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyjf4b6fm.scala:12:22\
    \ ------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e\
    [36mchanges\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyjf4b6fm.scala:13:21\
    \ ------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e\
    [36mchange\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyjf4b6fm.scala:132:1\
    \ --------------------\e[0m\e[0m\n\e[31m132 |\e[0m}\n\e[31m\e[31m    |\e[0m ^\e\
    [0m\n\e[31m    |\e[0m Found:    Unit\n\e[31m    |\e[0m Required: Long\n\e[31m\
    \    |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmpyjf4b6fm.scala:121:4 ---------------------------------------\e\
    [0m\e[0m\n\e[33m121 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m:\
    \ \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m    |\e[0m    ^\e[0m\n\
    \e[33m    |\e[0m    Line is indented too far to the left, or a `}` is missing\n\
    1 warning found\n5 errors found\n"
  stdout: ''
  timestamp: 1660010364
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val p = new Array[Long](n + 1)\n        val\
    \ r = new Array[Long](n + 1)\n        val s = new Array[Long](n + 1)\n       \
    \ val t = new Array[Long](n + 1)\n        val u = new Array[Long](n + 1)\n   \
    \     val v = new Array[Long](n + 1)\n        val w = new Array[Long](n + 1)\n\
    \        val x = new Array[Long](n + 1)\n        val y = new Array[Long](n + 1)\n\
    \        val z = new Array[Long](n + 1)\n        val a = new Array[Long](n + 1)\n\
    \        val b = new Array[Long](n + 1)\n        val c = new Array[Long](n + 1)\n\
    \        val d = new Array[Long](n + 1)\n        val e = new Array[Long](n + 1)\n\
    \        val f = new Array[Long](n + 1)\n        val g = new Array[Long](n + 1)\n\
    \        val h = new Array[Long](n + 1)\n        val i = new Array[Long](n + 1)\n\
    \        val j = new Array[Long](n + 1)\n        val k = new Array[Long](n + 1)\n\
    \        val l = new Array[Long](n + 1)\n        val m = new Array[Long](n + 1)\n\
    \        val n = new Array[Long](n + 1)\n        val o = new Array[Long](n + 1)\n\
    \        val p = new Array[Long](n + 1)\n        val q = new Array[Long](n + 1)\n\
    \        val r = new Array[Long](n + 1)\n        val s = new Array[Long](n + 1)\n\
    \        val t = new Array[Long](n + 1)\n        val u = new Array[Long](n + 1)\n\
    \        val v = new Array[Long](n + 1)\n        val w = new Array[Long](n + 1)\n\
    \        val x = new Array[Long](n + 1)\n        val y = new Array[Long](n + 1)\n\
    \        val z = new Array[Long](n + 1)\n        val a = new Array[Long](n + 1)\n\
    \        val b = new Array[Long](n + 1)\n        val c = new Array[Long](n + 1)\n\
    \        val d = new Array[Long](n + 1)\n        val e = new Array[Long](n + 1)\n\
    \        val f = new Array[Long](n + 1)\n        val g = new Array[Long](n + 1)\n\
    \        val h = new Array[Long](n + 1)\n        val i = new Array[Long](n + 1)\n\
    \        val j = new Array[Long\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpy5c03bc7.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ']' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpy5c03bc7.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mm\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mLong\e[0m](n + \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpy5c03bc7.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36mn\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mLong\e[0m](n + \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mn is already defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpy5c03bc7.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mp\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mLong\e[0m](n + \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mp is already defined as \e[33mvalue\e[0m \e[35mp\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpy5c03bc7.scala:38:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mLong\e[0m](n + \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpy5c03bc7.scala:39:12\
    \ ------"
  stdout: ''
  timestamp: 1660010363
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val minChange = math.min(arr.take(n - 1), arr.take(n\
    \ - 2))\n        val maxChange = math.max(arr.take(n - 1), arr.take(n - 2))\n\
    \        minChange\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmphf5q0iq0.scala:9:18 ----------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m  |\e[0m                  ^\e[0m\n\e[31m  |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010361
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val palindromic = arr.filter(_ == arr.reverse.head)\n        val changes\
    \ = palindromic.length\n        val min = changes / 2\n        val max = n - changes\
    \ / 2\n        val min = min + min / 2\n        val max = max + max / 2\n    \
    \    val min = min + min / 2\n        val max = max + max / 2\n        val min\
    \ = min + min / 2\n        val max = max + max / 2\n        val min = min + min\
    \ / 2\n        val max = max + max / 2\n        val min = min + min / 2\n    \
    \    val max = max + max / 2\n        val min = min + min / 2\n        val max\
    \ = max + max / 2\n        val min = min + min / 2\n        val max = max + max\
    \ / 2\n        val min = min + min / 2\n        val max = max + max / 2\n    \
    \    val min = min + min / 2\n        val max = max + max / 2\n        val min\
    \ = min + min / 2\n        val max = max + max / 2\n        val min = min + min\
    \ / 2\n        val max = max + max / 2\n        val min = min + min / 2\n    \
    \    val max = max + max / 2\n        val min = min + min / 2\n        val max\
    \ = max + max / 2\n        val min = min + min / 2\n        val max = max + max\
    \ / 2\n        val min = min + min / 2\n        val max = max + max / 2\n    \
    \    val min = min + min / 2\n        val max = max + max / 2\n        val min\
    \ = min + min / 2\n        val max = max + max / 2\n        val min = min + min\
    \ / 2\n        val max = max + max / 2\n        val min = min + min / 2\n    \
    \    val max = max + max / 2\n        val min = min + min / 2\n        val max\
    \ = max + max / 2\n        val min = min + min / 2\n        val max = max + max\
    \ / 2\n        val min = min + min / 2\n        val max = max + max / 2\n    \
    \    val min = min + min / 2\n        val max = max + max / 2\n        val min\
    \ = min + min / 2\n        val max = max + max / 2\n        val min = min + min\
    \ / 2\n        val max = max + max / 2\n        val min = min + min / 2\n    \
    \    val max = max + max \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9e288di3.scala:14:12 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = min + min / \e\
    [31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mmin is already defined as \e[33mvalue\e[0m \e[35mmin\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9e288di3.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmax\e[0m = max + max / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmax is already defined as \e[33mvalue\e[0m \e[35mmax\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp9e288di3.scala:16:12 ---------------------------\e[0m\e[0m\n\e[31m16\
    \ |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = min + min / \e[31m2\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmin is already\
    \ defined as \e[33mvalue\e[0m \e[35mmin\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9e288di3.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = max + max / \e\
    [31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mmax is already defined as \e[33mvalue\e[0m \e[35mmax\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9e288di3.scala:18:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmin\e[0m = min + min / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmin is already defined as \e[33mvalue\e[0m \e[35mmin\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definition"
  stdout: ''
  timestamp: 1660010364
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val p = new Array[Long](n)\n        val r =\
    \ new Array[Long](n)\n        val s = new Array[Long](n)\n        val t = new\
    \ Array[Long](n)\n        val u = new Array[Long](n)\n        val v = new Array[Long](n)\n\
    \        val w = new Array[Long](n)\n        val x = new Array[Long](n)\n    \
    \    val y = new Array[Long](n)\n        val z = new Array[Long](n)\n        val\
    \ a = new Array[Long](n)\n        val b = new Array[Long](n)\n        val c =\
    \ new Array[Long](n)\n        val d = new Array[Long](n)\n        val e = new\
    \ Array[Long](n)\n        val f = new Array[Long](n)\n        val g = new Array[Long](n)\n\
    \        val h = new Array[Long](n)\n        val i = new Array[Long](n)\n    \
    \    val j = new Array[Long](n)\n        val k = new Array[Long](n)\n        val\
    \ l = new Array[Long](n)\n        val m = new Array[Long](n)\n        val n =\
    \ new Array[Long](n)\n        val o = new Array[Long](n)\n        val p = new\
    \ Array[Long](n)\n        val q = new Array[Long](n)\n        val r = new Array[Long](n)\n\
    \        val s = new Array[Long](n)\n        val t = new Array[Long](n)\n    \
    \    val u = new Array[Long](n)\n        val v = new Array[Long](n)\n        val\
    \ w = new Array[Long](n)\n        val x = new Array[Long](n)\n        val y =\
    \ new Array[Long](n)\n        val z = new Array[Long](n)\n        val a = new\
    \ Array[Long](n)\n        val b = new Array[Long](n)\n        val c = new Array[Long](n)\n\
    \        val d = new Array[Long](n)\n        val e = new Array[Long](n)\n    \
    \    val f = new Array[Long](n)\n        val g = new Array[Long](n)\n        val\
    \ h = new Array[Long](n)\n        val i = new Array[Long](n)\n        val j =\
    \ new Array[Long](n)\n        val k = new Array[Long](n)\n        val l = new\
    \ Array[Long](n)\n        val m = new Array[Long](n)\n        val n = new Array[Long](n)\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmph8jeld3k.scala:61:11 ---------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmph8jeld3k.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = \e[33mnew\e[0m\
    \ \e[35mArray\e[0m[\e[35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmph8jeld3k.scala:34:12 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mn is already defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmph8jeld3k.scala:36:12 ---------------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m        \e[33mval\e[0m \e[36mp\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mp is already defined as \e[33mvalue\e[0m \e[35mp\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmph8jeld3k.scala:38:12 ---------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Err"
  stdout: ''
  timestamp: 1660010353
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.take(n/2).length\n        val k = arr.take(n/2).reverse\n\
    \        val l = arr.take(n/2).reverse\n        val m = arr.take(n/2).reverse\n\
    \        val n = arr.take(n/2).reverse\n        val m = arr.take(n/2).reverse\n\
    \        val m = arr.take(n/2).reverse\n        val m = arr.take(n/2).reverse\n\
    \        val m = arr.take(n/2).reverse\n        val m = arr.take(n/2).reverse\n\
    \        val m = arr.take(n/2).reverse\n        val m = arr.take(n/2).reverse\n\
    \        val m = arr.take(n/2).reverse\n        val m = arr.take(n/2).reverse\n\
    \        val m = arr.take(n/2).reverse\n        val m = arr.take(n/2).reverse\n\
    \        val m = arr.take(n/2).reverse\n        val m = arr.take(n/2).reverse\n\
    \        val m = arr.take(n/2).reverse\n        val m = arr.take(n/2).reverse\n\
    \        val m = arr.take(n/2).reverse\n        val m = arr.take(n/2).reverse\n\
    \        val m = arr.take(n/2).reverse\n        val m = arr.take(n/2).reverse\n\
    \        val m = arr.take(n/2).reverse\n        val m = arr.take(n/2).reverse\n\
    \        val m = arr.take(n/2).reverse\n        val m = arr.take(n/2).reverse\n\
    \        val m = arr.take(n/2).reverse\n        val m = arr.take(n/2).reverse\n\
    \        val m = arr.take(n/2).reverse\n        val m = arr.take(n/2).reverse\n\
    \        val m = arr.take(n/2).reverse\n        val m = arr.take(n/2).reverse\n\
    \        val m = arr.take(n/2).reverse\n        val m = arr.take(n/2).reverse\n\
    \        val m = arr.take(n/2).reverse\n        val m = arr.take(n/2).reverse\n\
    \        val m = arr.take(n/2).reverse\n        val m = arr.take(n/2).reverse\n\
    \        val m = arr.take(n/2).reverse\n        val m = arr.take(n/2).reverse\n\
    \        val m = arr.take(n/2).reverse\n        val m = arr.take(n/2).reverse\n\
    \        val m = arr.take(n/2).reverse\n        val m = arr.take(n/2).reverse\n\
    \        val m = arr.take(n/2).reverse\n        val m = arr.take(n/2).reverse\n\
    \        val m = arr.take(n/2).reverse\n        val m = arr.take(n/2).reverse\n\
    \        val m = arr.take(n\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpe44np51q.scala:61:4 ----------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe44np51q.scala:13:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m\
    \ \e[36mm\e[0m = arr.take(n/\e[31m2\e[0m).reverse\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined as\
    \ \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpe44np51q.scala:14:12 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.take(n/\e[31m2\e\
    [0m).reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mn is already defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpe44np51q.scala:15:12 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.take(n/\e[31m2\e[0m).reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe44np51q.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m\
    \ \e[36mm\e[0m = arr.take(n/\e[31m2\e[0m).reverse\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined as\
    \ \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpe44np51q.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.take(n/\e[31m2\e\
    [0m).reverse\n\e[31m\e[3"
  stdout: ''
  timestamp: 1660010364
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val minChange = math.max((arr.head - arr.last) / 2, 0)\n        val changes\
    \ = mutable.ListBuffer.empty[Long]\n        var i = 0\n        while (i < n) {\n\
    \            val j = n - i - 1\n            val k = n - j\n            val diff\
    \ = arr(i) - arr(j)\n            if (diff < 0 || diff > minChange) {\n       \
    \         changes += diff\n            }\n            i += 1\n        }\n    \
    \    changes.min\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5fq0jxha.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010362
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.last\n        val arr = arr.sortBy(-_)\n        val changes\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changed = mutable.ArrayBuffer.empty[Long]\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var change =\
    \ 0\n        var start = 0\n        var end = 0\n        var minChange = 0\n \
    \       while (i < n) {\n            while (j < n && arr(i) == arr(j)) {\n   \
    \             j += 1\n            }\n            while (k < n && arr(i) != arr(k))\
    \ {\n                k += 1\n            }\n            start = i\n          \
    \  end = k\n            while (i < n && j < n && arr(i) == arr(j)) {\n       \
    \         i += 1\n                j += 1\n            }\n            while (i\
    \ < n && k < n && arr(i) != arr(k)) {\n                i += 1\n              \
    \  k += 1\n            }\n            change = end - start\n            if (change\
    \ > minChange) {\n                minChange = change\n            }\n        \
    \    changes += change\n            changed += start\n            changed += end\n\
    \        }\n        minChange\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpdleg5u0t.scala:11:18 ---------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(-_)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpdleg5u0t.scala:12:22 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpdleg5u0t.scala:13:22 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010362
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.max\n        val minChange = math.min(math.ceil(n/2), math.ceil(m/2))\n\
    \        val changes = mutable.ArrayBuffer.empty[Long]\n        val palindromic\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changed = mutable.ArrayBuffer.empty[Long]\n\
    \        val change = mutable.ArrayBuffer.empty[Long]\n        val palindromicChange\
    \ = mutable.ArrayBuffer.empty[Long]\n        val palindromicChanged = mutable.ArrayBuffer.empty[Long]\n\
    \        val palindromicChange = mutable.ArrayBuffer.empty[Long]\n        val\
    \ palindromicChanged = mutable.ArrayBuffer.empty[Long]\n        val palindromicChange\
    \ = mutable.ArrayBuffer.empty[Long]\n        val palindromicChanged = mutable.ArrayBuffer.empty[Long]\n\
    \        val palindromicChange = mutable.ArrayBuffer.empty[Long]\n        val\
    \ palindromicChanged = mutable.ArrayBuffer.empty[Long]\n        val palindromicChange\
    \ = mutable.ArrayBuffer.empty[Long]\n        val palindromicChanged = mutable.ArrayBuffer.empty[Long]\n\
    \        val palindromicChange = mutable.ArrayBuffer.empty[Long]\n        val\
    \ palindromicChanged = mutable.ArrayBuffer.empty[Long]\n        val palindromicChange\
    \ = mutable.ArrayBuffer.empty[Long]\n        val palindromicChanged = mutable.ArrayBuffer.empty[Long]\n\
    \        val palindromicChange = mutable.ArrayBuffer.empty[Long]\n        val\
    \ palindromicChanged = mutable.ArrayBuffer.empty[Long]\n        val palindromicChange\
    \ = mutable.ArrayBuffer.empty[Long]\n        val palindromicChanged = mutable.ArrayBuffer.empty[Long]\n\
    \        val palindromicChange = mutable.ArrayBuffer.empty[Long]\n        val\
    \ palindromicChanged = mutable.ArrayBuffer.empty[Long]\n        val palindromicChange\
    \ = mutable.ArrayBuffer.empty[Long]\n        val palindromicChanged = mutable.ArrayBuffer.empty[Long]\n\
    \        val palindromicChange = mutable.ArrayBuffer.empty[Long]\n        val\
    \ palindromicChanged = mutable.ArrayBuffer.empty[Long]\n        val palindromicChange\
    \ = mutable.ArrayBuffer.empty[Long]\n        val \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp4vxwggul.scala:41:11 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp4vxwggul.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mpalindromicChange\e[0m =\
    \ mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mpalindromicChange is already defined as \e[33mvalue\e[0m \e\
    [35mpalindromicChange\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp4vxwggul.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mpalindromicChanged\e[0m\
    \ = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mpalindromicChanged is already defined as \e[33mvalue\e[0m\
    \ \e[35mpalindromicChanged\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp4vxwggul.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mpalindromicChange\e[0m =\
    \ mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mpalindromicChange is already defined as \e[33mvalue\e[0m \e\
    [35mpalindromicChange\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp4vxwggul.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mpalindromicChanged\e[0m\
    \ = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^"
  stdout: ''
  timestamp: 1660010372
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val result = new Array[Long](n)\n        var\
    \ i = 0\n        var j = 0\n        var k = 0\n        var minChange = Long.MaxValue\n\
    \        var change = 0\n        while (i < n && j < n) {\n            if (arr(i)\
    \ < arr(j)) {\n                change = arr(i) - arr(j)\n                minChange\
    \ = math.min(minChange, change)\n                i += 1\n                j +=\
    \ 1\n            } else if (arr(i) > arr(j)) {\n                change = arr(j)\
    \ - arr(i)\n                minChange = math.min(minChange, change)\n        \
    \        j += 1\n            } else {\n                i += 1\n              \
    \  j += 1\n            }\n        }\n        if (minChange == Long.MaxValue) {\n\
    \            return 0\n        }\n        change = n - i - j\n        minChange\
    \ = math.min(minChange, change)\n        return math.min(minChange, change)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe85y0i8o.scala:19:25\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m                change = arr(i)\
    \ - arr(j)\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Found:    Long\n\e[31m   |\e[0m      \
    \                   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpe85y0i8o.scala:24:25 --------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m                change = arr(j) - arr(i)\n\e[31m\e[31m   |\e[0m      \
    \                   ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \     Found:    Long\n\e[31m   |\e[0m                         Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010372
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.last\n        val max = (n - m) / 2\n        val max2 = max\
    \ / 2\n        val max3 = max / 3\n        val max4 = max / 4\n        val max5\
    \ = max / 5\n        val max6 = max / 6\n        val max7 = max / 7\n        val\
    \ max8 = max / 8\n        val max9 = max / 9\n        val max10 = max / 10\n \
    \       val max11 = max / 11\n        val max12 = max / 12\n        val max13\
    \ = max / 13\n        val max14 = max / 14\n        val max15 = max / 15\n   \
    \     val max16 = max / 16\n        val max17 = max / 17\n        val max18 =\
    \ max / 18\n        val max19 = max / 19\n        val max20 = max / 20\n     \
    \   val max21 = max / 21\n        val max22 = max / 22\n        val max23 = max\
    \ / 23\n        val max24 = max / 24\n        val max25 = max / 25\n        val\
    \ max26 = max / 26\n        val max27 = max / 27\n        val max28 = max / 28\n\
    \        val max29 = max / 29\n        val max30 = max / 30\n        val max31\
    \ = max / 31\n        val max32 = max / 32\n        val max33 = max / 33\n   \
    \     val max34 = max / 34\n        val max35 = max / 35\n        val max36 =\
    \ max / 36\n        val max37 = max / 37\n        val max38 = max / 38\n     \
    \   val max39 = max / 39\n        val max40 = max / 40\n        val max41 = max\
    \ / 41\n        val max42 = max / 42\n        val max43 = max / 43\n        val\
    \ max44 = max / 44\n        val max45 = max / 45\n        val max46 = max / 46\n\
    \        val max47 = max / 47\n        val max48 = max / 48\n        val max49\
    \ = max / 49\n        val max50 = max / 50\n        val max51 = max / 51\n   \
    \     val max52 = max / 52\n        val max53 = max / 53\n        val max54 =\
    \ max / 54\n        val max55 = max / 55\n        val max56 = max / 56\n     \
    \   val max57 = max / 57\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsa69flze.scala:68:5\
    \ ---------------------\e[0m\e[0m\n\e[31m68 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010372
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val changes = mutable.ArrayBuffer.empty[Int]\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        while (i < n\
    \ && j < m) {\n            if (arr(i) < arr(j)) {\n                changes +=\
    \ k\n                i += 1\n            } else {\n                changes +=\
    \ k\n                j += 1\n            }\n            k += 1\n        }\n  \
    \      if (i < n) {\n            changes += k\n        }\n        if (j < m) {\n\
    \            changes += k\n        }\n        changes.min\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpcdjn1z8m.scala:11:18 ---------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpcdjn1z8m.scala:12:22 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010368
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val result = new Array[Long](n)\n        var\
    \ i = 0\n        var j = 0\n        var k = 0\n        var minChange = 0\n   \
    \     var minChangeIndex = 0\n        var isPalindromic = false\n        while\
    \ (i < n && j < n) {\n            if (arr(i) == arr(j)) {\n                i +=\
    \ 1\n                j += 1\n                k += 1\n            } else {\n  \
    \              if (arr(i) < arr(j)) {\n                    minChange = minChange\
    \ + 1\n                    minChangeIndex = k\n                    isPalindromic\
    \ = false\n                } else {\n                    minChange = minChange\
    \ + 1\n                    minChangeIndex = k\n                    isPalindromic\
    \ = true\n                }\n                i += 1\n                j += 1\n\
    \                k += 1\n            }\n        }\n        if (isPalindromic)\
    \ {\n            minChange = minChange + 1\n            minChangeIndex = k\n \
    \       }\n        val minChangeCount = minChangeIndex + 1\n        if (minChangeCount\
    \ > m) {\n            minChangeCount = m\n        }\n        result(minChangeIndex)\
    \ = minChangeCount\n        result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwb7wx_gj.scala:44:29\
    \ --------------------\e[0m\e[0m\n\e[31m44 |\e[0m            minChangeCount =\
    \ m\n\e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m\
    \                             Found:    (m : Long)\n\e[31m   |\e[0m          \
    \                   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpwb7wx_gj.scala:47:8 ---------------------\e[0m\e[0m\n\e[31m47\
    \ |\e[0m        result\n\e[31m\e[31m   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e\
    [0m        Found:    (result : Array[Long])\n\e[31m   |\e[0m        Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010372
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val maxChange = arr.foldLeft(0)(_ + arr.last)\n\
    \        val minChange = arr.foldLeft(0)(_ + arr.head)\n        val maxChange2\
    \ = arr.foldLeft(0)(_ + arr.last)\n        val minChange2 = arr.foldLeft(0)(_\
    \ + arr.head)\n        val maxChange3 = arr.foldLeft(0)(_ + arr.last)\n      \
    \  val minChange3 = arr.foldLeft(0)(_ + arr.head)\n        val maxChange4 = arr.foldLeft(0)(_\
    \ + arr.last)\n        val minChange4 = arr.foldLeft(0)(_ + arr.head)\n      \
    \  val maxChange5 = arr.foldLeft(0)(_ + arr.last)\n        val minChange5 = arr.foldLeft(0)(_\
    \ + arr.head)\n        val maxChange6 = arr.foldLeft(0)(_ + arr.last)\n      \
    \  val minChange6 = arr.foldLeft(0)(_ + arr.head)\n        val maxChange7 = arr.foldLeft(0)(_\
    \ + arr.last)\n        val minChange7 = arr.foldLeft(0)(_ + arr.head)\n      \
    \  val maxChange8 = arr.foldLeft(0)(_ + arr.last)\n        val minChange8 = arr.foldLeft(0)(_\
    \ + arr.head)\n        val maxChange9 = arr.foldLeft(0)(_ + arr.last)\n      \
    \  val minChange9 = arr.foldLeft(0)(_ + arr.head)\n        val maxChange10 = arr.foldLeft(0)(_\
    \ + arr.last)\n        val minChange10 = arr.foldLeft(0)(_ + arr.head)\n     \
    \   val maxChange11 = arr.foldLeft(0)(_ + arr.last)\n        val minChange11 =\
    \ arr.foldLeft(0)(_ + arr.head)\n        val maxChange12 = arr.foldLeft(0)(_ +\
    \ arr.last)\n        val minChange12 = arr.foldLeft(0)(_ + arr.head)\n       \
    \ val maxChange13 = arr.foldLeft(0)(_ + arr.last)\n        val minChange13 = arr.foldLeft(0)(_\
    \ + arr.head)\n        val maxChange14 = arr.foldLeft(0)(_ + arr.last)\n     \
    \   val minChange14 = arr.foldLeft(0)(_ + arr.head)\n        val maxChange15 =\
    \ arr.foldLeft(0)(_ + arr.last)\n        val minChange15 = arr.foldLeft(0)(_ +\
    \ arr.\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvrzi2n2m.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpvrzi2n2m.scala:9:18 ----------------------------\e[0m\e[0m\n\e[31m9\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m  |\e\
    [0m                  ^\e[0m\n\e[31m  |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpvrzi2n2m.scala:41:5 ---------------------\e[0m\e[0m\n\e[31m41\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010372
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val p = new Array[Long](n)\n        val r =\
    \ new Array[Long](n)\n        var i = 0\n        var j = 0\n        var k = 0\n\
    \        var min = Long.MaxValue\n        var max = 0\n        while(i < n) {\n\
    \            p(i) = arr(i)\n            i += 1\n        }\n        while(j < n)\
    \ {\n            r(j) = arr(j)\n            j += 1\n        }\n        while(i\
    \ < n) {\n            k = j\n            while(k >= 0 && r(k) == p(i)) {\n   \
    \             k -= 1\n            }\n            if(k > 0) {\n               \
    \ min = Math.min(min, k - i)\n                max = Math.max(max, k - i)\n   \
    \         }\n            i += 1\n        }\n        return min + max\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmph7bxq62u.scala:40)\n\tat Problem.main(tmph7bxq62u.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010374
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        var i = 0\n        var j = 0\n        var\
    \ changes = 0\n        while(i < len) {\n            while(j < len) {\n      \
    \          if(arr(i) != arr(j)) {\n                    j++\n                }\
    \ else {\n                    j++\n                    changes++\n           \
    \     }\n            }\n            i += 1\n            j = 0\n        }\n   \
    \     changes\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpwjz_sxza.scala:17:23 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpwjz_sxza.scala:20:29 ---------------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m                    changes++\n\e[31m\e[31m   |\e[0m                 \
    \            ^\e[0m\n\e[31m   |\e[0m                             expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpwjz_sxza.scala:9:18 ----------------------------\e[0m\e[0m\n\e[31m9\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m  |\e\
    [0m                  ^\e[0m\n\e[31m  |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpwjz_sxza.scala:19:21 ------------------------\e[0m\e[0m\n\e[31m19 |\e\
    [0m                    j++\n\e[31m\e[31m   |\e[0m                    ^^^\e[0m\n\
    \e[31m   |\e[0m                    value ++ is not a member of Int\n4 errors found\n"
  stdout: ''
  timestamp: 1660010373
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = n/2\n        val arr = arr.toList\n        val changes = mutable.ListBuffer[Long]()\n\
    \        val change = mutable.ListBuffer[Long]()\n        val changed = mutable.ListBuffer[Long]()\n\
    \        val changed1 = mutable.ListBuffer[Long]()\n        val changed2 = mutable.ListBuffer[Long]()\n\
    \        val changed3 = mutable.ListBuffer[Long]()\n        val changed4 = mutable.ListBuffer[Long]()\n\
    \        val changed5 = mutable.ListBuffer[Long]()\n        val changed6 = mutable.ListBuffer[Long]()\n\
    \        val changed7 = mutable.ListBuffer[Long]()\n        val changed8 = mutable.ListBuffer[Long]()\n\
    \        val changed9 = mutable.ListBuffer[Long]()\n        val changed10 = mutable.ListBuffer[Long]()\n\
    \        val changed11 = mutable.ListBuffer[Long]()\n        val changed12 = mutable.ListBuffer[Long]()\n\
    \        val changed13 = mutable.ListBuffer[Long]()\n        val changed14 = mutable.ListBuffer[Long]()\n\
    \        val changed15 = mutable.ListBuffer[Long]()\n        val changed16 = mutable.ListBuffer[Long]()\n\
    \        val changed17 = mutable.ListBuffer[Long]()\n        val changed18 = mutable.ListBuffer[Long]()\n\
    \        val changed19 = mutable.ListBuffer[Long]()\n        val changed20 = mutable.ListBuffer[Long]()\n\
    \        val changed21 = mutable.ListBuffer[Long]()\n        val changed22 = mutable.ListBuffer[Long]()\n\
    \        val changed23 = mutable.ListBuffer[Long]()\n        val changed24 = mutable.ListBuffer[Long]()\n\
    \        val changed25 = mutable.ListBuffer[Long]()\n        val changed26 = mutable.ListBuffer[Long]()\n\
    \        val changed27 = mutable.ListBuffer[Long]()\n        val changed28 = mutable.ListBuffer[Long]()\n\
    \        val changed29 = mutable.ListBuffer[Long]()\n        val changed30 = mutable.ListBuffer[Long]()\n\
    \        val changed31 = mutable.ListBuffer[Long]()\n        val changed32\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpo9y5cnwl.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpo9y5cnwl.scala:11:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo9y5cnwl.scala:12:22\
    \ ------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e\
    [36mchanges\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo9y5cnwl.scala:13:21\
    \ ------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e\
    [36mchange\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo9y5cnwl.scala:14:22\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mchanged\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo9y5cnwl.scala:15:23\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mchanged1\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \ Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation a"
  stdout: ''
  timestamp: 1660010372
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val minChange =\
    \ arr.size\n        var change = 0\n        var i = 0\n        var j = arr.size\
    \ - 1\n        while (i < j) {\n            if (arr(i) != arr(j)) {\n        \
    \        change += 1\n            }\n            i += 1\n            j -= 1\n\
    \        }\n        minChange\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7hxo9kir.scala:23)\n\tat Problem.main(tmp7hxo9kir.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010374
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val p = new Array[Long](n)\n        val r =\
    \ new Array[Long](n)\n        val minChange = Long.MaxValue\n        val maxChange\
    \ = Long.MinValue\n        val changes = mutable.ArrayBuffer.empty[Long]\n   \
    \     val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeIndex = mutable.ArrayBuffer.empty[Int]\n        val changeIndex2\
    \ = mutable.ArrayBuffer.empty[Int]\n        val changeIndex3 = mutable.ArrayBuffer.empty[Int]\n\
    \        val changeIndex4 = mutable.ArrayBuffer.empty[Int]\n        val changeIndex5\
    \ = mutable.ArrayBuffer.empty[Int]\n        val changeIndex6 = mutable.ArrayBuffer.empty[Int]\n\
    \        val changeIndex7 = mutable.ArrayBuffer.empty[Int]\n        val changeIndex8\
    \ = mutable.ArrayBuffer.empty[Int]\n        val changeIndex9 = mutable.ArrayBuffer.empty[Int]\n\
    \        val changeIndex10 = mutable.ArrayBuffer.empty[Int]\n        val changeIndex11\
    \ = mutable.ArrayBuffer.empty[Int]\n        val changeIndex12 = mutable.ArrayBuffer.empty[Int]\n\
    \        val changeIndex13 = mutable.ArrayBuffer.empty[Int]\n        val changeIndex14\
    \ = mutable.ArrayBuffer.empty[Int]\n        val changeIndex15 = mutable.ArrayBuffer.empty[Int]\n\
    \        val changeIndex16 = mutable.ArrayBuffer.empty[Int]\n        val changeIndex17\
    \ = mutable.ArrayBuffer.empty[Int]\n        val changeIndex18 = mutable.ArrayBuffer.empty[Int]\n\
    \        val changeIndex19 = mutable.ArrayBuffer.empty[Int]\n        val changeIndex20\
    \ = mutable.ArrayBuffer.empty[Int]\n        val changeIndex21 = mutable.ArrayBuffer.empty[Int]\n\
    \        val changeIndex22 = mutable.ArrayBuffer.empty[Int]\n        val changeIndex23\
    \ = mutable.ArrayBuffer.empty[Int]\n        val changeIndex24 = mutable.ArrayBuffer.empty[Int]\n\
    \        val changeIndex25 = mutable.ArrayBuffer.empty[Int]\n        val changeIndex26\
    \ = mutable.ArrayBuffer.empty[Int]\n        val changeIndex27 = mutable.ArrayBuffer.empty[Int]\n\
    \        val changeIndex28 = mutable.ArrayBuffer.empty[Int]\n        val changeIndex29\
    \ = mutable.ArrayBuffer.empty[Int]\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyhmfigqu.scala:15:22 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpyhmfigqu.scala:16:22 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpyhmfigqu.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpyhmfigqu.scala:18:26 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mchangeIndex\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpyhmfigqu.scala:19:27 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mchangeIndex2\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpyhmfigqu.scala:20:27 ------------------------\e"
  stdout: ''
  timestamp: 1660010373
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val p = new Array[Long](n)\n        val r =\
    \ new Array[Long](n)\n        val s = new Array[Long](n)\n        val minChange\
    \ = math.min(m, n)\n        val maxChange = math.max(m, n)\n        val changes\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changed = mutable.ArrayBuffer.empty[Long]\n\
    \        var i = 0\n        while (i < minChange) {\n            val j = i + 1\n\
    \            while (j < maxChange) {\n                if (arr(i) == arr(j)) {\n\
    \                    s(i) = arr(i)\n                    s(j) = arr(j)\n      \
    \              p.update(i, arr(i))\n                    p.update(j, arr(j))\n\
    \                    r.update(i, arr(j))\n                    r.update(j, arr(i))\n\
    \                    changes += arr(i)\n                    changes += arr(j)\n\
    \                    changed(i) = arr(i)\n                    changed(j) = arr(j)\n\
    \                    i += 1\n                    j += 1\n                }\n \
    \               j += 1\n            }\n            i += 1\n        }\n       \
    \ val change = changes.length\n        if (change == 0) {\n            return\
    \ 0\n        }\n        val changed = changed.length\n        val changes = changes.length\n\
    \        val change = changes.length\n        val change = changes.length\n  \
    \      val change = changes.length\n        val change = changes.length\n    \
    \    val change = changes.length\n        val change = changes.length\n      \
    \  val change = changes.length\n        val change = changes.length\n        val\
    \ change = changes.length\n        val change = changes.length\n        val change\
    \ = changes.length\n        val change = changes.length\n        val change =\
    \ changes.length\n        val change = changes.length\n        val change = changes.length\n\
    \        val change = changes.length\n        val change = changes.length\n  \
    \      val change = changes.length\n        val change = changes.length\n    \
    \    val change = changes.length\n        val change = changes.length\n      \
    \  val change = changes.length\n        val change = changes.length\n        val\
    \ change = changes.length\n        val change = changes.length\n        val change\
    \ = changes.length\n        val change = changes.length\n        val change =\
    \ changes.length\n        val change = changes.length\n        val change = changes.length\n\
    \        val change = changes.length\n        val change = changes.length\n  \
    \      val change = changes.length\n        val change = changes.length\n    \
    \    val change = changes.length\n        val change = changes.length\n      \
    \  val change = changes.length\n        val change = changes.length\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmph51jl7hv.scala:44:12 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = changed.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mchanged\
    \ is already defined as \e[33mvalue\e[0m \e[35mchanged\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmph51jl7hv.scala:45:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m\
    \ \e[36mchanges\e[0m = changes.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchanges is already defined as \e[33mvalue\e[0m \e[35mchanges\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmph51jl7hv.scala:46:12 ---------------------------\e[0m\e[0m\n\e\
    [31m46 |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = changes.length\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mchange is\
    \ already defined as \e[33mvalue\e[0m \e[35mchange\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmph51jl7hv.scala:47:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m\
    \ \e[36mchange\e[0m = changes.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchange is already defined as \e[33mvalue\e[0m \e[35mchange\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmph51jl7hv.scala:48:12 ---------------------------\e[0m\e[0m\n\e\
    [31m48 |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = changes.length\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mchange is\
    \ already defined as \e[33mvalue\e[0m \e[35mchange\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the "
  stdout: ''
  timestamp: 1660010374
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        val maxChange\
    \ = len\n        var i = 0\n        var j = 0\n        var change = 0\n      \
    \  while (i < len) {\n            while (j < len) {\n                if (arr(i)\
    \ != arr(j)) {\n                    change = change + 1\n                }\n \
    \               j = j + 1\n            }\n            i = i + 1\n            j\
    \ = j - 1\n            if (change < minChange) {\n                minChange =\
    \ change\n            }\n            if (change > maxChange) {\n             \
    \   maxChange = change\n            }\n            change = 0\n        }\n   \
    \     minChange\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmprjg_qe99.scala:9:18 ----------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m  |\e[0m                  ^\e[0m\n\e[31m  |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmprjg_qe99.scala:26:26 -----------------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m                minChange = change\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val minChange\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmprjg_qe99.scala:29:26\
    \ -----------------------------\e[0m\e[0m\n\e[31m29 |\e[0m                maxChange\
    \ = change\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                Reassignment to val maxChange\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010370
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.last\n        val changes = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeIndex = mutable.ArrayBuffer.empty[Long]\n        val changeIndex2\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeIndex3 = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeIndex4 = mutable.ArrayBuffer.empty[Long]\n        val changeIndex5\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeIndex6 = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeIndex7 = mutable.ArrayBuffer.empty[Long]\n        val changeIndex8\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeIndex9 = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeIndex10 = mutable.ArrayBuffer.empty[Long]\n        val changeIndex11\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeIndex12 = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeIndex13 = mutable.ArrayBuffer.empty[Long]\n        val changeIndex14\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeIndex15 = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeIndex16 = mutable.ArrayBuffer.empty[Long]\n        val changeIndex17\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeIndex18 = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeIndex19 = mutable.ArrayBuffer.empty[Long]\n        val changeIndex20\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeIndex21 = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeIndex22 = mutable.ArrayBuffer.empty[Long]\n        val changeIndex23\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeIndex24 = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeIndex25 = mutable.ArrayBuffer.empty[Long]\n        val changeIndex26\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeIndex27 = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeIndex28 = mutable.ArrayBuffer.empty[Long]\n        val changeIndex29\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeIndex30 = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeIndex31 = mutable.ArrayBuffer.empty[Long]\n        val changeIndex32\
    \ = mutable.Array\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgi4f5jer.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpgi4f5jer.scala:12:22 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpgi4f5jer.scala:13:21 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpgi4f5jer.scala:14:26 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mchangeIndex\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpgi4f5jer.scala:15:27 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mchangeIndex2\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpgi4f5jer.scala:16:27 -----------------------"
  stdout: ''
  timestamp: 1660010373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val minChange =\
    \ arr.size\n        val reversed = arr.reverse\n        var i = 0\n        var\
    \ j = 0\n        while(i < minChange && j < reversed.size) {\n            if(arr(i)\
    \ == reversed(j)) {\n                i += 1\n                j += 1\n        \
    \    } else {\n                i += 1\n            }\n        }\n        minChange\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsv8q8n9t.scala:24)\n\tat Problem.main(tmpsv8q8n9t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010375
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val changes = mutable.ListBuffer[Long]()\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        while (i < n)\
    \ {\n            while (j < n && arr(i) == arr(j)) {\n                j += 1\n\
    \            }\n            while (k < n && arr(i) != arr(k)) {\n            \
    \    k += 1\n            }\n            val change = k - j\n            changes\
    \ += change\n            i += change\n            j += change\n            k +=\
    \ change\n        }\n        changes.min\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjhocbf26.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010372
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.max\n        val maxChange = arr.foldLeft(0)((acc, x) =>\
    \ if (x == m) acc else acc + 1)\n        val minChange = arr.foldLeft(0)((acc,\
    \ x) => if (x == 0) acc else acc + 1)\n        if (maxChange == minChange) maxChange\n\
    \        else maxChange - minChange\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyeoz37me.scala:17)\n\tat Problem.main(tmpyeoz37me.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010377
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val result = new Array[Long](n)\n        var\
    \ i = 0\n        var j = 0\n        var k = 0\n        var minChange = 0\n   \
    \     var maxChange = 0\n        while(i < n && j < n) {\n            if(arr(i)\
    \ < arr(j)) {\n                result(i) = arr(i)\n                i += 1\n  \
    \          } else {\n                result(j) = arr(j)\n                j +=\
    \ 1\n            }\n            k += 1\n        }\n        while(i < n) {\n  \
    \          result(i) = arr(i)\n            i += 1\n            k += 1\n      \
    \  }\n        while(j < n) {\n            result(j) = arr(j)\n            j +=\
    \ 1\n            k += 1\n        }\n        while(k != 0) {\n            minChange\
    \ = math.min(minChange, k)\n            maxChange = math.max(maxChange, k)\n \
    \           k -= 1\n        }\n        if(minChange == maxChange) {\n        \
    \    return minChange\n        } else {\n            return minChange + maxChange\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1wnldiqi.scala:49)\n\tat Problem.main(tmp1wnldiqi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010376
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val m = arr.length\n\
    \        val n = arr.head\n        val changes = mutable.ArrayBuffer.empty[Long]\n\
    \        val change = mutable.ArrayBuffer.empty[Long]\n        val changed = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeMap = mutable.HashMap.empty[Long, Long]\n        val changeMap2\
    \ = mutable.HashMap.empty[Long, Long]\n        val changeMap3 = mutable.HashMap.empty[Long,\
    \ Long]\n        val changeMap4 = mutable.HashMap.empty[Long, Long]\n        val\
    \ changeMap5 = mutable.HashMap.empty[Long, Long]\n        val changeMap6 = mutable.HashMap.empty[Long,\
    \ Long]\n        val changeMap7 = mutable.HashMap.empty[Long, Long]\n        val\
    \ changeMap8 = mutable.HashMap.empty[Long, Long]\n        val changeMap9 = mutable.HashMap.empty[Long,\
    \ Long]\n        val changeMap10 = mutable.HashMap.empty[Long, Long]\n       \
    \ val changeMap11 = mutable.HashMap.empty[Long, Long]\n        val changeMap12\
    \ = mutable.HashMap.empty[Long, Long]\n        val changeMap13 = mutable.HashMap.empty[Long,\
    \ Long]\n        val changeMap14 = mutable.HashMap.empty[Long, Long]\n       \
    \ val changeMap15 = mutable.HashMap.empty[Long, Long]\n        val changeMap16\
    \ = mutable.HashMap.empty[Long, Long]\n        val changeMap17 = mutable.HashMap.empty[Long,\
    \ Long]\n        val changeMap18 = mutable.HashMap.empty[Long, Long]\n       \
    \ val changeMap19 = mutable.HashMap.empty[Long, Long]\n        val changeMap20\
    \ = mutable.HashMap.empty[Long, Long]\n        val changeMap21 = mutable.HashMap.empty[Long,\
    \ Long]\n        val changeMap22 = mutable.HashMap.empty[Long, Long]\n       \
    \ val changeMap23 = mutable.HashMap.empty[Long, Long]\n        val changeMap24\
    \ = mutable.HashMap.empty[Long, Long]\n        val changeMap25 = mutable.HashMap.empty[Long,\
    \ Long]\n        val changeMap26 = mutable.HashMap.empty[Long, Long]\n       \
    \ val changeMap27 = mutable.HashMap.empty[Long, Long]\n        val changeMap28\
    \ = mutable.HashMap.empty[Long, Long\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmx5ir0of.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ']' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmx5ir0of.scala:11:22\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mchanges\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmx5ir0of.scala:12:21\
    \ ------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e\
    [36mchange\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmx5ir0of.scala:13:22\
    \ ------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e\
    [36mchanged\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmx5ir0of.scala:14:24\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mchangeMap\e[0m = mutable.HashMap.empty[\e[35mLong\e[0m, \e[35mLong\e[0m]\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpmx5ir0of.scala:15:25 ------------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mchangeMap2\e[0m = mutable.HashMap.empty[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                       \
    \  ^^^^^^^\e[0m\n\e[31m   |\e[0m                    "
  stdout: ''
  timestamp: 1660010374
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val minChange = math.max((arr.length / 2) * (arr.length / 2), 0)\n  \
    \      val changes = mutable.ArrayBuffer.empty[Long]\n        var i = 0\n    \
    \    while (i < n) {\n            val j = n - i - 1\n            val k = j - 1\n\
    \            val x = arr(i)\n            val y = arr(j)\n            val z = arr(k)\n\
    \            if (x == y && x == z) {\n                changes += x\n         \
    \       i += 1\n            } else if (x == y || x == z) {\n                if\
    \ (x == y) {\n                    changes += x\n                    i += 1\n \
    \               } else {\n                    changes += y\n                 \
    \   i -= 1\n                }\n            } else {\n                changes +=\
    \ z\n                i -= 1\n            }\n        }\n        minChange\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptzr1cbi8.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010373
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        var minChange = len\n        var minChangeIndex\
    \ = 0\n        var minChangeIndex2 = len\n        var minChangeIndex3 = len\n\
    \        var minChangeIndex4 = len\n        var minChangeIndex5 = len\n      \
    \  var minChangeIndex6 = len\n        var minChangeIndex7 = len\n        var minChangeIndex8\
    \ = len\n        var minChangeIndex9 = len\n        var minChangeIndex10 = len\n\
    \        var minChangeIndex11 = len\n        var minChangeIndex12 = len\n    \
    \    var minChangeIndex13 = len\n        var minChangeIndex14 = len\n        var\
    \ minChangeIndex15 = len\n        var minChangeIndex16 = len\n        var minChangeIndex17\
    \ = len\n        var minChangeIndex18 = len\n        var minChangeIndex19 = len\n\
    \        var minChangeIndex20 = len\n        var minChangeIndex21 = len\n    \
    \    var minChangeIndex22 = len\n        var minChangeIndex23 = len\n        var\
    \ minChangeIndex24 = len\n        var minChangeIndex25 = len\n        var minChangeIndex26\
    \ = len\n        var minChangeIndex27 = len\n        var minChangeIndex28 = len\n\
    \        var minChangeIndex29 = len\n        var minChangeIndex30 = len\n    \
    \    var minChangeIndex31 = len\n        var minChangeIndex32 = len\n        var\
    \ minChangeIndex33 = len\n        var minChangeIndex34 = len\n        var minChangeIndex35\
    \ = len\n        var minChangeIndex36 = len\n        var minChangeIndex37 = len\n\
    \        var minChangeIndex38 = len\n        var minChangeIndex39 = len\n    \
    \    var minChangeIndex40 = len\n        var minChangeIndex41 = len\n        var\
    \ minChangeIndex42 = len\n        var minChangeIndex43 = len\n        var minChangeIndex44\
    \ = len\n        var minChangeIndex45 = len\n        var minChangeIndex46 = len\n\
    \        var minChangeIndex47 = len\n        var minChangeIndex48 = len\n    \
    \    var minChangeIndex49 = len\n        var minChangeIndex50 = len\n        var\
    \ minChangeIndex51 = len\n        var minChangeIndex52 = len\n        var minChangeIndex53\
    \ = len\n        var minChangeIndex54 = len\n        var minChangeIndex55 = len\n\
    \        var minChangeIndex56 = len\n        var minChangeIndex57 = len\n    \
    \    var minChangeIndex58 = len\n        var minChangeIndex59 = len\n        var\
    \ minChangeIndex60 = len\n        var minChangeIndex61 = len\n        var minChangeIndex62\
    \ = len\n        var minChangeIndex63 = len\n        var min\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjq2sms1z.scala:76:4 ----------------------------\e\
    [0m\e[0m\n\e[31m76 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpjq2sms1z.scala:9:18\
    \ ----------------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m  |\e[0m                  ^\e[0m\n\e\
    [31m  |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjq2sms1z.scala:76:5\
    \ ---------------------\e[0m\e[0m\n\e[31m76 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010375
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val arr = arr.sortBy(-_)\n        val changes = mutable.ArrayBuffer.empty[Long]\n\
    \        var i = 0\n        while (i < n) {\n            if (arr(i) != arr(n-i))\
    \ {\n                changes += arr(i)\n            }\n            i += 1\n  \
    \      }\n        changes.min\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpjr_tbgdg.scala:10:18 ---------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(-_)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpjr_tbgdg.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010372
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val minChange =\
    \ arr.size\n        val changes = mutable.ListBuffer[Long]()\n        val reversed\
    \ = arr.reverse\n        val reversedSize = reversed.size\n        val reversedArray\
    \ = reversed.toArray\n        val reversedArraySize = reversedArray.length\n \
    \       val reversedArrayIterator = reversedArray.iterator\n        val reversedArrayIteratorSize\
    \ = reversedArrayIterator.length\n        val reversedArrayIteratorElement = reversedArrayIterator.next\n\
    \        val reversedArrayIteratorElementSize = reversedArrayIteratorElement.length\n\
    \        val reversedArrayIteratorElementElement = reversedArrayIteratorElement.next\n\
    \        val reversedArrayIteratorElementElementSize = reversedArrayIteratorElementElement.length\n\
    \        val reversedArrayIteratorElementElementElement = reversedArrayIteratorElementElement.next\n\
    \        val reversedArrayIteratorElementElementElementSize = reversedArrayIteratorElementElementElement.length\n\
    \        val reversedArrayIteratorElementElementElementElement = reversedArrayIteratorElementElementElement.next\n\
    \        val reversedArrayIteratorElementElementElementSize = reversedArrayIteratorElementElementElement.length\n\
    \        val reversedArrayIteratorElementElementElementElement = reversedArrayIteratorElementElementElement.next\n\
    \        val reversedArrayIteratorElementElementElementSize = reversedArrayIteratorElementElementElementElement.length\n\
    \        val reversedArrayIteratorElementElementElementElement = reversedArrayIteratorElementElementElement.next\n\
    \        val reversedArrayIteratorElementElementElementSize = reversedArrayIteratorElementElementElementElement.length\n\
    \        val reversedArrayIteratorElementElementElementElement = reversedArrayIteratorElementElementElement.next\n\
    \        val reversedArrayIteratorElementElementElementSize = reversedArrayIteratorElementElementElementElement.length\n\
    \        val reversedArrayIteratorElementElementElementElement = reversedArrayIteratorElementElementElement.next\n\
    \        val reversedArrayIteratorElementElementElementSize = reversedArrayIteratorElementElementElementElement.length\n\
    \        val reversedArrayIteratorElementElementElementElement = reversedArrayIteratorElementElementElement.next\n\
    \        val reversedArrayIteratorElementElementElementSize = reversedArrayIteratorElementElementElementElement.length\n\
    \        val reversedArrayIteratorElementElementElementElement = reversedArrayIteratorElementElementElement.next\n\
    \        val reversedArrayIteratorElementElementElementSize = reversedArrayIteratorElementElementElementElement.length\n\
    \        val reversedArrayIteratorElementElementElementElement = reversedArrayIteratorElementElementElement.next\n\
    \        val reversedArrayIteratorElementElementElementSize = reversedArrayIteratorElementElementElementElement.length\n\
    \        val reversedArrayIteratorElementElementElement\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpsvcu1d9d.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsvcu1d9d.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mreversedArrayIteratorElementElementElementSize\e[0m = reversedArrayIteratorElementElementElement.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mreversedArrayIteratorElementElementElementSize is already\
    \ defined as \e[33mvalue\e[0m \e[35mreversedArrayIteratorElementElementElementSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpsvcu1d9d.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mreversedArrayIteratorElementElementElementElement\e\
    [0m = reversedArrayIteratorElementElementElement.next\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mreversedArrayIteratorElementElementElementElement is already\
    \ defined as \e[33mvalue\e[0m \e[35mreversedArrayIteratorElementElementElementElement\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpsvcu1d9d.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36mreversedArrayIteratorElementElementElementSize\e\
    [0m = reversedArrayIteratorElementElementElementElement.length\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mreversedArrayIteratorElementElementElementSize is already\
    \ defined as \e[33mvalue\e[0m \e[35mreversedArrayIteratorElementElementElementSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31"
  stdout: ''
  timestamp: 1660010377
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val changes = mutable.ArrayBuffer.empty[Long]\n\
    \        val change = mutable.ArrayBuffer.empty[Long]\n        val changeCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCounts = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeCounts_ = mutable.ArrayBuffer.empty[Long]\n        val changeCounts_1\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCounts_2 = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeCounts_3 = mutable.ArrayBuffer.empty[Long]\n        val changeCounts_4\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCounts_5 = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeCounts_6 = mutable.ArrayBuffer.empty[Long]\n        val changeCounts_7\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCounts_8 = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeCounts_9 = mutable.ArrayBuffer.empty[Long]\n        val changeCounts_10\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCounts_11 = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeCounts_12 = mutable.ArrayBuffer.empty[Long]\n        val changeCounts_13\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCounts_14 = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeCounts_15 = mutable.ArrayBuffer.empty[Long]\n        val changeCounts_16\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCounts_17 = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeCounts_18 = mutable.ArrayBuffer.empty[Long]\n        val changeCounts_19\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCounts_20 = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeCounts_21 = mutable.ArrayBuffer.empty[Long]\n        val changeCounts_22\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCounts_23 = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeCounts_24 = mutable.ArrayBuffer.empty[Long]\n        val changeCounts_25\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCounts_26 = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeCounts_27 = mutable.ArrayBuffer.empty[Long]\n        val changeCounts_28\
    \ = mutable.ArrayBuffer.empty\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4jskte7y.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp4jskte7y.scala:12:21 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp4jskte7y.scala:13:26 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mchangeCount\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp4jskte7y.scala:14:27 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mchangeCounts\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp4jskte7y.scala:15:28 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mchangeCounts_\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                            Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp4jskte7y.scala:16:29 -----"
  stdout: ''
  timestamp: 1660010378
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        var i = 0\n        var j = 0\n        var change\
    \ = 0\n        var changeCount = 0\n        var changeCountMin = 0\n        var\
    \ changeCountMax = 0\n        var changeCountMaxMin = 0\n        var changeCountMinMax\
    \ = 0\n        var changeCountMinMaxMin = 0\n        var changeCountMinMaxMinMin\
    \ = 0\n        var changeCountMinMaxMinMinMin = 0\n        var changeCountMinMaxMinMinMin\
    \ = 0\n        var changeCountMinMaxMinMinMin = 0\n        var changeCountMinMaxMinMinMin\
    \ = 0\n        var changeCountMinMaxMinMinMin = 0\n        var changeCountMinMaxMinMinMin\
    \ = 0\n        var changeCountMinMaxMinMinMin = 0\n        var changeCountMinMaxMinMinMin\
    \ = 0\n        var changeCountMinMaxMinMinMin = 0\n        var changeCountMinMaxMinMinMin\
    \ = 0\n        var changeCountMinMaxMinMinMin = 0\n        var changeCountMinMaxMinMinMin\
    \ = 0\n        var changeCountMinMaxMinMinMin = 0\n        var changeCountMinMaxMinMinMin\
    \ = 0\n        var changeCountMinMaxMinMinMin = 0\n        var changeCountMinMaxMinMinMin\
    \ = 0\n        var changeCountMinMaxMinMinMin = 0\n        var changeCountMinMaxMinMinMin\
    \ = 0\n        var changeCountMinMaxMinMinMin = 0\n        var changeCountMinMaxMinMinMin\
    \ = 0\n        var changeCountMinMaxMinMinMin = 0\n        var changeCountMinMaxMinMinMin\
    \ = 0\n        var changeCountMinMaxMinMinMin = 0\n        var changeCountMinMaxMinMinMin\
    \ = 0\n        var changeCountMinMaxMinMinMin = 0\n        var changeCountMinMaxMinMinMin\
    \ = 0\n        var changeCountMinMaxMinMinMin = 0\n        var changeCountMinMaxMinMinMin\
    \ = 0\n        var changeCountMinMaxMinMinMin = 0\n        var changeCountMinMaxMinMinMin\
    \ = 0\n        var changeCountMinMaxMinMinMin = 0\n        var changeCountMinMaxMinMinMin\
    \ = 0\n        var changeCountMinMaxMinMinMin = 0\n        var changeCountMinMaxMinMinMin\
    \ = 0\n        var changeCountMinMaxMinMinMin = 0\n        var changeCountMinMaxMinMinMin\
    \ = 0\n        var changeCountMinMaxMinMinMin = 0\n        var changeCountMinMaxMinMinMin\
    \ = 0\n        var changeCountMinMaxMinMinMin = 0\n        var changeCountMinMaxMinMinMin\
    \ = 0\n        var changeCountMinMaxMinMinMin = 0\n        var changeCountMinMaxMinMinMin\
    \ = 0\n        var changeCountMinMaxMinMinMin = 0\n        var changeCountMinMaxMinMinMin\
    \ = 0\n        var \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmppocjxg0v.scala:65:11 ---------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m        \e[33mvar\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmppocjxg0v.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mvar\e[0m \e[36mchangeCountMinMaxMinMinMin\e\
    [0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchangeCountMinMaxMinMinMin is already defined as \e[33mvariable\e\
    [0m \e[35mchangeCountMinMaxMinMinMin\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmppocjxg0v.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mvar\e[0m \e[36mchangeCountMinMaxMinMinMin\e\
    [0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchangeCountMinMaxMinMinMin is already defined as \e[33mvariable\e\
    [0m \e[35mchangeCountMinMaxMinMinMin\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmppocjxg0v.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mvar\e[0m \e[36mchangeCountMinMaxMinMinMin\e\
    [0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchangeCountMinMaxMinMinMin is already defined as \e[33mvariable\e\
    [0m \e[35mchangeCountMinMaxMinMinMin\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmppocjxg0v.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mvar\e[0m \e[36mchangeCountMinMaxMinMinMin\e\
    [0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchangeCountMinMaxMinMinMin is already defined a"
  stdout: ''
  timestamp: 1660010380
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val p = new Array[Long](n)\n        var i =\
    \ 0\n        var j = 0\n        var k = 0\n        var minChange = 0\n       \
    \ while (i < n && j < n) {\n            if (arr(i) < arr(j)) {\n             \
    \   p(k) = arr(i)\n                i += 1\n                k += 1\n          \
    \  } else {\n                p(k) = arr(j)\n                j += 1\n         \
    \       k += 1\n            }\n        }\n        if (i == n) {\n            minChange\
    \ = k\n        } else if (j == n) {\n            minChange = k\n        } else\
    \ {\n            minChange = k\n            while (i < n && j < n) {\n       \
    \         if (arr(i) < arr(j)) {\n                    p(k) = arr(i)\n        \
    \            i += 1\n                    k += 1\n                } else {\n  \
    \                  p(k) = arr(j)\n                    j += 1\n               \
    \     k += 1\n                }\n            }\n        }\n        minChange\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 8 out of bounds for length\
    \ 8\n\tat Problem$.smallestChange(tmplg82hyge.scala:18)\n\tat Problem$.main(tmplg82hyge.scala:48)\n\
    \tat Problem.main(tmplg82hyge.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010384
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val changes = mutable.ArrayBuffer.empty[Long]\n\
    \        val change = mutable.ArrayBuffer.empty[Long]\n        val changed = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeIndex = mutable.ArrayBuffer.empty[Int]\n        val changeIndexSize\
    \ = mutable.ArrayBuffer.empty[Int]\n        val changeIndexMax = mutable.ArrayBuffer.empty[Int]\n\
    \        val changeIndexMaxSize = mutable.ArrayBuffer.empty[Int]\n        val\
    \ changeIndexMaxIndex = mutable.ArrayBuffer.empty[Int]\n        val changeIndexMaxIndexSize\
    \ = mutable.ArrayBuffer.empty[Int]\n        val changeIndexMaxIndexMax = mutable.ArrayBuffer.empty[Int]\n\
    \        val changeIndexMaxIndexMaxSize = mutable.ArrayBuffer.empty[Int]\n   \
    \     val changeIndexMaxIndexMaxIndex = mutable.ArrayBuffer.empty[Int]\n     \
    \   val changeIndexMaxIndexMaxIndexSize = mutable.ArrayBuffer.empty[Int]\n   \
    \     val changeIndexMaxIndexMaxIndexMax = mutable.ArrayBuffer.empty[Int]\n  \
    \      val changeIndexMaxIndexMaxIndexMaxSize = mutable.ArrayBuffer.empty[Int]\n\
    \        val changeIndexMaxIndexMaxIndexMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val changeIndexMaxIndexMaxIndexMaxIndexSize = mutable.ArrayBuffer.empty[Int]\n\
    \        val changeIndexMaxIndexMaxIndexMaxIndexMax = mutable.ArrayBuffer.empty[Int]\n\
    \        val changeIndexMaxIndexMaxIndexMaxIndexMaxSize = mutable.ArrayBuffer.empty[Int]\n\
    \        val changeIndexMaxIndexMaxIndexMaxIndexMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val changeIndexMaxIndexMaxIndexMaxIndexMaxIndexSize = mutable.ArrayBuffer.empty[Int]\n\
    \        val changeIndexMaxIndexMaxIndexMaxIndexMaxIndexMax = mutable.ArrayBuffer.empty[Int]\n\
    \        val changeIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxSize = mutable.ArrayBuffer.empty[Int]\n\
    \        val changeIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val changeIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexSize = mutable.ArrayBuffer.empty[Int]\n\
    \        val changeIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMax = mutable.ArrayBuffer.empty[Int]\n\
    \        val changeIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxIndexMaxSize = mutable.ArrayBuffer.empty[Int\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxw888622.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ']' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpxw888622.scala:9:18\
    \ ----------------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m  |\e[0m                  ^\e[0m\n\e\
    [31m  |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxw888622.scala:11:22\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mchanges\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxw888622.scala:12:21\
    \ ------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e\
    [36mchange\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxw888622.scala:13:22\
    \ ------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e\
    [36mchanged\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxw888622.scala:14:26\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mchangeIndex\e[0m = mutable.ArrayBuffer.empty[\e[35mInt\e[0m]\n\e[31m\e[31m\
    \   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \              Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e["
  stdout: ''
  timestamp: 1660010381
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.take(n/2).length\n        val p = new Array[Long](m)\n  \
    \      val r = new Array[Long](m)\n        val s = new Array[Long](m)\n      \
    \  val t = new Array[Long](m)\n        val u = new Array[Long](m)\n        val\
    \ v = new Array[Long](m)\n        val w = new Array[Long](m)\n        val x =\
    \ new Array[Long](m)\n        val y = new Array[Long](m)\n        val z = new\
    \ Array[Long](m)\n        val a = new Array[Long](m)\n        val b = new Array[Long](m)\n\
    \        val c = new Array[Long](m)\n        val d = new Array[Long](m)\n    \
    \    val e = new Array[Long](m)\n        val f = new Array[Long](m)\n        val\
    \ g = new Array[Long](m)\n        val h = new Array[Long](m)\n        val i =\
    \ new Array[Long](m)\n        val j = new Array[Long](m)\n        val k = new\
    \ Array[Long](m)\n        val l = new Array[Long](m)\n        val m = new Array[Long](m)\n\
    \        val n = new Array[Long](m)\n        val o = new Array[Long](m)\n    \
    \    val p = new Array[Long](m)\n        val q = new Array[Long](m)\n        val\
    \ r = new Array[Long](m)\n        val s = new Array[Long](m)\n        val t =\
    \ new Array[Long](m)\n        val u = new Array[Long](m)\n        val v = new\
    \ Array[Long](m)\n        val w = new Array[Long](m)\n        val x = new Array[Long](m)\n\
    \        val y = new Array[Long](m)\n        val z = new Array[Long](m)\n    \
    \    val a = new Array[Long](m)\n        val b = new Array[Long](m)\n        val\
    \ c = new Array[Long](m)\n        val d = new Array[Long](m)\n        val e =\
    \ new Array[Long](m)\n        val f = new Array[Long](m)\n        val g = new\
    \ Array[Long](m)\n        val h = new Array[Long](m)\n        val i = new Array[Long](m)\n\
    \        val j = new Array[Long](m)\n        val k = new Array[Long](m)\n    \
    \    val l = new Array[Long](m)\n        val m = new Array[Long](m)\n        val\
    \ n = new Array[Long](\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpmcyptnj8.scala:60:32 ---------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = \e[33mnew\e[0m\
    \ \e[35mArray\e[0m[\e[35mLong\e[0m](\n\e[31m\e[31m   |\e[0m                  \
    \              ^\e[0m\n\e[31m   |\e[0m                                expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\nexception occurred while parser /tmp/tmpmcyptnj8.scala\n\
    exception occurred while compiling /tmp/tmpmcyptnj8.scala\nException in thread\
    \ \"main\" java.lang.AssertionError: assertion failed: position error, parent\
    \ span does not contain child span\nparent      = \e[33mnew \e[0m\e[35mArray\e\
    [0m[\e[35mLong\e[0m](\e[31mnull\e[0m) # -1,\nparent span = <2224..2240>,\nchild\
    \       = \e[31mnull\e[0m # -1,\nchild span  = [2240..2245..2245]\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:8)\n\
    \tat dotty.tools.dotc.ast.Positioned.check$1(Positioned.scala:172)\n\tat dotty.tools.dotc.ast.Positioned.check$1$$anonfun$3(Positioned.scala:202)\n\
    \tat scala.runtime.function.JProcedure1.apply(JProcedure1.java:15)\n\tat scala.runtime.function.JProcedure1.apply(JProcedure1.java:10)\n\
    \tat scala.collection.immutable.List.foreach(List.scala:333)\n\tat dotty.tools.dotc.ast.Positioned.check$1(Positioned.scala:202)\n\
    \tat dotty.tools.dotc.ast.Positioned.checkPos(Positioned.scala:223)\n\tat dotty.tools.dotc.ast.Positioned.check$1(Positioned.scala:197)\n\
    \tat dotty.tools.dotc.ast.Positioned.checkPos(Positioned.scala:223)\n\tat dotty.tools.dotc.ast.Positioned.check$1(Positioned.scala:197)\n\
    \tat dotty.tools.dotc.ast.Positioned.check$1$$anonfun$3(Positioned.scala:202)\n\
    \tat scala.runtime.function.JProcedure1.apply(JProcedure1.java:15)\n\tat scala.runtime.function.JProcedure1.apply(JProcedure1.java:10)\n\
    \tat scala.collection.immutable.List.foreach(List.scala:333)\n\tat dotty.tools.dotc.ast.Positioned.check$1(Positioned.scala:202)\n\
    \tat dotty.tools.dotc.ast.Positioned.checkPos(Positioned.scala:223)\n\tat dotty.tools.dotc.ast.Positioned.check$1(Positioned.scala:197)\n\
    \tat dotty"
  stdout: "error while checking \e[33mnew \e[0m\e[35mArray\e[0m[\e[35mLong\e[0m](\e\
    [31mnull\e[0m)\nerror while checking \e[33mval\e[0m \e[36mn\e[0m = \e[33mnew \e\
    [0m\e[35mArray\e[0m[\e[35mLong\e[0m](\e[31mnull\e[0m)\nerror while checking {\n\
    \  \e[33mval\e[0m \e[36mn\e[0m = arr.length\n  \e[33mval\e[0m \e[36mm\e[0m = arr.take(n\
    \ / 2).length\n  \e[33mval\e[0m \e[36mp\e[0m = \e[33mnew \e[0m\e[35mArray\e[0m[\e\
    [35mLong\e[0m](m)\n  \e[33mval\e[0m \e[36mr\e[0m = \e[33mnew \e[0m\e[35mArray\e\
    [0m[\e[35mLong\e[0m](m)\n  \e[33mval\e[0m \e[36ms\e[0m = \e[33mnew \e[0m\e[35mArray\e\
    [0m[\e[35mLong\e[0m](m)\n  \e[33mval\e[0m \e[36mt\e[0m = \e[33mnew \e[0m\e[35mArray\e\
    [0m[\e[35mLong\e[0m](m)\n  \e[33mval\e[0m \e[36mu\e[0m = \e[33mnew \e[0m\e[35mArray\e\
    [0m[\e[35mLong\e[0m](m)\n  \e[33mval\e[0m \e[36mv\e[0m = \e[33mnew \e[0m\e[35mArray\e\
    [0m[\e[35mLong\e[0m](m)\n  \e[33mval\e[0m \e[36mw\e[0m = \e[33mnew \e[0m\e[35mArray\e\
    [0m[\e[35mLong\e[0m](m)\n  \e[33mval\e[0m \e[36mx\e[0m = \e[33mnew \e[0m\e[35mArray\e\
    [0m[\e[35mLong\e[0m](m)\n  \e[33mval\e[0m \e[36my\e[0m = \e[33mnew \e[0m\e[35mArray\e\
    [0m[\e[35mLong\e[0m](m)\n  \e[33mval\e[0m \e[36mz\e[0m = \e[33mnew \e[0m\e[35mArray\e\
    [0m[\e[35mLong\e[0m](m)\n  \e[33mval\e[0m \e[36ma\e[0m = \e[33mnew \e[0m\e[35mArray\e\
    [0m[\e[35mLong\e[0m](m)\n  \e[33mval\e[0m \e[36mb\e[0m = \e[33mnew \e[0m\e[35mArray\e\
    [0m[\e[35mLong\e[0m](m)\n  \e[33mval\e[0m \e[36mc\e[0m = \e[33mnew \e[0m\e[35mArray\e\
    [0m[\e[35mLong\e[0m](m)\n  \e[33mval\e[0m \e[36md\e[0m = \e[33mnew \e[0m\e[35mArray\e\
    [0m[\e[35mLong\e[0m](m)\n  \e[33mval\e[0m \e[36me\e[0m = \e[33mnew \e[0m\e[35mArray\e\
    [0m[\e[35mLong\e[0m](m)\n  \e[33mval\e[0m \e[36mf\e[0m = \e[33mnew \e[0m\e[35mArray\e\
    [0m[\e[35mLong\e[0m](m)\n  \e[33mval\e[0m \e[36mg\e[0m = \e[33mnew \e[0m\e[35mArray\e\
    [0m[\e[35mLong\e[0m](m)\n  \e[33mval\e[0m \e[36mh\e[0m = \e[33mnew \e[0m\e[35mArray\e\
    [0m[\e[35mLong\e[0m](m)\n  \e[33mval\e[0m \e[36mi\e[0m = \e[33mnew \e[0m\e[35mArray\e\
    [0m[\e[35mLong\e[0m](m)\n  \e[33mval\e[0m \e[36mj\e[0m = \e[33mnew \e[0m\e[35mArray\e\
    [0m[\e[35mLong\e[0m](m)\n  \e[33mval\e[0m \e[36mk\e[0m = \e[33mnew \e[0m\e[35mArray\e\
    [0m[\e[35mLong\e[0m](m)\n  \e[33mval\e[0m \e[36ml\e[0m = \e[33mnew \e[0m\e[35mArray\e\
    [0m[\e[35mLong\e[0m](m)\n  \e[33mval\e[0m \e[36mm\e[0m = \e[33mnew \e[0m\e[35mArray\e\
    [0m[\e[35mLong\e[0m](m)\n  \e[33mval\e[0m \e[36mn\e[0m = \e[33mnew \e[0m\e[35mArr"
  timestamp: 1660010377
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val palindromic = new mutable.HashSet[Long]()\n        val palindromicArray\
    \ = new mutable.ArrayList[Long]()\n        val palindromicArray2 = new mutable.ArrayList[Long]()\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var minChange\
    \ = 0\n        var minChangeIndex = 0\n        var minChangeIndex2 = 0\n     \
    \   var minChangeIndex3 = 0\n        var minChangeIndex4 = 0\n        var minChangeIndex5\
    \ = 0\n        var minChangeIndex6 = 0\n        var minChangeIndex7 = 0\n    \
    \    var minChangeIndex8 = 0\n        var minChangeIndex9 = 0\n        var minChangeIndex10\
    \ = 0\n        var minChangeIndex11 = 0\n        var minChangeIndex12 = 0\n  \
    \      var minChangeIndex13 = 0\n        var minChangeIndex14 = 0\n        var\
    \ minChangeIndex15 = 0\n        var minChangeIndex16 = 0\n        var minChangeIndex17\
    \ = 0\n        var minChangeIndex18 = 0\n        var minChangeIndex19 = 0\n  \
    \      var minChangeIndex20 = 0\n        var minChangeIndex21 = 0\n        var\
    \ minChangeIndex22 = 0\n        var minChangeIndex23 = 0\n        var minChangeIndex24\
    \ = 0\n        var minChangeIndex25 = 0\n        var minChangeIndex26 = 0\n  \
    \      var minChangeIndex27 = 0\n        var minChangeIndex28 = 0\n        var\
    \ minChangeIndex29 = 0\n        var minChangeIndex30 = 0\n        var minChangeIndex31\
    \ = 0\n        var minChangeIndex32 = 0\n        var minChangeIndex33 = 0\n  \
    \      var minChangeIndex34 = 0\n        var minChangeIndex35 = 0\n        var\
    \ minChangeIndex36 = 0\n        var minChangeIndex37 = 0\n        var minChangeIndex38\
    \ = 0\n        var minChangeIndex39 = 0\n        var minChangeIndex40 = 0\n  \
    \      var minChangeIndex41 = 0\n        var minChangeIndex42 = 0\n        var\
    \ minChangeIndex43 = 0\n        var minChangeIndex44 = 0\n        var minChangeIndex45\
    \ = 0\n        var minChangeIndex46 = 0\n        var minChangeIndex47 = 0\n  \
    \      var minChangeIndex48 = 0\n        var minChangeIndex49 = 0\n        var\
    \ minChangeIndex50 = 0\n        var minChangeIndex51 = 0\n        var minChangeIndex52\
    \ = 0\n        var minChangeIndex53 = 0\n        var minChangeIndex54 = 0\n  \
    \      var minChangeIndex55 = 0\n        var minChangeIndex56 = 0\n        var\
    \ minChangeIndex57 = 0\n        var minChangeIndex58 = 0\n        var minChangeIndex59\
    \ = 0\n        var minChangeIndex60 = 0\n        var minChangeIndex61 = 0\n  \
    \      var minChangeIndex62 = 0\n        var minChangeIndex63 = 0\n        var\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpmttqzd2j.scala:80:11 ---------------------------\e\
    [0m\e[0m\n\e[31m80 |\e[0m        \e[33mvar\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpmttqzd2j.scala:10:30 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mpalindromic\e[0m = \e[33mnew\e\
    [0m mutable.HashSet[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                              Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmttqzd2j.scala:11:35\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mpalindromicArray\e[0m = \e[33mnew\e[0m mutable.ArrayList[\e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                                   Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpmttqzd2j.scala:12:36 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mpalindromicArray2\e[0m =\
    \ \e[33mnew\e[0m mutable.ArrayList[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m \
    \                                   ^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpmttqzd2j.scala:81:5 ---------------------\e\
    [0m\e[0m\n\e[31m81 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n5 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010381
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val p = new Array[Long](n + 1)\n        val\
    \ p1 = new Array[Long](n + 1)\n        val p2 = new Array[Long](n + 1)\n     \
    \   val p3 = new Array[Long](n + 1)\n        val p4 = new Array[Long](n + 1)\n\
    \        val p5 = new Array[Long](n + 1)\n        val p6 = new Array[Long](n +\
    \ 1)\n        val p7 = new Array[Long](n + 1)\n        val p8 = new Array[Long](n\
    \ + 1)\n        val p9 = new Array[Long](n + 1)\n        val p10 = new Array[Long](n\
    \ + 1)\n        val p11 = new Array[Long](n + 1)\n        val p12 = new Array[Long](n\
    \ + 1)\n        val p13 = new Array[Long](n + 1)\n        val p14 = new Array[Long](n\
    \ + 1)\n        val p15 = new Array[Long](n + 1)\n        val p16 = new Array[Long](n\
    \ + 1)\n        val p17 = new Array[Long](n + 1)\n        val p18 = new Array[Long](n\
    \ + 1)\n        val p19 = new Array[Long](n + 1)\n        val p20 = new Array[Long](n\
    \ + 1)\n        val p21 = new Array[Long](n + 1)\n        val p22 = new Array[Long](n\
    \ + 1)\n        val p23 = new Array[Long](n + 1)\n        val p24 = new Array[Long](n\
    \ + 1)\n        val p25 = new Array[Long](n + 1)\n        val p26 = new Array[Long](n\
    \ + 1)\n        val p27 = new Array[Long](n + 1)\n        val p28 = new Array[Long](n\
    \ + 1)\n        val p29 = new Array[Long](n + 1)\n        val p30 = new Array[Long](n\
    \ + 1)\n        val p31 = new Array[Long](n + 1)\n        val p32 = new Array[Long](n\
    \ + 1)\n        val p33 = new Array[Long](n + 1)\n        val p34 = new Array[Long](n\
    \ + 1)\n        val p35 = new Array[Long](n + 1)\n        val p36 = new Array[Long](n\
    \ + 1)\n        val p37 = new Array[Long](n + 1)\n        val p38 = new Array[Long](n\
    \ + 1)\n        val p39 = new Array[Long](n + 1)\n        val p40 = new Array[Long](n\
    \ + 1)\n        val p41 = new Array[\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmufjc8g8.scala:53:4 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmpmufjc8g8.scala:52:18\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m52 |\e[0m       \
    \ \e[33mval\e[0m \e[36mp41\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\n\e[31m\e[31m\
    \   |\e[0m                  ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmissing argument for\
    \ parameter _length of \e[33mconstructor\e[0m \e[35mArray\e[0m in \e[33mclass\e\
    [0m \e[35mArray\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmufjc8g8.scala:53:5\
    \ ---------------------\e[0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010382
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        var i = 0\n\
    \        var j = 0\n        while (i < len) {\n            val temp = arr(i)\n\
    \            val temp2 = arr(j)\n            if (temp != temp2) {\n          \
    \      minChange = minChange - 1\n                i = i + 1\n                j\
    \ = j + 1\n            } else {\n                i = i + 1\n            }\n  \
    \      }\n        minChange\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp88gn8byt.scala:9:18 ----------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m  |\e[0m                  ^\e[0m\n\e[31m  |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmp88gn8byt.scala:18:26 -----------------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m                minChange = minChange - \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \               Reassignment to val minChange\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010380
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val m = arr.length\n\
    \        val n = arr.last\n        val changes = mutable.ArrayBuffer(n)\n    \
    \    var i = 0\n        var j = 0\n        while(i < m && j < n) {\n         \
    \   if(arr(i) < arr(j)) {\n                changes += arr(i)\n               \
    \ i += 1\n            } else {\n                changes += arr(j)\n          \
    \      j += 1\n            }\n        }\n        changes.min\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9be6ssii.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ArrayBuffer(n)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010380
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.last\n        val arr = arr.sortBy(-_)\n        val changes\
    \ = mutable.ArrayBuffer.empty[Long]\n        var i = 0\n        var j = 0\n  \
    \      while (i < n) {\n            while (j < n && arr(i) == arr(j)) {\n    \
    \            j += 1\n            }\n            changes += j - i\n           \
    \ i += 1\n            j = 0\n        }\n        changes.min\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpsnksdau3.scala:11:18 ---------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(-_)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpsnksdau3.scala:12:22 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010380
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val p = new Array[Long](n + 1)\n        var\
    \ i = 0\n        var j = 0\n        var k = 0\n        var minChange = 0\n   \
    \     while (i < n) {\n            p(i) = arr(i)\n            i += 1\n       \
    \ }\n        while (j < n) {\n            k += 1\n            while (k > 0) {\n\
    \                if (p(j) < p(k)) {\n                    p(i) = p(j)\n       \
    \             i += 1\n                    j -= 1\n                    k -= 1\n\
    \                } else {\n                    p(i) = p(k)\n                 \
    \   i -= 1\n                    k -= 1\n                }\n            }\n   \
    \         j += 1\n        }\n        minChange = i - 1\n        return minChange\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 9 out of bounds for length\
    \ 9\n\tat Problem$.smallestChange(tmppp5jxcfi.scala:24)\n\tat Problem$.main(tmppp5jxcfi.scala:40)\n\
    \tat Problem.main(tmppp5jxcfi.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010385
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        var changes = 0\n        var i = 0\n      \
    \  var j = 0\n        var k = 0\n        var temp = 0\n        while (i < n) {\n\
    \            while (j < n) {\n                if (arr(i) == arr(j)) {\n      \
    \              temp += 1\n                    j += 1\n                }\n    \
    \            else {\n                    j += 1\n                }\n         \
    \   }\n            while (k < n) {\n                if (arr(i) == arr(k)) {\n\
    \                    temp += 1\n                    k += 1\n                }\n\
    \                else {\n                    k += 1\n                }\n     \
    \       }\n            if (temp == m) {\n                changes += 1\n      \
    \          temp = 0\n            }\n            i += 1\n        }\n        return\
    \ changes\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcbsltc71.scala:44)\n\tat Problem.main(tmpcbsltc71.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010385
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val min = math.min(arr.head, arr.last)\n  \
    \      val max = math.max(arr.head, arr.last)\n        val changes = mutable.ListBuffer[Long]()\n\
    \        var i = 0\n        while (i < n) {\n            val current = arr(i)\n\
    \            if (current == max) {\n                changes += max\n         \
    \       i += 1\n            } else if (current == min) {\n                changes\
    \ += min\n                i += 1\n            } else if (current > max && current\
    \ < min) {\n                changes += current - min\n                i += 1\n\
    \            } else if (current < min && current > max) {\n                changes\
    \ += max - current\n                i += 1\n            }\n        }\n       \
    \ changes.min\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8ygfirfi.scala:9:18 ----------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m  |\e[0m                  ^\e[0m\n\e[31m  |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp8ygfirfi.scala:13:22 ------------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010380
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.max\n        val maxChange = arr.foldLeft(0)((acc, x) =>\
    \ if (x == m) acc else acc + 1)\n        val minChange = arr.foldLeft(0)((acc,\
    \ x) => if (x == 0) acc else acc + 1)\n        val maxChangePalindromic = arr.foldLeft(0)((acc,\
    \ x) => if (x == m) acc else acc + 1)\n        val minChangePalindromic = arr.foldLeft(0)((acc,\
    \ x) => if (x == 0) acc else acc + 1)\n        val maxChangePalindromic2 = arr.foldLeft(0)((acc,\
    \ x) => if (x == m) acc else acc + 1)\n        val minChangePalindromic2 = arr.foldLeft(0)((acc,\
    \ x) => if (x == 0) acc else acc + 1)\n        val maxChangePalindromic3 = arr.foldLeft(0)((acc,\
    \ x) => if (x == m) acc else acc + 1)\n        val minChangePalindromic3 = arr.foldLeft(0)((acc,\
    \ x) => if (x == 0) acc else acc + 1)\n        val maxChangePalindromic4 = arr.foldLeft(0)((acc,\
    \ x) => if (x == m) acc else acc + 1)\n        val minChangePalindromic4 = arr.foldLeft(0)((acc,\
    \ x) => if (x == 0) acc else acc + 1)\n        val maxChangePalindromic5 = arr.foldLeft(0)((acc,\
    \ x) => if (x == m) acc else acc + 1)\n        val minChangePalindromic5 = arr.foldLeft(0)((acc,\
    \ x) => if (x == 0) acc else acc + 1)\n        val maxChangePalindromic6 = arr.foldLeft(0)((acc,\
    \ x) => if (x == m) acc else acc + 1)\n        val minChangePalindromic6 = arr.foldLeft(0)((acc,\
    \ x) => if (x == 0) acc else acc + 1)\n        val maxChangePalindromic7 = arr.foldLeft(0)((acc,\
    \ x) => if (x == m) acc else acc + 1)\n        val minChangePalindromic7 = arr.foldLeft(0)((acc,\
    \ x) => if (x == 0) acc else acc + 1)\n        val maxChangePalindromic8 = arr.foldLeft(0)((acc,\
    \ x) => if (x == m) acc else acc + 1)\n        val minChangePalindromic8 = arr.foldLeft(0)((acc,\
    \ x) => if (x == 0) acc \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwrh1r28s.scala:29:4 ----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpwrh1r28s.scala:28:64 --------------------\e[0m\e[0m\n\e[31m28 |\e[0m\
    \        \e[33mval\e[0m \e[36mminChangePalindromic8\e[0m = arr.foldLeft(\e[31m0\e\
    [0m)((\e[36macc\e[0m, \e[36mx\e[0m) => \e[33mif\e[0m (x == \e[31m0\e[0m) acc \n\
    \e[31m\e[31m   |\e[0m                                                        \
    \        ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 Found:    Unit\n\
    \e[31m   |\e[0m                 Required: Int\n\e[31m   |\e[0m               \
    \  Maybe you are missing an else part for the conditional?\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwrh1r28s.scala:29:5 ---------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010384
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val p = new Array[Long](n)\n        val p1 = new Array[Long](n)\n   \
    \     val p2 = new Array[Long](n)\n        val p3 = new Array[Long](n)\n     \
    \   val p4 = new Array[Long](n)\n        val p5 = new Array[Long](n)\n       \
    \ val p6 = new Array[Long](n)\n        val p7 = new Array[Long](n)\n        val\
    \ p8 = new Array[Long](n)\n        val p9 = new Array[Long](n)\n        val p10\
    \ = new Array[Long](n)\n        val p11 = new Array[Long](n)\n        val p12\
    \ = new Array[Long](n)\n        val p13 = new Array[Long](n)\n        val p14\
    \ = new Array[Long](n)\n        val p15 = new Array[Long](n)\n        val p16\
    \ = new Array[Long](n)\n        val p17 = new Array[Long](n)\n        val p18\
    \ = new Array[Long](n)\n        val p19 = new Array[Long](n)\n        val p20\
    \ = new Array[Long](n)\n        val p21 = new Array[Long](n)\n        val p22\
    \ = new Array[Long](n)\n        val p23 = new Array[Long](n)\n        val p24\
    \ = new Array[Long](n)\n        val p25 = new Array[Long](n)\n        val p26\
    \ = new Array[Long](n)\n        val p27 = new Array[Long](n)\n        val p28\
    \ = new Array[Long](n)\n        val p29 = new Array[Long](n)\n        val p30\
    \ = new Array[Long](n)\n        val p31 = new Array[Long](n)\n        val p32\
    \ = new Array[Long](n)\n        val p33 = new Array[Long](n)\n        val p34\
    \ = new Array[Long](n)\n        val p35 = new Array[Long](n)\n        val p36\
    \ = new Array[Long](n)\n        val p37 = new Array[Long](n)\n        val p38\
    \ = new Array[Long](n)\n        val p39 = new Array[Long](n)\n        val p40\
    \ = new Array[Long](n)\n        val p41 = new Array[Long](n)\n        val p42\
    \ = new Array[Long](n)\n        val p43 = new Array[Long](n)\n        val p44\
    \ = new Array[Long](n)\n        val p45 = new Array[Long\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpfb_68dy6.scala:56:4 ----------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ']' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmpfb_68dy6.scala:55:18\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m55 |\e[0m       \
    \ \e[33mval\e[0m \e[36mp45\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mLong\e\
    [0m\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mmissing argument for parameter _length of \e[33mconstructor\e[0m \e[35mArray\e\
    [0m in \e[33mclass\e[0m \e[35mArray\e[0m: (_length: Int): Array[Long]\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpfb_68dy6.scala:56:5 ---------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010384
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val result = new Array[Long](n)\n        val\
    \ changes = new Array[Long](n)\n        val changed = new Array[Boolean](n)\n\
    \        val visited = new Array[Boolean](n)\n        val stack = new Array[Int](n)\n\
    \        val stackSize = 0\n        val stackIndex = 0\n        val stackPointer\
    \ = 0\n        val stackPointer2 = 0\n        val stackPointer3 = 0\n        val\
    \ stackPointer4 = 0\n        val stackPointer5 = 0\n        val stackPointer6\
    \ = 0\n        val stackPointer7 = 0\n        val stackPointer8 = 0\n        val\
    \ stackPointer9 = 0\n        val stackPointer10 = 0\n        val stackPointer11\
    \ = 0\n        val stackPointer12 = 0\n        val stackPointer13 = 0\n      \
    \  val stackPointer14 = 0\n        val stackPointer15 = 0\n        val stackPointer16\
    \ = 0\n        val stackPointer17 = 0\n        val stackPointer18 = 0\n      \
    \  val stackPointer19 = 0\n        val stackPointer20 = 0\n        val stackPointer21\
    \ = 0\n        val stackPointer22 = 0\n        val stackPointer23 = 0\n      \
    \  val stackPointer24 = 0\n        val stackPointer25 = 0\n        val stackPointer26\
    \ = 0\n        val stackPointer27 = 0\n        val stackPointer28 = 0\n      \
    \  val stackPointer29 = 0\n        val stackPointer30 = 0\n        val stackPointer31\
    \ = 0\n        val stackPointer32 = 0\n        val stackPointer33 = 0\n      \
    \  val stackPointer34 = 0\n        val stackPointer35 = 0\n        val stackPointer36\
    \ = 0\n        val stackPointer37 = 0\n        val stackPointer38 = 0\n      \
    \  val stackPointer39 = 0\n        val stackPointer40 = 0\n        val stackPointer41\
    \ = 0\n        val stackPointer42 = 0\n        val stackPointer43 = 0\n      \
    \  val stackPointer44 = 0\n        val stackPointer45 = 0\n        val stackPointer46\
    \ = 0\n        val stackPointer47 = 0\n        val stackPointer48 = 0\n      \
    \  val stackPointer49 = 0\n        val stackPointer50 = 0\n        val stackPointer51\
    \ = 0\n        val stackPointer52 = 0\n        val stackPointer53 = 0\n      \
    \  val stackPointer54 = 0\n        val stackPointer55 = 0\n        val stackPointer56\
    \ = 0\n        val stackPointer57 = 0\n        val stackPointer58 = 0\n      \
    \  val stackPointer59 = 0\n        val stackPointer60 = 0\n        val stackPointer61\
    \ = 0\n        val stackPointer62 = 0\n        val stack\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpyn8c_upi.scala:81:4 ----------------------------\e\
    [0m\e[0m\n\e[31m81 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpyn8c_upi.scala:81:5 ---------------------\e[0m\e[0m\n\e[31m81 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010385
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val min = arr.min\n        val max = arr.max\n\
    \        val mid = len / 2\n        val left = new Array[Long](mid)\n        val\
    \ right = new Array[Long](mid)\n        val change = new Array[Long](mid)\n  \
    \      val changeCount = new Array[Long](mid)\n        val changeCount2 = new\
    \ Array[Long](mid)\n        val changeCount3 = new Array[Long](mid)\n        val\
    \ changeCount4 = new Array[Long](mid)\n        val changeCount5 = new Array[Long](mid)\n\
    \        val changeCount6 = new Array[Long](mid)\n        val changeCount7 = new\
    \ Array[Long](mid)\n        val changeCount8 = new Array[Long](mid)\n        val\
    \ changeCount9 = new Array[Long](mid)\n        val changeCount10 = new Array[Long](mid)\n\
    \        val changeCount11 = new Array[Long](mid)\n        val changeCount12 =\
    \ new Array[Long](mid)\n        val changeCount13 = new Array[Long](mid)\n   \
    \     val changeCount14 = new Array[Long](mid)\n        val changeCount15 = new\
    \ Array[Long](mid)\n        val changeCount16 = new Array[Long](mid)\n       \
    \ val changeCount17 = new Array[Long](mid)\n        val changeCount18 = new Array[Long](mid)\n\
    \        val changeCount19 = new Array[Long](mid)\n        val changeCount20 =\
    \ new Array[Long](mid)\n        val changeCount21 = new Array[Long](mid)\n   \
    \     val changeCount22 = new Array[Long](mid)\n        val changeCount23 = new\
    \ Array[Long](mid)\n        val changeCount24 = new Array[Long](mid)\n       \
    \ val changeCount25 = new Array[Long](mid)\n        val changeCount26 = new Array[Long](mid)\n\
    \        val changeCount27 = new Array[Long](mid)\n        val changeCount28 =\
    \ new Array[Long](mid)\n        val changeCount29 = new Array[Long](mid)\n   \
    \     val changeCount30 = new Array[Long](mid)\n        val changeCount31 = new\
    \ Array[Long](mid)\n        val changeCount32 = new Array[Long](mid)\n       \
    \ val changeCount33 = new Array[Long](mid)\n        val changeCount34 = new Array[Long](mid)\n\
    \        val change\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpo3c60xve.scala:52:4 ----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpo3c60xve.scala:9:18\
    \ ----------------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m  |\e[0m                  ^\e[0m\n\e\
    [31m  |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo3c60xve.scala:52:5\
    \ ---------------------\e[0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010384
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val minChange =\
    \ arr.size\n        val palindromic = arr.filter(_ == arr.reverse.head)\n    \
    \    val changes = arr.filter(_ != arr.reverse.head)\n        val changesToMakePalindromic\
    \ = changes.size\n        val changesToMakePalindromicToMakePalindromic = changesToMakePalindromic\
    \ - palindromic.size\n        minChange + changesToMakePalindromicToMakePalindromic\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3mstlber.scala:17)\n\tat Problem.main(tmp3mstlber.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010386
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val minChange = math.max(n, 0)\n        val\
    \ maxChange = math.min(n, 0)\n        var change = 0\n        var i = 0\n    \
    \    var j = 0\n        var k = 0\n        while (i < n && j < n) {\n        \
    \    if (arr(i) < arr(j)) {\n                change += 1\n                i +=\
    \ 1\n            } else if (arr(i) > arr(j)) {\n                change += 1\n\
    \                j += 1\n            } else {\n                i += 1\n      \
    \          j += 1\n            }\n        }\n        if (change == 0) {\n    \
    \        return 0\n        }\n        while (i < n) {\n            change += 1\n\
    \            i += 1\n        }\n        while (j < n) {\n            change +=\
    \ 1\n            j += 1\n        }\n        while (i < n && j < n) {\n       \
    \     if (arr(i) < arr(j)) {\n                change += 1\n                i +=\
    \ 1\n            } else if (arr(i) > arr(j)) {\n                change += 1\n\
    \                j += 1\n            } else {\n                i += 1\n      \
    \          j += 1\n            }\n        }\n        if (change == 0) {\n    \
    \        return 0\n        }\n        while (i < n) {\n            change += 1\n\
    \            i += 1\n        }\n        while (j < n) {\n            change +=\
    \ 1\n            j += 1\n        }\n        while (i < n && j < n) {\n       \
    \     if (arr(i) < arr(j)) {\n                change += 1\n                i +=\
    \ 1\n            } else if (arr(i) > arr(j)) {\n                change += 1\n\
    \                j += 1\n            } else {\n                i += 1\n      \
    \          j += 1\n            }\n        }\n        if (change == 0) {\n    \
    \        return 0\n        }\n        while (i < n) {\n            change += 1\n\
    \            i += 1\n        }\n        while (j < n) {\n            change +=\
    \ 1\n            j += 1\n        }\n        while (i < n && j < n) {\n       \
    \     if (arr(i) < arr(j)) {\n                change += 1\n                i +=\
    \ 1\n            } else if (arr(i) > arr(j)) {\n                change += 1\n\
    \                j += 1\n            } else {\n                i += 1\n      \
    \          j += 1\n            }\n        }\n        if (change == 0) {\n    \
    \        return 0\n        }\n        while (i < n) {\n            change += 1\n\
    \            i += 1\n        }\n        while (j < n) {\n            change +=\
    \ 1\n            j += 1\n        }\n        while (i < n && j < n) {\n       \
    \     if (arr(i) < arr(j)) {\n                change += 1\n                i +=\
    \ 1\n            } else if (arr(i) > arr(j)) {\n                change += 1\n\
    \                j += 1\n            } else {\n                i += 1\n      \
    \          j += 1\n            }\n        }\n        if (change == 0) {\n    \
    \        return 0\n        }\n        while (i < n) {\n            change += 1\n\
    \            i += 1\n        }\n        while (j < n) {\n            change +=\
    \ 1\n            j += 1\n        }\n        while (i < n && j < n) {\n       \
    \     if (arr(i) < arr(j)) {\n                change += 1\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5ick25ym.scala:148:0 ---------------------------\e\
    [0m\e[0m\n\e[31m148 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp5ick25ym.scala:9:18\
    \ ----------------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m  |\e[0m                  ^\e[0m\n\e\
    [31m  |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5ick25ym.scala:132:8\
    \ --------------------\e[0m\e[0m\n\e[31m132 |\e[0m        \e[33mwhile\e[0m (i\
    \ < n && j < n) {\n\e[31m\e[31m    |\e[0m        ^\e[0m\n\e[31m    |\e[0m    \
    \    Found:    Unit\n\e[31m    |\e[0m        Required: Long\n\e[31m133 |\e[0m\
    \            \e[33mif\e[0m (arr(i) < arr(j)) {\n\e[31m134 |\e[0m             \
    \   change += \e[31m1\e[0m\n\e[31m135 |\e[0m    }\n\e[31m136 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[31m137 |\e[0m    assert(smallestChange((List[\e[35mLong\e[0m](\e[31m1l\e[0m.toLong,\
    \ \e[31m2l\e[0m.toLong, \e[31m3l\e[0m.toLong, \e[31m5l\e[0m.toLong, \e[31m4l\e\
    [0m.toLong, \e[31m7l\e[0m.toLong, \e[31m9l\e[0m.toLong, \e[31m6l\e[0m.toLong)))\
    \ == (\e[31m4l\e[0m));\n\e[31m138 |\e[0m    assert(smallestChange((List[\e[35mLong\e\
    [0m](\e[31m1l\e[0m.toLong, \e[31m2l\e[0m.toLong, \e[31m3l\e[0m.toLong, \e[31m4l\e\
    [0m.toLong, \e[31m3l\e[0m.toLong, \e[31m2l\e[0m.toLong, \e[31m2l\e[0m.toLong)))\
    \ == (\e[31m1l\e[0m));\n\e[31m139 |\e[0m    assert(smallestChange((List[\e[35mLong\e\
    [0m](\e[31m1l\e[0m.toLong, \e[31m4l\e[0m.toLong, \e[31m2l\e[0m.toLong))) == (\e\
    [31m1l\e[0m));\n\e[31m140 |\e[0m    assert(smallestChange((List[\e[35mLong\e[0m](\e\
    [31m1l\e[0m.toLong, \e[31m4l\e[0m.toLong, \e[31m4l\e[0m.toLong, \e[31m2l\e[0m.toLong)))\
    \ == (\e[31m1l\e[0m));\n\e[31m141 |\e[0m    assert(smallestChange((List[\e[35mLong\e\
    [0m](\e[31m1l\e[0m.toLong, \e[31m2l\e[0m.toLong, \e[31m3l\e[0m.toLong, \e[31m2l\e\
    [0m.toLong, \e[31m1l\e[0m.toLong))) == (\e[31m0l\e[0m));\n\e[31m142 |\e[0m   \
    \ assert(smallestChange((List[\e[35mLong\e[0m](\e[31"
  stdout: ''
  timestamp: 1660010386
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val changes = mutable.ListBuffer[Long]()\n\
    \        val change = mutable.ListBuffer[Long]()\n        val changed = mutable.ListBuffer[Long]()\n\
    \        val change = mutable.ListBuffer[Long]()\n        var i = 0\n        var\
    \ j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var\
    \ n = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var\
    \ s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var\
    \ w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var\
    \ a = 0\n        var b = 0\n        var c = 0\n        var d = 0\n        var\
    \ e = 0\n        var f = 0\n        var g = 0\n        var h = 0\n        var\
    \ i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var\
    \ m = 0\n        var n = 0\n        var p = 0\n        var q = 0\n        var\
    \ r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var\
    \ v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var\
    \ z = 0\n        var a = 0\n        var b = 0\n        var c = 0\n        var\
    \ d = 0\n        var e = 0\n        var f = 0\n        var g = 0\n        var\
    \ h = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var\
    \ l = 0\n        var m = 0\n        var n = 0\n        var p = 0\n        var\
    \ q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var\
    \ u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var\
    \ y = 0\n        var z = 0\n        var a = 0\n        var b = 0\n        var\
    \ c = 0\n        var d = 0\n        var e = 0\n        var f = 0\n        var\
    \ g = 0\n        var h = 0\n        var i = 0\n        var j = 0\n        var\
    \ k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var\
    \ p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var\
    \ t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var\
    \ x = 0\n        var y = 0\n        var z = 0\n        var a = 0\n        var\
    \ b = 0\n        var c = 0\n        var d = 0\n        var e = 0\n        var\
    \ f = 0\n        var g = 0\n        var h = 0\n        var i = 0\n        var\
    \ j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var\
    \ n = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var\
    \ s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var\
    \ w = 0\n        var x\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpe9pamujz.scala:130:4 ---------------------------\e\
    [0m\e[0m\n\e[31m130 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe9pamujz.scala:14:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m\
    \ \e[36mchange\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mchange\
    \ is already defined as \e[33mvalue\e[0m \e[35mchange\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe9pamujz.scala:19:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mm\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe9pamujz.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mn\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mn is already defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe9pamujz.scala:40:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mi\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mi is already defined as \e[33mvariable\e[0m \e[35mi\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpe9pamujz.scala:41:12 ---------------------------\e[0m\e[0m\n\e[31m41\
    \ |\e[0m        \e[33mvar\e[0m \e[36mj\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mj is already defined as \e[33mvariable\e\
    [0m \e[35mj\e[0m\n\e[31m "
  stdout: ''
  timestamp: 1660010387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val palindromic = new mutable.ListBuffer[Long]()\n\
    \        var i = 0\n        var j = 0\n        while (i < n) {\n            while\
    \ (j < n && arr(i) == arr(j)) {\n                j += 1\n            }\n     \
    \       if (j == n) {\n                palindromic.append(arr(i))\n          \
    \      i += 1\n                j = 0\n            } else {\n                j\
    \ += 1\n            }\n        }\n        if (palindromic.isEmpty) {\n       \
    \     return 0\n        } else {\n            return palindromic.length\n    \
    \    }\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmphzujdhiw.scala:10:18 ---------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmphzujdhiw.scala:11:30 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mpalindromic\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                              Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010384
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val len = arr.length\n\
    \        val arr = arr.sortBy(-_)\n        val len = arr.length\n        val arr\
    \ = arr.sortBy(-_)\n        val len = arr.length\n        val arr = arr.sortBy(-_)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(-_)\n        val len\
    \ = arr.length\n        val arr = arr.sortBy(-_)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(-_)\n        val len = arr.length\n        val arr\
    \ = arr.sortBy(-_)\n        val len = arr.length\n        val arr = arr.sortBy(-_)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(-_)\n        val len\
    \ = arr.length\n        val arr = arr.sortBy(-_)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(-_)\n        val len = arr.length\n        val arr\
    \ = arr.sortBy(-_)\n        val len = arr.length\n        val arr = arr.sortBy(-_)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(-_)\n        val len\
    \ = arr.length\n        val arr = arr.sortBy(-_)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(-_)\n        val len = arr.length\n        val arr\
    \ = arr.sortBy(-_)\n        val len = arr.length\n        val arr = arr.sortBy(-_)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(-_)\n        val len\
    \ = arr.length\n        val arr = arr.sortBy(-_)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(-_)\n        val len = arr.length\n        val arr\
    \ = arr.sortBy(-_)\n        val len = arr.length\n        val arr = arr.sortBy(-_)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(-_)\n        val len\
    \ = arr.length\n        val arr = arr.sortBy(-_)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(-_)\n        val len = arr.length\n        val arr\
    \ = arr.sortBy(-_)\n        val len = arr.length\n        val arr = arr.sortBy(-_)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(-_)\n        val len\
    \ = arr.length\n        val arr = arr.sortBy(-_)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(-_)\n        val len = arr.length\n        val arr\
    \ = arr.sortBy(-_)\n\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcz9rmszb.scala:11:12 ---------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcz9rmszb.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(-_)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcz9rmszb.scala:13:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m\
    \ \e[36mlen\e[0m = arr.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlen is already defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpcz9rmszb.scala:14:12 ---------------------------\e[0m\e[0m\n\e[31m14\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(-_)\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcz9rmszb.scala:15:12 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcz9rmszb.scala:"
  stdout: ''
  timestamp: 1660010389
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val len = arr.length\n\
    \        val maxLen = len / 2\n        val maxLen2 = maxLen / 2\n        val maxLen3\
    \ = maxLen / 3\n        val maxLen4 = maxLen / 4\n        val maxLen5 = maxLen\
    \ / 5\n        val maxLen6 = maxLen / 6\n        val maxLen7 = maxLen / 7\n  \
    \      val maxLen8 = maxLen / 8\n        val maxLen9 = maxLen / 9\n        val\
    \ maxLen10 = maxLen / 10\n        val maxLen11 = maxLen / 11\n        val maxLen12\
    \ = maxLen / 12\n        val maxLen13 = maxLen / 13\n        val maxLen14 = maxLen\
    \ / 14\n        val maxLen15 = maxLen / 15\n        val maxLen16 = maxLen / 16\n\
    \        val maxLen17 = maxLen / 17\n        val maxLen18 = maxLen / 18\n    \
    \    val maxLen19 = maxLen / 19\n        val maxLen20 = maxLen / 20\n        val\
    \ maxLen21 = maxLen / 21\n        val maxLen22 = maxLen / 22\n        val maxLen23\
    \ = maxLen / 23\n        val maxLen24 = maxLen / 24\n        val maxLen25 = maxLen\
    \ / 25\n        val maxLen26 = maxLen / 26\n        val maxLen27 = maxLen / 27\n\
    \        val maxLen28 = maxLen / 28\n        val maxLen29 = maxLen / 29\n    \
    \    val maxLen30 = maxLen / 30\n        val maxLen31 = maxLen / 31\n        val\
    \ maxLen32 = maxLen / 32\n        val maxLen33 = maxLen / 33\n        val maxLen34\
    \ = maxLen / 34\n        val maxLen35 = maxLen / 35\n        val maxLen36 = maxLen\
    \ / 36\n        val maxLen37 = maxLen / 37\n        val maxLen38 = maxLen / 38\n\
    \        val maxLen39 = maxLen / 39\n        val maxLen40 = maxLen / 40\n    \
    \    val maxLen41 = maxLen / 41\n        val maxLen42 = maxLen / 42\n        val\
    \ maxLen43 = maxLen / 43\n        val maxLen44 = maxLen / 44\n        val maxLen45\
    \ = maxLen / 45\n        val maxLen46 = maxLen / 46\n        val maxLen47 = maxLen\
    \ / 47\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpntgx0ggd.scala:57:11 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpntgx0ggd.scala:58:5 ---------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010388
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val changes = mutable.ListBuffer[Long]()\n\
    \        val changed = mutable.ListBuffer[Long]()\n        val change = mutable.ListBuffer[Long]()\n\
    \        val changeIndex = mutable.ListBuffer[Int]()\n        val changeIndex2\
    \ = mutable.ListBuffer[Int]()\n        val changeIndex3 = mutable.ListBuffer[Int]()\n\
    \        val changeIndex4 = mutable.ListBuffer[Int]()\n        val changeIndex5\
    \ = mutable.ListBuffer[Int]()\n        val changeIndex6 = mutable.ListBuffer[Int]()\n\
    \        val changeIndex7 = mutable.ListBuffer[Int]()\n        val changeIndex8\
    \ = mutable.ListBuffer[Int]()\n        val changeIndex9 = mutable.ListBuffer[Int]()\n\
    \        val changeIndex10 = mutable.ListBuffer[Int]()\n        val changeIndex11\
    \ = mutable.ListBuffer[Int]()\n        val changeIndex12 = mutable.ListBuffer[Int]()\n\
    \        val changeIndex13 = mutable.ListBuffer[Int]()\n        val changeIndex14\
    \ = mutable.ListBuffer[Int]()\n        val changeIndex15 = mutable.ListBuffer[Int]()\n\
    \        val changeIndex16 = mutable.ListBuffer[Int]()\n        val changeIndex17\
    \ = mutable.ListBuffer[Int]()\n        val changeIndex18 = mutable.ListBuffer[Int]()\n\
    \        val changeIndex19 = mutable.ListBuffer[Int]()\n        val changeIndex20\
    \ = mutable.ListBuffer[Int]()\n        val changeIndex21 = mutable.ListBuffer[Int]()\n\
    \        val changeIndex22 = mutable.ListBuffer[Int]()\n        val changeIndex23\
    \ = mutable.ListBuffer[Int]()\n        val changeIndex24 = mutable.ListBuffer[Int]()\n\
    \        val changeIndex25 = mutable.ListBuffer[Int]()\n        val changeIndex26\
    \ = mutable.ListBuffer[Int]()\n        val changeIndex27 = mutable.ListBuffer[Int]()\n\
    \        val changeIndex28 = mutable.ListBuffer[Int]()\n        val changeIndex29\
    \ = mutable.ListBuffer[Int]()\n        val changeIndex30 = mutable.ListBuffer[Int]()\n\
    \        val changeIndex31 = mutable.ListBuffer[Int]()\n        val changeIndex32\
    \ = mutable.List\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb0ayrayx.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpb0ayrayx.scala:12:22 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpb0ayrayx.scala:13:21 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpb0ayrayx.scala:14:26 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mchangeIndex\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpb0ayrayx.scala:15:27 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mchangeIndex2\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpb0ayrayx.scala:16:27 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m    "
  stdout: ''
  timestamp: 1660010388
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val p = new Array[Long](n)\n        var i =\
    \ 0\n        var j = 0\n        var k = 0\n        var minChange = 0\n       \
    \ var minChangeIndex = 0\n        var changeCount = 0\n        while (i < n) {\n\
    \            while (j < n) {\n                if (arr(i) == arr(j)) {\n      \
    \              p(i) = arr(i)\n                    j += 1\n                } else\
    \ {\n                    j += 1\n                }\n            }\n          \
    \  while (k < n) {\n                if (arr(i) == arr(k)) {\n                \
    \    p(k) = arr(i)\n                    k += 1\n                } else {\n   \
    \                 k += 1\n                }\n            }\n            val reverse\
    \ = new Array[Long](n)\n            var reverseIndex = 0\n            var reverseCount\
    \ = 0\n            while (i < n) {\n                reverse(reverseIndex) = arr(i)\n\
    \                i += 1\n                reverseIndex += 1\n            }\n  \
    \          val reverseReverse = new Array[Long](n)\n            var reverseReverseIndex\
    \ = 0\n            var reverseReverseCount = 0\n            while (k < n) {\n\
    \                reverseReverse(reverseReverseIndex) = arr(k)\n              \
    \  k += 1\n                reverseReverseIndex += 1\n            }\n         \
    \   val reverseReverseReverse = new Array[Long](n)\n            var reverseReverseReverseIndex\
    \ = 0\n            var reverseReverseReverseCount = 0\n            while (j <\
    \ n) {\n                reverseReverseReverse(reverseReverseReverseIndex) = arr(j)\n\
    \                j += 1\n                reverseReverseReverseIndex += 1\n   \
    \         }\n            val reverseReverseReverseReverse = new Array[Long](n)\n\
    \            var reverseReverseReverseReverseIndex = 0\n            var reverseReverseReverseReverseCount\
    \ = 0\n            while (k < n) {\n                reverseReverseReverseReverse(reverseReverseReverseReverseIndex)\
    \ = arr(k)\n                k += 1\n                reverseReverseReverseReverseIndex\
    \ += 1\n            }\n            val reverseReverseReverseReverse = new Array[Long](n)\n\
    \            var reverseReverseReverseReverseIndex = 0\n            var reverseReverseReverseReverseCount\
    \ = 0\n            while (i < n) {\n                reverse(reverseIndex) = arr(i)\n\
    \                i += 1\n                reverseIndex += 1\n            }\n  \
    \          val reverseReverseReverseReverse = new Array[Long](n)\n           \
    \ var reverseReverseReverseReverseIndex = 0\n            var reverseReverseReverseReverseCount\
    \ = 0\n            while (k < n) {\n                reverseReverseReverseReverse(reverseReverseReverseIndex)\
    \ = arr(k)\n                k += 1\n                reverseReverseReverseReverseIndex\
    \ += 1\n            }\n            val reverseReverseReverseReverse = new Array[Long](n)\n\
    \            var reverseReverseReverseReverseIndex = 0\n            var reverseReverseReverseReverseCount\
    \ = 0\n            while (j < n) {\n                reverseReverseReverseReverse(reverseReverseReverseIndex)\
    \ = arr(j)\n                j += 1\n                reverseReverse\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1b9800fp.scala:103:0 ---------------------------\e\
    [0m\e[0m\n\e[31m103 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1b9800fp.scala:67:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m67 |\e[0m            \e[33mval\e\
    [0m \e[36mreverseReverseReverseReverse\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mreverseReverseReverseReverse is already defined as \e[33mvalue\e\
    [0m \e[35mreverseReverseReverseReverse\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1b9800fp.scala:68:16 ---------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m            \e[33mvar\e[0m \e[36mreverseReverseReverseReverseIndex\e\
    [0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mreverseReverseReverseReverseIndex is already defined as \e\
    [33mvariable\e[0m \e[35mreverseReverseReverseReverseIndex\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1b9800fp.scala:69:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m69 |\e[0m            \e[33mvar\e\
    [0m \e[36mreverseReverseReverseReverseCount\e[0m = \e[31m0\e[0m\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mreverseReverseReverseReverseCount is already defined as \e[33mvariable\e\
    [0m \e[35mreverseReverseReverseReverseCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1b9800fp.scala:75:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m75 |\e[0m            \e[33mval\e\
    [0m \e[36mreverseReverseReverseReverse\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660010386
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.max\n        val result = new Array[Long](n)\n        val\
    \ changes = new Array[Long](n)\n        var i = 0\n        var j = 0\n       \
    \ var k = 0\n        var temp = 0\n        var change = 0\n        var changeCount\
    \ = 0\n        var minChange = 0\n        var minChangeCount = 0\n        while\
    \ (i < n) {\n            change = 0\n            changeCount = 0\n           \
    \ minChange = 0\n            minChangeCount = 0\n            while (j < n) {\n\
    \                if (arr(i) == arr(j)) {\n                    change = change\
    \ + 1\n                    changeCount = changeCount + 1\n                   \
    \ if (change == m) {\n                        changes(k) = j\n               \
    \         k = k + 1\n                    }\n                }\n              \
    \  else {\n                    change = 0\n                    changeCount = 0\n\
    \                }\n                j = j + 1\n            }\n            if (change\
    \ == m) {\n                changes(k) = i\n                k = k + 1\n       \
    \     }\n            i = i + 1\n        }\n        while (j < n) {\n         \
    \   change = 0\n            changeCount = 0\n            minChange = 0\n     \
    \       minChangeCount = 0\n            while (i < n) {\n                if (arr(i)\
    \ == arr(j)) {\n                    change = change + 1\n                    changeCount\
    \ = changeCount + 1\n                    if (change == m) {\n                \
    \        changes(k) = i\n                        k = k + 1\n                 \
    \   }\n                }\n                else {\n                    change =\
    \ 0\n                    changeCount = 0\n                }\n                i\
    \ = i + 1\n            }\n            if (change == m) {\n                changes(k)\
    \ = j\n                k = k + 1\n            }\n            j = j + 1\n     \
    \   }\n        while (i < n) {\n            change = 0\n            changeCount\
    \ = 0\n            minChange = 0\n            minChangeCount = 0\n           \
    \ while (j < n) {\n                if (arr(i) == arr(j)) {\n                 \
    \   change = change + 1\n                    changeCount = changeCount + 1\n \
    \                   if (change == m) {\n                        changes(k) = j\n\
    \                        k = k + 1\n                    }\n                }\n\
    \                else {\n                    change = 0\n                    changeCount\
    \ = 0\n                }\n                j = j + 1\n            }\n         \
    \   if (change == m) {\n                changes(k) = i\n                k = k\
    \ + 1\n            }\n            i = i + 1\n        }\n        while (j < n)\
    \ {\n            change = 0\n            changeCount = 0\n            minChange\
    \ = 0\n            minChangeCount = 0\n            while (i < n) {\n         \
    \       if (arr(i) == arr(j)) {\n                    change = change + 1\n   \
    \                 changeCount = changeCount + 1\n                    if (change\
    \ == m) {\n                        changes(k) = i\n                        k =\
    \ k + 1\n                    }\n                }\n                else {\n  \
    \                  change = 0\n                    changeCount = 0\n         \
    \       }\n                \n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpkpe72r3r.scala:131:0 ---------------------------\e\
    [0m\e[0m\n\e[31m131 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkpe72r3r.scala:99:8\
    \ ---------------------\e[0m\e[0m\n\e[31m 99 |\e[0m        \e[33mwhile\e[0m (j\
    \ < n) {\n\e[31m\e[31m    |\e[0m        ^\e[0m\n\e[31m    |\e[0m        Found:\
    \    Unit\n\e[31m    |\e[0m        Required: Long\n\e[31m100 |\e[0m          \
    \  change = \e[31m0\e[0m\n\e[31m101 |\e[0m            changeCount = \e[31m0\e\
    [0m\n\e[31m102 |\e[0m            minChange = \e[31m0\e[0m\n\e[31m103 |\e[0m  \
    \          minChangeCount = \e[31m0\e[0m\n\e[31m104 |\e[0m            \e[33mwhile\e\
    [0m (i < n) {\n\e[31m105 |\e[0m                \e[33mif\e[0m (arr(i) == arr(j))\
    \ {\n\e[31m106 |\e[0m                    change = change + \e[31m1\e[0m\n\e[31m107\
    \ |\e[0m                    changeCount = changeCount + \e[31m1\e[0m\n\e[31m108\
    \ |\e[0m                    \e[33mif\e[0m (change == m) {\n\e[31m109 |\e[0m  \
    \                      changes(k) = i\n\e[31m110 |\e[0m                      \
    \  k = k + \e[31m1\e[0m\n\e[31m111 |\e[0m                    }\n\e[31m112 |\e\
    [0m                }\n\e[31m113 |\e[0m                \e[33melse\e[0m {\n\e[31m114\
    \ |\e[0m                    change = \e[31m0\e[0m\n\e[31m115 |\e[0m          \
    \          changeCount = \e[31m0\e[0m\n\e[31m116 |\e[0m                }\n\e[31m117\
    \ |\e[0m                \n\e[31m118 |\e[0m    }\n\e[31m119 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[31m120 |\e[0m    assert(smallestChange((List[\e[35mLong\e[0m](\e[31m1l\e[0m.toLong,\
    \ \e[31m2l\e[0m.toLong, \e[31m3l\e[0m.toLong, \e[31m5l\e[0m.toLong, \e[31m4l\e\
    [0m.toLong, \e[31m7l\e[0m.toLong, \e[31m9l\e[0m.toLong, \e[31m6l\e[0m.toLong)))\
    \ == (\e[31m4l\e[0m));\n\e[31m121 |\e[0m    assert(smallestChange((List[\e[35mLong\e\
    [0m](\e[31m1l\e[0m.toLong, \e[31m2l\e[0m.toLong, \e[31m3l\e[0m.toLong, \e[31m4l\e\
    [0m.toLong, \e[31m3l\e[0m.toLong, \e[31m2l\e[0m.toLong, \e[31m2l\e[0m.toLong)))\
    \ == (\e[31m1l\e[0m));\n\e[31m122 |\e[0m    assert(smallestChange((List[\e[35mLong\e\
    [0m](\e[31m1l\e[0m.toLong, \e[31m4l\e[0m.toLong, \e[31m2l\e[0m.toLong))"
  stdout: ''
  timestamp: 1660010392
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.head\n        var changes = 0\n        val arr = arr.tail\n\
    \        val arr2 = arr.toList\n        val arr3 = arr2.reverse\n        val arr4\
    \ = arr3.toList\n        val arr5 = arr4.toList\n        val arr6 = arr5.toList\n\
    \        val arr7 = arr6.reverse\n        val arr8 = arr7.toList\n        val\
    \ arr9 = arr8.toList\n        val arr10 = arr9.reverse\n        val arr11 = arr10.toList\n\
    \        val arr12 = arr11.toList\n        val arr13 = arr12.reverse\n       \
    \ val arr14 = arr13.toList\n        val arr15 = arr14.toList\n        val arr16\
    \ = arr15.reverse\n        val arr17 = arr16.toList\n        val arr18 = arr17.toList\n\
    \        val arr19 = arr18.reverse\n        val arr20 = arr19.toList\n       \
    \ val arr21 = arr20.toList\n        val arr22 = arr21.reverse\n        val arr23\
    \ = arr22.toList\n        val arr24 = arr23.toList\n        val arr25 = arr24.reverse\n\
    \        val arr26 = arr25.toList\n        val arr27 = arr26.reverse\n       \
    \ val arr28 = arr27.toList\n        val arr29 = arr28.reverse\n        val arr30\
    \ = arr29.toList\n        val arr31 = arr30.reverse\n        val arr32 = arr31.toList\n\
    \        val arr33 = arr32.reverse\n        val arr34 = arr33.toList\n       \
    \ val arr35 = arr34.reverse\n        val arr36 = arr35.toList\n        val arr37\
    \ = arr36.reverse\n        val arr38 = arr37.toList\n        val arr39 = arr38.reverse\n\
    \        val arr40 = arr39.toList\n        val arr41 = arr40.reverse\n       \
    \ val arr42 = arr41.toList\n        val arr43 = arr42.reverse\n        val arr44\
    \ = arr43.toList\n        val arr45 = arr44.reverse\n        val arr46 = arr45.toList\n\
    \        val arr47 = arr46.reverse\n        val arr48 = arr47.toList\n       \
    \ val arr49 = arr48.reverse\n        val arr50 = arr49.toList\n        val arr51\
    \ = arr50.reverse\n        val arr52 = arr51.toList\n        val arr53 = arr52.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2jg96as8.scala:65:4 ----------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp2jg96as8.scala:12:18 ---------------------------\e[0m\e[0m\n\e[31m12\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m\
    \                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp2jg96as8.scala:65:5 ---------------------\e[0m\e[0m\n\e[31m65\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010391
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        val maxChange\
    \ = len\n        var i = 0\n        var j = 0\n        var k = 0\n        var\
    \ change = 0\n        while (i < len) {\n            while (j < len) {\n     \
    \           if (arr(i) == arr(j)) {\n                    j++\n               \
    \ }\n                else {\n                    k++\n                }\n    \
    \        }\n            if (k > maxChange) {\n                maxChange = k\n\
    \            }\n            while (k > minChange) {\n                minChange\
    \ = k\n                k--\n            }\n            change = minChange\n  \
    \          i++\n            j = 0\n            k = 0\n        }\n        return\
    \ change\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpdjqrjniy.scala:20:23 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpdjqrjniy.scala:23:23 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m                    k++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpdjqrjniy.scala:31:19\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m                k--\n\e\
    [31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                \
    \   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ Error: /tmp/tmpdjqrjniy.scala:35:14 -----------------------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            j = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m \
    \             ^\e[0m\n\e[31m   |\e[0m              end of statement expected but\
    \ '=' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpdjqrjniy.scala:9:18 ----------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m  |\e[0m                  ^\e[0m\n\e[31m  |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpdjqrjniy.scala:27:26 -----------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m                maxChange = k\n\e[31m\e[31m   |\e[0m     \
    \           ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment to\
    \ val maxChange\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpdjqrjniy.scala:30:26 "
  stdout: ''
  timestamp: 1660010391
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.head\n        var i = 0\n        var j = 0\n        var k\
    \ = 0\n        var minChange = Long.MaxValue\n        var change = 0\n       \
    \ while (i < n && j < n) {\n            if (arr(i) < arr(j)) {\n             \
    \   k = j\n            } else {\n                k = i\n            }\n      \
    \      while (k < n && arr(k) == arr(k + 1)) {\n                k += 1\n     \
    \       }\n            change += k - j\n            minChange = Math.min(minChange,\
    \ change)\n            i += 1\n            j += 1\n        }\n        minChange\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 8\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.smallestChange(tmp8j6dqfvj.scala:22)\n\tat Problem$.main(tmp8j6dqfvj.scala:33)\n\
    \tat Problem.main(tmp8j6dqfvj.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010392
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        val minChangeIndex\
    \ = -1\n        val minChangeIndex2 = -1\n        val minChangeIndex3 = -1\n \
    \       val minChangeIndex4 = -1\n        val minChangeIndex5 = -1\n        val\
    \ minChangeIndex6 = -1\n        val minChangeIndex7 = -1\n        val minChangeIndex8\
    \ = -1\n        val minChangeIndex9 = -1\n        val minChangeIndex10 = -1\n\
    \        val minChangeIndex11 = -1\n        val minChangeIndex12 = -1\n      \
    \  val minChangeIndex13 = len\n        val minChangeIndex14 = len\n        val\
    \ minChangeIndex15 = len\n        val minChangeIndex16 = len\n        val minChangeIndex17\
    \ = len\n        val minChangeIndex18 = len\n        val minChangeIndex19 = len\n\
    \        val minChangeIndex20 = len\n        val minChangeIndex21 = len\n    \
    \    val minChangeIndex22 = len\n        val minChangeIndex23 = len\n        val\
    \ minChangeIndex24 = len\n        val minChangeIndex25 = len\n        val minChangeIndex26\
    \ = len\n        val minChangeIndex27 = len\n        val minChangeIndex28 = len\n\
    \        val minChangeIndex29 = len\n        val minChangeIndex30 = len\n    \
    \    val minChangeIndex31 = len\n        val minChangeIndex32 = len\n        val\
    \ minChangeIndex33 = len\n        val minChangeIndex34 = len\n        val minChangeIndex35\
    \ = len\n        val minChangeIndex36 = len\n        val minChangeIndex37 = len\n\
    \        val minChangeIndex38 = len\n        val minChangeIndex39 = len\n    \
    \    val minChangeIndex40 = len\n        val minChangeIndex41 = len\n        val\
    \ minChangeIndex42 = len\n        val minChangeIndex43 = len\n        val minChangeIndex44\
    \ = len\n        val minChangeIndex45 = len\n        val minChangeIndex46 = len\n\
    \        val minChangeIndex47 = len\n        val minChangeIndex48 = len\n    \
    \    val minChangeIndex49 = len\n        val minChangeIndex50 = len\n        val\
    \ minChangeIndex51 = len\n        val minChangeIndex52 = len\n        val minChangeIndex53\
    \ = len\n        val minChangeIndex54 = len\n        val minChangeIndex55 = len\n\
    \        val minChangeIndex56 = len\n        \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp01f7ef_t.scala:9:18 ----------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m  |\e[0m                  ^\e[0m\n\e[31m  |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp01f7ef_t.scala:69:5 ---------------------\e[0m\e\
    [0m\n\e[31m69 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010352
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.head\n        var count = 0\n        val arr = arr.tail\n\
    \        val reversed = arr.reverse\n        val reversedSize = reversed.size\n\
    \        val reversedArray = reversed.toArray\n        val reversedArraySize =\
    \ reversedArray.length\n        val palindromicArray = arr.reverse\n        val\
    \ palindromicArraySize = palindromicArray.length\n        val palindromicArrayReversed\
    \ = palindromicArray.reverse\n        val palindromicArrayReversedSize = palindromicArrayReversed.size\n\
    \        val palindromicArrayReversedArray = palindromicArrayReversed.toArray\n\
    \        val palindromicArrayReversedArraySize = palindromicArrayReversedArray.length\n\
    \        val palindromicArrayReversedArrayReversed = palindromicArrayReversed.reverse\n\
    \        val palindromicArrayReversedArrayReversedSize = palindromicArrayReversedArrayReversed.size\n\
    \        val palindromicArrayReversedArrayReversedArray = palindromicArrayReversedArrayReversed.toArray\n\
    \        val palindromicArrayReversedArrayReversedArraySize = palindromicArrayReversedArrayReversedArray.length\n\
    \        val palindromicArrayReversedArrayReversedArrayReversed = palindromicArrayReversedArrayReversed.reverse\n\
    \        val palindromicArrayReversedArrayReversedArrayReversedSize = palindromicArrayReversedArrayReversedArrayReversed.size\n\
    \        val palindromicArrayReversedArrayReversedArrayReversedArray = palindromicArrayReversedArrayReversedArrayReversed.toArray\n\
    \        val palindromicArrayReversedArrayReversedArrayReversedArraySize = palindromicArrayReversedArrayReversedArrayReversedArray.length\n\
    \        val palindromicArrayReversedArrayReversedArrayReversedArrayReversed =\
    \ palindromicArrayReversedArrayReversedArrayReversed.reverse\n        val palindromicArrayReversedArrayReversedArrayReversedArrayReversedSize\
    \ = palindromicArrayReversedArrayReversedArrayReversedArrayReversed.size\n   \
    \     val palindromicArrayReversedArrayReversedArrayReversedArrayReversedArray\
    \ = palindromicArrayReversedArrayReversedArrayReversedArrayReversed.toArray\n\
    \        val palindromicArrayReversedArrayReversedArrayReversedArrayReversedArraySize\
    \ = p\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpksx4hrts.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpksx4hrts.scala:34:87 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mpalindromicArrayReversedArrayReversedArrayReversedArrayReversedArraySize\e\
    [0m = p\n\e[31m\e[31m   |\e[0m                                               \
    \                                        ^\e[0m\n\e[31m   |\e[0m             \
    \                                               Not found: p\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpksx4hrts.scala:35:5 ---------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010391
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val changes = mutable.ListBuffer[Long]()\n\
    \        val change = mutable.ListBuffer[Long]()\n        val changed = mutable.ListBuffer[Long]()\n\
    \        val changeCount = mutable.ListBuffer[Long]()\n        val changeCounts\
    \ = mutable.ListBuffer[Long]()\n        val changeCountMax = mutable.ListBuffer[Long]()\n\
    \        val changeCountMaxs = mutable.ListBuffer[Long]()\n        val changeCountMin\
    \ = mutable.ListBuffer[Long]()\n        val changeCountMins = mutable.ListBuffer[Long]()\n\
    \        val changeCountMinMax = mutable.ListBuffer[Long]()\n        val changeCountMinMaxs\
    \ = mutable.ListBuffer[Long]()\n        val changeCountMinMaxMin = mutable.ListBuffer[Long]()\n\
    \        val changeCountMinMaxMins = mutable.ListBuffer[Long]()\n        val changeCountMinMaxMinMax\
    \ = mutable.ListBuffer[Long]()\n        val changeCountMinMaxMinMaxs = mutable.ListBuffer[Long]()\n\
    \        val changeCountMinMaxMinMaxMin = mutable.ListBuffer[Long]()\n       \
    \ val changeCountMinMaxMinMaxMins = mutable.ListBuffer[Long]()\n        val changeCountMinMaxMinMaxMinMax\
    \ = mutable.ListBuffer[Long]()\n        val changeCountMinMaxMinMaxMinMaxs = mutable.ListBuffer[Long]()\n\
    \        val changeCountMinMaxMinMaxMinMaxMax = mutable.ListBuffer[Long]()\n \
    \       val changeCountMinMaxMinMaxMinMaxMaxs = mutable.ListBuffer[Long]()\n \
    \       val changeCountMinMaxMinMaxMinMaxMaxMax = mutable.ListBuffer[Long]()\n\
    \        val changeCountMinMaxMinMaxMinMaxMaxMaxs = mutable.ListBuffer[Long]()\n\
    \        val changeCountMinMaxMinMaxMinMaxMaxMaxMax = mutable.ListBuffer[Long]()\n\
    \        val changeCountMinMaxMinMaxMinMaxMaxMaxMaxs = mutable.ListBuffer[Long]()\n\
    \        val changeCountMinMaxMinMaxMinMaxMaxMaxMax = mutable.ListBuffer[Long]()\n\
    \        val changeCountMinMaxMinMaxMinMaxMaxMaxMaxs = mutable.ListBuffer[Long]()\n\
    \        val changeCountMinMaxMinMaxMinMax\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpzjmqv6oe.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzjmqv6oe.scala:37:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m\
    \ \e[36mchangeCountMinMaxMinMaxMinMaxMaxMaxMax\e[0m = mutable.ListBuffer[\e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchangeCountMinMaxMinMaxMinMaxMaxMaxMax is already defined\
    \ as \e[33mvalue\e[0m \e[35mchangeCountMinMaxMinMaxMinMaxMaxMaxMax\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpzjmqv6oe.scala:38:12 ---------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m        \e[33mval\e[0m \e[36mchangeCountMinMaxMinMaxMinMaxMaxMaxMaxs\e\
    [0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchangeCountMinMaxMinMaxMinMaxMaxMaxMaxs is already defined\
    \ as \e[33mvalue\e[0m \e[35mchangeCountMinMaxMinMaxMinMaxMaxMaxMaxs\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpzjmqv6oe.scala:11:18 ---------------------------\e[0m\e[0m\n\e[31m11\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m\
    \                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpzjmqv6oe.scala:12:22 ------------------------\e[0m\e[0m\n\e[31m12 |\e\
    [0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ListBuffer[\e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer expla"
  stdout: ''
  timestamp: 1660010391
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val changes = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        var i = 0\n  \
    \      var j = 0\n        var k = 0\n        while (i < n && j < m) {\n      \
    \      if (arr(i) < arr(j)) {\n                changes += arr(i)\n           \
    \     i += 1\n            } else {\n                changes += arr(j)\n      \
    \          j += 1\n            }\n        }\n        val maxChange = changes.max\n\
    \        val maxChangeIndex = changes.indexOfMax\n        val maxChangeIndex =\
    \ changes.indexOfMax\n        val maxChangeIndex = changes.indexOfMax\n      \
    \  val maxChangeIndex = changes.indexOfMax\n        val maxChangeIndex = changes.indexOfMax\n\
    \        val maxChangeIndex = changes.indexOfMax\n        val maxChangeIndex =\
    \ changes.indexOfMax\n        val maxChangeIndex = changes.indexOfMax\n      \
    \  val maxChangeIndex = changes.indexOfMax\n        val maxChangeIndex = changes.indexOfMax\n\
    \        val maxChangeIndex = changes.indexOfMax\n        val maxChangeIndex =\
    \ changes.indexOfMax\n        val maxChangeIndex = changes.indexOfMax\n      \
    \  val maxChangeIndex = changes.indexOfMax\n        val maxChangeIndex = changes.indexOfMax\n\
    \        val maxChangeIndex = changes.indexOfMax\n        val maxChangeIndex =\
    \ changes.indexOfMax\n        val maxChangeIndex = changes.indexOfMax\n      \
    \  val maxChangeIndex = changes.indexOfMax\n        val maxChangeIndex = changes.indexOfMax\n\
    \        val maxChangeIndex = changes.indexOfMax\n        val maxChangeIndex =\
    \ changes.indexOfMax\n        val maxChangeIndex = changes.indexOfMax\n      \
    \  val maxChangeIndex = changes.indexOfMax\n        val maxChangeIndex = changes.indexOfMax\n\
    \        val maxChangeIndex = changes.indexOfMax\n        val maxChangeIndex =\
    \ changes.indexOfMax\n        val maxChangeIndex = changes.indexOfMax\n      \
    \  val maxChangeIndex = changes.indexOfMax\n        val maxChangeIndex = changes.indexOfMax\n\
    \        val maxChangeIndex = changes.indexOfMax\n        val maxChangeIndex =\
    \ changes.indexOfMax\n        val maxChangeIndex = changes.indexOfMax\n      \
    \  val maxChangeIndex = changes.indexOfMax\n        val maxChangeIndex = changes.indexOfMax\n\
    \        val maxChangeIndex = changes.indexOfMax\n        val maxChangeIndex =\
    \ changes.indexOfMax\n        val maxChangeIndex = changes.indexOfMax\n      \
    \  val maxChangeIndex = changes.indexOfMax\n        val maxChangeIndex = changes.indexOfMax\n\
    \        val maxChangeIndex = changes.indexOfMax\n        val maxChangeIndex =\
    \ changes.indexOfMax\n        val maxChangeIndex = changes.indexOfMax\n      \
    \  val maxChangeIndex = changes.indexOfMax\n        val maxChangeIndex = changes.indexOfMax\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpgriuwxue.scala:72:11 ---------------------------\e\
    [0m\e[0m\n\e[31m72 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpgriuwxue.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mmaxChangeIndex\e[0m = changes.indexOfMax\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mmaxChangeIndex is already defined as \e[33mvalue\e[0m \e[35mmaxChangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpgriuwxue.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mmaxChangeIndex\e[0m = changes.indexOfMax\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mmaxChangeIndex is already defined as \e[33mvalue\e[0m \e[35mmaxChangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpgriuwxue.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mmaxChangeIndex\e[0m = changes.indexOfMax\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mmaxChangeIndex is already defined as \e[33mvalue\e[0m \e[35mmaxChangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpgriuwxue.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mmaxChangeIndex\e[0m = changes.indexOfMax\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mmaxChangeIndex is already defined as \e[33mvalue\e[0m \e[35mmaxChangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded "
  stdout: ''
  timestamp: 1660010392
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val changes = mutable.ArrayBuffer.empty[Long]\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        while (i < n\
    \ / 2) {\n            while (j < n / 2 && arr(i) == arr(j)) {\n              \
    \  j += 1\n            }\n            while (k < n / 2 && arr(i) == arr(k)) {\n\
    \                k += 1\n            }\n            if (j > k) {\n           \
    \     changes += (n - i - 1)\n                i += 1\n                j = 0\n\
    \                k = 0\n            } else {\n                changes += (n -\
    \ i - 1)\n                i += 1\n                k = 0\n                j = 0\n\
    \            }\n        }\n        changes.min\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7jv62yza.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010390
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val p = new Array[Long](n)\n        val r =\
    \ new Array[Long](n)\n        val s = new Array[Long](n)\n        val t = new\
    \ Array[Long](n)\n        val u = new Array[Long](n)\n        val v = new Array[Long](n)\n\
    \        val w = new Array[Long](n)\n        val x = new Array[Long](n)\n    \
    \    val y = new Array[Long](n)\n        val z = new Array[Long](n)\n        val\
    \ a = new Array[Long](n)\n        val b = new Array[Long](n)\n        val c =\
    \ new Array[Long](n)\n        val d = new Array[Long](n)\n        val e = new\
    \ Array[Long](n)\n        val f = new Array[Long](n)\n        val g = new Array[Long](n)\n\
    \        val h = new Array[Long](n)\n        val i = new Array[Long](n)\n    \
    \    val j = new Array[Long](n)\n        val k = new Array[Long](n)\n        val\
    \ l = new Array[Long](n)\n        val m = new Array[Long](n)\n        val n =\
    \ new Array[Long](n)\n        val o = new Array[Long](n)\n        val p = new\
    \ Array[Long](n)\n        val q = new Array[Long](n)\n        val r = new Array[Long](n)\n\
    \        val s = new Array[Long](n)\n        val t = new Array[Long](n)\n    \
    \    val u = new Array[Long](n)\n        val v = new Array[Long](n)\n        val\
    \ w = new Array[Long](n)\n        val x = new Array[Long](n)\n        val y =\
    \ new Array[Long](n)\n        val z = new Array[Long](n)\n        val a = new\
    \ Array[Long](n)\n        val b = new Array[Long](n)\n        val c = new Array[Long](n)\n\
    \        val d = new Array[Long](n)\n        val e = new Array[Long](n)\n    \
    \    val f = new Array[Long](n)\n        val g = new Array[Long](n)\n        val\
    \ h = new Array[Long](n)\n        val i = new Array[Long](n)\n        val j =\
    \ new Array[Long](n)\n        val k = new Array[Long](n)\n        val l = new\
    \ Array[Long](n)\n        val m = new Array[Long](n)\n        val n = new Array[Long](n)\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp7803z89g.scala:61:11 ---------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp7803z89g.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = \e[33mnew\e[0m\
    \ \e[35mArray\e[0m[\e[35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp7803z89g.scala:34:12 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mn is already defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp7803z89g.scala:36:12 ---------------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m        \e[33mval\e[0m \e[36mp\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mp is already defined as \e[33mvalue\e[0m \e[35mp\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp7803z89g.scala:38:12 ---------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Err"
  stdout: ''
  timestamp: 1660010395
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.last\n        val dp = new Array[Long](n + 1)\n        dp(0)\
    \ = 1\n        for (i<-1 to n) {\n            val dp1 = new Array[Long](n + 1)\n\
    \            dp1(0) = 1\n            for (j<-1 to n) {\n                val dp2\
    \ = new Array[Long](n + 1)\n                dp2(0) = 1\n                for (k<-1\
    \ to n) {\n                    val dp3 = new Array[Long](n + 1)\n            \
    \        dp3(0) = 1\n                    for (l<-1 to n) {\n                 \
    \       val dp4 = new Array[Long](n + 1)\n                        dp4(0) = 1\n\
    \                        for (m<-1 to n) {\n                            val dp5\
    \ = new Array[Long](n + 1)\n                            dp5(0) = 1\n         \
    \                   for (o<-1 to n) {\n                                val dp6\
    \ = new Array[Long](n + 1)\n                                dp6(0) = 1\n     \
    \                           for (q<-1 to n) {\n                              \
    \      val dp7 = new Array[Long](n + 1)\n                                    dp7(0)\
    \ = 1\n                                    for (p<-1 to n) {\n               \
    \                         val dp8 = new Array[Long](n + 1)\n                 \
    \                       dp8(0) = 1\n                                        for\
    \ (q<-1 to n) {\n                                            val dp9 = new Array[Long](n\
    \ + 1)\n                                            dp9(0) = 1\n             \
    \                               for (r<-1 to n) {\n                          \
    \                      val dp10 = new Array[Long](n + 1)\n                   \
    \                             dp10(0) = 1\n                                  \
    \          }\n                                        }\n                    \
    \                }\n                                }\n                      \
    \      }\n                        }\n                    }\n                }\n\
    \            }\n            dp(i) = dp1(i) + dp2(i) + dp3(i) + dp4(i) + dp5(i)\
    \ + dp6(i) + dp7(i) + dp8(i) + dp9(i) + dp10(i)\n        }\n        val ans =\
    \ dp(n) - dp(m) + n\n        ans\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppx7p5_cd.scala:52:29 ------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m            dp(i) = dp1(i) + dp2(i) + dp3(i) + dp4(i)\
    \ + dp5(i) + dp6(i) + dp7(i) + dp8(i) + dp9(i) + dp10(i)\n\e[31m\e[31m   |\e[0m\
    \                             ^^^\e[0m\n\e[31m   |\e[0m                      \
    \       Not found: dp2\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppx7p5_cd.scala:54:29\
    \ --------------------\e[0m\e[0m\n\e[31m54 |\e[0m        \e[33mval\e[0m \e[36mans\e\
    [0m = dp(n) - dp(m) + n\n\e[31m\e[31m   |\e[0m                             ^\e\
    [0m\n\e[31m   |\e[0m                             Found:    (m : Long)\n\e[31m\
    \   |\e[0m                             Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010395
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.last\n        val maxChange = arr.take(n).reverse.take(n).map(x\
    \ => x - m).sum\n        val minChange = arr.take(n).map(x => x - m).sum\n   \
    \     val change = maxChange - minChange\n        change\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphmrc2f79.scala:17)\n\tat Problem.main(tmphmrc2f79.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010398
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val min = len\n        val max = len -\
    \ 1\n        val mid = len / 2\n        var i = 0\n        var j = 0\n       \
    \ var k = 0\n        var count = 0\n        while (i < len) {\n            if\
    \ (arr(i) == arr(j)) {\n                count += 1\n                i += 1\n \
    \               j += 1\n                k += 1\n            } else if (arr(i)\
    \ < arr(j)) {\n                count += 1\n                i += 1\n          \
    \  } else if (arr(i) > arr(j)) {\n                count -= 1\n               \
    \ j -= 1\n            }\n            if (count < min) {\n                min =\
    \ count\n            }\n            if (count > max) {\n                max =\
    \ count\n            }\n        }\n        min\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpaz_2qcu2.scala:9:18 ----------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m  |\e[0m                  ^\e[0m\n\e[31m  |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpaz_2qcu2.scala:32:20 -----------------------------\e[0m\e\
    [0m\n\e[31m32 |\e[0m                min = count\n\e[31m\e[31m   |\e[0m       \
    \         ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment to val\
    \ min\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpaz_2qcu2.scala:35:20\
    \ -----------------------------\e[0m\e[0m\n\e[31m35 |\e[0m                max\
    \ = count\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                Reassignment to val max\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010392
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.takeRight(n).reverse.take(n).length\n        val ans = arr.takeRight(n).reverse.take(n).foldLeft(0)(_\
    \ + _)\n        ans\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0dqh5m6w.scala:11:63\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mans\e\
    [0m = arr.takeRight(n).reverse.take(n).foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e\
    [31m   |\e[0m                                                               ^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                         \
    \ Found:    Long\n\e[31m   |\e[0m                                            \
    \              Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010395
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val changes = mutable.ListBuffer[Long]()\n\
    \        var i = 0\n        var j = 0\n        while (i < arr.length) {\n    \
    \        while (j < arr.length && arr(i) == arr(j)) {\n                j += 1\n\
    \            }\n            changes += j - i\n            i = j\n            j\
    \ = 0\n        }\n        changes.min\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr36q5ef_.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010392
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.max\n        val changes = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val palindromic = mutable.ArrayBuffer.empty[Long]\n        val palindromicChange\
    \ = mutable.ArrayBuffer.empty[Long]\n        val palindromicChanged = mutable.ArrayBuffer.empty[Long]\n\
    \        val palindromicChanges = mutable.ArrayBuffer.empty[Long]\n        val\
    \ palindromicChangesChanged = mutable.ArrayBuffer.empty[Long]\n        val palindromicChangesChangesChanged\
    \ = mutable.ArrayBuffer.empty[Long]\n        val palindromicChangesChangesChangesChanged\
    \ = mutable.ArrayBuffer.empty[Long]\n        val palindromicChangesChangesChangesChangesChanged\
    \ = mutable.ArrayBuffer.empty[Long]\n        val palindromicChangesChangesChangesChangesChangesChanged\
    \ = mutable.ArrayBuffer.empty[Long]\n        val palindromicChangesChangesChangesChangesChangesChangesChanged\
    \ = mutable.ArrayBuffer.empty[Long]\n        val palindromicChangesChangesChangesChangesChangesChangesChangesChanged\
    \ = mutable.ArrayBuffer.empty[Long]\n        val palindromicChangesChangesChangesChangesChangesChangesChangesChangesChanged\
    \ = mutable.ArrayBuffer.empty[Long]\n        val palindromicChangesChangesChangesChangesChangesChangesChangesChangesChangesChanged\
    \ = mutable.ArrayBuffer.empty[Long]\n        val palindromicChangesChangesChangesChangesChangesChangesChangesChangesChangesChangesChanged\
    \ = mutable.ArrayBuffer.empty[Long]\n        val palindromicChangesChangesChangesChangesChangesChangesChangesChangesChangesChangesChangesChanged\
    \ = mutable.ArrayBuffer.empty[Long]\n        val palindromicChangesChangesChangesChangesChangesChangesChangesChangesChangesChangesChangesChanged\
    \ = mutable.ArrayBuffer.empty[Long]\n        val palindromicChangesChangesChangesChangesChangesChangesChangesChangesChangesChangesChangesChangesChanged\
    \ = mutable.ArrayBuffer.\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpld4gps_n.scala:31:4 ----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpld4gps_n.scala:29:12 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36mpalindromicChangesChangesChangesChangesChangesChangesChangesChangesChangesChangesChangesChanged\e\
    [0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mpalindromicChangesChangesChangesChangesChangesChangesChangesChangesChangesChangesChangesChanged\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  palindromicChangesChangesChangesChangesChangesChangesChangesChangesChangesChangesChangesChanged\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpld4gps_n.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpld4gps_n.scala:12:22 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpld4gps_n.scala:13:21 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                   "
  stdout: ''
  timestamp: 1660010395
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val changes = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeCount = mutable.ArrayBuffer.empty[Long]\n        val changeCounts\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMax = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeCountMaxs = mutable.ArrayBuffer.empty[Long]\n        val changeCountMin\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMins = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeCountMinMax = mutable.ArrayBuffer.empty[Long]\n        val\
    \ changeCountMinMaxs = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMin\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMins = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeCountMinMaxMinMax = mutable.ArrayBuffer.empty[Long]\n     \
    \   val changeCountMinMaxMinMaxs = mutable.ArrayBuffer.empty[Long]\n        val\
    \ changeCountMinMaxMinMaxMin = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMinMaxMins\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMinMaxMinMax\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMinMaxMinMaxs\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMinMaxMinMaxMax\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMinMaxMinMaxMaxs\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMinMaxMinMaxMaxMax\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMinMaxMinMaxMaxMaxs\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMinMaxMinMaxMaxMaxMax\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMinMaxMinMaxMaxMaxMaxs\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMinMaxMinMaxMaxMaxMaxMax\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMinMaxMinMaxMaxMaxMaxMaxs\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMinMaxMinMaxMaxMaxMaxMax\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpb0uc9ndn.scala:39:4 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb0uc9ndn.scala:11:22\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mchanges\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb0uc9ndn.scala:12:22\
    \ ------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e\
    [36mchanged\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb0uc9ndn.scala:13:21\
    \ ------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e\
    [36mchange\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb0uc9ndn.scala:14:26\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mchangeCount\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m\
    \   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \              Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpb0uc9ndn.scala:15:27 ------------------------\e[0m\e[0m\n\e[31m15 |\e\
    [0m        \e[33mval\e[0m \e[36mchangeCounts\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not f"
  stdout: ''
  timestamp: 1660010395
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val min = len / 2\n        val max = len\
    \ - min\n        val mid = len / 2\n        var count = 0\n        var i = 0\n\
    \        var j = 0\n        var k = 0\n        while (i < min && j < max) {\n\
    \            if (arr(i) == arr(j)) {\n                count += 1\n           \
    \     i += 1\n                j += 1\n            } else if (arr(i) < arr(j))\
    \ {\n                i += 1\n            } else {\n                j += 1\n  \
    \          }\n        }\n        if (count > mid) {\n            count = count\
    \ - mid\n        }\n        count\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpw0b9oq4u.scala:9:18 ----------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m  |\e[0m                  ^\e[0m\n\e[31m  |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010395
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        val maxChange\
    \ = len\n        val minChangeIndex = -1\n        val maxChangeIndex = -1\n  \
    \      var i = 0\n        var j = 0\n        while (i < len) {\n            while\
    \ (j < len) {\n                if (arr(i) != arr(j)) {\n                    minChangeIndex\
    \ = j\n                    maxChangeIndex = j\n                    minChange =\
    \ arr(i)\n                    maxChange = arr(j)\n                    break\n\
    \                }\n                j += 1\n            }\n            i += 1\n\
    \            j += 1\n        }\n        minChangeIndex\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpd87brp4g.scala:9:18 ----------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m  |\e[0m                  ^\e[0m\n\e[31m  |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpd87brp4g.scala:20:35 -----------------------------\e[0m\e\
    [0m\n\e[31m20 |\e[0m                    minChangeIndex = j\n\e[31m\e[31m   |\e\
    [0m                    ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \      Reassignment to val minChangeIndex\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpd87brp4g.scala:21:35 -----------------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m                    maxChangeIndex = j\n\e[31m\e[31m   |\e\
    [0m                    ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \      Reassignment to val maxChangeIndex\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpd87brp4g.scala:22:30 -----------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m                    minChange = arr(i)\n\e[31m\e[31m   |\e\
    [0m                    ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \      Reassignment to val minChange\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpd87brp4g.scala:23:30 -----------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m                    maxChange = arr(j)\n\e[31m\e[31m   |\e\
    [0m                    ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \      Reassignment to val maxChange\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpd87brp4g.scala:24:20 ------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m                    break\n\e[31m\e[31m   |\e[0m         \
    \           ^^^^^\e[0m\n\e[31m   |\e[0m                    Not"
  stdout: ''
  timestamp: 1660010394
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val maxChange = arr.take(len/2).reverse.take(len/2).reverse.length\n\
    \        val minChange = arr.take(len/2).reverse.length\n        val change =\
    \ minChange\n        if(maxChange < minChange) change else change\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpifm18sn6.scala:9:18 ----------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m  |\e[0m                  ^\e[0m\n\e[31m  |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010394
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val result = new Array[Long](n + 1)\n     \
    \   var i = 0\n        var j = 0\n        var k = 0\n        var minChange = 0\n\
    \        var minChangeIndex = 0\n        var change = 0\n        var changeIndex\
    \ = 0\n        var temp = 0\n        while (i < n) {\n            while (j < n)\
    \ {\n                temp = arr(j) - arr(j)\n                if (temp < 0) {\n\
    \                    temp = -temp\n                }\n                if (temp\
    \ == m) {\n                    result(i) = temp\n                    j = n\n \
    \                   minChangeIndex = i\n                    changeIndex = j\n\
    \                    minChange = change\n                    change = temp\n \
    \                   i = i + 1\n                }\n                else {\n   \
    \                 j = j + 1\n                }\n            }\n            k =\
    \ n - 1\n            while (k >= 0) {\n                temp = arr(k) - arr(k)\n\
    \                if (temp < 0) {\n                    temp = -temp\n         \
    \       }\n                if (temp == m) {\n                    result(i) = temp\n\
    \                    k = n - 1\n                    minChangeIndex = i\n     \
    \               changeIndex = k\n                    minChange = change\n    \
    \                change = temp\n                    i = i + 1\n              \
    \  }\n                else {\n                    k = k - 1\n                }\n\
    \            }\n        }\n        if (minChange == 0) {\n            return 0\n\
    \        }\n        else {\n            return minChange\n        }\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdg336ovd.scala:22:23\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m                temp = arr(j)\
    \ - arr(j)\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                       Found:    Long\n\e[31m   |\e[0m        \
    \               Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpdg336ovd.scala:41:23 --------------------\e[0m\e[0m\n\e[31m41\
    \ |\e[0m                temp = arr(k) - arr(k)\n\e[31m\e[31m   |\e[0m        \
    \               ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       Found:\
    \    Long\n\e[31m   |\e[0m                       Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010399
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val min = len/2\n        val max = len-1\n\
    \        val minChange = arr.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take(min).reverse.take\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpy_wig9wk.scala:9:18 ----------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m  |\e[0m                  ^\e[0m\n\e[31m  |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpy_wig9wk.scala:14:5 ---------------------\e[0m\e\
    [0m\n\e[31m14 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010398
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.last\n        val minChange = math.min(math.ceil(n/2), math.floor(n/2))\n\
    \        val changes = mutable.ListBuffer.empty[Long]\n        val change = mutable.ListBuffer.empty[Long]\n\
    \        val changed = mutable.ListBuffer.empty[Long]\n        val changeIndex\
    \ = mutable.ListBuffer.empty[Int]\n        val changeIndex = mutable.ListBuffer.empty[Int]\n\
    \        val changeIndex = mutable.ListBuffer.empty[Int]\n        val changeIndex\
    \ = mutable.ListBuffer.empty[Int]\n        val changeIndex = mutable.ListBuffer.empty[Int]\n\
    \        val changeIndex = mutable.ListBuffer.empty[Int]\n        val changeIndex\
    \ = mutable.ListBuffer.empty[Int]\n        val changeIndex = mutable.ListBuffer.empty[Int]\n\
    \        val changeIndex = mutable.ListBuffer.empty[Int]\n        val changeIndex\
    \ = mutable.ListBuffer.empty[Int]\n        val changeIndex = mutable.ListBuffer.empty[Int]\n\
    \        val changeIndex = mutable.ListBuffer.empty[Int]\n        val changeIndex\
    \ = mutable.ListBuffer.empty[Int]\n        val changeIndex = mutable.ListBuffer.empty[Int]\n\
    \        val changeIndex = mutable.ListBuffer.empty[Int]\n        val changeIndex\
    \ = mutable.ListBuffer.empty[Int]\n        val changeIndex = mutable.ListBuffer.empty[Int]\n\
    \        val changeIndex = mutable.ListBuffer.empty[Int]\n        val changeIndex\
    \ = mutable.ListBuffer.empty[Int]\n        val changeIndex = mutable.ListBuffer.empty[Int]\n\
    \        val changeIndex = mutable.ListBuffer.empty[Int]\n        val changeIndex\
    \ = mutable.ListBuffer.empty[Int]\n        val changeIndex = mutable.ListBuffer.empty[Int]\n\
    \        val changeIndex = mutable.ListBuffer.empty[Int]\n        val changeIndex\
    \ = mutable.ListBuffer.empty[Int]\n        val changeIndex = mutable.ListBuffer.empty[Int]\n\
    \        val changeIndex = mutable.ListBuffer.empty[Int]\n        val changeIndex\
    \ = mutable.ListBuffer.empty[Int]\n        val changeIndex = mutable.ListBuffer.empty[Int]\n\
    \        val changeIndex = mutable.ListBuffer.empty[Int]\n        val changeIndex\
    \ = mutable.ListBuffer.empty[Int]\n        val changeIndex = mutable.ListBuffer.empty[Int]\n\
    \        val changeIndex = mutable.ListBuffer.empty[Int]\n        val changeIndex\
    \ = mutable.ListBuffer.empty[Int]\n        \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsah3tamp.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mchangeIndex\e[0m = mutable.ListBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchangeIndex is already defined as \e[33mvalue\e[0m \e[35mchangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpsah3tamp.scala:17:12 ---------------------------\e[0m\e[0m\n\e\
    [31m17 |\e[0m        \e[33mval\e[0m \e[36mchangeIndex\e[0m = mutable.ListBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchangeIndex is already defined as \e[33mvalue\e[0m \e[35mchangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpsah3tamp.scala:18:12 ---------------------------\e[0m\e[0m\n\e\
    [31m18 |\e[0m        \e[33mval\e[0m \e[36mchangeIndex\e[0m = mutable.ListBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchangeIndex is already defined as \e[33mvalue\e[0m \e[35mchangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpsah3tamp.scala:19:12 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m        \e[33mval\e[0m \e[36mchangeIndex\e[0m = mutable.ListBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchangeIndex is already defined as \e[33mvalue\e[0m \e[35mchangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpsah3tamp.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mchangeIndex\e[0"
  stdout: ''
  timestamp: 1660010399
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val result = new Array[Long](n)\n        val\
    \ changes = new Array[Long](n)\n        var i = 0\n        var j = 0\n       \
    \ var k = 0\n        var change = 0\n        var changeCount = 0\n        var\
    \ changeIndex = 0\n        var changeIndex2 = 0\n        var changeIndex3 = 0\n\
    \        var changeIndex4 = 0\n        var changeIndex5 = 0\n        var changeIndex6\
    \ = 0\n        var changeIndex7 = 0\n        var changeIndex8 = 0\n        var\
    \ changeIndex9 = 0\n        var changeIndex10 = 0\n        var changeIndex11 =\
    \ 0\n        var changeIndex12 = 0\n        var changeIndex13 = 0\n        var\
    \ changeIndex14 = 0\n        var changeIndex15 = 0\n        var changeIndex16\
    \ = 0\n        var changeIndex17 = 0\n        var changeIndex18 = 0\n        var\
    \ changeIndex19 = 0\n        var changeIndex20 = 0\n        var changeIndex21\
    \ = 0\n        var changeIndex22 = 0\n        var changeIndex23 = 0\n        var\
    \ changeIndex24 = 0\n        var changeIndex25 = 0\n        var changeIndex26\
    \ = 0\n        var changeIndex27 = 0\n        var changeIndex28 = 0\n        var\
    \ changeIndex29 = 0\n        var changeIndex30 = 0\n        var changeIndex31\
    \ = 0\n        var changeIndex32 = 0\n        var changeIndex33 = 0\n        var\
    \ changeIndex34 = 0\n        var changeIndex35 = 0\n        var changeIndex36\
    \ = 0\n        var changeIndex37 = 0\n        var changeIndex38 = 0\n        var\
    \ changeIndex39 = 0\n        var changeIndex40 = 0\n        var changeIndex41\
    \ = 0\n        var changeIndex42 = 0\n        var changeIndex43 = 0\n        var\
    \ changeIndex44 = 0\n        var changeIndex45 = 0\n        var changeIndex46\
    \ = 0\n        var changeIndex47 = 0\n        var changeIndex48 = 0\n        var\
    \ changeIndex49 = 0\n        var changeIndex50 = 0\n        var changeIndex51\
    \ = 0\n        var changeIndex52 = 0\n        var changeIndex53 = 0\n        var\
    \ changeIndex54 = 0\n        var changeIndex55 = 0\n        var changeIndex56\
    \ = 0\n        var changeIndex57 = 0\n        var changeIndex58 = 0\n        var\
    \ changeIndex59 = 0\n        var changeIndex60 = 0\n        var changeIndex61\
    \ = 0\n        var changeIndex62 = 0\n        var changeIndex63 = 0\n        var\
    \ changeIndex64 = 0\n        var changeIndex65 = 0\n        var changeIndex66\
    \ = 0\n        var changeIndex67 = 0\n        var changeIndex68 = 0\n        var\
    \ changeIndex69 = 0\n        var changeIndex70 = 0\n        var changeIndex71\
    \ = 0\n        var changeIndex72 = 0\n        var changeIndex73 = 0\n        var\
    \ changeIndex74 = 0\n        var changeIndex75 = 0\n        var changeIndex76\
    \ = 0\n        var changeIndex77 = 0\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpplh_hea8.scala:95:5\
    \ ---------------------\e[0m\e[0m\n\e[31m95 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010400
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.last\n        val p = new Array[Long](n + 1)\n        val\
    \ r = new Array[Long](n + 1)\n        val s = new Array[Long](n + 1)\n       \
    \ var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n       \
    \ var m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n       \
    \ var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n       \
    \ var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n       \
    \ var y = 0\n        var z = 0\n        var aa = 0\n        var bb = 0\n     \
    \   var cc = 0\n        var dd = 0\n        var ee = 0\n        var ff = 0\n \
    \       var gg = 0\n        var hh = 0\n        var ii = 0\n        var jj = 0\n\
    \        var kk = 0\n        var ll = 0\n        var mm = 0\n        var nn =\
    \ 0\n        var oo = 0\n        var pp = 0\n        var qq = 0\n        var rr\
    \ = 0\n        var ss = 0\n        var tt = 0\n        var uu = 0\n        var\
    \ vv = 0\n        var ww = 0\n        var xx = 0\n        var yy = 0\n       \
    \ var zz = 0\n        var aaa = 0\n        var bbb = 0\n        var ccc = 0\n\
    \        var ddd = 0\n        var eee = 0\n        var fff = 0\n        var ggg\
    \ = 0\n        var hhh = 0\n        var iii = 0\n        var jjj = 0\n       \
    \ var kkk = 0\n        var lll = 0\n        var mmm = 0\n        var nnn = 0\n\
    \        var ooo = 0\n        var ppp = 0\n        var qqq = 0\n        var rrr\
    \ = 0\n        var sss = 0\n        var ttt = 0\n        var uuu = 0\n       \
    \ var vvv = 0\n        var www = 0\n        var xxx = 0\n        var yyy = 0\n\
    \        var zzz = 0\n        var aaaa = 0\n        var bbbb = 0\n        var\
    \ cccc = 0\n        var dddd = 0\n        var eeee = 0\n        var ffff = 0\n\
    \        var gggg = 0\n        var hhhh = 0\n        var iiii = 0\n        var\
    \ jjjj = 0\n        var kkkk = 0\n        var llll = 0\n        var mmmm = 0\n\
    \        var nnnn = 0\n        var oooo = 0\n        var pppp = 0\n        var\
    \ qqqq = 0\n        var rrrr = 0\n        var ssss = 0\n        var tttt = 0\n\
    \        var uuuu = 0\n        var vvvv = 0\n        var wwww = 0\n        var\
    \ xxxx = 0\n        var yyyy = 0\n        var zzzz = 0\n        var aaaaa = 0\n\
    \        var bbbbb = 0\n        var ccccc = 0\n        var ddddd = 1\n       \
    \ var eeeee = 0\n        var fffff = 0\n        var ggggg = 0\n        var hhhhh\
    \ = 0\n        var iiiii = 0\n\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpd00hu55o.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mvar\e[0m \e[36mm\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpd00hu55o.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mvar\e[0m \e[36mn\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpd00hu55o.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mvar\e[0m \e[36mp\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mp is already defined\
    \ as \e[33mvalue\e[0m \e[35mp\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpd00hu55o.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mvar\e[0m \e[36mr\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpd00hu55o.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mvar\e[0m \e[36ms\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0ms is already defined\
    \ as \e[33mvalue\e[0m \e[35ms\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpd00hu55o.scala:120:5 --------------------\e\
    [0m\e[0m\n\e[31m120 |\e[0m    }\n\e[31m\e[31m    |\e[0m     ^\e[0m\n\e[31m    "
  stdout: ''
  timestamp: 1660010400
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val palindromic = arr.toSet\n        val changes = mutable.HashSet[Long]()\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        while (i < n)\
    \ {\n            while (j < n && arr(i) == arr(j)) {\n                j += 1\n\
    \            }\n            while (k < n && arr(i) != arr(k)) {\n            \
    \    k += 1\n            }\n            if (j == k) {\n                changes\
    \ += arr(i)\n                i += 1\n                j = 0\n                k\
    \ = 0\n            }\n        }\n        changes.toList.min\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphalk7e8c.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.HashSet[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010399
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val max = (arr.head\
    \ + arr.last) / 2\n        val min = (arr.head - arr.last) / 2\n        val changes\
    \ = mutable.ListBuffer[Long]()\n        val change = mutable.ListBuffer[Long]()\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        while (i < n\
    \ && j < n) {\n            if (arr(i) < arr(j)) {\n                changes +=\
    \ arr(i)\n                i += 1\n            } else {\n                changes\
    \ += arr(j)\n                j += 1\n            }\n        }\n        val change\
    \ = changes.toList\n        val change2 = change.reverse\n        val change3\
    \ = change2.reverse\n        val change4 = change3.reverse\n        val change5\
    \ = change4.reverse\n        val change6 = change5.reverse\n        val change7\
    \ = change6.reverse\n        val change8 = change7.reverse\n        val change9\
    \ = change8.reverse\n        val change10 = change9.reverse\n        val change11\
    \ = change10.reverse\n        val change12 = change11.reverse\n        val change13\
    \ = change12.reverse\n        val change14 = change13.reverse\n        val change15\
    \ = change14.reverse\n        val change16 = change15.reverse\n        val change17\
    \ = change16.reverse\n        val change18 = change17.reverse\n        val change19\
    \ = change18.reverse\n        val change20 = change19.reverse\n        val change21\
    \ = change20.reverse\n        val change22 = change21.reverse\n        val change23\
    \ = change22.reverse\n        val change24 = change23.reverse\n        val change25\
    \ = change24.reverse\n        val change26 = change25.reverse\n        val change27\
    \ = change26.reverse\n        val change28 = change27.reverse\n        val change29\
    \ = change28.reverse\n        val change30 = change29.reverse\n        val change31\
    \ = change30.reverse\n        val change32 = change31.reverse\n        val change33\
    \ = change32.reverse\n        val change34 = change33.reverse\n        val change35\
    \ = change34.reverse\n        val change36 = change35.reverse\n        val change37\
    \ = change36.reverse\n        val change38 = change37.reverse\n        val change39\
    \ = change38.reverse\n        val change40 = change39.reverse\n        val change41\
    \ = change40.reverse\n        val change42 = change41.reverse\n        val change43\
    \ = change42.reverse\n        val change44 = change43.reverse\n        val change45\
    \ = change44\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4dvwx2fe.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = changes.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mchange\
    \ is already defined as \e[33mvalue\e[0m \e[35mchange\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp4dvwx2fe.scala:11:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e\
    [31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4dvwx2fe.scala:14:22\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mchanges\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4dvwx2fe.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mchange\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4dvwx2fe.scala:73:5\
    \ ---------------------\e[0m\e[0m\n\e[31m73 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660010401
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val palindromic = arr.takeRight(n).reverse == arr\n        val changes\
    \ = arr.filter(_ != 0).count(x => palindromic || palindromic.reverse)\n      \
    \  changes\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfflg5i2n.scala:11:79 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = arr.filter(_\
    \ != \e[31m0\e[0m).count(\e[36mx\e[0m => palindromic || palindromic.reverse)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \           ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \        value reverse is not a member of Boolean\n1 error found\n"
  stdout: ''
  timestamp: 1660010402
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val result = new Array[Long](n)\n        var\
    \ i = 0\n        var j = 0\n        var k = 0\n        var min = 0\n        var\
    \ max = 0\n        var temp = 0\n        var temp2 = 0\n        var temp3 = 0\n\
    \        var temp4 = 0\n        var temp5 = 0\n        var temp6 = 0\n       \
    \ var temp7 = 0\n        var temp8 = 0\n        var temp9 = 0\n        var temp10\
    \ = 0\n        var temp11 = 0\n        var temp12 = 0\n        var temp13 = 0\n\
    \        var temp14 = 0\n        var temp15 = 0\n        var temp16 = 0\n    \
    \    var temp17 = 0\n        var temp18 = 0\n        var temp19 = 0\n        var\
    \ temp20 = 0\n        var temp21 = 0\n        var temp22 = 0\n        var temp23\
    \ = 0\n        var temp24 = 0\n        var temp25 = 0\n        var temp26 = 0\n\
    \        var temp27 = 0\n        var temp28 = 0\n        var temp29 = 0\n    \
    \    var temp30 = 0\n        var temp31 = 0\n        var temp32 = 0\n        var\
    \ temp33 = 0\n        var temp34 = 0\n        var temp35 = 0\n        var temp36\
    \ = 0\n        var temp37 = 0\n        var temp38 = 0\n        var temp39 = 0\n\
    \        var temp40 = 0\n        var temp41 = 0\n        var temp42 = 0\n    \
    \    var temp43 = 0\n        var temp44 = 0\n        var temp45 = 0\n        var\
    \ temp46 = 0\n        var temp47 = 0\n        var temp48 = 0\n        var temp49\
    \ = 0\n        var temp50 = 0\n        var temp51 = 0\n        var temp52 = 0\n\
    \        var temp53 = 0\n        var temp54 = 0\n        var temp55 = 0\n    \
    \    var temp56 = 0\n        var temp57 = 0\n        var temp58 = 0\n        var\
    \ temp59 = 0\n        var temp60 = 0\n        var temp61 = 0\n        var temp62\
    \ = 0\n        var temp63 = 0\n        var temp64 = 0\n        var temp65 = 0\n\
    \        var temp66 = 0\n        var temp67 = 0\n        var temp68 = 0\n    \
    \    var temp69 = 0\n        var temp70 = 0\n        var temp71 = 0\n        var\
    \ temp72 = 0\n        var temp73 = 0\n        var temp74 = 0\n        var temp75\
    \ = 0\n        var temp76 = 0\n        var temp77 = 0\n        var temp78 = 0\n\
    \        var temp79 = 0\n        var temp80 = 0\n        var temp81 = 0\n    \
    \    var temp82 = 0\n        var temp83 = 0\n        var temp84 = 0\n        var\
    \ temp85 = 0\n        var temp86 = 0\n        var temp87 = 0\n        var temp88\
    \ = 0\n        var temp89 = 0\n        var temp90 = 0\n        var temp91 = 0\n\
    \        var temp92 = 0\n        var temp93 = 0\n        var temp94 = 0\n    \
    \    var temp\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp47lg9nsi.scala:112:4 ---------------------------\e\
    [0m\e[0m\n\e[31m112 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp47lg9nsi.scala:112:5 --------------------\e[0m\e[0m\n\e[31m112 |\e[0m\
    \    }\n\e[31m\e[31m    |\e[0m     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\
    \e[31m    |\e[0m     Required: Long\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010401
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val result = new Array[Long](n)\n        var\
    \ i = 0\n        var j = 0\n        var k = 0\n        var min = Long.MaxValue\n\
    \        var max = 0\n        while (i < n) {\n            while (j < n) {\n \
    \               if (arr(i) == arr(j)) {\n                    result(i) = arr(i)\n\
    \                    j++\n                } else {\n                    j++\n\
    \                }\n            }\n            k = i\n            while (k < n)\
    \ {\n                if (arr(k) != arr(n - k)) {\n                    result(k)\
    \ = arr(n - k)\n                    k++\n                } else {\n          \
    \          k++\n                }\n            }\n            min = Math.min(min,\
    \ result(i))\n            max = Math.max(max, result(i))\n            i += 1\n\
    \        }\n        max - min\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpl558v3ot.scala:21:23 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpl558v3ot.scala:23:23 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpl558v3ot.scala:30:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m                    k++\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E018] Syntax Error: /tmp/tmpl558v3ot.scala:32:23 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                    k++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpl558v3ot.scala:36:38 --------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m            max = Math.max(max, result(i))\n\e[31m\e[31m   |\e[0m    \
    \                            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \               Found:    Long\n\e[31m   |\e[0m                              \
    \  Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660010403
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.dropRight(1)\n        val arr2\
    \ = arr.toList\n        val arr3 = arr2.reverse\n        val arr4 = arr3.toList\n\
    \        val arr5 = arr4.toList\n        val arr6 = arr5.toList\n        val arr7\
    \ = arr6.reverse\n        val arr8 = arr7.toList\n        val arr9 = arr8.toList\n\
    \        val arr10 = arr9.reverse\n        val arr11 = arr10.toList\n        val\
    \ arr12 = arr11.toList\n        val arr13 = arr12.reverse\n        val arr14 =\
    \ arr13.toList\n        val arr15 = arr14.toList\n        val arr16 = arr15.reverse\n\
    \        val arr17 = arr16.toList\n        val arr18 = arr17.toList\n        val\
    \ arr19 = arr18.reverse\n        val arr20 = arr19.toList\n        val arr21 =\
    \ arr20.toList\n        val arr22 = arr21.reverse\n        val arr23 = arr22.toList\n\
    \        val arr24 = arr23.toList\n        val arr25 = arr24.reverse\n       \
    \ val arr26 = arr25.toList\n        val arr27 = arr26.reverse\n        val arr28\
    \ = arr27.toList\n        val arr29 = arr28.reverse\n        val arr30 = arr29.toList\n\
    \        val arr31 = arr30.reverse\n        val arr32 = arr31.toList\n       \
    \ val arr33 = arr32.reverse\n        val arr34 = arr33.toList\n        val arr35\
    \ = arr34.reverse\n        val arr36 = arr35.toList\n        val arr37 = arr36.reverse\n\
    \        val arr38 = arr37.toList\n        val arr39 = arr38.reverse\n       \
    \ val arr40 = arr39.toList\n        val arr41 = arr40.reverse\n        val arr42\
    \ = arr41.toList\n        val arr43 = arr42.reverse\n        val arr44 = arr43.toList\n\
    \        val arr45 = arr44.reverse\n        val arr46 = arr45.toList\n       \
    \ val arr47 = arr46.reverse\n        val arr48 = arr47.toList\n        val arr49\
    \ = arr48.reverse\n        val arr50 = arr49.toList\n        val arr51 = arr50.reverse\n\
    \        val arr52 = arr51.toList\n        val arr53 = arr52.reverse\n\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpfi6mypqh.scala:11:18 ---------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.dropRight(\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m  \
    \                Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfi6mypqh.scala:65:5 ---------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010404
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val min = len\n        var i = 0\n    \
    \    var j = 0\n        var k = 0\n        var changes = 0\n        while (i <\
    \ len) {\n            while (j < len) {\n                if (arr(i) == arr(j))\
    \ {\n                    j++\n                }\n                else {\n    \
    \                k++\n                    changes = k\n                    j++\n\
    \                }\n            }\n            i++\n            j = 0\n      \
    \      k = 0\n        }\n        return changes\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpko5pmf6s.scala:19:23 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpko5pmf6s.scala:23:28\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m23 |\e[0m       \
    \             changes = k\n\e[31m\e[31m   |\e[0m                            ^\e\
    [0m\n\e[31m   |\e[0m                            end of statement expected but\
    \ '=' found\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpko5pmf6s.scala:24:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m                    j++\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- Error: /tmp/tmpko5pmf6s.scala:28:14 -----------------------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            j = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m \
    \             ^\e[0m\n\e[31m   |\e[0m              end of statement expected but\
    \ '=' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpko5pmf6s.scala:9:18 ----------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m  |\e[0m                  ^\e[0m\n\e[31m  |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpko5pmf6s.scala:22:21 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m                    k++\n\e[31m\e[31m   |\e[0m           \
    \         ^^^\e[0m\n\e[31m   |\e[0m                    value ++ is not a member\
    \ of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpko5pmf6s.scala:27:13\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m            i++\n\e[31m\e\
    [31m   |\e[0m            ^^^\e[0m\n\e[31m   |\e[0m            value ++ is not\
    \ a member "
  stdout: ''
  timestamp: 1660010403
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        var ans = Long.MaxValue\n        var i = 0\n\
    \        var j = 0\n        while (i < n) {\n            while (j < n) {\n   \
    \             if (arr(i) != arr(j)) {\n                    ans = Math.min(ans,\
    \ j-i+1)\n                }\n                j++\n            }\n            i\
    \ += 1\n            j = 0\n        }\n        ans\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp4vqkng2u.scala:19:19 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                j++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010401
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val minChange = math.min(arr.takeRight(n).reverse, arr.take(n))\n   \
    \     val maxChange = math.max(arr.takeRight(n).reverse, arr.take(n))\n      \
    \  minChange.compare(maxChange)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp6p2koj4g.scala:10:29 -----------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mminChange\e[0m = math.min(arr.takeRight(n).reverse,\
    \ arr.take(n))\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e\
    [0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x:\
    \ Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e\
    [31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\
    \e[31m   |\e[0mmatch arguments ((List[Long]#reverse : => List[Long]), List[Long])\n\
    \e[31m\e[31m-- [E134] Type Error: /tmp/tmp6p2koj4g.scala:11:29 -----------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mmaxChange\e[0m = math.max(arr.takeRight(n).reverse,\
    \ arr.take(n))\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmax\e\
    [0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x:\
    \ Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e\
    [31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\
    \e[31m   |\e[0mmatch arguments ((List[Long]#reverse : => List[Long]), List[Long])\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010401
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val m = arr.size\n\
    \        var count = 0\n        var i = 0\n        var j = 0\n        while (i\
    \ < m && j < m) {\n            if (arr(i) < arr(j)) {\n                count +=\
    \ 1\n                i += 1\n            } else {\n                j += 1\n  \
    \          }\n        }\n        if (i == m) {\n            count\n        } else\
    \ {\n            count + smallestChange(arr.drop(i).reverse)\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.StackOverflowError\n\tat scala.collection.immutable.List.reverse(List.scala:342)\n\
    \tat Problem$.smallestChange(tmpl2_fuxgt.scala:24)\n\tat Problem$.smallestChange(tmpl2_fuxgt.scala:24)\n\
    \tat Problem$.smallestChange(tmpl2_fuxgt.scala:24)\n\tat Problem$.smallestChange(tmpl2_fuxgt.scala:24)\n\
    \tat Problem$.smallestChange(tmpl2_fuxgt.scala:24)\n\tat Problem$.smallestChange(tmpl2_fuxgt.scala:24)\n\
    \tat Problem$.smallestChange(tmpl2_fuxgt.scala:24)\n\tat Problem$.smallestChange(tmpl2_fuxgt.scala:24)\n\
    \tat Problem$.smallestChange(tmpl2_fuxgt.scala:24)\n\tat Problem$.smallestChange(tmpl2_fuxgt.scala:24)\n\
    \tat Problem$.smallestChange(tmpl2_fuxgt.scala:24)\n\tat Problem$.smallestChange(tmpl2_fuxgt.scala:24)\n\
    \tat Problem$.smallestChange(tmpl2_fuxgt.scala:24)\n\tat Problem$.smallestChange(tmpl2_fuxgt.scala:24)\n\
    \tat Problem$.smallestChange(tmpl2_fuxgt.scala:24)\n\tat Problem$.smallestChange(tmpl2_fuxgt.scala:24)\n\
    \tat Problem$.smallestChange(tmpl2_fuxgt.scala:24)\n\tat Problem$.smallestChange(tmpl2_fuxgt.scala:24)\n\
    \tat Problem$.smallestChange(tmpl2_fuxgt.scala:24)\n\tat Problem$.smallestChange(tmpl2_fuxgt.scala:24)\n\
    \tat Problem$.smallestChange(tmpl2_fuxgt.scala:24)\n\tat Problem$.smallestChange(tmpl2_fuxgt.scala:24)\n\
    \tat Problem$.smallestChange(tmpl2_fuxgt.scala:24)\n\tat Problem$.smallestChange(tmpl2_fuxgt.scala:24)\n\
    \tat Problem$.smallestChange(tmpl2_fuxgt.scala:24)\n\tat Problem$.smallestChange(tmpl2_fuxgt.scala:24)\n\
    \tat Problem$.smallestChange(tmpl2_fuxgt.scala:24)\n\tat Problem$.smallestChange(tmpl2_fuxgt.scala:24)\n\
    \tat Problem$.smallestChange(tmpl2_fuxgt.scala:24)\n\tat Problem$.smallestChange(tmpl2_fuxgt.scala:24)\n\
    \tat Problem$.smallestChange(tmpl2_fuxgt.scala:24)\n\tat Problem$.smallestChange(tmpl2_fuxgt.scala:24)\n\
    \tat Problem$.smallestChange(tmpl2_fuxgt.scala:24)\n\tat Problem$.smallestChange(tmpl2_fuxgt.scala:24)\n\
    \tat Problem$.smallestChange(tmpl2_fuxgt.scala:24)\n\tat Problem$.smallestChange(tmpl2_fuxgt.scala:24)\n\
    \tat Problem$.smallestChange(tmpl2_fuxgt.scala:24)\n\tat Problem$.smallestChange(tmpl2_fuxgt.scala:24)\n\
    \tat Problem$.smallestChange(tmpl"
  stdout: ''
  timestamp: 1660010407
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val p = new Array[Long](n + 1)\n        val\
    \ r = new Array[Long](n + 1)\n        var i = 0\n        var j = 0\n        var\
    \ k = 0\n        var min = 0\n        var max = 0\n        while(i < n) {\n  \
    \          p(k) = arr(i)\n            i += 1\n            k += 1\n        }\n\
    \        while(j < n) {\n            r(k) = arr(j)\n            j += 1\n     \
    \       k += 1\n        }\n        while(i < n) {\n            while(j < n) {\n\
    \                if(p(k) == r(j)) {\n                    min += 1\n          \
    \          j += 1\n                }\n                else {\n               \
    \     max += 1\n                    i += 1\n                }\n            }\n\
    \            while(j < n) {\n                if(p(k) != r(j)) {\n            \
    \        min += 1\n                    i += 1\n                }\n           \
    \     else {\n                    max += 1\n                    j += 1\n     \
    \           }\n            }\n            i += 1\n            j += 1\n       \
    \ }\n        if(min == max) {\n            min\n        }\n        else {\n  \
    \          min + max\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 9 out of bounds for length\
    \ 9\n\tat Problem$.smallestChange(tmprbbntgqb.scala:24)\n\tat Problem$.main(tmprbbntgqb.scala:60)\n\
    \tat Problem.main(tmprbbntgqb.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010408
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.max\n        val minChange = math.min(math.floor(n/2), math.floor(m/2))\n\
    \        val maxChange = math.min(math.floor(n/2), math.floor(m/2))\n        val\
    \ changes = mutable.ListBuffer[Long]()\n        val change = mutable.ListBuffer[Long]()\n\
    \        val changed = mutable.ListBuffer[Long]()\n        val changeMap = mutable.Map[Long,\
    \ Long]()\n        val changeMap2 = mutable.Map[Long, Long]()\n        val changeMap3\
    \ = mutable.Map[Long, Long]()\n        val changeMap4 = mutable.Map[Long, Long]()\n\
    \        val changeMap5 = mutable.Map[Long, Long]()\n        val changeMap6 =\
    \ mutable.Map[Long, Long]()\n        val changeMap7 = mutable.Map[Long, Long]()\n\
    \        val changeMap8 = mutable.Map[Long, Long]()\n        val changeMap9 =\
    \ mutable.Map[Long, Long]()\n        val changeMap10 = mutable.Map[Long, Long]()\n\
    \        val changeMap11 = mutable.Map[Long, Long]()\n        val changeMap12\
    \ = mutable.Map[Long, Long]()\n        val changeMap13 = mutable.Map[Long, Long]()\n\
    \        val changeMap14 = mutable.Map[Long, Long]()\n        val changeMap15\
    \ = mutable.Map[Long, Long]()\n        val changeMap16 = mutable.Map[Long, Long]()\n\
    \        val changeMap17 = mutable.Map[Long, Long]()\n        val changeMap18\
    \ = mutable.Map[Long, Long]()\n        val changeMap19 = mutable.Map[Long, Long]()\n\
    \        val changeMap20 = mutable.Map[Long, Long]()\n        val changeMap21\
    \ = mutable.Map[Long, Long]()\n        val changeMap22 = mutable.Map[Long, Long]()\n\
    \        val changeMap23 = mutable.Map[Long, Long]()\n        val changeMap24\
    \ = mutable.Map[Long, Long]()\n        val changeMap25 = mutable.Map[Long, Long]()\n\
    \        val changeMap26 = mutable.Map[Long, Long]()\n        val changeMap27\
    \ = mutable.Map[Long, Long]()\n        val changeMap28 = mutable.Map[Long, Long]()\n\
    \        val changeMap29 = mutable.Map[Long, Long]()\n        val change\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9bxsi1l3.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9bxsi1l3.scala:13:22\
    \ ------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e\
    [36mchanges\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9bxsi1l3.scala:14:21\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mchange\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9bxsi1l3.scala:15:22\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mchanged\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9bxsi1l3.scala:16:24\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mchangeMap\e[0m = mutable.Map[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp9bxsi1l3.scala:17:25 ------------------------\e[0m\e[0m\n\e[31m17 |\e\
    [0m        \e[33mval\e[0m \e[36mchangeMap2\e[0m = mutable.Map[\e[35mLong\e[0m,\
    \ \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: mutable\n\e[31m  "
  stdout: ''
  timestamp: 1660010405
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val maxChange = math.pow(2, n)\n        val\
    \ changes = mutable.ArrayBuffer.empty[Long]\n        var i = 0\n        while\
    \ (i < n) {\n            val j = n - i - 1\n            val a = arr(i)\n     \
    \       val b = arr(j)\n            val c = math.pow(b, 2)\n            val d\
    \ = math.pow(a, 2)\n            if (c < d) {\n                changes += c\n \
    \               i += 1\n            } else if (c > d) {\n                changes\
    \ += d\n                i -= 1\n            } else {\n                changes\
    \ += b\n                i += 1\n            }\n        }\n        val min = changes.min\n\
    \        if (min > maxChange) {\n            throw new IllegalArgumentException(\"\
    Not a palindromic array\")\n        }\n        min\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2brg8ue1.scala:12:22 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010403
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        val maxChange\
    \ = len\n        var i = 0\n        var j = 0\n        var k = 0\n        while\
    \ (i < len) {\n            while (j < len) {\n                if (arr(i) == arr(j))\
    \ {\n                    j++\n                } else {\n                    k++\n\
    \                }\n            }\n            minChange = Math.min(minChange,\
    \ k)\n            j = k = 0\n            i += 1\n        }\n        minChange\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpb0qpi_sj.scala:19:23 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpb0qpi_sj.scala:21:23 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m                    k++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb0qpi_sj.scala:9:18\
    \ ----------------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m  |\e[0m                  ^\e[0m\n\e\
    [31m  |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpb0qpi_sj.scala:24:22\
    \ -----------------------------\e[0m\e[0m\n\e[31m24 |\e[0m            minChange\
    \ = Math.min(minChange, k)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val minChange\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb0qpi_sj.scala:25:18 --------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            j = k = \e[31m0\e[0m\n\e[31m\e[31m   |\e\
    [0m                ^^^^^\e[0m\n\e[31m   |\e[0m                Found:    Unit\n\
    \e[31m   |\e[0m                Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660010405
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val arr = arr.sortWith(_ < _)\n        val len = arr.length\n       \
    \ val minChange = math.min(len / 2, len - 1)\n        val change = arr.take(minChange).zip(arr.drop(minChange)).map\
    \ { case (l, r) => r - l }\n        val changeCount = change.count(_ > 0)\n  \
    \      val minChangeCount = minChange * changeCount\n        minChangeCount /\
    \ n\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpeogwkgzm.scala:10:18 ---------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m       \
    \           Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010403
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val min =\
    \ arr.min\n        val max = arr.max\n        val mid = len / 2\n        val mid2\
    \ = len / 2\n        val mid3 = len / 2\n        val mid4 = len / 2\n        val\
    \ mid5 = len / 2\n        val mid6 = len / 2\n        val mid7 = len / 2\n   \
    \     val mid8 = len / 2\n        val mid9 = len / 2\n        val mid10 = len\
    \ / 2\n        val mid11 = len / 2\n        val mid12 = len / 2\n        val mid13\
    \ = len / 2\n        val mid14 = len / 2\n        val mid15 = len / 2\n      \
    \  val mid16 = len / 2\n        val mid17 = len / 2\n        val mid18 = len /\
    \ 2\n        val mid19 = len / 2\n        val mid20 = len / 2\n        val mid21\
    \ = len / 2\n        val mid22 = len / 2\n        val mid23 = len / 2\n      \
    \  val mid24 = len / 2\n        val mid25 = len / 2\n        val mid26 = len /\
    \ 2\n        val mid27 = len / 2\n        val mid28 = len / 2\n        val mid29\
    \ = len / 2\n        val mid30 = len / 2\n        val mid31 = len / 2\n      \
    \  val mid32 = len / 2\n        val mid33 = len / 2\n        val mid34 = len /\
    \ 2\n        val mid35 = len / 2\n        val mid36 = len / 2\n        val mid37\
    \ = len / 2\n        val mid38 = len / 2\n        val mid39 = len / 2\n      \
    \  val mid40 = len / 2\n        val mid41 = len / 2\n        val mid42 = len /\
    \ 2\n        val mid43 = len / 2\n        val mid44 = len / 2\n        val mid45\
    \ = len / 2\n        val mid46 = len / 2\n        val mid47 = len / 2\n      \
    \  val mid48 = len / 2\n        val mid49 = len / 2\n        val mid50 = len /\
    \ 2\n        val mid51 = len / 2\n        val mid52 = len / 2\n        val mid53\
    \ = len / 2\n        val mid54 = len / 2\n        val mid55 = len / \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpd14j7j85.scala:68:25 ---------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m        \e[33mval\e[0m \e[36mmid55\e[0m = len / \n\e\
    [31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m   |\e[0m          \
    \               expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpd14j7j85.scala:10:18 ---------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpd14j7j85.scala:69:5 ---------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010406
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val p = new Array[Long](n)\n        val p1 = new Array[Long](n)\n   \
    \     val p2 = new Array[Long](n)\n        val p3 = new Array[Long](n)\n     \
    \   val p4 = new Array[Long](n)\n        val p5 = new Array[Long](n)\n       \
    \ val p6 = new Array[Long](n)\n        val p7 = new Array[Long](n)\n        val\
    \ p8 = new Array[Long](n)\n        val p9 = new Array[Long](n)\n        val p10\
    \ = new Array[Long](n)\n        val p11 = new Array[Long](n)\n        val p12\
    \ = new Array[Long](n)\n        val p13 = new Array[Long](n)\n        val p14\
    \ = new Array[Long](n)\n        val p15 = new Array[Long](n)\n        val p16\
    \ = new Array[Long](n)\n        val p17 = new Array[Long](n)\n        val p18\
    \ = new Array[Long](n)\n        val p19 = new Array[Long](n)\n        val p20\
    \ = new Array[Long](n)\n        val p21 = new Array[Long](n)\n        val p22\
    \ = new Array[Long](n)\n        val p23 = new Array[Long](n)\n        val p24\
    \ = new Array[Long](n)\n        val p25 = new Array[Long](n)\n        val p26\
    \ = new Array[Long](n)\n        val p27 = new Array[Long](n)\n        val p28\
    \ = new Array[Long](n)\n        val p29 = new Array[Long](n)\n        val p30\
    \ = new Array[Long](n)\n        val p31 = new Array[Long](n)\n        val p32\
    \ = new Array[Long](n)\n        val p33 = new Array[Long](n)\n        val p34\
    \ = new Array[Long](n)\n        val p35 = new Array[Long](n)\n        val p36\
    \ = new Array[Long](n)\n        val p37 = new Array[Long](n)\n        val p38\
    \ = new Array[Long](n)\n        val p39 = new Array[Long](n)\n        val p40\
    \ = new Array[Long](n)\n        val p41 = new Array[Long](n)\n        val p42\
    \ = new Array[Long](n)\n        val p43 = new Array[Long](n)\n        val p44\
    \ = new Array[Long](n)\n        val p45 = new Array[Long\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpfb_68dy6.scala:56:4 ----------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ']' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmpfb_68dy6.scala:55:18\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m55 |\e[0m       \
    \ \e[33mval\e[0m \e[36mp45\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mLong\e\
    [0m\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mmissing argument for parameter _length of \e[33mconstructor\e[0m \e[35mArray\e\
    [0m in \e[33mclass\e[0m \e[35mArray\e[0m: (_length: Int): Array[Long]\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpfb_68dy6.scala:56:5 ---------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010384
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val minChange = math.min(math.ceil(n/2), math.floor(n/2))\n\
    \        val changes = mutable.ListBuffer[Long]()\n        val change = mutable.ListBuffer[Long]()\n\
    \        var i = 0\n        var j = 0\n        while (i < n && j < n) {\n    \
    \        if (arr(i) < arr(j)) {\n                change.append(arr(i))\n     \
    \           i += 1\n            } else {\n                change.append(arr(j))\n\
    \                j += 1\n            }\n        }\n        val changeCount = change.size\n\
    \        val changeCount = changeCount / 2\n        val changeCount = changeCount\
    \ * 2\n        val changeCount = changeCount + 1\n        val changeCount = changeCount\
    \ * 2\n        val changeCount = changeCount + 1\n        val changeCount = changeCount\
    \ * 2\n        val changeCount = changeCount + 1\n        val changeCount = changeCount\
    \ * 2\n        val changeCount = changeCount + 1\n        val changeCount = changeCount\
    \ * 2\n        val changeCount = changeCount + 1\n        val changeCount = changeCount\
    \ * 2\n        val changeCount = changeCount + 1\n        val changeCount = changeCount\
    \ * 2\n        val changeCount = changeCount + 1\n        val changeCount = changeCount\
    \ * 2\n        val changeCount = changeCount + 1\n        val changeCount = changeCount\
    \ * 2\n        val changeCount = changeCount + 1\n        val changeCount = changeCount\
    \ * 2\n        val changeCount = changeCount + 1\n        val changeCount = changeCount\
    \ * 2\n        val changeCount = changeCount + 1\n        val changeCount = changeCount\
    \ * 2\n        val changeCount = changeCount + 1\n        val changeCount = changeCount\
    \ * 2\n        val changeCount = changeCount + 1\n        val changeCount = changeCount\
    \ * 2\n        val changeCount = changeCount + 1\n        val changeCount = changeCount\
    \ * 2\n        val changeCount = changeCount + 1\n        val changeCount = changeCount\
    \ * 2\n        val changeCount = changeCount + 1\n        val changeCount = changeCount\
    \ * 2\n        val changeCount = changeCount + 1\n        val changeCount = changeCount\
    \ * 2\n        val changeCount = changeCount + 1\n        val changeCount = changeCount\
    \ * 2\n        val changeCount = changeCount + 1\n        val changeCount = changeCount\
    \ * 2\n        val changeCount = changeCount + 1\n        val changeCount = changeCount\
    \ * 2\n        val changeCount = changeCount + 1\n        val changeCount = changeCount\
    \ * 2\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp_mvvt0yz.scala:70:11 ---------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp_mvvt0yz.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mchangeCount\e[0m = changeCount\
    \ / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchangeCount is already defined as \e[33mvalue\e[0m \e[35mchangeCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_mvvt0yz.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36mchangeCount\e[0m = changeCount * \e\
    [31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mchangeCount is already defined as \e[33mvalue\e[0m \e[35mchangeCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_mvvt0yz.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36mchangeCount\e[0m = changeCount + \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mchangeCount is already defined as \e[33mvalue\e[0m \e[35mchangeCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_mvvt0yz.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mchangeCount\e[0m = changeCount * \e\
    [31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mchangeCount is already defined as \e[33mvalue\e[0m \e[35mchangeCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the s"
  stdout: ''
  timestamp: 1660010406
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val min = len / 2\n        val max = len\
    \ - min\n        val mid = len / 2\n        val changes = mutable.ListBuffer[Long]()\n\
    \        var i = 0\n        while (i < min) {\n            changes += mid\n  \
    \          i += 1\n        }\n        while (i < max) {\n            changes +=\
    \ mid\n            i += 1\n        }\n        val change = changes.min\n     \
    \   val changes = changes.toList\n        val change = changes.min\n        val\
    \ changes = changes.toList\n        val change = changes.min\n        val changes\
    \ = changes.toList\n        val change = changes.min\n        val changes = changes.toList\n\
    \        val change = changes.min\n        val changes = changes.toList\n    \
    \    val change = changes.min\n        val changes = changes.toList\n        val\
    \ change = changes.min\n        val changes = changes.toList\n        val change\
    \ = changes.min\n        val changes = changes.toList\n        val change = changes.min\n\
    \        val changes = changes.toList\n        val change = changes.min\n    \
    \    val changes = changes.toList\n        val change = changes.min\n        val\
    \ changes = changes.toList\n        val change = changes.min\n        val changes\
    \ = changes.toList\n        val change = changes.min\n        val changes = changes.toList\n\
    \        val change = changes.min\n        val changes = changes.toList\n    \
    \    val change = changes.min\n        val changes = changes.toList\n        val\
    \ change = changes.min\n        val changes = changes.toList\n        val change\
    \ = changes.min\n        val changes = changes.toList\n        val change = changes.min\n\
    \        val changes = changes.toList\n        val change = changes.min\n    \
    \    val changes = changes.toList\n        val change = changes.min\n        val\
    \ changes = changes.toList\n        val change = changes.min\n        val changes\
    \ = changes.toList\n        val change = changes.min\n        val changes = changes.toList\n\
    \        val change = changes.min\n        val changes = changes.toList\n    \
    \    val change = changes.min\n        val changes = changes.toList\n        val\
    \ change = changes.min\n        val changes = changes.toList\n        val change\
    \ = changes.min\n        val changes = changes.toList\n        val change = changes.min\n\
    \        val changes = changes.toList\n        val change = changes.min\n    \
    \    val changes = changes.toList\n        val change = changes.min\n        val\
    \ changes = changes.\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnd0hm5hx.scala:82:4 ----------------------------\e\
    [0m\e[0m\n\e[31m82 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpnd0hm5hx.scala:25:12 ---------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = changes.toList\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mchanges is\
    \ already defined as \e[33mvalue\e[0m \e[35mchanges\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnd0hm5hx.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mchange\e[0m = changes.min\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchange is already defined as \e[33mvalue\e[0m \e[35mchange\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpnd0hm5hx.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = changes.toList\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mchanges\
    \ is already defined as \e[33mvalue\e[0m \e[35mchanges\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnd0hm5hx.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mchange\e[0m = changes.min\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchange is already defined as \e[33mvalue\e[0m \e[35mchange\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpnd0hm5hx.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = changes.toList\n\e[31m\e\
    [31m   |\e[0m      "
  stdout: ''
  timestamp: 1660010409
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = n/2\n        val maxChange = math.min(m, n)\n        var change\
    \ = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var minChange\
    \ = math.min(m, n)\n        while(i < maxChange) {\n            while(j < maxChange\
    \ && arr(i) == arr(j)) {\n                j += 1\n            }\n            while(k\
    \ <= j && arr(i) == arr(k)) {\n                k += 1\n            }\n       \
    \     change += k - j\n            i += 1\n            j += 1\n            k +=\
    \ 1\n        }\n        minChange\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiemxdycf.scala:33)\n\tat Problem.main(tmpiemxdycf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010412
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val ans = n\n        val arr = arr.tail\n \
    \       val len = arr.length\n        val mid = len / 2\n        val mid2 = len\
    \ / 2\n        val mid3 = len / 2\n        val mid4 = len / 2\n        val mid5\
    \ = len / 2\n        val mid6 = len / 2\n        val mid7 = len / 2\n        val\
    \ mid8 = len / 2\n        val mid9 = len / 2\n        val mid10 = len / 2\n  \
    \      val mid11 = len / 2\n        val mid12 = len / 2\n        val mid13 = len\
    \ / 2\n        val mid14 = len / 2\n        val mid15 = len / 2\n        val mid16\
    \ = len / 2\n        val mid17 = len / 2\n        val mid18 = len / 2\n      \
    \  val mid19 = len / 2\n        val mid20 = len / 2\n        val mid21 = len /\
    \ 2\n        val mid22 = len / 2\n        val mid23 = len / 2\n        val mid24\
    \ = len / 2\n        val mid25 = len / 2\n        val mid26 = len / 2\n      \
    \  val mid27 = len / 2\n        val mid28 = len / 2\n        val mid29 = len /\
    \ 2\n        val mid30 = len / 2\n        val mid31 = len / 2\n        val mid32\
    \ = len / 2\n        val mid33 = len / 2\n        val mid34 = len / 2\n      \
    \  val mid35 = len / 2\n        val mid36 = len / 2\n        val mid37 = len /\
    \ 2\n        val mid38 = len / 2\n        val mid39 = len / 2\n        val mid40\
    \ = len / 2\n        val mid41 = len / 2\n        val mid42 = len / 2\n      \
    \  val mid43 = len / 2\n        val mid44 = len / 2\n        val mid45 = len /\
    \ 2\n        val mid46 = len / 2\n        val mid47 = len / 2\n        val mid48\
    \ = len / 2\n        val mid49 = len / 2\n        val mid50 = len / 2\n      \
    \  val mid51 = len / 2\n        val mid52 = len / 2\n        val mid53 = len /\
    \ 2\n        val mid54 = len / 2\n        val mid55 = len / 2\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpx1lor2r6.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpx1lor2r6.scala:69:5 ---------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010410
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val changes = mutable.ArrayBuffer(0)\n    \
    \    val change = mutable.ArrayBuffer(0)\n        val changed = mutable.ArrayBuffer(0)\n\
    \        val changeMap = mutable.HashMap[Long, Long]()\n        val changeMap2\
    \ = mutable.HashMap[Long, Long]()\n        val changeMap3 = mutable.HashMap[Long,\
    \ Long]()\n        val changeMap4 = mutable.HashMap[Long, Long]()\n        val\
    \ changeMap5 = mutable.HashMap[Long, Long]()\n        val changeMap6 = mutable.HashMap[Long,\
    \ Long]()\n        val changeMap7 = mutable.HashMap[Long, Long]()\n        val\
    \ changeMap8 = mutable.HashMap[Long, Long]()\n        val changeMap9 = mutable.HashMap[Long,\
    \ Long]()\n        val changeMap10 = mutable.HashMap[Long, Long]()\n        val\
    \ changeMap11 = mutable.HashMap[Long, Long]()\n        val changeMap12 = mutable.HashMap[Long,\
    \ Long]()\n        val changeMap13 = mutable.HashMap[Long, Long]()\n        val\
    \ changeMap14 = mutable.HashMap[Long, Long]()\n        val changeMap15 = mutable.HashMap[Long,\
    \ Long]()\n        val changeMap16 = mutable.HashMap[Long, Long]()\n        val\
    \ changeMap17 = mutable.HashMap[Long, Long]()\n        val changeMap18 = mutable.HashMap[Long,\
    \ Long]()\n        val changeMap19 = mutable.HashMap[Long, Long]()\n        val\
    \ changeMap20 = mutable.HashMap[Long, Long]()\n        val changeMap21 = mutable.HashMap[Long,\
    \ Long]()\n        val changeMap22 = mutable.HashMap[Long, Long]()\n        val\
    \ changeMap23 = mutable.HashMap[Long, Long]()\n        val changeMap24 = mutable.HashMap[Long,\
    \ Long]()\n        val changeMap25 = mutable.HashMap[Long, Long]()\n        val\
    \ changeMap26 = mutable.HashMap[Long, Long]()\n        val changeMap27 = mutable.HashMap[Long,\
    \ Long]()\n        val changeMap28 = mutable.HashMap[Long, Long]()\n        val\
    \ changeMap29 = mutable.HashMap[Long, Long]()\n        val changeMap30 = mutable.HashMap[Long,\
    \ Long]()\n        val change\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprfekzy72.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprfekzy72.scala:11:22\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mchanges\e[0m = mutable.ArrayBuffer(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprfekzy72.scala:12:21\
    \ ------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e\
    [36mchange\e[0m = mutable.ArrayBuffer(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m   \
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprfekzy72.scala:13:22\
    \ ------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e\
    [36mchanged\e[0m = mutable.ArrayBuffer(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprfekzy72.scala:14:24\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mchangeMap\e[0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmprfekzy72.scala:15:25 ------------------------\e[0m\e[0m\n\e[31m15 |\e\
    [0m        \e[33mval\e[0m \e[36mchangeMap2\e[0m = mutable.HashMap[\e[35mLong\e\
    [0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e["
  stdout: ''
  timestamp: 1660010410
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val minChange =\
    \ arr.size\n        val palindromic = arr.map(x => x % 2 == 0).reverse.map(x =>\
    \ x % 2 == 0).reverse\n        val changes = palindromic.count(x => x < minChange)\n\
    \        minChange\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpps3xfglh.scala:10:70 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mpalindromic\e[0m = arr.map(\e\
    [36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e[0m).reverse.map(\e[36mx\e[0m => x\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).reverse\n\e[31m\e[31m   |\e[0m             \
    \                                                       ^^^\e[0m\n\e[31m   |\e\
    [0mvalue % is not a member of Boolean, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe following import might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpps3xfglh.scala:11:47\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mchanges\e[0m = palindromic.count(\e[36mx\e[0m => x < minChange)\n\e[31m\e\
    [31m   |\e[0m                                             ^^^\e[0m\n\e[31m   |\e\
    [0mvalue < is not a member of Nothing, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\
    \e[31m   |\e[0m  import Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\
    \e[31m   |\e[0m  import Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\
    \e[31m   |\e[0m  import Char.char2double\n\e[31m   |\e[0m  import Char.char2float\n\
    \e[31m   |\e[0m  import Char.char2int\n\e[31m   |\e[0m  import Char.char2long\n\
    \e[31m   |\e[0m  import concurrent.duration.Deadline.DeadlineIsOrdered.mkOrderingOps\n\
    \e[31m   |\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660010411
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val max = (n - 1) / 2\n        val min = (n\
    \ - 1) / 2\n        val max2 = max - min\n        val min2 = max - min\n     \
    \   val max3 = max * max\n        val min3 = min * min\n        val max4 = max2\
    \ * max\n        val min4 = min2 * min\n        val max5 = max3 * max\n      \
    \  val min5 = min3 * min\n        val max6 = max4 * max\n        val min6 = min4\
    \ * min\n        val max7 = max5 * max\n        val min7 = min5 * min\n      \
    \  val max8 = max6 * max\n        val min8 = min6 * min\n        val max9 = max7\
    \ * max\n        val min9 = min7 * min\n        val max10 = max8 * max\n     \
    \   val min10 = min8 * min\n        val max11 = max9 * max\n        val min11\
    \ = min9 * min\n        val max12 = max10 * max\n        val min12 = min10 * min\n\
    \        val max13 = max11 * max\n        val min13 = min11 * min\n        val\
    \ max14 = max12 * max\n        val min14 = min12 * min\n        val max15 = max13\
    \ * max\n        val min15 = min13 * min\n        val max16 = max14 * max\n  \
    \      val min16 = min14 * min\n        val max17 = max15 * max\n        val min17\
    \ = min15 * min\n        val max18 = max16 * max\n        val min18 = min16 *\
    \ min\n        val max19 = max17 * max\n        val min19 = min17 * min\n    \
    \    val max20 = max18 * max\n        val min20 = min18 * min\n        val max21\
    \ = max19 * max\n        val min21 = min19 * min\n        val max22 = max20 *\
    \ max\n        val min22 = min20 * min\n        val max23 = max21 * max\n    \
    \    val min23 = min21 * min\n        val max24 = max22 * max\n        val min24\
    \ = min22 * min\n        val max25 = max23 * max\n        val min25 = min23 *\
    \ min\n        val max26 = max24 * max\n        val min26 = min24 * min\n    \
    \    val max27 = max25 * max\n        val min27 = min25 * min\n        val max28\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxq6jb2zz.scala:66:4 ----------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpxq6jb2zz.scala:66:5 ---------------------\e[0m\e[0m\n\e[31m66 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010411
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val changes = mutable.ListBuffer[Long]()\n\
    \        val change = mutable.ListBuffer[Long]()\n        val changed = mutable.ListBuffer[Long]()\n\
    \        val changeIndex = mutable.ListBuffer[Int]()\n        val changeIndex2\
    \ = mutable.ListBuffer[Int]()\n        val changeIndex3 = mutable.ListBuffer[Int]()\n\
    \        val changeIndex4 = mutable.ListBuffer[Int]()\n        val changeIndex5\
    \ = mutable.ListBuffer[Int]()\n        val changeIndex6 = mutable.ListBuffer[Int]()\n\
    \        val changeIndex7 = mutable.ListBuffer[Int]()\n        val changeIndex8\
    \ = mutable.ListBuffer[Int]()\n        val changeIndex9 = mutable.ListBuffer[Int]()\n\
    \        val changeIndex10 = mutable.ListBuffer[Int]()\n        val changeIndex11\
    \ = mutable.ListBuffer[Int]()\n        val changeIndex12 = mutable.ListBuffer[Int]()\n\
    \        val changeIndex13 = mutable.ListBuffer[Int]()\n        val changeIndex14\
    \ = mutable.ListBuffer[Int]()\n        val changeIndex15 = mutable.ListBuffer[Int]()\n\
    \        val changeIndex16 = mutable.ListBuffer[Int]()\n        val changeIndex17\
    \ = mutable.ListBuffer[Int]()\n        val changeIndex18 = mutable.ListBuffer[Int]()\n\
    \        val changeIndex19 = mutable.ListBuffer[Int]()\n        val changeIndex20\
    \ = mutable.ListBuffer[Int]()\n        val changeIndex21 = mutable.ListBuffer[Int]()\n\
    \        val changeIndex22 = mutable.ListBuffer[Int]()\n        val changeIndex23\
    \ = mutable.ListBuffer[Int]()\n        val changeIndex24 = mutable.ListBuffer[Int]()\n\
    \        val changeIndex25 = mutable.ListBuffer[Int]()\n        val changeIndex26\
    \ = mutable.ListBuffer[Int]()\n        val changeIndex27 = mutable.ListBuffer[Int]()\n\
    \        val changeIndex28 = mutable.ListBuffer[Int]()\n        val changeIndex29\
    \ = mutable.ListBuffer[Int]()\n        val changeIndex30 = mutable.ListBuffer[Int]()\n\
    \        val changeIndex31 = mutable.ListBuffer[Int]()\n        val change\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpd8q24_0r.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpd8q24_0r.scala:11:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e\
    [31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpd8q24_0r.scala:12:22\
    \ ------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e\
    [36mchanges\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpd8q24_0r.scala:13:21\
    \ ------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e\
    [36mchange\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpd8q24_0r.scala:14:22\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mchanged\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpd8q24_0r.scala:15:26\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mchangeIndex\e[0m = mutable.ListBuffer[\e[35mInt\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explana"
  stdout: ''
  timestamp: 1660010412
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.max\n        val changes = mutable.ArrayBuffer.empty[Long]\n\
    \        val palindromic = mutable.ArrayBuffer.empty[Long]\n        val palindromicIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val palindromicIndex2 = mutable.ArrayBuffer.empty[Int]\n\
    \        val palindromicIndex3 = mutable.ArrayBuffer.empty[Int]\n        val palindromicIndex4\
    \ = mutable.ArrayBuffer.empty[Int]\n        val palindromicIndex5 = mutable.ArrayBuffer.empty[Int]\n\
    \        val palindromicIndex6 = mutable.ArrayBuffer.empty[Int]\n        val palindromicIndex7\
    \ = mutable.ArrayBuffer.empty[Int]\n        val palindromicIndex8 = mutable.ArrayBuffer.empty[Int]\n\
    \        val palindromicIndex9 = mutable.ArrayBuffer.empty[Int]\n        val palindromicIndex10\
    \ = mutable.ArrayBuffer.empty[Int]\n        val palindromicIndex11 = mutable.ArrayBuffer.empty[Int]\n\
    \        val palindromicIndex12 = mutable.ArrayBuffer.empty[Int]\n        val\
    \ palindromicIndex13 = mutable.ArrayBuffer.empty[Int]\n        val palindromicIndex14\
    \ = mutable.ArrayBuffer.empty[Int]\n        val palindromicIndex15 = mutable.ArrayBuffer.empty[Int]\n\
    \        val palindromicIndex16 = mutable.ArrayBuffer.empty[Int]\n        val\
    \ palindromicIndex17 = mutable.ArrayBuffer.empty[Int]\n        val palindromicIndex18\
    \ = mutable.ArrayBuffer.empty[Int]\n        val palindromicIndex19 = mutable.ArrayBuffer.empty[Int]\n\
    \        val palindromicIndex20 = mutable.ArrayBuffer.empty[Int]\n        val\
    \ palindromicIndex21 = mutable.ArrayBuffer.empty[Int]\n        val palindromicIndex22\
    \ = mutable.ArrayBuffer.empty[Int]\n        val palindromicIndex23 = mutable.ArrayBuffer.empty[Int]\n\
    \        val palindromicIndex24 = mutable.ArrayBuffer.empty[Int]\n        val\
    \ palindromicIndex25 = mutable.ArrayBuffer.empty[Int]\n        val palindromicIndex26\
    \ = mutable.ArrayBuffer.empty[Int]\n        val palindromicIndex27 = mutable.ArrayBuffer.empty[Int\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3qp_rlyq.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ']' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3qp_rlyq.scala:11:22\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mchanges\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3qp_rlyq.scala:12:26\
    \ ------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e\
    [36mpalindromic\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m\
    \   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \              Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp3qp_rlyq.scala:13:31 ------------------------\e[0m\e[0m\n\e[31m13 |\e\
    [0m        \e[33mval\e[0m \e[36mpalindromicIndex\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                               ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                               Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3qp_rlyq.scala:14:32 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mpalindromicIndex2\e[0m =\
    \ mutable.ArrayBuffer.empty[\e[35mInt\e[0m]\n\e[31m\e[31m   |\e[0m           \
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \      Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp3qp_rlyq.scala:15:32 ------------------------\e[0m\e[0m\n\e[31m15 |\e\
    [0m        \e[33mval\e[0m \e[36mpalindromicIndex3\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                      "
  stdout: ''
  timestamp: 1660010411
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val ans = Long.MaxValue\n        for(i <- 0\
    \ until n){\n            val left = arr.take(i).reverse\n            val right\
    \ = arr.drop(i).reverse\n            val leftMin = left.min\n            val rightMin\
    \ = right.min\n            val leftMax = left.max\n            val rightMax =\
    \ right.max\n            val leftDiff = leftMax - leftMin\n            val rightDiff\
    \ = rightMax - rightMin\n            val leftSum = left.sum\n            val rightSum\
    \ = right.sum\n            val leftSumDiff = leftSum - leftMin\n            val\
    \ rightSumDiff = rightSum - rightMin\n            val leftDiffDiff = leftDiff\
    \ - leftSumDiff\n            val rightDiffDiff = rightDiff - rightSumDiff\n  \
    \          val leftMinDiff = leftMax - leftSumDiff\n            val rightMinDiff\
    \ = rightMax - rightSumDiff\n            val leftMaxDiff = leftMax - leftMinDiff\n\
    \            val rightMaxDiff = rightMax - rightMinDiff\n            val leftMinDiffDiff\
    \ = leftMinDiff - leftSumDiff\n            val rightMinDiffDiff = rightMinDiff\
    \ - rightSumDiff\n            val leftMaxDiffDiff = leftMaxDiff - leftMinDiffDiff\n\
    \            val rightMaxDiffDiff = rightMaxDiff - rightMinDiffDiff\n        \
    \    val leftMaxDiffDiffDiff = leftMaxDiffDiff - leftSumDiff\n            val\
    \ rightMaxDiffDiffDiff = rightMaxDiffDiff - rightSumDiffDiff\n            val\
    \ leftMaxDiffDiffDiffDiff = leftMaxDiffDiffDiff - leftSumDiff\n            val\
    \ rightMaxDiffDiffDiff = rightMaxDiffDiffDiff - rightSumDiffDiff\n           \
    \ val leftMaxDiffDiffDiffDiff = leftMaxDiffDiffDiffDiff - leftSumDiff\n      \
    \      val rightMaxDiffDiffDiff = rightMaxDiffDiffDiff - rightSumDiffDiff\n  \
    \          val leftMaxDiffDiffDiffDiff = leftMaxDiffDiffDiffDiff - leftSumDiff\n\
    \            val rightMaxDiffDiffDiff = rightMaxDiffDiffDiff - rightSumDiffDiff\n\
    \            val leftMaxDiffDiffDiffDiff = leftMaxDiffDiffDiffDiff - leftSumDiff\n\
    \            val rightMaxDiffDiffDiff = rightMaxDiffDiffDiff - rightSumDiffDiff\n\
    \            val leftMaxDiffDiffDiffDiff = leftMaxDiffDiffDiffDiff - leftSumDiff\n\
    \            val right\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpklldyi10.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpklldyi10.scala:60:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m60 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpklldyi10.scala:39:16 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m            \e[33mval\e[0m \e[36mleftMaxDiffDiffDiffDiff\e[0m = leftMaxDiffDiffDiffDiff\
    \ - leftSumDiff\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mleftMaxDiffDiffDiffDiff is already defined as \e[33mvalue\e\
    [0m \e[35mleftMaxDiffDiffDiffDiff\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpklldyi10.scala:41:16 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m            \e[33mval\e[0m \e[36mleftMaxDiffDiffDiffDiff\e\
    [0m = leftMaxDiffDiffDiffDiff - leftSumDiff\n\e[31m\e[31m   |\e[0m           \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mleftMaxDiffDiffDiffDiff is already defined as \e[33mvalue\e[0m \e\
    [35mleftMaxDiffDiffDiffDiff\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpklldyi10.scala:43:16 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m            \e[33mval\e[0m \e[36mleftMaxDiffDiffDiffDiff\e\
    [0m = leftMaxDiffDiffDiffDiff - leftSumDiff\n\e[31m\e[31m   |\e[0m           \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mleftMaxDiffDiffDiffDiff is already defined as \e[33mvalue\e[0m \e\
    [35mleftMaxDiffDiffDiffDiff\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpklldyi10.scala:45:16 -----"
  stdout: ''
  timestamp: 1660010413
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val changes = mutable.ListBuffer[Long]()\n\
    \        val palindromic = mutable.ListBuffer[Long]()\n        val change = mutable.ListBuffer[Long]()\n\
    \        val palindromicChange = mutable.ListBuffer[Long]()\n        val changeCount\
    \ = mutable.ListBuffer[Long]()\n        val palindromicChangeCount = mutable.ListBuffer[Long]()\n\
    \        val palindromicChangeCount2 = mutable.ListBuffer[Long]()\n        val\
    \ palindromicChangeCount3 = mutable.ListBuffer[Long]()\n        val palindromicChangeCount4\
    \ = mutable.ListBuffer[Long]()\n        val palindromicChangeCount5 = mutable.ListBuffer[Long]()\n\
    \        val palindromicChangeCount6 = mutable.ListBuffer[Long]()\n        val\
    \ palindromicChangeCount7 = mutable.ListBuffer[Long]()\n        val palindromicChangeCount8\
    \ = mutable.ListBuffer[Long]()\n        val palindromicChangeCount9 = mutable.ListBuffer[Long]()\n\
    \        val palindromicChangeCount10 = mutable.ListBuffer[Long]()\n        val\
    \ palindromicChangeCount11 = mutable.ListBuffer[Long]()\n        val palindromicChangeCount12\
    \ = mutable.ListBuffer[Long]()\n        val palindromicChangeCount13 = mutable.ListBuffer[Long]()\n\
    \        val palindromicChangeCount14 = mutable.ListBuffer[Long]()\n        val\
    \ palindromicChangeCount15 = mutable.ListBuffer[Long]()\n        val palindromicChangeCount16\
    \ = mutable.ListBuffer[Long]()\n        val palindromicChangeCount17 = mutable.ListBuffer[Long]()\n\
    \        val palindromicChangeCount18 = mutable.ListBuffer[Long]()\n        val\
    \ palindromicChangeCount19 = mutable.ListBuffer[Long]()\n        val palindromicChangeCount20\
    \ = mutable.ListBuffer[Long]()\n        val palindromicChangeCount21 = mutable.ListBuffer[Long]()\n\
    \        val palindromicChangeCount22 = mutable.ListBuffer[Long]()\n        val\
    \ palindromicChangeCount23 = mutable.ListBuffer[Long]()\n        val palin\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpaf5b5647.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpaf5b5647.scala:11:22\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mchanges\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpaf5b5647.scala:12:26\
    \ ------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e\
    [36mpalindromic\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpaf5b5647.scala:13:21 ------------------------\e[0m\e[0m\n\e[31m13 |\e\
    [0m        \e[33mval\e[0m \e[36mchange\e[0m = mutable.ListBuffer[\e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpaf5b5647.scala:14:32 ------------------------\e[0m\e\
    [0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mpalindromicChange\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                                ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                Not found: mutable\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpaf5b5647.scala:15:26 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mchangeCount\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Not"
  stdout: ''
  timestamp: 1660010412
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val changes = mutable.ListBuffer[Long]()\n\
    \        val len = arr.length\n        val mid = len / 2\n        var i = 0\n\
    \        var j = 0\n        var k = 0\n        while (i < mid) {\n           \
    \ while (j < len) {\n                if (arr(i) == arr(j)) {\n               \
    \     changes += k\n                    j += 1\n                    k += 1\n \
    \               } else {\n                    j += 1\n                }\n    \
    \        }\n            i += 1\n            j = 0\n            k += 1\n      \
    \  }\n        changes.min\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp63hdf3b9.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010409
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val maxLen = len - 1;\n        val minLen\
    \ = len - 2;\n        val maxChange = arr.take(maxLen).reverse.take(minLen).reverse.length\n\
    \        val minChange = arr.take(minLen).reverse.take(maxLen).reverse.length\n\
    \        val maxChangeMin = arr.take(maxLen).reverse.take(minLen).reverse.length\n\
    \        val minChangeMax = arr.take(minLen).reverse.take(maxLen).reverse.length\n\
    \        val maxChangeMinMax = arr.take(maxLen).reverse.take(minLen).reverse.length\n\
    \        val minChangeMaxMin = arr.take(minLen).reverse.take(maxLen).reverse.length\n\
    \        val maxChangeMinMaxMin = arr.take(maxLen).reverse.take(minLen).reverse.length\n\
    \        val minChangeMaxMinMax = arr.take(minLen).reverse.take(maxLen).reverse.length\n\
    \        val maxChangeMinMaxMinMax = arr.take(maxLen).reverse.take(minLen).reverse.length\n\
    \        val minChangeMaxMinMaxMin = arr.take(minLen).reverse.take(maxLen).reverse.length\n\
    \        val maxChangeMinMaxMinMaxMin = arr.take(maxLen).reverse.take(minLen).reverse.length\n\
    \        val minChangeMaxMinMaxMinMax = arr.take(minLen).reverse.take(maxLen).reverse.length\n\
    \        val maxChangeMinMaxMinMaxMinMax = arr.take(maxLen).reverse.take(minLen).reverse.length\n\
    \        val minChangeMaxMinMaxMinMaxMin = arr.take(minLen).reverse.take(maxLen).reverse.length\n\
    \        val maxChangeMinMaxMinMaxMinMaxMin = arr.take(maxLen).reverse.take(minLen).reverse.length\n\
    \        val minChangeMaxMinMaxMinMaxMinMax = arr.take(minLen).reverse.take(maxLen).reverse.length\n\
    \        val maxChangeMinMaxMinMaxMinMaxMinMax = arr.take(maxLen).reverse.take(minLen).reverse.length\n\
    \        val minChangeMaxMinMaxMinMaxMinMaxMin = arr.take(minLen).reverse.take(maxLen).reverse.length\n\
    \        val maxChangeMinMaxMinMaxMinMaxMinMaxMin = arr.take(maxLen).reverse.take(minLen).reverse.length\n\
    \        val minChangeMaxMinMaxMinMaxMinMaxMinMax = arr.take(minLen).reverse.take\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplymnatje.scala:9:18 ----------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m  |\e[0m                  ^\e[0m\n\e[31m  |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmplymnatje.scala:33:5 ---------------------\e[0m\e\
    [0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010412
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val changes = mutable.ArrayBuffer.empty[Long]\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        while (i < n\
    \ && j < n) {\n            if (arr(i) < arr(j)) {\n                changes +=\
    \ k\n                i += 1\n            } else {\n                changes +=\
    \ k\n                j += 1\n            }\n            k += 1\n        }\n  \
    \      if (i < n) {\n            changes += k\n        }\n        if (j < n) {\n\
    \            changes += k\n        }\n        changes.min\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpq4jf1m3b.scala:11:18 ---------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpq4jf1m3b.scala:12:22 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010411
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val changes = mutable.ListBuffer[Long]()\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var k1 = n -\
    \ 1\n        var k2 = n - 1\n        while (i < n / 2 && j < m / 2) {\n      \
    \      if (arr(i) == arr(j)) {\n                changes += k\n               \
    \ i += 1\n                j += 1\n                k += 1\n            } else if\
    \ (arr(i) > arr(j)) {\n                i += 1\n                k += 1\n      \
    \      } else {\n                j += 1\n                k -= 1\n            }\n\
    \        }\n        if (k1 == k2) {\n            changes += k\n        }\n   \
    \     changes.min\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpgvjg38hc.scala:11:18 ---------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpgvjg38hc.scala:12:22 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010411
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val p = new Array[Long](n+1)\n        val p1\
    \ = new Array[Long](n+1)\n        val p2 = new Array[Long](n+1)\n        val p3\
    \ = new Array[Long](n+1)\n        val p4 = new Array[Long](n+1)\n        val p5\
    \ = new Array[Long](n+1)\n        val p6 = new Array[Long](n+1)\n        val p7\
    \ = new Array[Long](n+1)\n        val p8 = new Array[Long](n+1)\n        val p9\
    \ = new Array[Long](n+1)\n        val p10 = new Array[Long](n+1)\n        val\
    \ p11 = new Array[Long](n+1)\n        val p12 = new Array[Long](n+1)\n       \
    \ val p13 = new Array[Long](n+1)\n        val p14 = new Array[Long](n+1)\n   \
    \     val p15 = new Array[Long](n+1)\n        val p16 = new Array[Long](n+1)\n\
    \        val p17 = new Array[Long](n+1)\n        val p18 = new Array[Long](n+1)\n\
    \        val p19 = new Array[Long](n+1)\n        val p20 = new Array[Long](n+1)\n\
    \        val p21 = new Array[Long](n+1)\n        val p22 = new Array[Long](n+1)\n\
    \        val p23 = new Array[Long](n+1)\n        val p24 = new Array[Long](n+1)\n\
    \        val p25 = new Array[Long](n+1)\n        val p26 = new Array[Long](n+1)\n\
    \        val p27 = new Array[Long](n+1)\n        val p28 = new Array[Long](n+1)\n\
    \        val p29 = new Array[Long](n+1)\n        val p30 = new Array[Long](n+1)\n\
    \        val p31 = new Array[Long](n+1)\n        val p32 = new Array[Long](n+1)\n\
    \        val p33 = new Array[Long](n+1)\n        val p34 = new Array[Long](n+1)\n\
    \        val p35 = new Array[Long](n+1)\n        val p36 = new Array[Long](n+1)\n\
    \        val p37 = new Array[Long](n+1)\n        val p38 = new Array[Long](n+1)\n\
    \        val p39 = new Array[Long](n+1)\n        val p40 = new Array[Long](n+1)\n\
    \        val p41 = new Array[\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphjlkxwoo.scala:53:4 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmphjlkxwoo.scala:52:18\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m52 |\e[0m       \
    \ \e[33mval\e[0m \e[36mp41\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\n\e[31m\e[31m\
    \   |\e[0m                  ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmissing argument for\
    \ parameter _length of \e[33mconstructor\e[0m \e[35mArray\e[0m in \e[33mclass\e\
    [0m \e[35mArray\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphjlkxwoo.scala:53:5\
    \ ---------------------\e[0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010414
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.max\n        val maxChange = arr.size - 1\n        val changes\
    \ = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var changeCount\
    \ = 0\n        while (i < n) {\n            while (j < n && arr(i) == arr(j))\
    \ {\n                j += 1\n            }\n            while (k < n && arr(i)\
    \ != arr(k)) {\n                k += 1\n            }\n            while (k <\
    \ n && arr(i) == arr(k)) {\n                k += 1\n            }\n          \
    \  while (j < n && arr(i) != arr(j)) {\n                j += 1\n            }\n\
    \            if (j == n) {\n                changes += changeCount\n         \
    \       changeCount += 1\n                changes += j\n                j = 0\n\
    \            }\n            if (k == n) {\n                changes += changeCount\n\
    \                changeCount += 1\n                changes += k\n            \
    \    k = 0\n            }\n            i += 1\n        }\n        if (changeCount\
    \ > maxChange) {\n            changes += changeCount\n            changeCount\
    \ += 1\n        }\n        changes.min\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsetk9dfd.scala:12:22 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpsetk9dfd.scala:13:21 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010412
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val min = len/2\n        var i = 0\n  \
    \      var j = 0\n        var changes = 0\n        var temp = 0\n        while(i\
    \ < len) {\n            temp = arr(i)\n            j = i\n            while(j\
    \ < len) {\n                if(arr(j) != temp) {\n                    changes\
    \ += 1\n                    j++\n                } else {\n                  \
    \  j++\n                }\n            }\n            i += 1\n        }\n    \
    \    return changes\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp1l0g5tno.scala:22:23 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp1l0g5tno.scala:24:23 ---------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp1l0g5tno.scala:9:18\
    \ ----------------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m  |\e[0m                  ^\e[0m\n\e\
    [31m  |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010412
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val changes = mutable.ListBuffer[Long]()\n\
    \        var i = 0\n        var j = 0\n        while (i < n && j < n) {\n    \
    \        if (arr(i) < arr(j)) {\n                changes += arr(i)\n         \
    \       i += 1\n            } else {\n                changes += arr(j)\n    \
    \            j += 1\n            }\n        }\n        if (i == n) {\n       \
    \     return m\n        }\n        if (j == n) {\n            return m\n     \
    \   }\n        if (changes.length == 1) {\n            return changes(0)\n   \
    \     }\n        if (changes.length == 2) {\n            return changes(0) - changes(1)\n\
    \        }\n        val maxChange = changes.length\n        val maxChangeIndex\
    \ = changes.max\n        val maxChangeIndex = changes.max\n        val maxChangeIndex\
    \ = changes.max\n        val maxChangeIndex = changes.max\n        val maxChangeIndex\
    \ = changes.max\n        val maxChangeIndex = changes.max\n        val maxChangeIndex\
    \ = changes.max\n        val maxChangeIndex = changes.max\n        val maxChangeIndex\
    \ = changes.max\n        val maxChangeIndex = changes.max\n        val maxChangeIndex\
    \ = changes.max\n        val maxChangeIndex = changes.max\n        val maxChangeIndex\
    \ = changes.max\n        val maxChangeIndex = changes.max\n        val maxChangeIndex\
    \ = changes.max\n        val maxChangeIndex = changes.max\n        val maxChangeIndex\
    \ = changes.max\n        val maxChangeIndex = changes.max\n        val maxChangeIndex\
    \ = changes.max\n        val maxChangeIndex = changes.max\n        val maxChangeIndex\
    \ = changes.max\n        val maxChangeIndex = changes.max\n        val maxChangeIndex\
    \ = changes.max\n        val maxChangeIndex = changes.max\n        val maxChangeIndex\
    \ = changes.max\n        val maxChangeIndex = changes.max\n        val maxChangeIndex\
    \ = changes.max\n        val maxChangeIndex = changes.max\n        val maxChangeIndex\
    \ = changes.max\n        val maxChangeIndex = changes.max\n        val maxChangeIndex\
    \ = changes.max\n        val maxChangeIndex = changes.max\n        val maxChangeIndex\
    \ = changes.max\n        val maxChangeIndex = changes.max\n        val maxChangeIndex\
    \ = changes.max\n        val maxChangeIndex = changes.max\n        val maxChangeIndex\
    \ = changes.max\n        val maxChangeIndex = changes.max\n        val maxChangeIndex\
    \ = changes.max\n        val maxChangeIndex = changes.max\n        val maxChangeIndex\
    \ = changes.max\n        val maxChangeIndex = changes.max\n        val maxChangeIndex\
    \ = changes.max\n        val maxChangeIndex = changes.max\n        val maxChangeIndex\
    \ = changes.max\n        val maxChangeIndex = changes.max\n        val maxChangeIndex\
    \ = changes.max\n        val maxChangeIndex = \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp6b_yasvt.scala:83:28 ---------------------------\e\
    [0m\e[0m\n\e[31m83 |\e[0m        \e[33mval\e[0m \e[36mmaxChangeIndex\e[0m = \n\
    \e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m     \
    \                       expression expected but \e[31m'}'\e[0m found\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6b_yasvt.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mmaxChangeIndex\e[0m = changes.max\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mmaxChangeIndex is already defined as \e[33mvalue\e[0m \e[35mmaxChangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp6b_yasvt.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36mmaxChangeIndex\e[0m = changes.max\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mmaxChangeIndex is already defined as \e[33mvalue\e[0m \e[35mmaxChangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp6b_yasvt.scala:39:12 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m        \e[33mval\e[0m \e[36mmaxChangeIndex\e[0m = changes.max\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mmaxChangeIndex is already defined as \e[33mvalue\e[0m \e[35mmaxChangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp6b_yasvt.scala:40:12 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m        \e[33mval\e[0m \e[36mmaxChangeIndex\e[0m = changes.max\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mmaxChangeIndex is already defined as \e[33mvalue\e[0m \e[35mmaxChangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31"
  stdout: ''
  timestamp: 1660010416
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.take(n/2).length\n        val k = arr.take(n/2).reverse.take(n/2).length\n\
    \        val m = arr.take(n/2).reverse.take(n/2).reverse.length\n        val m\
    \ = arr.take(n/2).reverse.take(n/2).reverse.take(n/2).length\n        val m =\
    \ arr.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.length\n        val\
    \ m = arr.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).length\n\
    \        val m = arr.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.length\n\
    \        val m = arr.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).length\n\
    \        val m = arr.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.length\n\
    \        val m = arr.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).length\n\
    \        val m = arr.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.length\n\
    \        val m = arr.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).length\n\
    \        val m = arr.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.length\n\
    \        val m = arr.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).length\n\
    \        val m = arr.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.length\n\
    \        val m = arr.take(n/2).reverse.take(n/\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpszs90r5s.scala:25:45 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.take(n/\e[31m2\e\
    [0m).reverse.take(n/\n\e[31m\e[31m   |\e[0m                                  \
    \           ^\e[0m\n\e[31m   |\e[0m                                       expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpszs90r5s.scala:12:12 ---------------------------\e[0m\e[0m\n\e[31m12\
    \ |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.take(n/\e[31m2\e[0m).reverse.take(n/\e\
    [31m2\e[0m).reverse.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpszs90r5s.scala:13:12 ---------------------------\e[0m\e[0m\n\e[31m13\
    \ |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.take(n/\e[31m2\e[0m).reverse.take(n/\e\
    [31m2\e[0m).reverse.take(n/\e[31m2\e[0m).length\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpszs90r5s.scala:14:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m\
    \ \e[36mm\e[0m = arr.take(n/\e[31m2\e[0m).reverse.take(n/\e[31m2\e[0m).reverse.take(n/\e\
    [31m2\e[0m).reverse.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpszs90r5s.scala:15:12 ---------------------------\e[0m\e[0m\n\e[31m15"
  stdout: ''
  timestamp: 1660010416
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val min = arr.min\n        val max = arr.max\n\
    \        val mid = len / 2\n        val left = new Array[Long](mid)\n        val\
    \ right = new Array[Long](len - mid)\n        val leftIndex = 0\n        val rightIndex\
    \ = 0\n        val changes = 0\n        while(leftIndex < mid && rightIndex <\
    \ len) {\n            val left = arr(leftIndex)\n            val right = arr(rightIndex)\n\
    \            if(left > right) {\n                left.copy(rightIndex)\n     \
    \           changes += 1\n                leftIndex += 1\n            } else {\n\
    \                right.copy(leftIndex)\n                changes += 1\n       \
    \         rightIndex += 1\n            }\n        }\n        changes\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp82kkqn2q.scala:9:18 ----------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m  |\e[0m                  ^\e[0m\n\e[31m  |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp82kkqn2q.scala:24:24 ------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m                changes += \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              value += is not\
    \ a member of Int - did you mean changes.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp82kkqn2q.scala:25:26 ------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m                leftIndex += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m     \
    \           ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member\
    \ of Int - did you mean leftIndex.!=?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp82kkqn2q.scala:28:24 ------------------------\e[0m\e[0m\n\e[31m28 |\e\
    [0m                changes += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m            \
    \    ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              value += is not a member of\
    \ Int - did you mean changes.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp82kkqn2q.scala:29:27\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m                rightIndex\
    \ += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m           value += is not a member of Int - did you mean rightIndex.!=?\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1660010418
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val changes = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_fbzlmse.scala:15:12 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchanged is already defined as \e[33mvalue\e[0m \e[35mchanged\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_fbzlmse.scala:16:12 ---------------------------\e[0m\e[0m\n\e\
    [31m16 |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchange is already defined as \e[33mvalue\e[0m \e[35mchange\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_fbzlmse.scala:17:12 ---------------------------\e[0m\e[0m\n\e\
    [31m17 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchanged is already defined as \e[33mvalue\e[0m \e[35mchanged\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_fbzlmse.scala:18:12 ---------------------------\e[0m\e[0m\n\e\
    [31m18 |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchange is already defined as \e[33mvalue\e[0m \e[35mchange\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_fbzlmse.scala:19:12 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e"
  stdout: ''
  timestamp: 1660010353
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val palindromicArray = arr.toSet.toList\n        val changes = mutable.Set[Long]()\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var change =\
    \ 0\n        while(i < n) {\n            while(j < n) {\n                if(arr(i)\
    \ == arr(j)) {\n                    j += 1\n                } else {\n       \
    \             val temp = arr(i)\n                    arr(i) = arr(j)\n       \
    \             arr(j) = temp\n                    change += 1\n               \
    \     changes += change\n                    j = 0\n                }\n      \
    \      }\n            i += 1\n            j += 1\n        }\n        changes +=\
    \ change\n        changes.min\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsg2kefww.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.Set[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpsg2kefww.scala:22:20 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                    arr(i) = arr(j)\n\e[31m\e[31m   |\e\
    [0m                    ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member\
    \ of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpsg2kefww.scala:23:20 ------------------------\e[0m\e[0m\n\e[31m23 |\e\
    [0m                    arr(j) = temp\n\e[31m\e[31m   |\e[0m                  \
    \  ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long] - did\
    \ you mean arr.updated?\n3 errors found\n"
  stdout: ''
  timestamp: 1660010419
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.last\n        val result = new Array[Long](n)\n        var\
    \ i = 0\n        var j = 0\n        var k = 0\n        var minChange = 0\n   \
    \     while (i < n && j < n) {\n            if (arr(i) < arr(j)) {\n         \
    \       result(i) = arr(i)\n                i += 1\n            } else {\n   \
    \             result(j) = arr(j)\n                j += 1\n            }\n    \
    \        k += 1\n        }\n        if (k > 0) {\n            minChange = k\n\
    \        }\n        while (i < n) {\n            result(i) = arr(i)\n        \
    \    i += 1\n        }\n        while (j < n) {\n            result(j) = arr(j)\n\
    \            j += 1\n        }\n        if (minChange > 0) {\n            minChange\
    \ = minChange * 2\n        }\n        minChange\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpovo28o4u.scala:43)\n\tat Problem.main(tmpovo28o4u.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010421
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val palindromic = new mutable.ListBuffer[Long]()\n\
    \        var i = 0\n        while (i < n) {\n            val j = n - 1\n     \
    \       while (j >= 0) {\n                if (arr(i) == arr(j)) {\n          \
    \          palindromic.append(arr(i))\n                    palindromic.append(arr(j))\n\
    \                    palindromic.append(arr(i))\n                    palindromic.append(arr(j))\n\
    \                    palindromic.append(arr(i))\n                    palindromic.append(arr(j))\n\
    \                    palindromic.append(arr(i))\n                    palindromic.append(arr(j))\n\
    \                    palindromic.append(arr(i))\n                    palindromic.append(arr(j))\n\
    \                    palindromic.append(arr(i))\n                    palindromic.append(arr(j))\n\
    \                    palindromic.append(arr(i))\n                    palindromic.append(arr(j))\n\
    \                    palindromic.append(arr(i))\n                    palindromic.append(arr(j))\n\
    \                    palindromic.append(arr(i))\n                    palindromic.append(arr(j))\n\
    \                    palindromic.append(arr(i))\n                    palindromic.append(arr(j))\n\
    \                    palindromic.append(arr(i))\n                    palindromic.append(arr(j))\n\
    \                    palindromic.append(arr(i))\n                    palindromic.append(arr(j))\n\
    \                    palindromic.append(arr(i))\n                    palindromic.append(arr(j))\n\
    \                    palindromic.append(arr(i))\n                    palindromic.append(arr(j))\n\
    \                    palindromic.append(arr(i))\n                    palindromic.append(arr(j))\n\
    \                    palindromic.append(arr(i))\n                    palindromic.append(arr(j))\n\
    \                    palindromic.append(arr(i))\n                    palindromic.append(arr(j))\n\
    \                    palindromic.append(arr(i))\n                    palindromic.append(arr(j))\n\
    \                    palindromic.append(arr(i))\n                    palindromic.append(arr(j))\n\
    \                    palindromic.append(arr(i))\n                    palindromic.append(arr(j))\n\
    \                    palindromic.append(arr(i))\n                    palindromic.append(arr(j))\n\
    \                    palindromic.append(arr(i))\n                    palindromic\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9vvc43tn.scala:74:0 ----------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9vvc43tn.scala:11:30\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mpalindromic\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e\
    [31m\e[31m   |\e[0m                              ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                              Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp9vvc43tn.scala:13:8 ---------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mwhile\e[0m (i < n) {\n\e[31m\e[31m   |\e\
    [0m        ^\e[0m\n\e[31m   |\e[0m        Found:    Unit\n\e[31m   |\e[0m    \
    \    Required: Long\n\e[31m14 |\e[0m            \e[33mval\e[0m \e[36mj\e[0m =\
    \ n - \e[31m1\e[0m\n\e[31m15 |\e[0m            \e[33mwhile\e[0m (j >= \e[31m0\e\
    [0m) {\n\e[31m16 |\e[0m                \e[33mif\e[0m (arr(i) == arr(j)) {\n\e\
    [31m17 |\e[0m                    palindromic.append(arr(i))\n\e[31m18 |\e[0m \
    \                   palindromic.append(arr(j))\n\e[31m19 |\e[0m              \
    \      palindromic.append(arr(i))\n\e[31m20 |\e[0m                    palindromic.append(arr(j))\n\
    \e[31m21 |\e[0m                    palindromic.append(arr(i))\n\e[31m22 |\e[0m\
    \                    palindromic.append(arr(j))\n\e[31m23 |\e[0m             \
    \       palindromic.append(arr(i))\n\e[31m24 |\e[0m                    palindromic.append(arr(j))\n\
    \e[31m25 |\e[0m                    palindromic.append(arr(i))\n\e[31m26 |\e[0m\
    \                    palindromic.append(arr(j))\n\e[31m27 |\e[0m             \
    \       palindromic.append(arr(i))\n\e[31m28 |\e[0m                    palindromic.append(arr(j))\n\
    \e[31m29 |\e[0m                    palindromic.append(arr(i))\n\e[31m30 |\e[0m\
    \                    palindromic.append(arr(j))\n\e[31m31 |\e[0m             \
    \       palindromic.append(arr(i))\n\e[31m32 |\e[0m                    palindromic.append(arr(j))\n\
    \e[31m33 |\e[0m                    palindromic.append(arr(i)"
  stdout: ''
  timestamp: 1660010420
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val changes = mutable.ListBuffer[Long]()\n\
    \        val start = 0\n        var end = n-1\n        while (start < end) {\n\
    \            val mid = (start + end) / 2\n            if (mid < 0 || mid > n-1)\
    \ break\n            if (mid < m) {\n                end = mid - 1\n         \
    \   } else {\n                start = mid + 1\n            }\n            changes\
    \ += mid\n        }\n        changes.min\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5ft8lmvt.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp5ft8lmvt.scala:16:38 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[33mif\e[0m (mid < \e[31m0\e[0m || mid\
    \ > n-\e[31m1\e[0m) break\n\e[31m\e[31m   |\e[0m                             \
    \         ^^^^^\e[0m\n\e[31m   |\e[0m                                      Not\
    \ found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp5ft8lmvt.scala:20:22\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m                start\
    \ = mid + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Reassignment to val start\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010417
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val minChange =\
    \ arr.length\n        val palindromic = arr.toSet.toList.reverse.forall(arr.contains(_))\n\
    \        if (palindromic) minChange else minChange + 1\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkxv3d0gb.scala:14)\n\tat Problem.main(tmpkxv3d0gb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010423
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.max\n        val result = new Array[Long](n)\n        val\
    \ arr = arr.toList\n        var i = 0\n        var j = 0\n        var k = 0\n\
    \        var min = 0\n        var max = 0\n        while (i < n) {\n         \
    \   while (j < n) {\n                if (arr(i) == arr(j)) {\n               \
    \     val temp = arr(i)\n                    arr(i) = arr(j)\n               \
    \     arr(j) = temp\n                    j++\n                }\n            \
    \    else {\n                    j++\n                }\n            }\n     \
    \       val temp = arr(i)\n            arr(i) = arr(j)\n            arr(j) = temp\n\
    \            val temp = arr(i)\n            arr(i) = arr(j)\n            arr(j)\
    \ = temp\n            val temp = arr(i)\n            arr(i) = arr(j)\n       \
    \     arr(j) = temp\n            val temp = arr(i)\n            arr(i) = arr(j)\n\
    \            arr(j) = temp\n            val temp = arr(i)\n            arr(i)\
    \ = arr(j)\n            arr(j) = temp\n            val temp = arr(i)\n       \
    \     arr(i) = arr(j)\n            arr(j) = temp\n            val temp = arr(i)\n\
    \            arr(i) = arr(j)\n            arr(j) = temp\n            val temp\
    \ = arr(i)\n            arr(i) = arr(j)\n            arr(j) = temp\n         \
    \   val temp = arr(i)\n            arr(i) = arr(j)\n            arr(j) = temp\n\
    \            val temp = arr(i)\n            arr(i) = arr(j)\n            arr(j)\
    \ = temp\n            val temp = arr(i)\n            arr(i) = arr(j)\n       \
    \     arr(j) = temp\n            val temp = arr(i)\n            arr(i) = arr(j)\n\
    \            arr(j) = temp\n            val temp = arr(i)\n            arr(i)\
    \ = arr(j)\n            arr(j) = temp\n            val temp = arr(i)\n       \
    \     arr(i) = arr(j)\n            arr(j) = temp\n            val temp = arr(i)\n\
    \            arr(i) = arr(j)\n            arr(j) = temp\n            val temp\
    \ = arr(i)\n            arr(i) = arr(j)\n            arr(j) = temp\n         \
    \   val temp = arr(i)\n            arr(i) = arr(j)\n            arr(j) = temp\n\
    \            val temp = arr(i)\n            arr(i) = arr(j)\n            arr(j)\
    \ = temp\n            val temp = arr(i)\n            arr(i) = arr(j)\n       \
    \     arr(j) = temp\n            val temp = arr(i)\n            arr(i\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp3imv8a36.scala:24:23 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp3imv8a36.scala:27:23 ---------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3imv8a36.scala:89:4\
    \ ----------------------------\e[0m\e[0m\n\e[31m89 |\e[0m    }\n\e[31m\e[31m \
    \  |\e[0m    ^\e[0m\n\e[31m   |\e[0m    ')' expected, but '}' found\n\e[31m\e\
    [31m-- [E040] Syntax Error: /tmp/tmp3imv8a36.scala:102:0 ---------------------------\e\
    [0m\e[0m\n\e[31m102 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp3imv8a36.scala:12:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3imv8a36.scala:33:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e\
    [0m \e[36mtemp\e[0m = arr(i)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mtemp is already defined as \e[33mvalue\e[0m \e[35mtemp\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp3imv8a36.scala:36:16 ---------------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m            \e[33mval\e[0m \e[36mtemp\e[0m = arr(i)\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^\e"
  stdout: ''
  timestamp: 1660010422
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val m = arr.length\n\
    \        val n = arr.head\n        val arr = arr.tail\n        val changes = mutable.ArrayBuffer.empty[Long]\n\
    \        var i = 0\n        var j = 0\n        while (i < m && j < n) {\n    \
    \        if (arr(i) < arr(j)) {\n                changes += arr(i)\n         \
    \       i += 1\n            } else {\n                changes += arr(j)\n    \
    \            j += 1\n            }\n        }\n        if (i == m) {\n       \
    \     changes += arr(j)\n        }\n        if (j == n) {\n            changes\
    \ += arr(i)\n        }\n        changes.min\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb2c1qvxx.scala:11:18 ---------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpb2c1qvxx.scala:12:22 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010418
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val maxChange = arr.tail.foldLeft(0)((acc,\
    \ x) => acc + (x - m))\n        val maxChange2 = arr.tail.foldLeft(0)((acc, x)\
    \ => acc + (x - m))\n        val maxChange3 = arr.tail.foldLeft(0)((acc, x) =>\
    \ acc + (x - m))\n        val maxChange4 = arr.tail.foldLeft(0)((acc, x) => acc\
    \ + (x - m))\n        val maxChange5 = arr.tail.foldLeft(0)((acc, x) => acc +\
    \ (x - m))\n        val maxChange6 = arr.tail.foldLeft(0)((acc, x) => acc + (x\
    \ - m))\n        val maxChange7 = arr.tail.foldLeft(0)((acc, x) => acc + (x -\
    \ m))\n        val maxChange8 = arr.tail.foldLeft(0)((acc, x) => acc + (x - m))\n\
    \        val maxChange9 = arr.tail.foldLeft(0)((acc, x) => acc + (x - m))\n  \
    \      val maxChange10 = arr.tail.foldLeft(0)((acc, x) => acc + (x - m))\n   \
    \     val maxChange11 = arr.tail.foldLeft(0)((acc, x) => acc + (x - m))\n    \
    \    val maxChange12 = arr.tail.foldLeft(0)((acc, x) => acc + (x - m))\n     \
    \   val maxChange13 = arr.tail.foldLeft(0)((acc, x) => acc + (x - m))\n      \
    \  val maxChange14 = arr.tail.foldLeft(0)((acc, x) => acc + (x - m))\n       \
    \ val maxChange15 = arr.tail.foldLeft(0)((acc, x) => acc + (x - m))\n        val\
    \ maxChange16 = arr.tail.foldLeft(0)((acc, x) => acc + (x - m))\n        val maxChange17\
    \ = arr.tail.foldLeft(0)((acc, x) => acc + (x - m))\n        val maxChange18 =\
    \ arr.tail.foldLeft(0)((acc, x) => acc + (x - m))\n        val maxChange19 = arr.tail.foldLeft(0)((acc,\
    \ x) => acc + (x - m))\n        val maxChange20 = arr.tail.foldLeft(0)((acc, x)\
    \ => acc + (x - m))\n        val maxChange21 = arr.tail.foldLeft(0)((acc, x) =>\
    \ acc + (x - m))\n        val maxChange22 = arr.tail\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph171c6ij.scala:11:57\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mmaxChange\e\
    [0m = arr.tail.foldLeft(\e[31m0\e[0m)((\e[36macc\e[0m, \e[36mx\e[0m) => acc +\
    \ (x - m))\n\e[31m\e[31m   |\e[0m                                            \
    \             ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                             \
    \                            Found:    Long\n\e[31m   |\e[0m                 \
    \                                        Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmph171c6ij.scala:12:58 --------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mmaxChange2\e[0m = arr.tail.foldLeft(\e\
    [31m0\e[0m)((\e[36macc\e[0m, \e[36mx\e[0m) => acc + (x - m))\n\e[31m\e[31m   |\e\
    [0m                                                          ^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                                          Found:\
    \    Long\n\e[31m   |\e[0m                                                   \
    \       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph171c6ij.scala:13:58\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxChange3\e\
    [0m = arr.tail.foldLeft(\e[31m0\e[0m)((\e[36macc\e[0m, \e[36mx\e[0m) => acc +\
    \ (x - m))\n\e[31m\e[31m   |\e[0m                                            \
    \              ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                            \
    \                              Found:    Long\n\e[31m   |\e[0m               \
    \                                           Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph171c6ij.scala:14:58 --------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mmaxChange4\e[0m = arr.tail.foldLeft(\e\
    [31m0\e[0m)((\e[36macc\e[0m, \e[36mx\e[0m) => acc + (x - m))\n\e[31m\e[31m   |\e\
    [0m                                                          "
  stdout: ''
  timestamp: 1660010425
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val min = len / 2\n        val max = len\
    \ - min\n        val mid = len / 2\n        val changes = mutable.HashMap[Long,\
    \ Long]()\n        val change = mutable.HashMap[Long, Long]()\n        var i =\
    \ 0\n        var j = 0\n        var k = 0\n        var k1 = len - 1\n        var\
    \ k2 = len - 1\n        var k3 = len - 1\n        var k4 = len - 1\n        var\
    \ k5 = len - 1\n        var k6 = len - 1\n        var k7 = len - 1\n        var\
    \ k8 = len - 1\n        var k9 = len - 1\n        var k10 = len - 1\n        var\
    \ k11 = len - 1\n        var k12 = len - 1\n        var k13 = len - 1\n      \
    \  var k14 = len - 1\n        var k15 = len - 1\n        var k16 = len - 1\n \
    \       var k17 = len - 1\n        var k18 = len - 1\n        var k19 = len -\
    \ 1\n        var k20 = len - 1\n        var k21 = len - 1\n        var k22 = len\
    \ - 1\n        var k23 = len - 1\n        var k24 = len - 1\n        var k25 =\
    \ len - 1\n        var k26 = len - 1\n        var k27 = len - 1\n        var k28\
    \ = len - 1\n        var k29 = len - 1\n        var k30 = len - 1\n        var\
    \ k31 = len - 1\n        var k32 = len - 1\n        var k33 = len - 1\n      \
    \  var k34 = len - 1\n        var k35 = len - 1\n        var k36 = len - 1\n \
    \       var k37 = len - 1\n        var k38 = len - 1\n        var k39 = len -\
    \ 1\n        var k40 = len - 1\n        var k41 = len - 1\n        var k42 = len\
    \ - 1\n        var k43 = len - 1\n        var k44 = len - 1\n        var k45 =\
    \ len - 1\n        var k46 = len - 1\n        var k47 = len - 1\n        var k48\
    \ = len - 1\n        var k49 = len - 1\n        var k50 = len - 1\n        var\
    \ k51 = len - 1\n        var k52 = len - 1\n        var k53 = len - 1\n      \
    \  var k54 = len - 1\n        var k55 = len - 1\n        var k56 = len - 1\n \
    \       var k57 = len - 1\n        var k58 = len - 1\n        var k59 = len -\
    \ 1\n        var k60 = len - 1\n        var k61 = len - 1\n        var k62 = len\
    \ - 1\n        var k63 = len - 1\n        var k64 = len - 1\n        var k65 =\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmps9gcp44e.scala:83:17 ---------------------------\e\
    [0m\e[0m\n\e[31m83 |\e[0m        \e[33mvar\e[0m \e[36mk65\e[0m = \n\e[31m\e[31m\
    \   |\e[0m                 ^\e[0m\n\e[31m   |\e[0m                 expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmps9gcp44e.scala:9:18 ----------------------------\e[0m\e[0m\n\e[31m9\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m  |\e\
    [0m                  ^\e[0m\n\e[31m  |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmps9gcp44e.scala:14:22 ------------------------\e[0m\e[0m\n\e[31m14 |\e\
    [0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.HashMap[\e[35mLong\e[0m,\
    \ \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmps9gcp44e.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmps9gcp44e.scala:84:5 ---------------------\e\
    [0m\e[0m\n\e[31m84 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n5 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010422
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val changes = mutable.ArrayBuffer.empty[Long]\n\
    \        val change = mutable.ArrayBuffer.empty[Long]\n        val changed = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeIndex = mutable.ArrayBuffer.empty[Int]\n        val changeIndex2\
    \ = mutable.ArrayBuffer.empty[Int]\n        val changeIndex3 = mutable.ArrayBuffer.empty[Int]\n\
    \        val changeIndex4 = mutable.ArrayBuffer.empty[Int]\n        val changeIndex5\
    \ = mutable.ArrayBuffer.empty[Int]\n        val changeIndex6 = mutable.ArrayBuffer.empty[Int]\n\
    \        val changeIndex7 = mutable.ArrayBuffer.empty[Int]\n        val changeIndex8\
    \ = mutable.ArrayBuffer.empty[Int]\n        val changeIndex9 = mutable.ArrayBuffer.empty[Int]\n\
    \        val changeIndex10 = mutable.ArrayBuffer.empty[Int]\n        val changeIndex11\
    \ = mutable.ArrayBuffer.empty[Int]\n        val changeIndex12 = mutable.ArrayBuffer.empty[Int]\n\
    \        val changeIndex13 = mutable.ArrayBuffer.empty[Int]\n        val changeIndex14\
    \ = mutable.ArrayBuffer.empty[Int]\n        val changeIndex15 = mutable.ArrayBuffer.empty[Int]\n\
    \        val changeIndex16 = mutable.ArrayBuffer.empty[Int]\n        val changeIndex17\
    \ = mutable.ArrayBuffer.empty[Int]\n        val changeIndex18 = mutable.ArrayBuffer.empty[Int]\n\
    \        val changeIndex19 = mutable.ArrayBuffer.empty[Int]\n        val changeIndex20\
    \ = mutable.ArrayBuffer.empty[Int]\n        val changeIndex21 = mutable.ArrayBuffer.empty[Int]\n\
    \        val changeIndex22 = mutable.ArrayBuffer.empty[Int]\n        val changeIndex23\
    \ = mutable.ArrayBuffer.empty[Int]\n        val changeIndex24 = mutable.ArrayBuffer.empty[Int]\n\
    \        val changeIndex25 = mutable.ArrayBuffer.empty[Int]\n        val changeIndex26\
    \ = mutable.ArrayBuffer.empty[Int]\n        val changeIndex27 = mutable.ArrayBuffer.empty[Int]\n\
    \        val changeIndex28 = mutable.ArrayBuffer.empty[Int]\n        val changeIndex29\
    \ = mutable.ArrayBuffer.empty[Int]\n        val changeIndex30 = mutable.ArrayBuffer.empty[Int]\n\
    \        val changeIndex31 = mutable.ArrayBuffer.empty[Int]\n        val change\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8imti1yz.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8imti1yz.scala:11:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e\
    [31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8imti1yz.scala:12:22\
    \ ------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e\
    [36mchanges\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8imti1yz.scala:13:21\
    \ ------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e\
    [36mchange\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8imti1yz.scala:14:22\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mchanged\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8imti1yz.scala:15:26\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mchangeIndex\e[0m = mutable.ArrayBuffer.empty[\e[35mInt\e[0m]\n\e[31m\e[31m\
    \   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \              Not found: mutable\n\e[31m   |\e[0m\n\e[31m   "
  stdout: ''
  timestamp: 1660010423
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val changes = mutable.ArrayBuffer.empty[Long]\n\
    \        val palindromic = mutable.ArrayBuffer.empty[Long]\n        val change\
    \ = mutable.ArrayBuffer.empty[Long]\n        var i = 0\n        while (i < n)\
    \ {\n            val j = n - i - 1\n            val k = j - 1\n            val\
    \ x = arr(j)\n            val y = arr(k)\n            if (x == y) {\n        \
    \        palindromic += x\n                changes += x\n                change\
    \ += x\n                i += 1\n            } else {\n                val z =\
    \ x - y\n                if (z < 0) {\n                    palindromic += z\n\
    \                    changes += z\n                    change += z\n         \
    \           i += 1\n                } else {\n                    palindromic\
    \ += y\n                    changes += y\n                    change += y\n  \
    \                  i += 1\n                }\n            }\n        }\n     \
    \   if (palindromic.length == 1) {\n            changes += palindromic(0)\n  \
    \          change += palindromic(0)\n        }\n        if (changes.length ==\
    \ 1) {\n            changes += change(0)\n            change += change(0)\n  \
    \      }\n        changes.length\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppgp_2eu4.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmppgp_2eu4.scala:12:26 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mpalindromic\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmppgp_2eu4.scala:13:21 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010419
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val minChange = math.min(arr.take(arr.length / 2).sum, arr.take(arr.length\
    \ / 2).reverse.sum)\n        val maxChange = math.min(arr.take(arr.length / 2).sum,\
    \ arr.take(arr.length / 2).reverse.sum)\n        val change = minChange\n    \
    \    val changes = arr.take(arr.length / 2).reverse.tail.foldLeft(0)((acc, x)\
    \ => acc + x)\n        val changed = changes - change\n        val changed = changes\
    \ - change\n        val changed = changes - change\n        val changed = changes\
    \ - change\n        val changed = changes - change\n        val changed = changes\
    \ - change\n        val changed = changes - change\n        val changed = changes\
    \ - change\n        val changed = changes - change\n        val changed = changes\
    \ - change\n        val changed = changes - change\n        val changed = changes\
    \ - change\n        val changed = changes - change\n        val changed = changes\
    \ - change\n        val changed = changes - change\n        val changed = changes\
    \ - change\n        val changed = changes - change\n        val changed = changes\
    \ - change\n        val changed = changes - change\n        val changed = changes\
    \ - change\n        val changed = changes - change\n        val changed = changes\
    \ - change\n        val changed = changes - change\n        val changed = changes\
    \ - change\n        val changed = changes - change\n        val changed = changes\
    \ - change\n        val changed = changes - change\n        val changed = changes\
    \ - change\n        val changed = changes - change\n        val changed = changes\
    \ - change\n        val changed = changes - change\n        val changed = changes\
    \ - change\n        val changed = changes - change\n        val changed = changes\
    \ - change\n        val changed = changes - change\n        val changed = changes\
    \ - change\n        val changed = changes - change\n        val changed = changes\
    \ - change\n        val changed = changes - change\n        val changed = changes\
    \ - change\n        val changed = changes - change\n        val changed = changes\
    \ - change\n        val changed = changes - change\n        val changed = changes\
    \ - change\n        val changed = changes - change\n        val changed = changes\
    \ - change\n        val changed = changes - change\n        val changed = changes\
    \ - change\n        val changed = changes - change\n        val changed = changes\
    \ - change\n        val changed = changes - change\n        val changed = changes\
    \ - change\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp45a267w3.scala:15:12 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = changes -\
    \ change\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mchanged is already defined as \e[33mvalue\e[0m \e[35mchanged\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp45a267w3.scala:16:12 ---------------------------\e[0m\e[0m\n\e[31m16\
    \ |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = changes - change\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mchanged\
    \ is already defined as \e[33mvalue\e[0m \e[35mchanged\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp45a267w3.scala:17:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m\
    \ \e[36mchanged\e[0m = changes - change\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchanged is already defined as \e[33mvalue\e[0m \e[35mchanged\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp45a267w3.scala:18:12 ---------------------------\e[0m\e[0m\n\e\
    [31m18 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = changes - change\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mchanged\
    \ is already defined as \e[33mvalue\e[0m \e[35mchanged\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp45a267w3.scala:19:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36mchanged\e[0m = changes - change\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchanged is already defined as \e[33mvalue\e[0m \e[35mchanged\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded met"
  stdout: ''
  timestamp: 1660010423
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val p = new Array[Long](n)\n        var i =\
    \ 0\n        var j = 0\n        var k = 0\n        var min = Long.MaxValue\n \
    \       while (i < n && j < n) {\n            if (arr(i) == arr(j)) {\n      \
    \          p(i) = arr(i)\n                i += 1\n                j += 1\n   \
    \             k += 1\n            } else if (arr(i) < arr(j)) {\n            \
    \    p(i) = arr(j)\n                j += 1\n                k += 1\n         \
    \   } else {\n                p(i) = arr(i)\n                i += 1\n        \
    \        k += 1\n            }\n            if (k == m) {\n                min\
    \ = Math.min(min, p(i))\n                k = 0\n            }\n        }\n   \
    \     min\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 8 out of bounds for length\
    \ 8\n\tat Problem$.smallestChange(tmp1viawmwq.scala:32)\n\tat Problem$.main(tmp1viawmwq.scala:39)\n\
    \tat Problem.main(tmp1viawmwq.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010424
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val minChange = math.min(math.abs(m), math.abs(n-m))\n\
    \        val changes = mutable.ArrayBuffer.empty[Long]\n        val change = math.min(math.abs(m),\
    \ math.abs(n-m))\n        val changed = mutable.ArrayBuffer.empty[Long]\n    \
    \    val changeCount = mutable.ArrayBuffer.empty[Long]\n        val changeCounts\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCounts_ = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeCounts_ = mutable.ArrayBuffer.empty[Long]\n        val changeCounts_\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCounts_ = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeCounts_ = mutable.ArrayBuffer.empty[Long]\n        val changeCounts_\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCounts_ = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeCounts_ = mutable.ArrayBuffer.empty[Long]\n        val changeCounts_\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCounts_ = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeCounts_ = mutable.ArrayBuffer.empty[Long]\n        val changeCounts_\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCounts_ = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeCounts_ = mutable.ArrayBuffer.empty[Long]\n        val changeCounts_\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCounts_ = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeCounts_ = mutable.ArrayBuffer.empty[Long]\n        val changeCounts_\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCounts_ = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeCounts_ = mutable.ArrayBuffer.empty[Long]\n        val changeCounts_\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCounts_ = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeCounts_ = mutable.ArrayBuffer.empty[Long]\n        val changeCounts_\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCounts_ = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeCounts_ = mutable.ArrayBuffer.empty[Long]\n        val changeCounts_\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCounts_ = mutable.Array\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp407ax0fl.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mchangeCounts_\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchangeCounts_ is already defined as \e[33mvalue\e[0m \e[35mchangeCounts_\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp407ax0fl.scala:19:12 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m        \e[33mval\e[0m \e[36mchangeCounts_\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchangeCounts_ is already defined as \e[33mvalue\e[0m \e[35mchangeCounts_\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp407ax0fl.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mchangeCounts_\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchangeCounts_ is already defined as \e[33mvalue\e[0m \e[35mchangeCounts_\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp407ax0fl.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36mchangeCounts_\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchangeCounts_ is already defined as \e[33mvalue\e[0m \e[35mchangeCounts_\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp407ax0fl.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m"
  stdout: ''
  timestamp: 1660010422
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.take(n/2).length\n        val k = arr.take(n/2).reverse.take(n/2).length\n\
    \        val m = arr.take(n/2).reverse.take(n/2).length\n        val m = arr.take(n/2).reverse.take(n/2).length\n\
    \        val m = arr.take(n/2).reverse.take(n/2).length\n        val m = arr.take(n/2).reverse.take(n/2).length\n\
    \        val m = arr.take(n/2).reverse.take(n/2).length\n        val m = arr.take(n/2).reverse.take(n/2).length\n\
    \        val m = arr.take(n/2).reverse.take(n/2).length\n        val m = arr.take(n/2).reverse.take(n/2).length\n\
    \        val m = arr.take(n/2).reverse.take(n/2).length\n        val m = arr.take(n/2).reverse.take(n/2).length\n\
    \        val m = arr.take(n/2).reverse.take(n/2).length\n        val m = arr.take(n/2).reverse.take(n/2).length\n\
    \        val m = arr.take(n/2).reverse.take(n/2).length\n        val m = arr.take(n/2).reverse.take(n/2).length\n\
    \        val m = arr.take(n/2).reverse.take(n/2).length\n        val m = arr.take(n/2).reverse.take(n/2).length\n\
    \        val m = arr.take(n/2).reverse.take(n/2).length\n        val m = arr.take(n/2).reverse.take(n/2).length\n\
    \        val m = arr.take(n/2).reverse.take(n/2).length\n        val m = arr.take(n/2).reverse.take(n/2).length\n\
    \        val m = arr.take(n/2).reverse.take(n/2).length\n        val m = arr.take(n/2).reverse.take(n/2).length\n\
    \        val m = arr.take(n/2).reverse.take(n/2).length\n        val m = arr.take(n/2).reverse.take(n/2).length\n\
    \        val m = arr.take(n/2).reverse.take(n/2).length\n        val m = arr.take(n/2).reverse.take(n/2).length\n\
    \        val m = arr.take(n/2).reverse.take(n/2).length\n        val m = arr.take(n/2).reverse.take(n/2).length\n\
    \        val m = arr.take(n/2).reverse.take(n/2).length\n        val m = arr.take(n/2).reverse.take(n/2).length\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwtkr21jv.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.take(n/\e[31m2\e\
    [0m).reverse.take(n/\e[31m2\e[0m).length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpwtkr21jv.scala:13:12 ---------------------------\e[0m\e[0m\n\e[31m13\
    \ |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.take(n/\e[31m2\e[0m).reverse.take(n/\e\
    [31m2\e[0m).length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpwtkr21jv.scala:14:12 ---------------------------\e[0m\e[0m\n\e[31m14\
    \ |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.take(n/\e[31m2\e[0m).reverse.take(n/\e\
    [31m2\e[0m).length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpwtkr21jv.scala:15:12 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.take(n/\e[31m2\e[0m).reverse.take(n/\e\
    [31m2\e[0m).length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpwtkr21jv.scala:16:12 ---------------------------\e[0m\e[0m\n\e[31m16\
    \ |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.take(n/\e[31m2\e[0m).reverse.take(n/\e\
    [31m2\e[0m).length\n\e"
  stdout: ''
  timestamp: 1660010423
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = n/2\n        val left = new Array[Long](n/2)\n        val right\
    \ = new Array[Long](n/2)\n        val changes = new Array[Long](n/2)\n       \
    \ val changed = new Array[Long](n/2)\n        val p = new Array[Long](n/2)\n \
    \       val palindromic = new Array[Long](n/2)\n        val leftIndex = 0\n  \
    \      val rightIndex = 0\n        val changeIndex = 0\n        val palindromicIndex\
    \ = 0\n        val changeIndex = 0\n        val palindromicIndex = 0\n       \
    \ val changeIndex = 0\n        val palindromicIndex = 0\n        val changeIndex\
    \ = 0\n        val palindromicIndex = 0\n        val changeIndex = 0\n       \
    \ val palindromicIndex = 0\n        val changeIndex = 0\n        val palindromicIndex\
    \ = 0\n        val changeIndex = 0\n        val palindromicIndex = 0\n       \
    \ val changeIndex = 0\n        val palindromicIndex = 0\n        val changeIndex\
    \ = 0\n        val palindromicIndex = 0\n        val changeIndex = 0\n       \
    \ val palindromicIndex = 0\n        val changeIndex = 0\n        val palindromicIndex\
    \ = 0\n        val changeIndex = 0\n        val palindromicIndex = 0\n       \
    \ val changeIndex = 0\n        val palindromicIndex = 0\n        val changeIndex\
    \ = 0\n        val palindromicIndex = 0\n        val changeIndex = 0\n       \
    \ val palindromicIndex = 0\n        val changeIndex = 0\n        val palindromicIndex\
    \ = 0\n        val changeIndex = 0\n        val palindromicIndex = 0\n       \
    \ val changeIndex = 0\n        val palindromicIndex = 0\n        val changeIndex\
    \ = 0\n        val palindromicIndex = 0\n        val changeIndex = 0\n       \
    \ val palindromicIndex = 0\n        val changeIndex = 0\n        val palindromicIndex\
    \ = 0\n        val changeIndex = 0\n        val palindromicIndex = 0\n       \
    \ val changeIndex = 0\n        val palindromicIndex = 0\n        val changeIndex\
    \ = 0\n        val palindromicIndex = 0\n        val changeIndex = 0\n       \
    \ val palindromicIndex = 0\n        val changeIndex = 0\n        val palindromicIndex\
    \ = 0\n        val changeIndex = 0\n        val palindromicIndex = 0\n       \
    \ val changeIndex = 0\n        val palindromicIndex\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnrgfpqly.scala:75:4 ----------------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnrgfpqly.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mchangeIndex\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchangeIndex is already defined as \e[33mvalue\e[0m \e[35mchangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpnrgfpqly.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mpalindromicIndex\e[0m = \e[31m0\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mpalindromicIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mpalindromicIndex\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpnrgfpqly.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mchangeIndex\e[0m = \e[31m0\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mchangeIndex is already\
    \ defined as \e[33mvalue\e[0m \e[35mchangeIndex\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnrgfpqly.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mpalindromicIndex\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mpalindromicIndex is already defined as \e[33mvalue\e[0m \e\
    [35mpalindromicIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpnrgfpqly.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mchangeI"
  stdout: ''
  timestamp: 1660010424
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val minChange =\
    \ arr.size\n        val changes = mutable.ListBuffer[Long]()\n        val reversedArr\
    \ = arr.reverse\n        val reversedArrSize = reversedArr.size\n        val reversedArrSize\
    \ = reversedArrSize / 2\n        val half = reversedArrSize / 2\n        var i\
    \ = 0\n        var j = 0\n        while (i < arr.size) {\n            while (j\
    \ < reversedArrSize) {\n                if (arr(i) == reversedArr(j)) {\n    \
    \                changes += arr(i)\n                    i += 1\n             \
    \       j = 0\n                } else {\n                    j += 1\n        \
    \        }\n            }\n            i += 1\n        }\n        val minChanges\
    \ = changes.min\n        val minChangesSize = minChanges.size\n        val minChangesSize\
    \ = minChangesSize / 2\n        var k = 0\n        var l = 0\n        while (k\
    \ < (minChangesSize * 2)) {\n            while (l < minChangesSize) {\n      \
    \          if (changes(k) == changes(l)) {\n                    k += 1\n     \
    \               l += 1\n                } else {\n                    k += 1\n\
    \                }\n            }\n            k += 1\n        }\n        minChanges\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5b5wbay0.scala:13:12 ---------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mreversedArrSize\e[0m = reversedArrSize\
    \ / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mreversedArrSize is already defined as \e[33mvalue\e[0m \e\
    [35mreversedArrSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp5b5wbay0.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mminChangesSize\e[0m = minChangesSize\
    \ / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminChangesSize is already defined as \e[33mvalue\e[0m \e[35mminChangesSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmp5b5wbay0.scala:10:22 ------------------------\e[0m\e[0m\n\
    \e[31m10 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010421
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val changes = mutable.ListBuffer[Long]()\n\
    \        val reversed = arr.toList.reverse\n        val reversedReversed = reversed.toList.reverse\n\
    \        val palindromic = reversedReversed.forall(x => x == m)\n        val change\
    \ = if (palindromic) 1 else 0\n        val changes = if (palindromic) changes.+:(change)\
    \ else changes.+:(change)\n        val changes = if (palindromic) changes.+:(change)\
    \ else changes.+:(change)\n        val changes = if (palindromic) changes.+:(change)\
    \ else changes.+:(change)\n        val changes = if (palindromic) changes.+:(change)\
    \ else changes.+:(change)\n        val changes = if (palindromic) changes.+:(change)\
    \ else changes.+:(change)\n        val changes = if (palindromic) changes.+:(change)\
    \ else changes.+:(change)\n        val changes = if (palindromic) changes.+:(change)\
    \ else changes.+:(change)\n        val changes = if (palindromic) changes.+:(change)\
    \ else changes.+:(change)\n        val changes = if (palindromic) changes.+:(change)\
    \ else changes.+:(change)\n        val changes = if (palindromic) changes.+:(change)\
    \ else changes.+:(change)\n        val changes = if (palindromic) changes.+:(change)\
    \ else changes.+:(change)\n        val changes = if (palindromic) changes.+:(change)\
    \ else changes.+:(change)\n        val changes = if (palindromic) changes.+:(change)\
    \ else changes.+:(change)\n        val changes = if (palindromic) changes.+:(change)\
    \ else changes.+:(change)\n        val changes = if (palindromic) changes.+:(change)\
    \ else changes.+:(change)\n        val changes = if (palindromic) changes.+:(change)\
    \ else changes.+:(change)\n        val changes = if (palindromic) changes.+:(change)\
    \ else changes.+:(change)\n        val changes = if (palindromic) changes.+:(change)\
    \ else changes.+:(change)\n        val changes = if (palindromic) changes.+:(change)\
    \ else changes.+:(change)\n        val changes = if (palindromic) changes.+:(change)\
    \ else changes.+:(change)\n        val changes = if (palindromic) changes.+:(change)\
    \ else \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpxul3w5cf.scala:36:62 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = \e[33mif\e\
    [0m (palindromic) changes.+:(change) \e[33melse\e[0m \n\e[31m\e[31m   |\e[0m \
    \                                                             ^\e[0m\n\e[31m \
    \  |\e[0m                                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxul3w5cf.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m\
    \ \e[36mchanges\e[0m = \e[33mif\e[0m (palindromic) changes.+:(change) \e[33melse\e\
    [0m changes.+:(change)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchanges is already defined as \e[33mvalue\e[0m \e[35mchanges\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpxul3w5cf.scala:17:12 ---------------------------\e[0m\e[0m\n\e\
    [31m17 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = \e[33mif\e[0m (palindromic)\
    \ changes.+:(change) \e[33melse\e[0m changes.+:(change)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchanges is already defined as \e[33mvalue\e[0m \e[35mchanges\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpxul3w5cf.scala:18:12 ---------------------------\e[0m\e[0m\n\e\
    [31m18 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = \e[33mif\e[0m (palindromic)\
    \ changes.+:(change) \e[33melse\e[0m changes.+:(change)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchanges is already defined as \e[33mvalue\e[0m \e[35mchanges\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of topleve"
  stdout: ''
  timestamp: 1660010424
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        var i = 0\n        var j = 0\n        var k\
    \ = 0\n        var minChange = 0\n        var minChangeIndex = 0\n        var\
    \ maxChange = 0\n        var maxChangeIndex = 0\n        while(i < n) {\n    \
    \        while(j < n) {\n                if(arr(i) == arr(j)) {\n            \
    \        j++\n                }\n                else {\n                    minChange\
    \ = arr(i) - arr(j)\n                    minChangeIndex = i\n                \
    \    maxChange = arr(i) - arr(j)\n                    maxChangeIndex = j\n   \
    \                 j++\n                }\n            }\n            i += 1\n\
    \            minChange = 0\n            minChangeIndex = -1\n            j +=\
    \ 1\n            maxChange = 0\n            maxChangeIndex = -1\n        }\n \
    \       if(minChange > maxChange) {\n            minChange = maxChange\n     \
    \       minChangeIndex = maxChangeIndex\n        }\n        minChangeIndex\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpkn0prwuy.scala:21:23 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpkn0prwuy.scala:28:23 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkn0prwuy.scala:24:32\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m                    minChange\
    \ = arr(i) - arr(j)\n\e[31m\e[31m   |\e[0m                                ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                Found:    Long\n\e[31m   |\e\
    [0m                                Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpkn0prwuy.scala:26:32 --------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                    maxChange = arr(i) - arr(j)\n\e[31m\e\
    [31m   |\e[0m                                ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                Found:    Long\n\e[31m   |\e[0m           \
    \                     Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010425
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.head\n        val changes = mutable.ArrayBuffer.empty[Long]\n\
    \        var i = 0\n        while (i < n) {\n            val j = n - i - 1\n \
    \           if (arr(i) == arr(j)) {\n                changes += j\n          \
    \  }\n            i += 1\n        }\n        changes.min\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnwg1wupa.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010423
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val arr = arr.sortBy(-_)\n        val changes = mutable.ArrayBuffer.empty[Long]\n\
    \        var i = 0\n        var j = 0\n        while (i < n) {\n            while\
    \ (j < n && arr(i) == arr(j)) {\n                j += 1\n            }\n     \
    \       changes += j - i\n            i += 1\n            j = 0\n        }\n \
    \       changes.min\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpk3iut8i2.scala:10:18 ---------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(-_)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpk3iut8i2.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010424
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val result = new Array[Long](n)\n        var\
    \ i = 0\n        var j = 0\n        var k = 0\n        var minChange = 0\n   \
    \     var maxChange = 0\n        var change = 0\n        var changeCount = 0\n\
    \        var changeCountMax = 0\n        var changeCountMin = 0\n        var changeCountMaxIndex\
    \ = 0\n        var changeCountMinIndex = 0\n        var changeCountMaxIndex2 =\
    \ 0\n        var changeCountMinIndex2 = 0\n        var changeCountMaxIndex3 =\
    \ 0\n        var changeCountMinIndex3 = 0\n        var changeCountMaxIndex4 =\
    \ 0\n        var changeCountMinIndex4 = 0\n        var changeCountMaxIndex5 =\
    \ 0\n        var changeCountMinIndex5 = 0\n        var changeCountMaxIndex6 =\
    \ 0\n        var changeCountMinIndex6 = 0\n        var changeCountMaxIndex7 =\
    \ 0\n        var changeCountMinIndex7 = 0\n        var changeCountMaxIndex8 =\
    \ 0\n        var changeCountMinIndex8 = 0\n        var changeCountMaxIndex9 =\
    \ 0\n        var changeCountMinIndex9 = 0\n        var changeCountMaxIndex10 =\
    \ 0\n        var changeCountMinIndex10 = 0\n        var changeCountMaxIndex11\
    \ = 0\n        var changeCountMinIndex11 = 0\n        var changeCountMaxIndex12\
    \ = 0\n        var changeCountMinIndex12 = 0\n        var changeCountMaxIndex13\
    \ = 0\n        var changeCountMinIndex13 = 0\n        var changeCountMaxIndex14\
    \ = 0\n        var changeCountMinIndex14 = 0\n        var changeCountMaxIndex15\
    \ = 0\n        var changeCountMinIndex15 = 0\n        var changeCountMaxIndex16\
    \ = 0\n        var changeCountMinIndex16 = 0\n        var changeCountMaxIndex17\
    \ = 0\n        var changeCountMinIndex17 = 0\n        var changeCountMaxIndex18\
    \ = 0\n        var changeCountMinIndex18 = 0\n        var changeCountMaxIndex19\
    \ = 0\n        var changeCountMinIndex19 = 0\n        var changeCountMaxIndex20\
    \ = 0\n        var changeCountMinIndex20 = 0\n        var changeCountMaxIndex21\
    \ = 0\n        var changeCountMinIndex21 = 0\n        var changeCountMaxIndex22\
    \ = 0\n        var changeCountMinIndex22 = 0\n        var changeCountMaxIndex23\
    \ = 0\n        var changeCountMinIndex23 = 0\n        var changeCountMaxIndex24\
    \ = 0\n        var changeCountMinIndex24 = 0\n        var changeCountMaxIndex25\
    \ = 0\n        var changeCountMinIndex25 = 0\n        var changeCountMaxIndex26\
    \ = 0\n        var changeCountMinIndex26 = 0\n        var changeCountMaxIndex27\
    \ = 0\n        var changeCountMinIndex27 = 0\n        var changeCountMaxIndex28\
    \ = 0\n        var changeCountMinIndex28 = 0\n        var change\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpcw7lh2he.scala:78:4 ----------------------------\e\
    [0m\e[0m\n\e[31m78 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpcw7lh2he.scala:78:5 ---------------------\e[0m\e[0m\n\e[31m78 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010427
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        var count = 0\n        val arr = arr.tail\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(-_)\n        val arr\
    \ = arr.toList\n        val arr = arr.sortBy(-_)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(-_)\n        val arr = arr.toList\n        val arr\
    \ = arr.sortBy(-_)\n        val arr = arr.toList\n        val arr = arr.sortBy(-_)\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(-_)\n        val arr\
    \ = arr.toList\n        val arr = arr.sortBy(-_)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(-_)\n        val arr = arr.toList\n        val arr\
    \ = arr.sortBy(-_)\n        val arr = arr.toList\n        val arr = arr.sortBy(-_)\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(-_)\n        val arr\
    \ = arr.toList\n        val arr = arr.sortBy(-_)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(-_)\n        val arr = arr.toList\n        val arr\
    \ = arr.sortBy(-_)\n        val arr = arr.toList\n        val arr = arr.sortBy(-_)\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(-_)\n        val arr\
    \ = arr.toList\n        val arr = arr.sortBy(-_)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(-_)\n        val arr = arr.toList\n        val arr\
    \ = arr.sortBy(-_)\n        val arr = arr.toList\n        val arr = arr.sortBy(-_)\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(-_)\n        val arr\
    \ = arr.toList\n        val arr = arr.sortBy(-_)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(-_)\n        val arr = arr.toList\n        val arr\
    \ = arr.sortBy(-_)\n        val arr = arr.toList\n        val arr = arr.sortBy(-_)\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(-_)\n        val arr\
    \ = arr.toList\n        val arr = arr.sortBy(-_)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(-_)\n        val arr = arr.toList\n        val arr\
    \ = arr.sortBy(-_\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_x4n3php.scala:71:4 ----------------------------\e\
    [0m\e[0m\n\e[31m71 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_x4n3php.scala:13:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_x4n3php.scala:14:12 ---------------------------\e[0m\e[0m\n\e[31m14\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(-_)\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_x4n3php.scala:15:12 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_x4n3php.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(-_)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_x4n3php.scala:17:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e["
  stdout: ''
  timestamp: 1660010427
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val n = arr.length\n        var minChange = 0\n        var minChangeIndex\
    \ = 0\n        var maxChangeIndex = 0\n        var maxChange = arr(0)\n      \
    \  var minChangeIndex = 0\n        var maxChangeIndex = 0\n        var maxChange\
    \ = arr(0)\n        var minChangeIndex = 0\n        var maxChangeIndex = 0\n \
    \       var maxChange = arr(0)\n        var minChangeIndex = 0\n        var maxChangeIndex\
    \ = 0\n        var maxChange = arr(0)\n        var minChangeIndex = 0\n      \
    \  var maxChangeIndex = 0\n        var maxChange = arr(0)\n        var minChangeIndex\
    \ = 0\n        var maxChangeIndex = 0\n        var maxChange = arr(0)\n      \
    \  var minChangeIndex = 0\n        var maxChangeIndex = 0\n        var maxChange\
    \ = arr(0)\n        var minChangeIndex = 0\n        var maxChangeIndex = 0\n \
    \       var maxChange = arr(0)\n        var minChangeIndex = 0\n        var maxChangeIndex\
    \ = 0\n        var maxChange = arr(0)\n        var minChangeIndex = 0\n      \
    \  var maxChangeIndex = 0\n        var maxChange = arr(0)\n        var minChangeIndex\
    \ = 0\n        var maxChangeIndex = 0\n        var maxChange = arr(0)\n      \
    \  var minChangeIndex = 0\n        var maxChangeIndex = 0\n        var maxChange\
    \ = arr(0)\n        var minChangeIndex = 0\n        var maxChangeIndex = 0\n \
    \       var maxChange = arr(0)\n        var minChangeIndex = 0\n        var maxChangeIndex\
    \ = 0\n        var maxChange = arr(0)\n        var minChangeIndex = 0\n      \
    \  var maxChangeIndex = 0\n        var maxChange = arr(0)\n        var minChangeIndex\
    \ = 0\n        var maxChangeIndex = 0\n        var maxChange = arr(0)\n      \
    \  var minChangeIndex = 0\n        var maxChangeIndex = 0\n        var maxChange\
    \ = arr(0)\n        var minChangeIndex = 0\n        var maxChangeIndex = 0\n \
    \       var maxChange = arr(0)\n        var minChangeIndex = 0\n        var maxChangeIndex\
    \ = 0\n        var maxChange = arr(0)\n        var minChangeIndex = 0\n      \
    \  var maxChangeIndex = 0\n        var maxChange = arr(0)\n        var minChangeIndex\
    \ = 0\n        var maxChangeIndex = 0\n        var maxChange = arr(0)\n      \
    \  var minChangeIndex = 0\n        var maxChangeIndex = 0\n        var maxChange\
    \ = arr(0)\n        var minChangeIndex = 0\n        var maxChangeIndex = 0\n \
    \       var maxChange = arr(0)\n        var minChangeIndex = 0\n        var maxChangeIndex\
    \ = 0\n        var maxChange = arr(0)\n        var minChangeIndex = 0\n      \
    \  var maxChangeIndex = 0\n        var maxChange = arr(0)\n        var minChangeIndex\
    \ = 0\n        var maxChangeIndex = 0\n        var maxChange = arr(0)\n\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9s5gr5ep.scala:15:12 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mvar\e[0m \e[36mminChangeIndex\e[0m = \e\
    [31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mminChangeIndex is already defined as \e[33mvariable\e[0m \e[35mminChangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp9s5gr5ep.scala:16:12 ---------------------------\e[0m\e[0m\n\e\
    [31m16 |\e[0m        \e[33mvar\e[0m \e[36mmaxChangeIndex\e[0m = \e[31m0\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxChangeIndex\
    \ is already defined as \e[33mvariable\e[0m \e[35mmaxChangeIndex\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp9s5gr5ep.scala:17:12 ---------------------------\e[0m\e[0m\n\e[31m17\
    \ |\e[0m        \e[33mvar\e[0m \e[36mmaxChange\e[0m = arr(\e[31m0\e[0m)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxChange is\
    \ already defined as \e[33mvariable\e[0m \e[35mmaxChange\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9s5gr5ep.scala:18:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mminChangeIndex\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminChangeIndex is already defined as \e[33mvariable\e[0m \e\
    [35mminChangeIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp9s5gr5ep.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mvar\e[0m \e[36mmaxChangeIndex\e[0m = \e\
    [31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mmaxChangeIndex is already defined as \e[33mvariable\e[0m \e[35mmaxChangeIndex\e\
    [0m\n\e[31m   |\e["
  stdout: ''
  timestamp: 1660010430
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val p = new Array[Long](n)\n        val p1 = new Array[Long](n)\n   \
    \     val p2 = new Array[Long](n)\n        val p3 = new Array[Long](n)\n     \
    \   val p4 = new Array[Long](n)\n        val p5 = new Array[Long](n)\n       \
    \ val p6 = new Array[Long](n)\n        val p7 = new Array[Long](n)\n        val\
    \ p8 = new Array[Long](n)\n        val p9 = new Array[Long](n)\n        val p10\
    \ = new Array[Long](n)\n        val p11 = new Array[Long](n)\n        val p12\
    \ = new Array[Long](n)\n        val p13 = new Array[Long](n)\n        val p14\
    \ = new Array[Long](n)\n        val p15 = new Array[Long](n)\n        val p16\
    \ = new Array[Long](n)\n        val p17 = new Array[Long](n)\n        val p18\
    \ = new Array[Long](n)\n        val p19 = new Array[Long](n)\n        val p20\
    \ = new Array[Long](n)\n        val p21 = new Array[Long](n)\n        val p22\
    \ = new Array[Long](n)\n        val p23 = new Array[Long](n)\n        val p24\
    \ = new Array[Long](n)\n        val p25 = new Array[Long](n)\n        val p26\
    \ = new Array[Long](n)\n        val p27 = new Array[Long](n)\n        val p28\
    \ = new Array[Long](n)\n        val p29 = new Array[Long](n)\n        val p30\
    \ = new Array[Long](n)\n        val p31 = new Array[Long](n)\n        val p32\
    \ = new Array[Long](n)\n        val p33 = new Array[Long](n)\n        val p34\
    \ = new Array[Long](n)\n        val p35 = new Array[Long](n)\n        val p36\
    \ = new Array[Long](n)\n        val p37 = new Array[Long](n)\n        val p38\
    \ = new Array[Long](n)\n        val p39 = new Array[Long](n)\n        val p40\
    \ = new Array[Long](n)\n        val p41 = new Array[Long](n)\n        val p42\
    \ = new Array[Long](n)\n        val p43 = new Array[Long](n)\n        val p44\
    \ = new Array[Long](n)\n        val p45 = new Array[Long\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpfb_68dy6.scala:56:4 ----------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ']' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmpfb_68dy6.scala:55:18\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m55 |\e[0m       \
    \ \e[33mval\e[0m \e[36mp45\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mLong\e\
    [0m\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mmissing argument for parameter _length of \e[33mconstructor\e[0m \e[35mArray\e\
    [0m in \e[33mclass\e[0m \e[35mArray\e[0m: (_length: Int): Array[Long]\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpfb_68dy6.scala:56:5 ---------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010384
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val m = arr.head\n        var changes = 0\n        val palindromic =\
    \ arr.toSet\n        val reversed = palindromic.toList.reverse\n        val reversedSet\
    \ = reversed.toSet\n        val reversedList = reversed.toList\n        val reversedSetList\
    \ = reversedSet.toList\n        val reversedSetList2 = reversedSetList.toList\n\
    \        val reversedSetList3 = reversedSetList2.toList\n        val reversedSetList4\
    \ = reversedSetList3.toList\n        val reversedSetList5 = reversedSetList4.toList\n\
    \        val reversedSetList6 = reversedSetList5.toList\n        val reversedSetList7\
    \ = reversedSetList6.toList\n        val reversedSetList8 = reversedSetList7.toList\n\
    \        val reversedSetList9 = reversedSetList8.toList\n        val reversedSetList10\
    \ = reversedSetList9.toList\n        val reversedSetList11 = reversedSetList10.toList\n\
    \        val reversedSetList12 = reversedSetList11.toList\n        val reversedSetList13\
    \ = reversedSetList12.toList\n        val reversedSetList14 = reversedSetList13.toList\n\
    \        val reversedSetList15 = reversedSetList14.toList\n        val reversedSetList16\
    \ = reversedSetList15.toList\n        val reversedSetList17 = reversedSetList16.toList\n\
    \        val reversedSetList18 = reversedSetList17.toList\n        val reversedSetList19\
    \ = reversedSetList18.toList\n        val reversedSetList20 = reversedSetList19.toList\n\
    \        val reversedSetList21 = reversedSetList20.toList\n        val reversedSetList22\
    \ = reversedSetList21.toList\n        val reversedSetList23 = reversedSetList22.toList\n\
    \        val reversedSetList24 = reversedSetList23.toList\n        val reversedSetList25\
    \ = reversedSetList24.toList\n        val reversedSetList26 = reversedSetList25.toList\n\
    \        val reversedSetList27 = reversedSetList26.toList\n        val reversedSetList28\
    \ = reversedSetList27.toList\n        val reversedSetList29 = reversedSetList28.toList\n\
    \        val reversed\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpcqyp4c9v.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpcqyp4c9v.scala:46:5 ---------------------\e[0m\e[0m\n\e[31m46 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val len = arr.length\n\
    \        val minChange = len / 2\n        val maxChange = len - minChange\n  \
    \      val changes = mutable.ArrayBuffer.empty[Long]\n        val changed = mutable.ArrayBuffer.empty[Long]\n\
    \        var i = 0\n        while (i < len) {\n            val j = i\n       \
    \     while (j < len) {\n                if (arr(i) != arr(j)) {\n           \
    \         changes += arr(i)\n                    changes += arr(j)\n         \
    \           changed(i) = true\n                    changed(j) = true\n       \
    \         }\n                j++\n            }\n            i += 1\n        }\n\
    \        val changeCount = changes.distinct().length\n        if (changeCount\
    \ < minChange) {\n            minChange\n        } else if (changeCount > maxChange)\
    \ {\n            maxChange\n        } else {\n            changeCount\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpg_1opghp.scala:24:19 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                j++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpg_1opghp.scala:12:22\
    \ ------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e\
    [36mchanges\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpg_1opghp.scala:13:22\
    \ ------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e\
    [36mchanged\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010427
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val m = arr.length\n\
    \        val n = arr.head\n        val arr = arr.tail\n        val changes = mutable.ArrayBuffer.empty[Int]\n\
    \        val change = mutable.ArrayBuffer.empty[Int]\n        var i = 0\n    \
    \    var j = 0\n        while (i < m && j < n) {\n            if (arr(i) < arr(j))\
    \ {\n                changes += i\n                i += 1\n            } else\
    \ {\n                changes += j\n                j += 1\n            }\n   \
    \     }\n        val minChanges = changes.min\n        if (minChanges == 0) 0\n\
    \        else minChanges\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpgqavs70p.scala:11:18 ---------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpgqavs70p.scala:12:22 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpgqavs70p.scala:13:21 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010426
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.take(n/2).length\n        val p = new Array[Long](m)\n  \
    \      var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n  \
    \      var m = 0\n        var n = 0\n        var p = 0\n        var q = 0\n  \
    \      var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n  \
    \      var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n  \
    \      var z = 0\n        var a = 0\n        var b = 0\n        var c = 0\n  \
    \      var d = 0\n        var e = 0\n        var f = 0\n        var g = 0\n  \
    \      var h = 0\n        var i = 0\n        var j = 0\n        var k = 0\n  \
    \      var l = 0\n        var m = 0\n        var n = 0\n        var p = 0\n  \
    \      var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n  \
    \      var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n  \
    \      var y = 0\n        var z = 0\n        var a = 0\n        var b = 0\n  \
    \      var c = 0\n        var d = 0\n        var e = 0\n        var f = 0\n  \
    \      var g = 0\n        var h = 0\n        var i = 0\n        var j = 0\n  \
    \      var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n  \
    \      var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n  \
    \      var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n  \
    \      var x = 0\n        var y = 0\n        var z = 0\n        var a = 0\n  \
    \      var b = 0\n        var c = 0\n        var d = 0\n        var e = 0\n  \
    \      var f = 0\n        var g = 0\n        var h = 0\n        var i = 0\n  \
    \      var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n  \
    \      var n = 0\n        var p = 0\n        var q = 0\n        var r = 0\n  \
    \      var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n  \
    \      var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n  \
    \      var a = 0\n        var b = 0\n        var c = 0\n        var d = 0\n  \
    \      var e = 0\n        var f = 0\n        var g = 0\n        var h = 0\n  \
    \      var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n  \
    \      var m = 0\n        var n = 0\n        var p = 0\n        var q = 0\n  \
    \      var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n  \
    \      var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n  \
    \      var z = 0\n        var a = 0\n        var b = 0\n        var c = 0\n  \
    \      var d = 0\n        var e = 0\n        var f = 0\n        var g = 0\n\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbjl21mjo.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mvar\e[0m \e[36mm\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbjl21mjo.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mvar\e[0m \e[36mn\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbjl21mjo.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mvar\e[0m \e[36mp\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mp is already defined\
    \ as \e[33mvalue\e[0m \e[35mp\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbjl21mjo.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mvar\e[0m \e[36mi\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mi is already defined\
    \ as \e[33mvariable\e[0m \e[35mi\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbjl21mjo.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mvar\e[0m \e[36mj\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mj is already defined\
    \ as \e[33mvariable\e[0m \e[35mj\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbjl21mjo.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mvar\e[0m \e[36mk\e[0m = \e[31m0"
  stdout: ''
  timestamp: 1660010430
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val m = arr.length\n\
    \        val n = arr.last\n        val dp = new Array[Long](m+1)\n        dp(0)\
    \ = 1\n        for(i<-1 to m){\n            val dp1 = new Array[Long](m+1)\n \
    \           dp1(0) = 1\n            for(j<-1 to m){\n                val dp2 =\
    \ new Array[Long](m+1)\n                dp2(0) = 1\n                for(k<-1 to\
    \ m){\n                    val dp3 = new Array[Long](m+1)\n                  \
    \  dp3(0) = 1\n                    for(l<-1 to m){\n                        val\
    \ dp4 = new Array[Long](m+1)\n                        dp4(0) = 1\n           \
    \             for(m<-1 to m){\n                            val dp5 = new Array[Long](m+1)\n\
    \                            dp5(0) = 1\n                            for(n<-1\
    \ to m){\n                                val dp6 = new Array[Long](m+1)\n   \
    \                             dp6(0) = 1\n                                for(p<-1\
    \ to m){\n                                    val dp7 = new Array[Long](m+1)\n\
    \                                    dp7(0) = 1\n                            \
    \        for(q<-1 to m){\n                                        val dp8 = new\
    \ Array[Long](m+1)\n                                        dp8(0) = 1\n     \
    \                                   for(r<-1 to m){\n                        \
    \                    val dp9 = new Array[Long](m+1)\n                        \
    \                    dp9(0) = 1\n                                            for(s<-1\
    \ to m){\n                                                val dp10 = new Array[Long](m+1)\n\
    \                                                dp10(0) = 1\n               \
    \                                 for(t<-1 to m){\n                          \
    \                          val dp11 = new Array[Long](m+1)\n                 \
    \                                   dp11(0) = 1\n                            \
    \                        for(u<-1 to m){\n                                   \
    \                     val dp12 = new Array[Long](m+1)\n                      \
    \                                  dp12(0) = 1\n                             \
    \                           for(v<-1 to m){\n                                \
    \                            val dp13 = new Array[Long](m+1)\n               \
    \                                             dp13(0) = 1\n                  \
    \                                          for(w<-1 to m){\n                 \
    \                                               val dp14 = new Array[Long](m+1)\n\
    \                                                                dp14(0) = 1\n\
    \                                                                for(x<-1 to m){\n\
    \                                                                    val dp15\
    \ = new Array[Long](m+1)\n                                                   \
    \                 dp15(0) = 1\n                                              \
    \                      for(y<-1 to m){\n                                     \
    \                                   val dp16 = new Array[Long](m+1)\n        \
    \                                                                dp16(0) = 1\n\
    \                                                                        for(z<-1\
    \ to m){\n                                                                   \
    \         val dp17 = new Array[Long](m+1)\n                                  \
    \                                          dp17(0) = 1\n                     \
    \                                                       for(a<-1 to m){\n    \
    \                                                                            val\
    \ dp18 = new Array[\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpo67jfcis.scala:66:4 ----------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpo67jfcis.scala:79:0 ----------------------------\e[0m\e[0m\n\e[31m79\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- Error: /tmp/tmpo67jfcis.scala:65:91 -----------------------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m                                                    \
    \                            \e[33mval\e[0m \e[36mdp18\e[0m = \e[33mnew\e[0m \e\
    [35mArray\e[0m[\n\e[31m\e[31m   |\e[0m                                       \
    \                                                    ^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mmissing argument for parameter _length of \e[33mconstructor\e[0m \e[35mArray\e\
    [0m in \e[33mclass\e[0m \e[35mArray\e[0m\n\e[33m\e[33m-- Warning: /tmp/tmpo67jfcis.scala:67:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m67 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m    Line is indented too far to\
    \ the left, or a `}` is missing\n1 warning found\n3 errors found\n"
  stdout: ''
  timestamp: 1660010430
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n\
    \        val palindromic = arr.toSet.reverse.size == arr.size\n        val changes\
    \ = 0 until n\n        val minChanges = changes.foldLeft(0)(_ + 1) // number of\
    \ changes that need to be made to make the array palindromic\n        val minChangesNeeded\
    \ = minChanges * 2 // number of changes that need to be made to make the array\
    \ palindromic\n        val minChangesNeededToMakePalindromic = minChangesNeeded\
    \ / 2\n        val minChangesNeededToMakePalindromicToMakePalindromic = minChangesNeededToMakePalindromic\
    \ * 2\n        val minChangesNeededToMakePalindromicToMakePalindromicToMakePalindromic\
    \ = minChangesNeededToMakePalindromicToMakePalindromic * 2\n        val minChangesNeededToMakePalindromicToMakePalindromicToMakePalindromicToMakePalindromic\
    \ = minChangesNeededToMakePalindromicToMakePalindromicToMakePalindromic * 2\n\
    \        val minChangesNeededToMakePalindromicToMakePalindromicToMakePalindromicToMakePalindromicToMakePalindromic\
    \ = minChangesNeededToMakePalindromicToMakePalindromicToMakePalindromicToMakePalindromic\
    \ * 2\n        val minChangesNeededToMakePalindromicToMakePalindromicToMakePalindromicToMakePalindromicToMakePalindromicToMakePalindromic\
    \ = minChangesNeededToMakePalindromicToMakePalindromicToMakePalindromicToMakePalindromicToMakePalindromic\
    \ * 2\n        val minChangesNeededToMakePalindromicToMakePalindromicToMakePalindromicToMakePalindromicToMakePalindromicToMakePalindromicToMakePalindromic\
    \ = minChangesNeededToMakePalindromicToMakePalindromicToMakePalindromicToMakePalindromicToMakePalindromicToMakePalindromic\
    \ * 2\n        val minChangesNeededToMakePalindromicToMakePalindromicToMakeP\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpggl7zz96.scala:22:4 ----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpggl7zz96.scala:10:36\
    \ ------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e\
    [36mpalindromic\e[0m = arr.toSet.reverse.size == arr.size\n\e[31m\e[31m   |\e\
    [0m                          ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue reverse\
    \ is not a member of Set[Long] - did you mean Set[Long].reversed?\n\e[31m\e[31m--\
    \ [E086] Syntax Error: /tmp/tmpggl7zz96.scala:12:45 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mminChanges\e[0m = changes.foldLeft(\e\
    [31m0\e[0m)(_ + \e[31m1\e[0m) \e[34m// number of changes that need to be made\
    \ to make the array palindromic\e[0m\n\e[31m\e[31m   |\e[0m                  \
    \                           ^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \           Wrong number of parameters, expected: 2\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpggl7zz96.scala:22:5 ---------------------\e[0m\e[0m\n\
    \e[31m22 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:\
    \    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010431
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val min = len\n        val max = len\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var changes\
    \ = 0\n        while (i < len) {\n            while (j < len) {\n            \
    \    if (arr(i) != arr(j)) {\n                    changes += 1\n             \
    \       max = Math.max(max, j - i)\n                    min = Math.min(min, j\
    \ - i)\n                }\n                j += 1\n            }\n           \
    \ i += 1\n            j = i\n            k += 1\n        }\n        changes\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp5thi46mx.scala:9:18 ----------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m  |\e[0m                  ^\e[0m\n\e[31m  |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmp5thi46mx.scala:21:24 -----------------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m                    max = Math.max(max, j - i)\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Reassignment to val max\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmp5thi46mx.scala:22:24 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                    min = Math.min(min, j - i)\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                    Reassignment to val min\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        var minChangeIndex\
    \ = 0\n        var minChangeVal = arr(0)\n        for(i <- 1 to len) {\n     \
    \       if(arr(i) == minChangeVal) {\n                minChangeIndex = i\n   \
    \             minChangeVal = arr(i-1)\n            }\n        }\n        minChangeIndex\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpumzely42.scala:9:18 ----------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m  |\e[0m                  ^\e[0m\n\e[31m  |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010430
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val min = Long.MaxValue\n        val max\
    \ = Long.MinValue\n        val changes = mutable.HashSet[Long]()\n        val\
    \ changed = mutable.HashSet[Long]()\n        val change = mutable.HashMap[Long,\
    \ Long]()\n        val changeCount = 0\n        val changeCounts = mutable.HashMap[Long,\
    \ Long]()\n        val changeCount = 0\n        val changeCounts = mutable.HashMap[Long,\
    \ Long]()\n        val changeCount = 0\n        val changeCounts = mutable.HashMap[Long,\
    \ Long]()\n        val changeCount = 0\n        val changeCounts = mutable.HashMap[Long,\
    \ Long]()\n        val changeCount = 0\n        val changeCounts = mutable.HashMap[Long,\
    \ Long]()\n        val changeCount = 0\n        val changeCounts = mutable.HashMap[Long,\
    \ Long]()\n        val changeCount = 0\n        val changeCounts = mutable.HashMap[Long,\
    \ Long]()\n        val changeCount = 0\n        val changeCounts = mutable.HashMap[Long,\
    \ Long]()\n        val changeCount = 0\n        val changeCounts = mutable.HashMap[Long,\
    \ Long]()\n        val changeCount = 0\n        val changeCounts = mutable.HashMap[Long,\
    \ Long]()\n        val changeCount = 0\n        val changeCounts = mutable.HashMap[Long,\
    \ Long]()\n        val changeCount = 0\n        val changeCounts = mutable.HashMap[Long,\
    \ Long]()\n        val changeCount = 0\n        val changeCounts = mutable.HashMap[Long,\
    \ Long]()\n        val changeCount = 0\n        val changeCounts = mutable.HashMap[Long,\
    \ Long]()\n        val changeCount = 0\n        val changeCounts = mutable.HashMap[Long,\
    \ Long]()\n        val changeCount = 0\n        val changeCounts = mutable.HashMap[Long,\
    \ Long]()\n        val changeCount = 0\n        val changeCounts = mutable.HashMap[Long,\
    \ Long]()\n        val changeCount = 0\n        val changeCounts = mutable.HashMap[Long,\
    \ Long]()\n        val changeCount = 0\n        val changeCounts = mutable.HashMap[Long,\
    \ Long]()\n        val changeCount = 0\n        val changeCounts = mutable.HashMap[Long,\
    \ Long]()\n        val changeCount = 0\n        val changeCounts = mutable.HashMap[Long,\
    \ Long]()\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpci3alhu4.scala:58:11 ---------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpci3alhu4.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mchangeCount\e[0m = \e[31m0\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mchangeCount\
    \ is already defined as \e[33mvalue\e[0m \e[35mchangeCount\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpci3alhu4.scala:19:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36mchangeCounts\e[0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchangeCounts is already defined as \e[33mvalue\e[0m \e[35mchangeCounts\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpci3alhu4.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mchangeCount\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mchangeCount\
    \ is already defined as \e[33mvalue\e[0m \e[35mchangeCount\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpci3alhu4.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mchangeCounts\e[0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchangeCounts is already defined as \e[33mvalue\e[0m \e[35mchangeCounts\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods mu"
  stdout: ''
  timestamp: 1660010431
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val m = arr.length\n\
    \        val n = arr.last\n        val p = new Array[Long](m)\n        val r =\
    \ new Array[Long](m)\n        var i = 0\n        var j = 0\n        var k = 0\n\
    \        var count = 0\n        while(i < m && j < m) {\n            val a = arr(i)\n\
    \            val b = arr(j)\n            if(a>b) {\n                val temp =\
    \ arr(i)\n                arr(i) = arr(j)\n                arr(j) = temp\n   \
    \             i += 1\n                j += 1\n            } else if(a<b) {\n \
    \               val temp = arr(j)\n                arr(j) = arr(i)\n         \
    \       arr(i) = temp\n                j += 1\n                i += 1\n      \
    \      } else if(a==b) {\n                i += 1\n                j += 1\n   \
    \         } else {\n                val temp = arr(j)\n                arr(j)\
    \ = arr(i)\n                arr(i) = temp\n                i += 1\n          \
    \      j += 1\n            }\n        }\n        while(i < m) {\n            arr(i)\
    \ = arr(m)\n            i += 1\n        }\n        while(j < n) {\n          \
    \  arr(j) = arr(m)\n            j += 1\n        }\n        while(i < m && j <\
    \ n) {\n            val a = arr(i)\n            val b = arr(j)\n            if(a>b)\
    \ {\n                val temp = arr(i)\n                arr(i) = arr(j)\n    \
    \            arr(j) = temp\n                i += 1\n                j += 1\n \
    \           } else if(a<b) {\n                val temp = arr(j)\n            \
    \    arr(j) = arr(i)\n                arr(i) = temp\n                j += 1\n\
    \                i += 1\n            } else if(a==b) {\n                i += 1\n\
    \                j += 1\n            } else {\n                val temp = arr(j)\n\
    \                arr(j) = arr(i)\n                arr(i) = temp\n            \
    \    i += 1\n                j += 1\n            }\n        }\n        while(i\
    \ < m) {\n            arr(i) = arr(m)\n            i += 1\n        }\n       \
    \ while(j < n) {\n            arr(j) = arr(m)\n            j += 1\n        }\n\
    \        while(i < m && j < n) {\n            val a = arr(i)\n            val\
    \ b = arr(j)\n            if(a>b) {\n                val temp = arr(i)\n     \
    \           arr(i) = arr(j)\n                arr(j) = temp\n                i\
    \ += 1\n                j += 1\n            } else if(a<b) {\n               \
    \ val temp = arr(j)\n                arr(j) = arr(i)\n                arr(i) =\
    \ temp\n                j += 1\n                i += 1\n            } else if(a==b)\
    \ {\n                i += 1\n                j += 1\n            } else {\n  \
    \              val temp = arr(j)\n                \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp575qe1kd.scala:119:0 ---------------------------\e\
    [0m\e[0m\n\e[31m119 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp575qe1kd.scala:22:16\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m                arr(i) =\
    \ arr(j)\n\e[31m\e[31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m  value\
    \ update is not a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp575qe1kd.scala:23:16 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                arr(j) = temp\n\e[31m\e[31m   |\e[0m\
    \                ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long]\
    \ - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp575qe1kd.scala:28:16\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m                arr(j) =\
    \ arr(i)\n\e[31m\e[31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m  value\
    \ update is not a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp575qe1kd.scala:29:16 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                arr(i) = temp\n\e[31m\e[31m   |\e[0m\
    \                ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long]\
    \ - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp575qe1kd.scala:37:16\
    \ ------------------------\e[0m\e[0m\n\e[31m37 |\e[0m                arr(j) =\
    \ arr(i)\n\e[31m\e[31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m  value\
    \ update is not a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp575qe1kd.scala:38:16 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                arr(i) = temp\n\e[31m\e[31m   |\e[0m\
    \                ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long]\
    \ - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp575qe1kd.scala:44:12\
    \ ------------------------\e[0m\e[0m\n\e[31m44 |\e[0m            arr(i) = arr(m)\n\
    \e[31m\e[31m   |\e[0m            ^^^\e[0m\n\e[31m   |\e[0m  value update is not\
    \ a member of List[Long] - did"
  stdout: ''
  timestamp: 1660010432
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val p = new Array[Long](n + 1)\n        val\
    \ r = new Array[Long](n + 1)\n        val s = new Array[Long](n + 1)\n       \
    \ val t = new Array[Long](n + 1)\n        val u = new Array[Long](n + 1)\n   \
    \     val v = new Array[Long](n + 1)\n        val w = new Array[Long](n + 1)\n\
    \        val x = new Array[Long](n + 1)\n        val y = new Array[Long](n + 1)\n\
    \        val z = new Array[Long](n + 1)\n        val a = new Array[Long](n + 1)\n\
    \        val b = new Array[Long](n + 1)\n        val c = new Array[Long](n + 1)\n\
    \        val d = new Array[Long](n + 1)\n        val e = new Array[Long](n + 1)\n\
    \        val f = new Array[Long](n + 1)\n        val g = new Array[Long](n + 1)\n\
    \        val h = new Array[Long](n + 1)\n        val i = new Array[Long](n + 1)\n\
    \        val j = new Array[Long](n + 1)\n        val k = new Array[Long](n + 1)\n\
    \        val l = new Array[Long](n + 1)\n        val m = new Array[Long](n + 1)\n\
    \        val n = new Array[Long](n + 1)\n        val o = new Array[Long](n + 1)\n\
    \        val p1 = new Array[Long](n + 1)\n        val p2 = new Array[Long](n +\
    \ 1)\n        val p3 = new Array[Long](n + 1)\n        val p4 = new Array[Long](n\
    \ + 1)\n        val p5 = new Array[Long](n + 1)\n        val p6 = new Array[Long](n\
    \ + 1)\n        val p7 = new Array[Long](n + 1)\n        val p8 = new Array[Long](n\
    \ + 1)\n        val p9 = new Array[Long](n + 1)\n        val p10 = new Array[Long](n\
    \ + 1)\n        val p11 = new Array[Long](n + 1)\n        val p12 = new Array[Long](n\
    \ + 1)\n        val p13 = new Array[Long](n + 1)\n        val p14 = new Array[Long](n\
    \ + 1)\n        val p15 = new Array[Long](n + 1)\n        val p16 = new Array[Long](n\
    \ + 1)\n        val p17 = new Array[Long](n + 1)\n        val p18 = new Array[Long](n\
    \ + 1)\n        val p19 = new Array[Long](n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5lvdcko4.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5lvdcko4.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mm\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mLong\e[0m](n + \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5lvdcko4.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36mn\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mLong\e[0m](n + \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mn is already defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5lvdcko4.scala:55:5\
    \ ---------------------\e[0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010431
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        var i = 0\n\
    \        var j = 0\n        var k = 0\n        while (i < len) {\n           \
    \ val temp = arr(i)\n            val temp2 = arr(j)\n            val temp3 = arr(k)\n\
    \            arr(i) = temp2\n            arr(j) = temp3\n            arr(k) =\
    \ temp\n            i += 1 // move to next element\n            j += 1 // move\
    \ to next element\n            k += 1 // move to next element\n            if\
    \ (arr(i) == arr(j) && arr(i) == arr(k)) {\n                minChange = minChange\
    \ - 1\n            }\n        }\n        minChange\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp5yh07ri7.scala:9:18 ----------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m  |\e[0m                  ^\e[0m\n\e[31m  |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmp5yh07ri7.scala:26:26 -----------------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m                minChange = minChange - \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \               Reassignment to val minChange\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010430
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val m = arr.min\n        val max = (arr.max).asInstanceOf[Long]\n\
    \        val max2 = max / 2\n        val max3 = max2 / 2\n        val max4 = max3\
    \ / 2\n        val max5 = max4 / 2\n        val max6 = max5 / 2\n        val max7\
    \ = max6 / 2\n        val max8 = max7 / 2\n        val max9 = max8 / 2\n     \
    \   val max10 = max9 / 2\n        val max11 = max10 / 2\n        val max12 = max11\
    \ / 2\n        val max13 = max12 / 2\n        val max14 = max13 / 2\n        val\
    \ max15 = max14 / 2\n        val max16 = max15 / 2\n        val max17 = max16\
    \ / 2\n        val max18 = max17 / 2\n        val max19 = max18 / 2\n        val\
    \ max20 = max19 / 2\n        val max21 = max20 / 2\n        val max22 = max21\
    \ / 2\n        val max23 = max22 / 2\n        val max24 = max23 / 2\n        val\
    \ max25 = max24 / 2\n        val max26 = max25 / 2\n        val max27 = max26\
    \ / 2\n        val max28 = max27 / 2\n        val max29 = max28 / 2\n        val\
    \ max30 = max29 / 2\n        val max31 = max30 / 2\n        val max32 = max31\
    \ / 2\n        val max33 = max32 / 2\n        val max34 = max33 / 2\n        val\
    \ max35 = max34 / 2\n        val max36 = max35 / 2\n        val max37 = max36\
    \ / 2\n        val max38 = max37 / 2\n        val max39 = max38 / 2\n        val\
    \ max40 = max39 / 2\n        val max41 = max40 / 2\n        val max42 = max41\
    \ / 2\n        val max43 = max42 / 2\n        val max44 = max43 / 2\n        val\
    \ max45 = max44 / 2\n        val max46 = max45 / 2\n        val max47 = max46\
    \ / 2\n        val max48 = max47 / 2\n        val max49 = max48 / 2\n        val\
    \ max50 = max49 / 2\n        \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp0rby0bi_.scala:9:18 ----------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m  |\e[0m                  ^\e[0m\n\e[31m  |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp0rby0bi_.scala:63:5 ---------------------\e[0m\e\
    [0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010431
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val changes = mutable.ArrayBuffer.empty[Long]\n\
    \        var i = 0\n        while (i < n) {\n            val j = n - i - 1\n \
    \           val a = arr(i)\n            val b = arr(j)\n            if (a != b)\
    \ {\n                changes += j\n            }\n            i += 1\n       \
    \ }\n        changes.min\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmppoyunvsn.scala:11:18 ---------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmppoyunvsn.scala:12:22 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010430
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        var count = 0\n        var i = 0\n        var\
    \ j = 0\n        var k = 0\n        while (i < n) {\n            while (j < n)\
    \ {\n                if (arr(i) != arr(j)) {\n                    count += 1\n\
    \                    j++\n                }\n                else {\n        \
    \            j++\n                }\n            }\n            i += 1\n     \
    \       j = 0\n        }\n        if (count < m) {\n            count = m\n  \
    \      }\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpa6db1p8v.scala:19:23 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpa6db1p8v.scala:22:23 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpa6db1p8v.scala:29:20\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m            count = m\n\e[31m\e\
    [31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m                    Found:\
    \    (m : Long)\n\e[31m   |\e[0m                    Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010432
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    def smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n\
    \        val m = arr.head\n        val result = new Array[Long](n)\n        var\
    \ i = 0\n        var j = 0\n        var k = 0\n        var minChange = 0\n   \
    \     while(i < n && j < n) {\n            val a = arr(i)\n            val b =\
    \ arr(j)\n            if(a>b) {\n                minChange = minChange + 1\n \
    \               result(i) = b\n                i = i + 1\n                j =\
    \ j + 1\n            } else if(a<b) {\n                minChange = minChange +\
    \ 1\n                result(j) = a\n                i = i + 1\n              \
    \  j = j + 1\n            } else {\n                minChange = minChange + 1\n\
    \                result(j) = a\n                i = i + 1\n                j =\
    \ j + 1\n            }\n        }\n        minChange\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpns5phqz0.scala:39)\n\tat Problem.main(tmpns5phqz0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010432
