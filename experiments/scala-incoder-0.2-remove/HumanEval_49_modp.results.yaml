language: scala
name: HumanEval_49_modp
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p\n        else r\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqv6fihhk.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p\n\e[31m\e[31m  |\e[0m                   ^^^^^\e[0m\n\e[31m \
    \ |\e[0m                   Found:    Double\n\e[31m  |\e[0m                  \
    \ Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqv6fihhk.scala:8:13\
    \ ---------------------\e[0m\e[0m\n\e[31m8 |\e[0m        \e[33melse\e[0m r\n\e\
    [31m\e[31m  |\e[0m             ^\e[0m\n\e[31m  |\e[0m             Found:    (r\
    \ : Double)\n\e[31m  |\e[0m             Required: Long\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (r < 0) r + p else r\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp533txq2v.scala:11)\n\tat Problem.main(tmp533txq2v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n)\n        val q =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val \n \
    \   }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp9fq3cr_g.scala:57:11 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp9fq3cr_g.scala:8:12 ----------------------------\e\
    [0m\e[0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.mod(r,\
    \ p)\n\e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e\
    [0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9fq3cr_g.scala:9:12\
    \ ----------------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = scala.math.mod(r, p)\n\e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m  |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m\
    \  |\e[0m\n\e[31m  |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9fq3cr_g.scala:10:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = scala.math.mod(r, p)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp9fq3cr_g.scala:11:12 ---------------------------\e[0m\e[0m\n\e[31m11\
    \ |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.mod(r, p)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already\
    \ defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9fq3cr_g.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m"
  stdout: ''
  timestamp: 1660010068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.mod(n, p)\n        if (n <\
    \ 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6n8a3br4.scala:6:27 -------------------------\e\
    [0m\e[0m\n\e[31m6 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.mod(n,\
    \ p)\n\e[31m\e[31m  |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m\
    \                value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (r == 0) r else p +\
    \ r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpshmpx8fe.scala:10)\n\tat Problem.main(tmpshmpx8fe.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010066
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val q = p + n\n        val r = q % p\n       \
    \ val s = q - r\n        r + (s * (s * (s * (s * (s * (s * (s * (s * (s * (s *\
    \ (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s\
    \ * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s *\
    \ (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s\
    \ * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s *\
    \ (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s\
    \ * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s *\
    \ (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s\
    \ * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s *\
    \ (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s\
    \ * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s *\
    \ (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s\
    \ * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s *\
    \ (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s\
    \ * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s *\
    \ (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s * (s\
    \ * (s * (\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpfgap6njw.scala:10:4 ----------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpfgap6njw.scala:11:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m11 |\e[0m    \e[33mdef\e[0m \e\
    [36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e\
    [31m   |\e[0m^^^\e[0m\n\e[31m   |\e[0m'}' expected, but 'end of statement' found\n\
    Exception in thread \"main\" java.lang.StackOverflowError\n\tat java.base/java.lang.ClassLoader.defineClass1(Native\
    \ Method)\n\tat java.base/java.lang.ClassLoader.defineClass(ClassLoader.java:1012)\n\
    \tat java.base/java.security.SecureClassLoader.defineClass(SecureClassLoader.java:150)\n\
    \tat java.base/jdk.internal.loader.BuiltinClassLoader.defineClass(BuiltinClassLoader.java:862)\n\
    \tat java.base/jdk.internal.loader.BuiltinClassLoader.findClassOnClassPathOrNull(BuiltinClassLoader.java:760)\n\
    \tat java.base/jdk.internal.loader.BuiltinClassLoader.loadClassOrNull(BuiltinClassLoader.java:681)\n\
    \tat java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:639)\n\
    \tat java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:188)\n\
    \tat java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)\n\tat java.base/java.lang.ClassLoader.defineClass1(Native\
    \ Method)\n\tat java.base/java.lang.ClassLoader.defineClass(ClassLoader.java:1012)\n\
    \tat java.base/java.security.SecureClassLoader.defineClass(SecureClassLoader.java:150)\n\
    \tat java.base/jdk.internal.loader.BuiltinClassLoader.defineClass(BuiltinClassLoader.java:862)\n\
    \tat java.base/jdk.internal.loader.BuiltinClassLoader.findClassOnClassPathOrNull(BuiltinClassLoader.java:760)\n\
    \tat java.base/jdk.internal.loader.BuiltinClassLoader.loadClassOrNull(BuiltinClassLoader.java:681)\n\
    \tat java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:639)\n\
    \tat java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:188)\n\
    \tat java.base/java.lang.ClassLoader.lo"
  stdout: 'java.lang.StackOverflowError while compiling /tmp/tmpfgap6njw.scala

    '
  timestamp: 1660010059
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val m = 2L\n        val r = n % p\n        if\
    \ (r < m)\n            modp(r + p, p)\n        else\n            r\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjn45835x.scala:15)\n\tat Problem.main(tmpjn45835x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n)\n        val m =\
    \ scala.math.mod(r, p)\n        val r = scala.math.pow(r, m)\n        r\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvmk1s2gm.scala:8:12 ----------------------------\e\
    [0m\e[0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.pow(r,\
    \ m)\n\e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e\
    [0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvmk1s2gm.scala:7:27\
    \ -------------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e\
    [36mm\e[0m = scala.math.mod(r, p)\n\e[31m\e[31m  |\e[0m                ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m  |\e[0m                value mod is not a member of math\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpvmk1s2gm.scala:9:8 ----------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        r\n\e[31m\e[31m  |\e[0m        ^\e[0m\n\e[31m\
    \  |\e[0m        Found:    (r : Double)\n\e[31m  |\e[0m        Required: Long\n\
    \e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n)\n        val q =\
    \ scala.math.pow(p, r)\n        val r = scala.math.mod(q, p)\n        r\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkw4zko95.scala:8:12 ----------------------------\e\
    [0m\e[0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.mod(q,\
    \ p)\n\e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e\
    [0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkw4zko95.scala:9:8\
    \ ----------------------\e[0m\e[0m\n\e[31m9 |\e[0m        r\n\e[31m\e[31m  |\e\
    [0m        ^\e[0m\n\e[31m  |\e[0m        Found:    (r : Double)\n\e[31m  |\e[0m\
    \        Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010065
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n)\n        val s =\
    \ scala.math.mod(r, p)\n        s\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) ==\
    \ (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps_sq3o9o.scala:7:27 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36ms\e[0m = scala.math.mod(r,\
    \ p)\n\e[31m\e[31m  |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m\
    \                value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1660010066
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n)\n        val m =\
    \ scala.math.mod(r, p)\n        val r = scala.math.pow(r, m)\n        r\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvmk1s2gm.scala:8:12 ----------------------------\e\
    [0m\e[0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.pow(r,\
    \ m)\n\e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e\
    [0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvmk1s2gm.scala:7:27\
    \ -------------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e\
    [36mm\e[0m = scala.math.mod(r, p)\n\e[31m\e[31m  |\e[0m                ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m  |\e[0m                value mod is not a member of math\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpvmk1s2gm.scala:9:8 ----------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        r\n\e[31m\e[31m  |\e[0m        ^\e[0m\n\e[31m\
    \  |\e[0m        Found:    (r : Double)\n\e[31m  |\e[0m        Required: Long\n\
    \e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (r == 0) r else p +\
    \ r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpshmpx8fe.scala:10)\n\tat Problem.main(tmpshmpx8fe.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010066
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n)\n        val q =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val \n \
    \   }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp9fq3cr_g.scala:57:11 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp9fq3cr_g.scala:8:12 ----------------------------\e\
    [0m\e[0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.mod(r,\
    \ p)\n\e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e\
    [0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9fq3cr_g.scala:9:12\
    \ ----------------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = scala.math.mod(r, p)\n\e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m  |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m\
    \  |\e[0m\n\e[31m  |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9fq3cr_g.scala:10:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = scala.math.mod(r, p)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp9fq3cr_g.scala:11:12 ---------------------------\e[0m\e[0m\n\e[31m11\
    \ |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.mod(r, p)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already\
    \ defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9fq3cr_g.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m"
  stdout: ''
  timestamp: 1660010068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.util.Random.nextLong()\n       \
    \ val x = scala.util.Random.nextLong()\n        val y = scala.util.Random.nextLong()\n\
    \        val z = scala.util.Random.nextLong()\n        val w = scala.util.Random.nextLong()\n\
    \        val t = scala.util.Random.nextLong()\n        val u = scala.util.Random.nextLong()\n\
    \        val v = scala.util.Random.nextLong()\n        val w = scala.util.Random.nextLong()\n\
    \        val x = scala.util.Random.nextLong()\n        val y = scala.util.Random.nextLong()\n\
    \        val z = scala.util.Random.nextLong()\n        val w = scala.util.Random.nextLong()\n\
    \        val t = scala.util.Random.nextLong()\n        val u = scala.util.Random.nextLong()\n\
    \        val v = scala.util.Random.nextLong()\n        val w = scala.util.Random.nextLong()\n\
    \        val x = scala.util.Random.nextLong()\n        val y = scala.util.Random.nextLong()\n\
    \        val z = scala.util.Random.nextLong()\n        val w = scala.util.Random.nextLong()\n\
    \        val t = scala.util.Random.nextLong()\n        val u = scala.util.Random.nextLong()\n\
    \        val v = scala.util.Random.nextLong()\n        val w = scala.util.Random.nextLong()\n\
    \        val x = scala.util.Random.nextLong()\n        val y = scala.util.Random.nextLong()\n\
    \        val z = scala.util.Random.nextLong()\n        val w = scala.util.Random.nextLong()\n\
    \        val t = scala.util.Random.nextLong()\n        val u = scala.util.Random.nextLong()\n\
    \        val v = scala.util.Random.nextLong()\n        val w = scala.util.Random.nextLong()\n\
    \        val x = scala.util.Random.nextLong()\n        val y = scala.util.Random.nextLong()\n\
    \        val z = scala.util.Random.nextLong()\n        val w = scala.util.Random.nextLong()\n\
    \        val t = scala.util.Random.nextLong()\n        val u = scala.util.Random.nextLong()\n\
    \        val v = scala.util.Random.nextLong()\n        val w = scala.util.Random.nextLong()\n\
    \        val x = scala.util.Random.nextLong()\n        val y = scala.util.Random.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpu9dqm4fq.scala:49:4 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpu9dqm4fq.scala:14:12 ---------------------------\e[0m\e[0m\n\e[31m14\
    \ |\e[0m        \e[33mval\e[0m \e[36mw\e[0m = scala.util.Random.nextLong()\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mw is already defined as \e[33mvalue\e[0m \e[35mw\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpu9dqm4fq.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mx\e[0m = scala.util.Random.nextLong()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mx is already defined as \e[33mvalue\e[0m \e[35mx\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpu9dqm4fq.scala:16:12 ---------------------------\e[0m\e[0m\n\e[31m16\
    \ |\e[0m        \e[33mval\e[0m \e[36my\e[0m = scala.util.Random.nextLong()\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0my is already defined as \e[33mvalue\e[0m \e[35my\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpu9dqm4fq.scala:17:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m\
    \ \e[36mz\e[0m = scala.util.Random.nextLong()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mz is already defined as \e[33mvalue\e[0m \e[35mz\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpu9dqm4fq.scala:18:12 ---------------------------\e[0m\e[0m\n\e[31m18\
    \ |\e[0m        \e[33mval\e[0m \e[36mw\e[0m = scala.uti"
  stdout: ''
  timestamp: 1660010067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        val q = p / r\n       \
    \ val r = p % r\n        val q = q * r\n        val r = r * r\n        val q =\
    \ q * q\n        val r = r * r\n        val q = q * q\n        val r = r * r\n\
    \        val q = q * q\n        val r = r * r\n        val q = q * q\n       \
    \ val r = r * r\n        val q = q * q\n        val r = r * r\n        val q =\
    \ q * q\n        val r = r * r\n        val q = q * q\n        val r = r * r\n\
    \        val q = q * q\n        val r = r * r\n        val q = q * q\n       \
    \ val r = r * r\n        val q = q * q\n        val r = r * r\n        val q =\
    \ q * q\n        val r = r * r\n        val q = q * q\n        val r = r * r\n\
    \        val q = q * q\n        val r = r * r\n        val q = q * q\n       \
    \ val r = r * r\n        val q = q * q\n        val r = r * r\n        val q =\
    \ q * q\n        val r = r * r\n        val q = q * q\n        val r = r * r\n\
    \        val q = q * q\n        val r = r * r\n        val q = q * q\n       \
    \ val r = r * r\n        val q = q * q\n        val r = r * r\n        val q =\
    \ q * q\n        val r = r * r\n        val q = q * q\n        val r = r * r\n\
    \        val q = q * q\n        val r = r * r\n        val q = q * q\n       \
    \ val r = r * r\n        val q = q * q\n        val r = r * r\n        val q =\
    \ q * q\n        val r = r * r\n        val q = q * q\n        val r = r * r\n\
    \        val q = q * q\n        val r = r * r\n        val q = q * q\n       \
    \ val r = r * r\n        val q = q * q\n        val r = r * r\n        val q =\
    \ q * q\n        val r = r * r\n        val q = q * q\n        val r = r * r\n\
    \        val q = q * q\n        val r = r * r\n        val q = q * q\n       \
    \ val r = r * r\n        val \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpn576_gcx.scala:79:11 ---------------------------\e\
    [0m\e[0m\n\e[31m79 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpn576_gcx.scala:8:12 ----------------------------\e\
    [0m\e[0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = p % r\n\e[31m\e\
    [31m  |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0mr is already defined as\
    \ \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m  |\e[0m\n\e[31m  |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpn576_gcx.scala:9:12 ----------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mq\e[0m = q * r\n\e[31m\e\
    [31m  |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0mq is already defined as\
    \ \e[33mvalue\e[0m \e[35mq\e[0m\n\e[31m  |\e[0m\n\e[31m  |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpn576_gcx.scala:10:12 ---------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = r * r\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined as\
    \ \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpn576_gcx.scala:11:12 ---------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mq\e[0m = q * q\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mq is already defined as\
    \ \e[33mvalue\e[0m \e[35mq\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpn576_gcx.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = r * r\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined as\
    \ \e[33mvalue\e[0m \e[35"
  stdout: ''
  timestamp: 1660010068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p\n        else r\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqv6fihhk.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p\n\e[31m\e[31m  |\e[0m                   ^^^^^\e[0m\n\e[31m \
    \ |\e[0m                   Found:    Double\n\e[31m  |\e[0m                  \
    \ Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqv6fihhk.scala:8:13\
    \ ---------------------\e[0m\e[0m\n\e[31m8 |\e[0m        \e[33melse\e[0m r\n\e\
    [31m\e[31m  |\e[0m             ^\e[0m\n\e[31m  |\e[0m             Found:    (r\
    \ : Double)\n\e[31m  |\e[0m             Required: Long\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n)\n        val m =\
    \ scala.math.mod(r, p)\n        val r = scala.math.pow(2, m)\n        r\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb_dsc6el.scala:8:12 ----------------------------\e\
    [0m\e[0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.pow(\e\
    [31m2\e[0m, m)\n\e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m  |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m  |\e\
    [0m\n\e[31m  |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpb_dsc6el.scala:7:27\
    \ -------------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e\
    [36mm\e[0m = scala.math.mod(r, p)\n\e[31m\e[31m  |\e[0m                ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m  |\e[0m                value mod is not a member of math\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpb_dsc6el.scala:9:8 ----------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        r\n\e[31m\e[31m  |\e[0m        ^\e[0m\n\e[31m\
    \  |\e[0m        Found:    (r : Double)\n\e[31m  |\e[0m        Required: Long\n\
    \e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.util.Random\n        val x = r.nextInt()\
    \ % p\n        val y = r.nextInt() % p\n        val z = r.nextInt() % p\n    \
    \    val w = r.nextInt() % p\n        val v = r.nextInt() % p\n        val u =\
    \ r.nextInt() % p\n        val t = r.nextInt() % p\n        val s = r.nextInt()\
    \ % p\n        val q = r.nextInt() % p\n        val r = r.nextInt() % p\n    \
    \    val q = r.nextInt() % p\n        val r = r.nextInt() % p\n        val q =\
    \ r.nextInt() % p\n        val r = r.nextInt() % p\n        val q = r.nextInt()\
    \ % p\n        val r = r.nextInt() % p\n        val q = r.nextInt() % p\n    \
    \    val r = r.nextInt() % p\n        val q = r.nextInt() % p\n        val r =\
    \ r.nextInt() % p\n        val q = r.nextInt() % p\n        val r = r.nextInt()\
    \ % p\n        val q = r.nextInt() % p\n        val r = r.nextInt() % p\n    \
    \    val q = r.nextInt() % p\n        val r = r.nextInt() % p\n        val q =\
    \ r.nextInt() % p\n        val r = r.nextInt() % p\n        val q = r.nextInt()\
    \ % p\n        val r = r.nextInt() % p\n        val q = r.nextInt() % p\n    \
    \    val r = r.nextInt() % p\n        val q = r.nextInt() % p\n        val r =\
    \ r.nextInt() % p\n        val q = r.nextInt() % p\n        val r = r.nextInt()\
    \ % p\n        val q = r.nextInt() % p\n        val r = r.nextInt() % p\n    \
    \    val q = r.nextInt() % p\n        val r = r.nextInt() % p\n        val q =\
    \ r.nextInt() % p\n        val r = r.nextInt() % p\n        val q = r.nextInt()\
    \ % p\n        val r = r.nextInt() % p\n        val q = r.nextInt() % p\n    \
    \    val r = r.nextInt() % p\n        val q = r.nextInt() % p\n        val r =\
    \ r.nextInt() % p\n        val q = r.nextInt() % p\n        val r = r.nextInt()\
    \ % p\n        val q = r.nextInt() % p\n        val r = r.nextInt() % p\n    \
    \    val q = r.nextInt() % p\n        val r = r.nextInt() % p\n        val q =\
    \ r.nextInt() % p\n        val r = r.nextInt() % p\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxttafns5.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = r.nextInt() % p\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is\
    \ already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxttafns5.scala:17:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m\
    \ \e[36mq\e[0m = r.nextInt() % p\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mq is already defined as \e[33mvalue\e[0m \e[35mq\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpxttafns5.scala:18:12 ---------------------------\e[0m\e[0m\n\e[31m18\
    \ |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = r.nextInt() % p\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxttafns5.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mq\e[0m = r.nextInt() % p\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mq is\
    \ already defined as \e[33mvalue\e[0m \e[35mq\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxttafns5.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = r.nextInt() % p\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpxttafns5.scala:21:12 "
  stdout: ''
  timestamp: 1660010067
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (r < 0) r + p else r\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp533txq2v.scala:11)\n\tat Problem.main(tmp533txq2v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (r < 0) r + p else r\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp533txq2v.scala:11)\n\tat Problem.main(tmp533txq2v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n)\n        val m =\
    \ scala.math.mod(r, p)\n        if (m == 0) r else m\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpx4ty_qty.scala:7:27 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = scala.math.mod(r,\
    \ p)\n\e[31m\e[31m  |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m\
    \                value mod is not a member of math\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpx4ty_qty.scala:8:20 ---------------------\e[0m\e[0m\n\
    \e[31m8 |\e[0m        \e[33mif\e[0m (m == \e[31m0\e[0m) r \e[33melse\e[0m m\n\e\
    [31m\e[31m  |\e[0m                    ^\e[0m\n\e[31m  |\e[0m                 \
    \   Found:    (r : Double)\n\e[31m  |\e[0m                    Required: Long\n\
    \e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (r < 0) r + p else r\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp533txq2v.scala:11)\n\tat Problem.main(tmp533txq2v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        val m = p / r\n       \
    \ val x = r * m + p\n        x % p\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) ==\
    \ (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpikn2awpl.scala:13)\n\tat Problem.main(tmpikn2awpl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010066
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (r == 0) r else p +\
    \ r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpshmpx8fe.scala:10)\n\tat Problem.main(tmpshmpx8fe.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010066
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val m = 1L\n        val r = n % p\n        val\
    \ q = p / r\n        val r = p % r\n        val s = (r + q) / 2\n        val t\
    \ = r - s\n        val r = r + q\n        val m = m + (s * (r + q))\n        val\
    \ m = m + (t * r)\n        val m = m + (t * r)\n        val m = m + (t * r)\n\
    \        val m = m + (t * r)\n        val m = m + (t * r)\n        val m = m +\
    \ (t * r)\n        val m = m + (t * r)\n        val m = m + (t * r)\n        val\
    \ m = m + (t * r)\n        val m = m + (t * r)\n        val m = m + (t * r)\n\
    \        val m = m + (t * r)\n        val m = m + (t * r)\n        val m = m +\
    \ (t * r)\n        val m = m + (t * r)\n        val m = m + (t * r)\n        val\
    \ m = m + (t * r)\n        val m = m + (t * r)\n        val m = m + (t * r)\n\
    \        val m = m + (t * r)\n        val m = m + (t * r)\n        val m = m +\
    \ (t * r)\n        val m = m + (t * r)\n        val m = m + (t * r)\n        val\
    \ m = m + (t * r)\n        val m = m + (t * r)\n        val m = m + (t * r)\n\
    \        val m = m + (t * r)\n        val m = m + (t * r)\n        val m = m +\
    \ (t * r)\n        val m = m + (t * r)\n        val m = m + (t * r)\n        val\
    \ m = m + (t * r)\n        val m = m + (t * r)\n        val m = m + (t * r)\n\
    \        val m = m + (t * r)\n        val m = m + (t * r)\n        val m = m +\
    \ (t * r)\n        val m = m + (t * r)\n        val m = m + (t * r)\n        val\
    \ m = m + (t * r)\n        val m = m + (t * r)\n        val m = m + (t * r)\n\
    \        val m = m + (t * r)\n        val m = m + (t * r)\n        val m = m +\
    \ (t * r)\n        val m = m + (t * r)\n        val m = m + (t * r)\n        val\
    \ m = m + (t * r)\n        val m = m + (t * r)\n        val m = m + (t * r)\n\
    \        val m = m + (t * r)\n        val m = m + (t * r)\n        val m = m +\
    \ (t * r)\n        val m = m + (t * r)\n        val m = m + (t * r)\n        val\
    \ m = m \n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuaphcp7t.scala:9:12 ----------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = p % r\n\e[31m\e\
    [31m  |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0mr is already defined as\
    \ \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m  |\e[0m\n\e[31m  |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpuaphcp7t.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = r + q\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined as\
    \ \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpuaphcp7t.scala:13:12 ---------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = m + (s * (r + q))\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm\
    \ is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuaphcp7t.scala:14:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m\
    \ \e[36mm\e[0m = m + (t * r)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpuaphcp7t.scala:15:12 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = m + (t * r)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined as \e\
    [33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpuaphcp7t.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        "
  stdout: ''
  timestamp: 1660010067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.mod(n, p)\n        r match\
    \ {\n            case 0 => p\n            case _ => r\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpt4omsh6s.scala:6:27 -------------------------\e\
    [0m\e[0m\n\e[31m6 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.mod(n,\
    \ p)\n\e[31m\e[31m  |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m\
    \                value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1660010066
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val m = scala.math.BigInt(n)\n        val r =\
    \ scala.math.BigInt(p)\n        val s = scala.math.BigInt(2)\n        val t =\
    \ scala.math.BigInt(m)\n        val u = scala.math.BigInt(r)\n        val v =\
    \ scala.math.BigInt(s)\n        val w = scala.math.BigInt(t)\n        val x =\
    \ scala.math.BigInt(u + v)\n        val y = scala.math.BigInt(u - v)\n       \
    \ val z = scala.math.BigInt(u * v)\n        val a = scala.math.BigInt(u / v)\n\
    \        val b = scala.math.BigInt(u % v)\n        val c = scala.math.BigInt(u\
    \ % w)\n        val d = scala.math.BigInt(u * w)\n        val e = scala.math.BigInt(u\
    \ / w)\n        val f = scala.math.BigInt(u % w)\n        val g = scala.math.BigInt(u\
    \ / w)\n        val h = scala.math.BigInt(u % w)\n        val i = scala.math.BigInt(u\
    \ / w)\n        val j = scala.math.BigInt(u % w)\n        val k = scala.math.BigInt(u\
    \ / w)\n        val l = scala.math.BigInt(u % w)\n        val m = scala.math.BigInt(u\
    \ / w)\n        val n = scala.math.BigInt(u % w)\n        val o = scala.math.BigInt(u\
    \ / w)\n        val p = scala.math.BigInt(u % w)\n        val q = scala.math.BigInt(u\
    \ / w)\n        val r = scala.math.BigInt(u % w)\n        val s = scala.math.BigInt(u\
    \ / w)\n        val t = scala.math.BigInt(u % w)\n        val u = scala.math.BigInt(u\
    \ / w)\n        val v = scala.math.BigInt(u % w)\n        val w = scala.math.BigInt(u\
    \ / w)\n        val x = scala.math.BigInt(u % w)\n        val y = scala.math.BigInt(u\
    \ / w)\n        val z = scala.math.BigInt(u % w)\n        val a = scala.math.BigInt(u\
    \ / w)\n        val b = scala.math.BigInt(u % w)\n        val c = scala.math.BigInt(u\
    \ / w)\n        val d = scala.math.BigInt(u % w)\n        val e = scala.math.BigInt(u\
    \ / w)\n        val f = scala.math.BigInt(u % w)\n        val g = scala.math.BigInt(u\
    \ / w)\n        val h = scala.math.BigInt(u % \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpi5un63tj.scala:49:37 ---------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m        \e[33mval\e[0m \e[36mh\e[0m = scala.math.BigInt(u\
    \ % \n\e[31m\e[31m   |\e[0m                                     ^\e[0m\n\e[31m\
    \   |\e[0m                                     expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi5un63tj.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mm\e[0m = scala.math.BigInt(u / w)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpi5un63tj.scala:33:12 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.BigInt(u % w)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is\
    \ already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi5un63tj.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36ms\e[0m = scala.math.BigInt(u / w)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0ms is already defined as \e[33mvalue\e[0m \e[35ms\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpi5un63tj.scala:35:12 ---------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m        \e[33mval\e[0m \e[36mt\e[0m = scala.math.BigInt(u % w)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mt is\
    \ already defined as \e[33mvalue\e[0m \e[35mt\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group o"
  stdout: ''
  timestamp: 1660010068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val m = 2L\n        val r = n % p\n        val\
    \ q = p / r\n        val r = p % r\n        val s = (r * r + m) % q\n        s\
    \ % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpw_7kup12.scala:9:12 ----------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = p % r\n\e[31m\e\
    [31m  |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0mr is already defined as\
    \ \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m  |\e[0m\n\e[31m  |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010062
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (r < 0) r + p else r\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp533txq2v.scala:11)\n\tat Problem.main(tmp533txq2v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        val m = n / p\n       \
    \ val r = r * p + m\n        r\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpelnqeuoc.scala:8:12 ----------------------------\e\
    [0m\e[0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = r * p + m\n\e[31m\e\
    [31m  |\e[0m        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m  |\e[0m\n\e[31m  |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010062
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val m = scala.math.pow(2, n)\n        val r =\
    \ scala.math.mod(m, p)\n        r.toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptqx1ncnl.scala:7:27 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.mod(m,\
    \ p)\n\e[31m\e[31m  |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m\
    \                value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (r < 0) r + p else r\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp533txq2v.scala:11)\n\tat Problem.main(tmp533txq2v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (r == 0) r else p +\
    \ r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpshmpx8fe.scala:10)\n\tat Problem.main(tmpshmpx8fe.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010066
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        val q = p + r\n       \
    \ if (q < p)\n            modp(q, p)\n        else\n            q\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n \
    \   assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n\
    \    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n\
    \    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpu6amlbga.scala:14)\n\tat Problem.main(tmpu6amlbga.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010071
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n)\n        val m =\
    \ scala.math.mod(r, p)\n        if (m == 0) r else r - m\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7d0fcyyp.scala:7:27 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = scala.math.mod(r,\
    \ p)\n\e[31m\e[31m  |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m\
    \                value mod is not a member of math\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp7d0fcyyp.scala:8:20 ---------------------\e[0m\e[0m\n\
    \e[31m8 |\e[0m        \e[33mif\e[0m (m == \e[31m0\e[0m) r \e[33melse\e[0m r -\
    \ m\n\e[31m\e[31m  |\e[0m                    ^\e[0m\n\e[31m  |\e[0m          \
    \          Found:    (r : Double)\n\e[31m  |\e[0m                    Required:\
    \ Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010075
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val m = 1L\n        val r = n % p\n        val\
    \ q = p / r\n        val r = p % r\n        val s = p * (r - q * m)\n        s\
    \ + q * m\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnbg8dtsk.scala:9:12 ----------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = p % r\n\e[31m\e\
    [31m  |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0mr is already defined as\
    \ \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m  |\e[0m\n\e[31m  |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010070
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n)\n        val m =\
    \ scala.math.mod(r, p)\n        val r = scala.math.pow(2, m)\n        r\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb_dsc6el.scala:8:12 ----------------------------\e\
    [0m\e[0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.pow(\e\
    [31m2\e[0m, m)\n\e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m  |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m  |\e\
    [0m\n\e[31m  |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpb_dsc6el.scala:7:27\
    \ -------------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e\
    [36mm\e[0m = scala.math.mod(r, p)\n\e[31m\e[31m  |\e[0m                ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m  |\e[0m                value mod is not a member of math\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpb_dsc6el.scala:9:8 ----------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        r\n\e[31m\e[31m  |\e[0m        ^\e[0m\n\e[31m\
    \  |\e[0m        Found:    (r : Double)\n\e[31m  |\e[0m        Required: Long\n\
    \e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (r == 0) r\n       \
    \ else modp(r, p + 2)\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660010081
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (r < 0) r + p else r\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp533txq2v.scala:11)\n\tat Problem.main(tmp533txq2v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n)\n        val m =\
    \ scala.math.mod(r, p)\n        if (m == 0) r else m\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpx4ty_qty.scala:7:27 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = scala.math.mod(r,\
    \ p)\n\e[31m\e[31m  |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m\
    \                value mod is not a member of math\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpx4ty_qty.scala:8:20 ---------------------\e[0m\e[0m\n\
    \e[31m8 |\e[0m        \e[33mif\e[0m (m == \e[31m0\e[0m) r \e[33melse\e[0m m\n\e\
    [31m\e[31m  |\e[0m                    ^\e[0m\n\e[31m  |\e[0m                 \
    \   Found:    (r : Double)\n\e[31m  |\e[0m                    Required: Long\n\
    \e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (p < 0 || r < 0) r +\
    \ p\n        else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxeogd00o.scala:12)\n\tat Problem.main(tmpxeogd00o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010078
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.util.Random.nextLong\n        val\
    \ q = scala.util.Random.nextLong\n        val r = scala.util.Random.nextLong\n\
    \        val q = scala.util.Random.nextLong\n        val r = scala.util.Random.nextLong\n\
    \        val q = scala.util.Random.nextLong\n        val r = scala.util.Random.nextLong\n\
    \        val q = scala.util.Random.nextLong\n        val r = scala.util.Random.nextLong\n\
    \        val q = scala.util.Random.nextLong\n        val r = scala.util.Random.nextLong\n\
    \        val q = scala.util.Random.nextLong\n        val r = scala.util.Random.nextLong\n\
    \        val q = scala.util.Random.nextLong\n        val r = scala.util.Random.nextLong\n\
    \        val q = scala.util.Random.nextLong\n        val r = scala.util.Random.nextLong\n\
    \        val q = scala.util.Random.nextLong\n        val r = scala.util.Random.nextLong\n\
    \        val q = scala.util.Random.nextLong\n        val r = scala.util.Random.nextLong\n\
    \        val q = scala.util.Random.nextLong\n        val r = scala.util.Random.nextLong\n\
    \        val q = scala.util.Random.nextLong\n        val r = scala.util.Random.nextLong\n\
    \        val q = scala.util.Random.nextLong\n        val r = scala.util.Random.nextLong\n\
    \        val q = scala.util.Random.nextLong\n        val r = scala.util.Random.nextLong\n\
    \        val q = scala.util.Random.nextLong\n        val r = scala.util.Random.nextLong\n\
    \        val q = scala.util.Random.nextLong\n        val r = scala.util.Random.nextLong\n\
    \        val q = scala.util.Random.nextLong\n        val r = scala.util.Random.nextLong\n\
    \        val q = scala.util.Random.nextLong\n        val r = scala.util.Random.nextLong\n\
    \        val q = scala.util.Random.nextLong\n        val r = scala.util.Random.nextLong\n\
    \        val q = scala.util.Random.nextLong\n        val r = scala.util.Random.nextLong\n\
    \        val q = scala.util.Random.nextLong\n        val r = scala.util.Random.nextLong\n\
    \        val q = scala.util.Random.nextLong\n        val r = scala.util.Random.nextLong\n\
    \        val q = scala.util.Random.nextLong\n        val r = scala.util.\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpgaz3am87.scala:53:4 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpgaz3am87.scala:8:12 ----------------------------\e[0m\e[0m\n\e[31m8\
    \ |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.util.Random.nextLong\n\e[31m\e\
    [31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0mr is\
    \ already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgaz3am87.scala:9:12\
    \ ----------------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m\
    \ \e[36mq\e[0m = scala.util.Random.nextLong\n\e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m  |\e[0mq is already defined as \e[33mvalue\e[0m \e[35mq\e[0m\n\e[31m\
    \  |\e[0m\n\e[31m  |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgaz3am87.scala:10:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = scala.util.Random.nextLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpgaz3am87.scala:11:12 ---------------------------\e[0m\e[0m\n\e[31m11\
    \ |\e[0m        \e[33mval\e[0m \e[36mq\e[0m = scala.util.Random.nextLong\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mq\
    \ is already defined as \e[33mvalue\e[0m \e[35mq\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgaz3am87.scala:12:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = scala.util.Random.nextLong\n\e[31m\e[3"
  stdout: ''
  timestamp: 1660010078
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (r == 0) r else p +\
    \ r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpshmpx8fe.scala:10)\n\tat Problem.main(tmpshmpx8fe.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010066
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (p < 0 || r > p) 0\n\
    \        else r + (p - (r + p) % p)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp4zpbzik.scala:11)\n\tat Problem.main(tmpp4zpbzik.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010078
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (r < 0) r + p else r\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp533txq2v.scala:11)\n\tat Problem.main(tmp533txq2v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n)\n        val m =\
    \ scala.math.mod(r, p)\n        val r = scala.math.pow(2, m)\n        r\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb_dsc6el.scala:8:12 ----------------------------\e\
    [0m\e[0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.pow(\e\
    [31m2\e[0m, m)\n\e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m  |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m  |\e\
    [0m\n\e[31m  |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpb_dsc6el.scala:7:27\
    \ -------------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e\
    [36mm\e[0m = scala.math.mod(r, p)\n\e[31m\e[31m  |\e[0m                ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m  |\e[0m                value mod is not a member of math\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpb_dsc6el.scala:9:8 ----------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        r\n\e[31m\e[31m  |\e[0m        ^\e[0m\n\e[31m\
    \  |\e[0m        Found:    (r : Double)\n\e[31m  |\e[0m        Required: Long\n\
    \e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val q = p / 2\n        val r = p % 2\n       \
    \ val s = scala.math.pow(2, n)\n        val t = scala.math.pow(2, n + 1)\n   \
    \     val u = scala.math.pow(2, n - 1)\n        val v = scala.math.pow(2, n -\
    \ 2)\n        val w = scala.math.pow(2, n - 3)\n        val x = scala.math.pow(2,\
    \ n - 4)\n        val y = scala.math.pow(2, n - 5)\n        val z = scala.math.pow(2,\
    \ n - 6)\n        val a = scala.math.pow(2, n - 7)\n        val b = scala.math.pow(2,\
    \ n - 8)\n        val c = scala.math.pow(2, n - 9)\n        val d = scala.math.pow(2,\
    \ n - 10)\n        val e = scala.math.pow(2, n - 11)\n        val f = scala.math.pow(2,\
    \ n - 12)\n        val g = scala.math.pow(2, n - 13)\n        val h = scala.math.pow(2,\
    \ n - 14)\n        val i = scala.math.pow(2, n - 15)\n        val j = scala.math.pow(2,\
    \ n - 16)\n        val k = scala.math.pow(2, n - 17)\n        val l = scala.math.pow(2,\
    \ n - 18)\n        val m = scala.math.pow(2, n - 19)\n        val n = scala.math.pow(2,\
    \ n - 20)\n        val o = scala.math.pow(2, n - 21)\n        val p = scala.math.pow(2,\
    \ n - 22)\n        val q = scala.math.pow(2, n - 23)\n        val r = scala.math.pow(2,\
    \ n - 24)\n        val s = scala.math.pow(2, n - 25)\n        val t = scala.math.pow(2,\
    \ n - 26)\n        val u = scala.math.pow(2, n - 27)\n        val v = scala.math.pow(2,\
    \ n - 28)\n        val w = scala.math.pow(2, n - 29)\n        val x = scala.math.pow(2,\
    \ n - 30)\n        val y = scala.math.pow(2, n - 31)\n        val z = scala.math.pow(2,\
    \ n - 32)\n        val a = scala.math.pow(2, n - 33)\n        val b = scala.math.pow(2,\
    \ n - 34)\n        val c = scala.math.pow(2, n - 35)\n        val d = scala.math.pow(2,\
    \ n - 36)\n        val e = scala.math.pow(2, n - 37)\n        val f = scala.math.pow(2,\
    \ n - 38)\n        val g = scala.math.pow(2, n - 39)\n        val h = scala.math.pow(2,\
    \ n - 40)\n        val i = scala.math.pow(2, n - 41)\n        val j = scala.math.pow(2,\
    \ n - 42)\n\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbkwulg8v.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mq\e[0m = scala.math.pow(\e\
    [31m2\e[0m, n - \e[31m23\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mq is already defined as \e[33mvalue\e[0m \e[35mq\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpbkwulg8v.scala:33:12 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.pow(\e[31m2\e[0m, n -\
    \ \e[31m24\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpbkwulg8v.scala:34:12 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m        \e[33mval\e[0m \e[36ms\e[0m = scala.math.pow(\e[31m2\e[0m, n -\
    \ \e[31m25\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0ms is already defined as \e[33mvalue\e[0m \e[35ms\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpbkwulg8v.scala:35:12 ---------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m        \e[33mval\e[0m \e[36mt\e[0m = scala.math.pow(\e[31m2\e[0m, n -\
    \ \e[31m26\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mt is already defined as \e[33mvalue\e[0m \e[35mt\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpbkwulg8v.scala:36:12 ---------------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m        \e[33mval\e[0m \e[36mu\e[0m = scala.math.pow(\e[31m2\e[0m, n -\
    \ \e[31m27\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mu is already defined as \e[33mvalue\e[0m \e["
  stdout: ''
  timestamp: 1660010079
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n)\n        val m =\
    \ scala.math.mod(r, p)\n        m + 1\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpm7ft0b1e.scala:7:27 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = scala.math.mod(r,\
    \ p)\n\e[31m\e[31m  |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m\
    \                value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1660010078
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.BigInt(n).mod(scala.math.BigInt(p))\n\
    \        r.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpc2igvr4m.scala:11)\n\tat Problem.main(tmpc2igvr4m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010078
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.BigInt(n).modPow(scala.math.BigInt(p),\
    \ scala.math.BigInt(2))\n        r.toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpm_3f3kxa.scala:10)\n\tat Problem.main(tmpm_3f3kxa.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010078
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (r == 0) r else p +\
    \ r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpshmpx8fe.scala:10)\n\tat Problem.main(tmpshmpx8fe.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010066
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val m = n / p\n        val r = n % p\n       \
    \ val q = p * r\n        val r = p * (r + m)\n        val r = p * (r + m)\n  \
    \      val r = p * (r + m)\n        val r = p * (r + m)\n        val r = p * (r\
    \ + m)\n        val r = p * (r + m)\n        val r = p * (r + m)\n        val\
    \ r = p * (r + m)\n        val r = p * (r + m)\n        val r = p * (r + m)\n\
    \        val r = p * (r + m)\n        val r = p * (r + m)\n        val r = p *\
    \ (r + m)\n        val r = p * (r + m)\n        val r = p * (r + m)\n        val\
    \ r = p * (r + m)\n        val r = p * (r + m)\n        val r = p * (r + m)\n\
    \        val r = p * (r + m)\n        val r = p * (r + m)\n        val r = p *\
    \ (r + m)\n        val r = p * (r + m)\n        val r = p * (r + m)\n        val\
    \ r = p * (r + m)\n        val r = p * (r + m)\n        val r = p * (r + m)\n\
    \        val r = p * (r + m)\n        val r = p * (r + m)\n        val r = p *\
    \ (r + m)\n        val r = p * (r + m)\n        val r = p * (r + m)\n        val\
    \ r = p * (r + m)\n        val r = p * (r + m)\n        val r = p * (r + m)\n\
    \        val r = p * (r + m)\n        val r = p * (r + m)\n        val r = p *\
    \ (r + m)\n        val r = p * (r + m)\n        val r = p * (r + m)\n        val\
    \ r = p * (r + m)\n        val r = p * (r + m)\n        val r = p * (r + m)\n\
    \        val r = p * (r + m)\n        val r = p * (r + m)\n        val r = p *\
    \ (r + m)\n        val r = p * (r + m)\n        val r = p * (r + m)\n        val\
    \ r = p * (r + m)\n        val r = p * (r + m)\n        val r = p * (r + m)\n\
    \        val r = p * (r + m)\n        val r = p * (r + m)\n        val r = p *\
    \ (r + m)\n        val r = p * (r + m)\n        val r = p * (r\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp60tpu3d3.scala:64:4 ----------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp60tpu3d3.scala:9:12\
    \ ----------------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = p * (r + m)\n\e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m  |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m\
    \  |\e[0m\n\e[31m  |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp60tpu3d3.scala:10:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = p * (r + m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp60tpu3d3.scala:11:12 ---------------------------\e[0m\e[0m\n\e[31m11\
    \ |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = p * (r + m)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined as \e\
    [33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp60tpu3d3.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = p * (r + m)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already\
    \ defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp60tpu3d3.scala:13:12 ---------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = p * (r + m)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already\
    \ defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ tha"
  stdout: ''
  timestamp: 1660010079
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (r == 0) r else r +\
    \ p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcgosi58u.scala:10)\n\tat Problem.main(tmpcgosi58u.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010078
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (n\
    \ < 0) -r\n        else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3zrcia15.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (n < \e\
    [31m0\e[0m) -r\n\e[31m\e[31m  |\e[0m                   ^^\e[0m\n\e[31m  |\e[0m\
    \                   Found:    Double\n\e[31m  |\e[0m                   Required:\
    \ Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3zrcia15.scala:8:13\
    \ ---------------------\e[0m\e[0m\n\e[31m8 |\e[0m        \e[33melse\e[0m r\n\e\
    [31m\e[31m  |\e[0m             ^\e[0m\n\e[31m  |\e[0m             Found:    (r\
    \ : Double)\n\e[31m  |\e[0m             Required: Long\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010079
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.mod(n, p)\n        r match\
    \ {\n            case 0 => p\n            case _ => r\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpt4omsh6s.scala:6:27 -------------------------\e\
    [0m\e[0m\n\e[31m6 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.mod(n,\
    \ p)\n\e[31m\e[31m  |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m\
    \                value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1660010066
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (n\
    \ < 0) r + p\n        else r\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuolpunl1.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (n < \e\
    [31m0\e[0m) r + p\n\e[31m\e[31m  |\e[0m                   ^^^^^\e[0m\n\e[31m \
    \ |\e[0m                   Found:    Double\n\e[31m  |\e[0m                  \
    \ Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuolpunl1.scala:8:13\
    \ ---------------------\e[0m\e[0m\n\e[31m8 |\e[0m        \e[33melse\e[0m r\n\e\
    [31m\e[31m  |\e[0m             ^\e[0m\n\e[31m  |\e[0m             Found:    (r\
    \ : Double)\n\e[31m  |\e[0m             Required: Long\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010079
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.BigInt(n)\n        val m =\
    \ scala.math.BigInt(p)\n        val r = r.modPow(m, p)\n        r.toLong\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmy082nbu.scala:8:12 ----------------------------\e\
    [0m\e[0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = r.modPow(m, p)\n\
    \e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0mr is already\
    \ defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m  |\e[0m\n\e[31m  |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010075
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.BigInt(n)\n        val q =\
    \ scala.math.BigInt(p)\n        val t = r.mod(q)\n        if (t == 0) 1 else t\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfajcql4u.scala:9:27\
    \ ---------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mif\e[0m (t == \e\
    [31m0\e[0m) \e[31m1\e[0m \e[33melse\e[0m t\n\e[31m\e[31m  |\e[0m             \
    \              ^\e[0m\n\e[31m  |\e[0m                           Found:    (t :\
    \ BigInt)\n\e[31m  |\e[0m                           Required: Long\n\e[31m  |\e\
    [0m\n\e[31m  |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010078
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.util.Random.nextLong()\n       \
    \ val q = scala.util.Random.nextLong()\n        val r = r * q % p\n        r %\
    \ p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpemxua51n.scala:8:12 ----------------------------\e\
    [0m\e[0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = r * q % p\n\e[31m\e\
    [31m  |\e[0m        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m  |\e[0m\n\e[31m  |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010074
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p\n        else r\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqv6fihhk.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p\n\e[31m\e[31m  |\e[0m                   ^^^^^\e[0m\n\e[31m \
    \ |\e[0m                   Found:    Double\n\e[31m  |\e[0m                  \
    \ Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqv6fihhk.scala:8:13\
    \ ---------------------\e[0m\e[0m\n\e[31m8 |\e[0m        \e[33melse\e[0m r\n\e\
    [31m\e[31m  |\e[0m             ^\e[0m\n\e[31m  |\e[0m             Found:    (r\
    \ : Double)\n\e[31m  |\e[0m             Required: Long\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (r < 0) r + p else r\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp533txq2v.scala:11)\n\tat Problem.main(tmp533txq2v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n)\n        val m =\
    \ scala.math.mod(r, p)\n        val r2 = scala.math.pow(r, 2)\n        val r3\
    \ = scala.math.pow(r, 3)\n        val r4 = scala.math.pow(r, 4)\n        val r5\
    \ = scala.math.pow(r, 5)\n        val r6 = scala.math.pow(r, 6)\n        val r7\
    \ = scala.math.pow(r, 7)\n        val r8 = scala.math.pow(r, 8)\n        val r9\
    \ = scala.math.pow(r, 9)\n        val r10 = scala.math.pow(r, 10)\n        val\
    \ r11 = scala.math.pow(r, 11)\n        val r12 = scala.math.pow(r, 12)\n     \
    \   val r13 = scala.math.pow(r, 13)\n        val r14 = scala.math.pow(r, 14)\n\
    \        val r15 = scala.math.pow(r, 15)\n        val r16 = scala.math.pow(r,\
    \ 16)\n        val r17 = scala.math.pow(r, 17)\n        val r18 = scala.math.pow(r,\
    \ 18)\n        val r19 = scala.math.pow(r, 19)\n        val r20 = scala.math.pow(r,\
    \ 20)\n        val r21 = scala.math.pow(r, 21)\n        val r22 = scala.math.pow(r,\
    \ 22)\n        val r23 = scala.math.pow(r, 23)\n        val r24 = scala.math.pow(r,\
    \ 24)\n        val r25 = scala.math.pow(r, 25)\n        val r26 = scala.math.pow(r,\
    \ 26)\n        val r27 = scala.math.pow(r, 27)\n        val r28 = scala.math.pow(r,\
    \ 28)\n        val r29 = scala.math.pow(r, 29)\n        val r30 = scala.math.pow(r,\
    \ 30)\n        val r31 = scala.math.pow(r, 31)\n        val r32 = scala.math.pow(r,\
    \ 32)\n        val r33 = scala.math.pow(r, 33)\n        val r34 = scala.math.pow(r,\
    \ 34)\n        val r35 = scala.math.pow(r, 35)\n        val r36 = scala.math.pow(r,\
    \ 36)\n        val r37 = scala.math.pow(r, 37)\n        val r38 = scala.math.pow(r,\
    \ 38)\n        val r39 = scala.math.pow(r, 39)\n        val r40 = scala.math.pow(r,\
    \ 40)\n        val r41 = scala.math.pow(r, 41)\n        val r42 = scala.math.pow\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwiqq3w64.scala:7:27 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = scala.math.mod(r,\
    \ p)\n\e[31m\e[31m  |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m\
    \                value mod is not a member of math\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpwiqq3w64.scala:49:5 ---------------------\e[0m\e[0m\n\
    \e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:\
    \    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010080
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val m = math.pow(2, n)\n        val r = math.mod(m,\
    \ p)\n        if (r < 0) r + p else r\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp683z4j1n.scala:7:21 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = math.mod(m, p)\n\
    \e[31m\e[31m  |\e[0m                ^^^^^^^^\e[0m\n\e[31m  |\e[0m            \
    \    value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1660010079
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n)\n        val m =\
    \ scala.math.mod(r, p)\n        m + 1\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpm7ft0b1e.scala:7:27 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = scala.math.mod(r,\
    \ p)\n\e[31m\e[31m  |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m\
    \                value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1660010078
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n)\n        val q =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val \n \
    \   }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp9fq3cr_g.scala:57:11 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp9fq3cr_g.scala:8:12 ----------------------------\e\
    [0m\e[0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.mod(r,\
    \ p)\n\e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e\
    [0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9fq3cr_g.scala:9:12\
    \ ----------------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = scala.math.mod(r, p)\n\e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m  |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m\
    \  |\e[0m\n\e[31m  |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9fq3cr_g.scala:10:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = scala.math.mod(r, p)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp9fq3cr_g.scala:11:12 ---------------------------\e[0m\e[0m\n\e[31m11\
    \ |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.mod(r, p)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already\
    \ defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9fq3cr_g.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m"
  stdout: ''
  timestamp: 1660010068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n)\n        val m =\
    \ scala.math.mod(r, p)\n        val q = scala.math.pow(p, m)\n        q\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpi04b6my5.scala:7:27 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = scala.math.mod(r,\
    \ p)\n\e[31m\e[31m  |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m\
    \                value mod is not a member of math\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpi04b6my5.scala:9:8 ----------------------\e[0m\e[0m\n\
    \e[31m9 |\e[0m        q\n\e[31m\e[31m  |\e[0m        ^\e[0m\n\e[31m  |\e[0m  \
    \      Found:    (q : Double)\n\e[31m  |\e[0m        Required: Long\n\e[31m  |\e\
    [0m\n\e[31m  |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010079
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.BigInt(n).modPow(scala.math.BigInt(p),\
    \ scala.math.BigInt(2))\n        r.toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpm_3f3kxa.scala:10)\n\tat Problem.main(tmpm_3f3kxa.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010078
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.util.Random\n        val q = p.toLong\n\
    \        val r = r.nextLong\n        val r = r.mod(q)\n        val r = r.pow(n)\n\
    \        val r = r.mod(q)\n        r\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4qw5etht.scala:8:12 ----------------------------\e\
    [0m\e[0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = r.nextLong\n\e[31m\e\
    [31m  |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m  |\e[0m\n\e[31m  |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp4qw5etht.scala:9:12 ----------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = r.mod(q)\n\e[31m\e\
    [31m  |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m  |\e[0m\n\e[31m  |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp4qw5etht.scala:10:12 ---------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = r.pow(n)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4qw5etht.scala:11:12 ---------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = r.mod(q)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4qw5etht.scala:12:8 ---------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        r\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m\
    \   |\e[0m        Found:    (r : scala.util.Random.type)\n\e[31m   |\e[0m    \
    \    Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660010080
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (r == 0) r else p +\
    \ r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpshmpx8fe.scala:10)\n\tat Problem.main(tmpshmpx8fe.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010066
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (n\
    \ < 0) r + p\n        else r\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuolpunl1.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (n < \e\
    [31m0\e[0m) r + p\n\e[31m\e[31m  |\e[0m                   ^^^^^\e[0m\n\e[31m \
    \ |\e[0m                   Found:    Double\n\e[31m  |\e[0m                  \
    \ Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuolpunl1.scala:8:13\
    \ ---------------------\e[0m\e[0m\n\e[31m8 |\e[0m        \e[33melse\e[0m r\n\e\
    [31m\e[31m  |\e[0m             ^\e[0m\n\e[31m  |\e[0m             Found:    (r\
    \ : Double)\n\e[31m  |\e[0m             Required: Long\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010079
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (r < 0) r + p else r\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp533txq2v.scala:11)\n\tat Problem.main(tmp533txq2v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (r == 0) r else p +\
    \ r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpshmpx8fe.scala:10)\n\tat Problem.main(tmpshmpx8fe.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010066
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n)\n        val m =\
    \ scala.math.mod(r, p)\n        if (m == 0) r else m\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpx4ty_qty.scala:7:27 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = scala.math.mod(r,\
    \ p)\n\e[31m\e[31m  |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m\
    \                value mod is not a member of math\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpx4ty_qty.scala:8:20 ---------------------\e[0m\e[0m\n\
    \e[31m8 |\e[0m        \e[33mif\e[0m (m == \e[31m0\e[0m) r \e[33melse\e[0m m\n\e\
    [31m\e[31m  |\e[0m                    ^\e[0m\n\e[31m  |\e[0m                 \
    \   Found:    (r : Double)\n\e[31m  |\e[0m                    Required: Long\n\
    \e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.BigInt(n).modPow(scala.math.BigInt(p),\
    \ scala.math.BigInt(2))\n        r.toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpm_3f3kxa.scala:10)\n\tat Problem.main(tmpm_3f3kxa.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010078
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.BigInt(n)\n        val m =\
    \ scala.math.BigInt(p)\n        val r = r.modPow(m, p)\n        r.toLong\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmy082nbu.scala:8:12 ----------------------------\e\
    [0m\e[0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = r.modPow(m, p)\n\
    \e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0mr is already\
    \ defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m  |\e[0m\n\e[31m  |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010075
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (r < 0) r + p else r\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp533txq2v.scala:11)\n\tat Problem.main(tmp533txq2v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n)\n        val q =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val \n \
    \   }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp9fq3cr_g.scala:57:11 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp9fq3cr_g.scala:8:12 ----------------------------\e\
    [0m\e[0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.mod(r,\
    \ p)\n\e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e\
    [0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9fq3cr_g.scala:9:12\
    \ ----------------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = scala.math.mod(r, p)\n\e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m  |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m\
    \  |\e[0m\n\e[31m  |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9fq3cr_g.scala:10:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = scala.math.mod(r, p)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp9fq3cr_g.scala:11:12 ---------------------------\e[0m\e[0m\n\e[31m11\
    \ |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.mod(r, p)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already\
    \ defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9fq3cr_g.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m"
  stdout: ''
  timestamp: 1660010068
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val m = 2L\n        val r = n % p\n        if\
    \ (p < 2L) m + (r % p) else m\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq1cpu9o6.scala:11)\n\tat Problem.main(tmpq1cpu9o6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010079
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.util.Random\n        val r = scala.util.Random\n\
    \        val r = scala.util.Random\n        val r = scala.util.Random\n      \
    \  val r = scala.util.Random\n        val r = scala.util.Random\n        val r\
    \ = scala.util.Random\n        val r = scala.util.Random\n        val r = scala.util.Random\n\
    \        val r = scala.util.Random\n        val r = scala.util.Random\n      \
    \  val r = scala.util.Random\n        val r = scala.util.Random\n        val r\
    \ = scala.util.Random\n        val r = scala.util.Random\n        val r = scala.util.Random\n\
    \        val r = scala.util.Random\n        val r = scala.util.Random\n      \
    \  val r = scala.util.Random\n        val r = scala.util.Random\n        val r\
    \ = scala.util.Random\n        val r = scala.util.Random\n        val r = scala.util.Random\n\
    \        val r = scala.util.Random\n        val r = scala.util.Random\n      \
    \  val r = scala.util.Random\n        val r = scala.util.Random\n        val r\
    \ = scala.util.Random\n        val r = scala.util.Random\n        val r = scala.util.Random\n\
    \        val r = scala.util.Random\n        val r = scala.util.Random\n      \
    \  val r = scala.util.Random\n        val r = scala.util.Random\n        val r\
    \ = scala.util.Random\n        val r = scala.util.Random\n        val r = scala.util.Random\n\
    \        val r = scala.util.Random\n        val r = scala.util.Random\n      \
    \  val r = scala.util.Random\n        val r = scala.util.Random\n        val r\
    \ = scala.util.Random\n        val r = scala.util.Random\n        val r = scala.util.Random\n\
    \        val r = scala.util.Random\n        val r = scala.util.Random\n      \
    \  val r = scala.util.Random\n        val r = scala.util.Random\n        val r\
    \ = scala.util.Random\n        val r = scala.util.Random\n        val r = scala.util.Random\n\
    \        val r = scala.util.Random\n        val r = scala.util.Random\n      \
    \  val r = scala.util.Random\n        val r = scala.util.Random\n        val r\
    \ = scala.util.Random\n        val r = scala.util.Random\n        val r = scala.util.Random\n\
    \        val r = scala.util.Random\n        val r = scala.util.Random\n      \
    \  val r = scala.util.Random\n        val r = scala.util.Random\n        val r\
    \ = scala.util.Random\n        val r = scala.util.Random\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpheaybjyd.scala:7:12 ----------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.util.Random\n\
    \e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0mr is\
    \ already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpheaybjyd.scala:8:12\
    \ ----------------------------\e[0m\e[0m\n\e[31m8 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = scala.util.Random\n\e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m  |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m\
    \  |\e[0m\n\e[31m  |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpheaybjyd.scala:9:12\
    \ ----------------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = scala.util.Random\n\e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m  |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m\
    \  |\e[0m\n\e[31m  |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpheaybjyd.scala:10:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = scala.util.Random\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpheaybjyd.scala:11:12 ---------------------------\e[0m\e[0m\n\e[31m11\
    \ |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.util.Random\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already\
    \ defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpheaybjyd.scala:1"
  stdout: ''
  timestamp: 1660010082
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n)\n        val q =\
    \ scala.math.mod(r, p)\n        val m = scala.math.mod(q, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val q = scala.math.mod(r, p)\n        val m =\
    \ scala.math.mod(q, p)\n        val r = scala.math.mod(r, p)\n        val q =\
    \ scala.math.mod(r, p)\n        val m = scala.math.mod(q, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val q = scala.math.mod(r, p)\n        val m =\
    \ scala.math.mod(q, p)\n        val r = scala.math.mod(r, p)\n        val q =\
    \ scala.math.mod(r, p)\n        val m = scala.math.mod(q, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val q = scala.math.mod(r, p)\n        val m =\
    \ scala.math.mod(q, p)\n        val r = scala.math.mod(r, p)\n        val q =\
    \ scala.math.mod(r, p)\n        val m = scala.math.mod(q, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val q = scala.math.mod(r, p)\n        val m =\
    \ scala.math.mod(q, p)\n        val r = scala.math.mod(r, p)\n        val q =\
    \ scala.math.mod(r, p)\n        val m = scala.math.mod(q, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val q = scala.math.mod(r, p)\n        val m =\
    \ scala.math.mod(q, p)\n        val r = scala.math.mod(r, p)\n        val q =\
    \ scala.math.mod(r, p)\n        val m = scala.math.mod(q, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val q = scala.math.mod(r, p)\n        val m =\
    \ scala.math.mod(q, p)\n        val r = scala.math.mod(r, p)\n        val q =\
    \ scala.math.mod(r, p)\n        val m = scala.math.mod(q, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val q = scala.math.mod(r, p)\n        val m =\
    \ scala.math.mod(q, p)\n        val r = scala.math.mod(r, p)\n        val q =\
    \ scala.math.mod(r, p)\n        val m = scala.math.mod(q, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val q = scala.math.mod(r, p)\n        val m =\
    \ scala.math.mod(q, p)\n        val r = scala.math.mod(r, p)\n        val q =\
    \ scala.math.mod(r, p)\n        val m = scala.math.mod(q, p)\n        val \n \
    \   }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpfgmk0vh1.scala:57:11 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpfgmk0vh1.scala:9:12 ----------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.mod(r,\
    \ p)\n\e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e\
    [0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfgmk0vh1.scala:10:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m\
    \ \e[36mq\e[0m = scala.math.mod(r, p)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mq is already defined as \e[33mvalue\e[0m \e[35mq\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpfgmk0vh1.scala:11:12 ---------------------------\e[0m\e[0m\n\e[31m11\
    \ |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = scala.math.mod(q, p)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already\
    \ defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfgmk0vh1.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.mod(r,\
    \ p)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfgmk0vh1.scala:13:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mva"
  stdout: ''
  timestamp: 1660010084
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n)\n        val q =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val \n \
    \   }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp9fq3cr_g.scala:57:11 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp9fq3cr_g.scala:8:12 ----------------------------\e\
    [0m\e[0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.mod(r,\
    \ p)\n\e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e\
    [0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9fq3cr_g.scala:9:12\
    \ ----------------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = scala.math.mod(r, p)\n\e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m  |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m\
    \  |\e[0m\n\e[31m  |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9fq3cr_g.scala:10:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = scala.math.mod(r, p)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp9fq3cr_g.scala:11:12 ---------------------------\e[0m\e[0m\n\e[31m11\
    \ |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.mod(r, p)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already\
    \ defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9fq3cr_g.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m"
  stdout: ''
  timestamp: 1660010068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.util.Random.nextInt() % p\n    \
    \    val q = scala.util.Random.nextInt() % p\n        val m = scala.util.Random.nextInt()\
    \ % p\n        val r = scala.util.Random.nextInt() % p\n        val q = scala.util.Random.nextInt()\
    \ % p\n        val m = scala.util.Random.nextInt() % p\n        val r = scala.util.Random.nextInt()\
    \ % p\n        val q = scala.util.Random.nextInt() % p\n        val m = scala.util.Random.nextInt()\
    \ % p\n        val r = scala.util.Random.nextInt() % p\n        val q = scala.util.Random.nextInt()\
    \ % p\n        val m = scala.util.Random.nextInt() % p\n        val r = scala.util.Random.nextInt()\
    \ % p\n        val q = scala.util.Random.nextInt() % p\n        val m = scala.util.Random.nextInt()\
    \ % p\n        val r = scala.util.Random.nextInt() % p\n        val q = scala.util.Random.nextInt()\
    \ % p\n        val m = scala.util.Random.nextInt() % p\n        val r = scala.util.Random.nextInt()\
    \ % p\n        val q = scala.util.Random.nextInt() % p\n        val m = scala.util.Random.nextInt()\
    \ % p\n        val r = scala.util.Random.nextInt() % p\n        val q = scala.util.Random.nextInt()\
    \ % p\n        val m = scala.util.Random.nextInt() % p\n        val r = scala.util.Random.nextInt()\
    \ % p\n        val q = scala.util.Random.nextInt() % p\n        val m = scala.util.Random.nextInt()\
    \ % p\n        val r = scala.util.Random.nextInt() % p\n        val q = scala.util.Random.nextInt()\
    \ % p\n        val m = scala.util.Random.nextInt() % p\n        val r = scala.util.Random.nextInt()\
    \ % p\n        val q = scala.util.Random.nextInt() % p\n        val m = scala.util.Random.nextInt()\
    \ % p\n        val r = scala.util.Random.nextInt() % p\n        val q = scala.util.Random.nextInt()\
    \ % p\n        val m = scala.util.Random.nextInt() % p\n        val r = scala.util.Random.nextInt()\
    \ % p\n        val q = scala.util.Random.nextInt() % p\n        val m = scala.util.Random.nextInt()\
    \ % p\n        val r = scala.\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpej9z1x4z.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpej9z1x4z.scala:9:12 ----------------------------\e[0m\e[0m\n\e[31m9\
    \ |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.util.Random.nextInt() % p\n\
    \e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \  |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m  |\e[0m\n\
    \e[31m  |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpej9z1x4z.scala:10:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m\
    \ \e[36mq\e[0m = scala.util.Random.nextInt() % p\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mq is already defined\
    \ as \e[33mvalue\e[0m \e[35mq\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpej9z1x4z.scala:11:12 ---------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = scala.util.Random.nextInt()\
    \ % p\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpej9z1x4z.scala:12:12 ---------------------------\e[0m\e[0m\n\e[31m12\
    \ |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.util.Random.nextInt() % p\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpej9z1x4z.scala:13:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m\
    \ \e[3"
  stdout: ''
  timestamp: 1660010087
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n)\n        val m =\
    \ scala.math.mod(r, p)\n        val s = scala.math.signum(r)\n        if (s ==\
    \ 0) m else m\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpz0ocmqtg.scala:7:27 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = scala.math.mod(r,\
    \ p)\n\e[31m\e[31m  |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m\
    \                value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1660010085
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val m = p.toLong\n        val r = n.toLong\n \
    \       val t = ((r - m) % m).toLong\n        if (t == 0) 1 else t\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphn6mz5hg.scala:12)\n\tat Problem.main(tmphn6mz5hg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010087
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.BigInt(n)\n        val m =\
    \ scala.math.BigInt(p)\n        val q = scala.math.BigInt(r.toInt)\n        val\
    \ r = scala.math.BigInt(r.toInt)\n        val r = scala.math.BigInt(r.toInt)\n\
    \        val r = scala.math.BigInt(r.toInt)\n        val r = scala.math.BigInt(r.toInt)\n\
    \        val r = scala.math.BigInt(r.toInt)\n        val r = scala.math.BigInt(r.toInt)\n\
    \        val r = scala.math.BigInt(r.toInt)\n        val r = scala.math.BigInt(r.toInt)\n\
    \        val r = scala.math.BigInt(r.toInt)\n        val r = scala.math.BigInt(r.toInt)\n\
    \        val r = scala.math.BigInt(r.toInt)\n        val r = scala.math.BigInt(r.toInt)\n\
    \        val r = scala.math.BigInt(r.toInt)\n        val r = scala.math.BigInt(r.toInt)\n\
    \        val r = scala.math.BigInt(r.toInt)\n        val r = scala.math.BigInt(r.toInt)\n\
    \        val r = scala.math.BigInt(r.toInt)\n        val r = scala.math.BigInt(r.toInt)\n\
    \        val r = scala.math.BigInt(r.toInt)\n        val r = scala.math.BigInt(r.toInt)\n\
    \        val r = scala.math.BigInt(r.toInt)\n        val r = scala.math.BigInt(r.toInt)\n\
    \        val r = scala.math.BigInt(r.toInt)\n        val r = scala.math.BigInt(r.toInt)\n\
    \        val r = scala.math.BigInt(r.toInt)\n        val r = scala.math.BigInt(r.toInt)\n\
    \        val r = scala.math.BigInt(r.toInt)\n        val r = scala.math.BigInt(r.toInt)\n\
    \        val r = scala.math.BigInt(r.toInt)\n        val r = scala.math.BigInt(r.toInt)\n\
    \        val r = scala.math.BigInt(r.toInt)\n        val r = scala.math.BigInt(r.toInt)\n\
    \        val r = scala.math.BigInt(r.toInt)\n        val r = scala.math.BigInt(r.toInt)\n\
    \        val r = scala.math.BigInt(r.toInt)\n        val r = scala.math.BigInt(r.toInt)\n\
    \        val r = scala.math.BigInt(r.toInt\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvq51eohv.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvq51eohv.scala:9:12\
    \ ----------------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = scala.math.BigInt(r.toInt)\n\e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m  |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m\
    \  |\e[0m\n\e[31m  |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvq51eohv.scala:10:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = scala.math.BigInt(r.toInt)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpvq51eohv.scala:11:12 ---------------------------\e[0m\e[0m\n\e[31m11\
    \ |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.BigInt(r.toInt)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr\
    \ is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvq51eohv.scala:12:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = scala.math.BigInt(r.toInt)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpvq51eohv.scala:13:12 ---------------------------\e[0m\e[0m\n\e[31m13\
    \ |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.BigInt(r.toInt)\n\e[31m\e\
    [31m   "
  stdout: ''
  timestamp: 1660010089
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (r == 0) r else p +\
    \ r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpshmpx8fe.scala:10)\n\tat Problem.main(tmpshmpx8fe.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010066
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val q = p / 2\n        val r = p % 2\n       \
    \ val s = n >> r\n        val t = n & -(r+1)\n        s * (q + t) % p\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdoscq_1m.scala:13)\n\tat Problem.main(tmpdoscq_1m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010090
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val m = 1L\n        val r = n % p\n        val\
    \ q = p / r\n        val r = p % r\n        val s = (r * r * r * r) % p\n    \
    \    val t = ((r * r * r * r * r) % p + m) % p\n        ((t * t * t * t * t) %\
    \ p + s) % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4alirxgv.scala:9:12 ----------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = p % r\n\e[31m\e\
    [31m  |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0mr is already defined as\
    \ \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m  |\e[0m\n\e[31m  |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010085
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n)\n        val m =\
    \ scala.math.mod(r, p)\n        if (m == 0) r else r - m\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7d0fcyyp.scala:7:27 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = scala.math.mod(r,\
    \ p)\n\e[31m\e[31m  |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m\
    \                value mod is not a member of math\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp7d0fcyyp.scala:8:20 ---------------------\e[0m\e[0m\n\
    \e[31m8 |\e[0m        \e[33mif\e[0m (m == \e[31m0\e[0m) r \e[33melse\e[0m r -\
    \ m\n\e[31m\e[31m  |\e[0m                    ^\e[0m\n\e[31m  |\e[0m          \
    \          Found:    (r : Double)\n\e[31m  |\e[0m                    Required:\
    \ Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010075
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n)\n        val m =\
    \ scala.math.mod(r, p)\n        val s = scala.math.signum(r)\n        if (s ==\
    \ 0) m else m\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpz0ocmqtg.scala:7:27 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = scala.math.mod(r,\
    \ p)\n\e[31m\e[31m  |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m\
    \                value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1660010085
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val q = p / 2\n        val r = p % 2\n       \
    \ val s = n % q\n        val t = n % r\n        val u = n - (s * q)\n        val\
    \ v = n - (t * r)\n        val w = n - (u * r)\n        val x = n - (v * q)\n\
    \        val y = n - (w * r)\n        val z = n - (x * q)\n        val a = n -\
    \ (y * r)\n        val b = n - (z * r)\n        val c = n - (a * q)\n        val\
    \ d = n - (b * r)\n        val e = n - (c * q)\n        val f = n - (d * r)\n\
    \        val g = n - (e * r)\n        val h = n - (f * q)\n        val i = n -\
    \ (g * r)\n        val j = n - (h * r)\n        val k = n - (i * q)\n        val\
    \ l = n - (j * r)\n        val m = n - (k * q)\n        val n = n - (l * r)\n\
    \        val o = n - (m * q)\n        val p = n - (n * r)\n        val q = n -\
    \ (o * q)\n        val r = n - (p * r)\n        val s = n - (q * r)\n        val\
    \ t = n - (r * q)\n        val u = n - (s * q)\n        val v = n - (t * r)\n\
    \        val w = n - (u * r)\n        val x = n - (v * q)\n        val y = n -\
    \ (w * r)\n        val z = n - (x * q)\n        val a = n - (y * r)\n        val\
    \ b = n - (z * r)\n        val c = n - (a * q)\n        val d = n - (b * r)\n\
    \        val e = n - (c * q)\n        val f = n - (d * r)\n        val g = n -\
    \ (e * r)\n        val h = n - (f * q)\n        val i = n - (g * r)\n        val\
    \ j = n - (h * r)\n        val k = n - (i * q)\n        val l = n - (j * r)\n\
    \        val m = n - (k * q)\n        val n = n - (l * r)\n        val o = n -\
    \ (m * q)\n        val p = n - (n * r)\n        val q = n - (o * q)\n        val\
    \ r = n - (p * r)\n        val s = n - (q * r)\n        val t = n - (r * q)\n\
    \        val u = n - (s * q)\n        val v = n - (t * r)\n        val w = n -\
    \ (u * r)\n        val x = n - (v * q)\n        val y = n - (w * r)\n\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9pgw3ztv.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mq\e[0m = n - (o * q)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mq is already\
    \ defined as \e[33mvalue\e[0m \e[35mq\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9pgw3ztv.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = n - (p * r)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already\
    \ defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9pgw3ztv.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36ms\e[0m = n - (q * r)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ms is already\
    \ defined as \e[33mvalue\e[0m \e[35ms\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9pgw3ztv.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mt\e[0m = n - (r * q)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mt is already\
    \ defined as \e[33mvalue\e[0m \e[35mt\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9pgw3ztv.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mu\e[0m = n - (s * q)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mu is already\
    \ defined as \e[33mvalue\e[0m \e[35mu\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9pgw3ztv.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31"
  stdout: ''
  timestamp: 1660010089
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n)\n        val q =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val \n \
    \   }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp9fq3cr_g.scala:57:11 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp9fq3cr_g.scala:8:12 ----------------------------\e\
    [0m\e[0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.mod(r,\
    \ p)\n\e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e\
    [0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9fq3cr_g.scala:9:12\
    \ ----------------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = scala.math.mod(r, p)\n\e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m  |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m\
    \  |\e[0m\n\e[31m  |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9fq3cr_g.scala:10:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = scala.math.mod(r, p)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp9fq3cr_g.scala:11:12 ---------------------------\e[0m\e[0m\n\e[31m11\
    \ |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.mod(r, p)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already\
    \ defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9fq3cr_g.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m"
  stdout: ''
  timestamp: 1660010068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.util.Random\n        val q = p.toLong\n\
    \        val x = r.nextInt() % q\n        val y = r.nextInt() % q\n        val\
    \ z = r.nextInt() % q\n        val w = r.nextInt() % q\n        val v = r.nextInt()\
    \ % q\n        val u = r.nextInt() % q\n        val t = r.nextInt() % q\n    \
    \    val s = r.nextInt() % q\n        val r = r.nextInt() % q\n        val q =\
    \ r.nextInt() % q\n        val p = r.nextInt() % q\n        val q = r.nextInt()\
    \ % q\n        val r = r.nextInt() % q\n        val q = r.nextInt() % q\n    \
    \    val r = r.nextInt() % q\n        val q = r.nextInt() % q\n        val r =\
    \ r.nextInt() % q\n        val q = r.nextInt() % q\n        val r = r.nextInt()\
    \ % q\n        val q = r.nextInt() % q\n        val r = r.nextInt() % q\n    \
    \    val q = r.nextInt() % q\n        val r = r.nextInt() % q\n        val q =\
    \ r.nextInt() % q\n        val r = r.nextInt() % q\n        val q = r.nextInt()\
    \ % q\n        val r = r.nextInt() % q\n        val q = r.nextInt() % q\n    \
    \    val r = r.nextInt() % q\n        val q = r.nextInt() % q\n        val r =\
    \ r.nextInt() % q\n        val q = r.nextInt() % q\n        val r = r.nextInt()\
    \ % q\n        val q = r.nextInt() % q\n        val r = r.nextInt() % q\n    \
    \    val q = r.nextInt() % q\n        val r = r.nextInt() % q\n        val q =\
    \ r.nextInt() % q\n        val r = r.nextInt() % q\n        val q = r.nextInt()\
    \ % q\n        val r = r.nextInt() % q\n        val q = r.nextInt() % q\n    \
    \    val r = r.nextInt() % q\n        val q = r.nextInt() % q\n        val r =\
    \ r.nextInt() % q\n        val q = r.nextInt() % q\n        val r = r.nextInt()\
    \ % q\n        val q = r.nextInt() % q\n        val r = r.nextInt() % q\n    \
    \    val q = r.nextInt() % q\n        val r = r.nextInt() % q\n        val q =\
    \ r.nextInt() % q\n        val r = r.nextInt() % q\n        val q = r.nextInt()\
    \ % q\n        val r = r.nextInt() % q\n        val \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp0gn41cn6.scala:63:11 ---------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp0gn41cn6.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = r.nextInt() % q\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is\
    \ already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0gn41cn6.scala:17:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m\
    \ \e[36mq\e[0m = r.nextInt() % q\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mq is already defined as \e[33mvalue\e[0m \e[35mq\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp0gn41cn6.scala:19:12 ---------------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m        \e[33mval\e[0m \e[36mq\e[0m = r.nextInt() % q\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mq is already defined\
    \ as \e[33mvalue\e[0m \e[35mq\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0gn41cn6.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = r.nextInt() % q\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is\
    \ already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0gn41cn6.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mq\e[0m = r.nextInt() % q\n"
  stdout: ''
  timestamp: 1660010090
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val m = scala.math.BigInt(n)\n        val r =\
    \ scala.math.BigInt(p)\n        val r = scala.math.BigInt(r).mod(m)\n        r.toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdu6dqqm5.scala:8:12 ----------------------------\e\
    [0m\e[0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.BigInt(r).mod(m)\n\
    \e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \ |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m  |\e[0m\n\
    \e[31m  |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n1 error found\n"
  stdout: ''
  timestamp: 1660010086
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n)\n        val q =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val \n \
    \   }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp9fq3cr_g.scala:57:11 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp9fq3cr_g.scala:8:12 ----------------------------\e\
    [0m\e[0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.mod(r,\
    \ p)\n\e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e\
    [0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9fq3cr_g.scala:9:12\
    \ ----------------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = scala.math.mod(r, p)\n\e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m  |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m\
    \  |\e[0m\n\e[31m  |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9fq3cr_g.scala:10:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = scala.math.mod(r, p)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp9fq3cr_g.scala:11:12 ---------------------------\e[0m\e[0m\n\e[31m11\
    \ |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.mod(r, p)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already\
    \ defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9fq3cr_g.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m"
  stdout: ''
  timestamp: 1660010068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.util.BigInt(n).mod(scala.util.BigInt(p)).toLong\n\
    \        if(r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp85_c5d2s.scala:6:27 -------------------------\e\
    [0m\e[0m\n\e[31m6 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.util.BigInt(n).mod(scala.util.BigInt(p)).toLong\n\
    \e[31m\e[31m  |\e[0m                ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m   \
    \             value BigInt is not a member of util\n1 error found\n"
  stdout: ''
  timestamp: 1660010089
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n)\n        val q =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val \n \
    \   }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp9fq3cr_g.scala:57:11 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp9fq3cr_g.scala:8:12 ----------------------------\e\
    [0m\e[0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.mod(r,\
    \ p)\n\e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e\
    [0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9fq3cr_g.scala:9:12\
    \ ----------------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = scala.math.mod(r, p)\n\e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m  |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m\
    \  |\e[0m\n\e[31m  |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9fq3cr_g.scala:10:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = scala.math.mod(r, p)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp9fq3cr_g.scala:11:12 ---------------------------\e[0m\e[0m\n\e[31m11\
    \ |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.mod(r, p)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already\
    \ defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9fq3cr_g.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m"
  stdout: ''
  timestamp: 1660010068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.mod(n, p)\n        val s =\
    \ scala.math.abs(r) % p\n        if (s == 0) r else r + p\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphivjrzlu.scala:6:27 -------------------------\e\
    [0m\e[0m\n\e[31m6 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.mod(n,\
    \ p)\n\e[31m\e[31m  |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m\
    \                value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1660010089
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n)\n        val m =\
    \ scala.math.mod(r, p)\n        if (m == 0) r else m\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpx4ty_qty.scala:7:27 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = scala.math.mod(r,\
    \ p)\n\e[31m\e[31m  |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m\
    \                value mod is not a member of math\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpx4ty_qty.scala:8:20 ---------------------\e[0m\e[0m\n\
    \e[31m8 |\e[0m        \e[33mif\e[0m (m == \e[31m0\e[0m) r \e[33melse\e[0m m\n\e\
    [31m\e[31m  |\e[0m                    ^\e[0m\n\e[31m  |\e[0m                 \
    \   Found:    (r : Double)\n\e[31m  |\e[0m                    Required: Long\n\
    \e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.mod(n, p)\n        if (n <\
    \ 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6n8a3br4.scala:6:27 -------------------------\e\
    [0m\e[0m\n\e[31m6 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.mod(n,\
    \ p)\n\e[31m\e[31m  |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m\
    \                value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (r < 0) r + p else r\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp533txq2v.scala:11)\n\tat Problem.main(tmp533txq2v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p\n        else r\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqv6fihhk.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p\n\e[31m\e[31m  |\e[0m                   ^^^^^\e[0m\n\e[31m \
    \ |\e[0m                   Found:    Double\n\e[31m  |\e[0m                  \
    \ Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqv6fihhk.scala:8:13\
    \ ---------------------\e[0m\e[0m\n\e[31m8 |\e[0m        \e[33melse\e[0m r\n\e\
    [31m\e[31m  |\e[0m             ^\e[0m\n\e[31m  |\e[0m             Found:    (r\
    \ : Double)\n\e[31m  |\e[0m             Required: Long\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (r < 0) r + p else r\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp533txq2v.scala:11)\n\tat Problem.main(tmp533txq2v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.BigInt(n).modPow(scala.math.BigInt(p),\
    \ scala.math.BigInt(2))\n        r.toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpm_3f3kxa.scala:10)\n\tat Problem.main(tmpm_3f3kxa.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010078
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (r == 0) r else p +\
    \ r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpshmpx8fe.scala:10)\n\tat Problem.main(tmpshmpx8fe.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010066
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n)\n        val m =\
    \ scala.math.mod(r, p)\n        m + 1\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpm7ft0b1e.scala:7:27 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = scala.math.mod(r,\
    \ p)\n\e[31m\e[31m  |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m\
    \                value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1660010078
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n)\n        val q =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val \n \
    \   }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp9fq3cr_g.scala:57:11 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp9fq3cr_g.scala:8:12 ----------------------------\e\
    [0m\e[0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.mod(r,\
    \ p)\n\e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e\
    [0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9fq3cr_g.scala:9:12\
    \ ----------------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = scala.math.mod(r, p)\n\e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m  |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m\
    \  |\e[0m\n\e[31m  |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9fq3cr_g.scala:10:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = scala.math.mod(r, p)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp9fq3cr_g.scala:11:12 ---------------------------\e[0m\e[0m\n\e[31m11\
    \ |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.mod(r, p)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already\
    \ defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9fq3cr_g.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m"
  stdout: ''
  timestamp: 1660010068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n)\n        val m =\
    \ scala.math.mod(r, p)\n        if (m == 0) r else m\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpx4ty_qty.scala:7:27 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = scala.math.mod(r,\
    \ p)\n\e[31m\e[31m  |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m\
    \                value mod is not a member of math\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpx4ty_qty.scala:8:20 ---------------------\e[0m\e[0m\n\
    \e[31m8 |\e[0m        \e[33mif\e[0m (m == \e[31m0\e[0m) r \e[33melse\e[0m m\n\e\
    [31m\e[31m  |\e[0m                    ^\e[0m\n\e[31m  |\e[0m                 \
    \   Found:    (r : Double)\n\e[31m  |\e[0m                    Required: Long\n\
    \e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (r < 0) r + p else r\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp533txq2v.scala:11)\n\tat Problem.main(tmp533txq2v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n)\n        val m =\
    \ scala.math.mod(r, p)\n        if (m == 0) r else m\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpx4ty_qty.scala:7:27 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = scala.math.mod(r,\
    \ p)\n\e[31m\e[31m  |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m\
    \                value mod is not a member of math\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpx4ty_qty.scala:8:20 ---------------------\e[0m\e[0m\n\
    \e[31m8 |\e[0m        \e[33mif\e[0m (m == \e[31m0\e[0m) r \e[33melse\e[0m m\n\e\
    [31m\e[31m  |\e[0m                    ^\e[0m\n\e[31m  |\e[0m                 \
    \   Found:    (r : Double)\n\e[31m  |\e[0m                    Required: Long\n\
    \e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (r < 0) r + p else r\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp533txq2v.scala:11)\n\tat Problem.main(tmp533txq2v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.BigInt(n).modPow(scala.math.BigInt(p),\
    \ scala.math.BigInt(2))\n        r.toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpm_3f3kxa.scala:10)\n\tat Problem.main(tmpm_3f3kxa.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010078
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val q = n / p\n        val r = n % p\n       \
    \ val s = q * q + r * r\n        if (s < p) q + p else q\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpd8ie_imc.scala:12)\n\tat Problem.main(tmpd8ie_imc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010091
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val m = n % (p + 1)\n        if (m == 0) 1\n \
    \       else modp(m, p)\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660010093
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val m = 2L\n        val r = n % p\n        if\
    \ (p == 1)\n            m\n        else if (r == 0)\n            1\n        else\n\
    \            modp(r, p * m) % p\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArithmeticException: / by zero\n\tat Problem$.modp(tmppcjoumal.scala:7)\n\
    \tat Problem$.modp(tmppcjoumal.scala:13)\n\tat Problem$.modp(tmppcjoumal.scala:13)\n\
    \tat Problem$.modp(tmppcjoumal.scala:13)\n\tat Problem$.modp(tmppcjoumal.scala:13)\n\
    \tat Problem$.modp(tmppcjoumal.scala:13)\n\tat Problem$.modp(tmppcjoumal.scala:13)\n\
    \tat Problem$.modp(tmppcjoumal.scala:13)\n\tat Problem$.modp(tmppcjoumal.scala:13)\n\
    \tat Problem$.modp(tmppcjoumal.scala:13)\n\tat Problem$.modp(tmppcjoumal.scala:13)\n\
    \tat Problem$.modp(tmppcjoumal.scala:13)\n\tat Problem$.modp(tmppcjoumal.scala:13)\n\
    \tat Problem$.modp(tmppcjoumal.scala:13)\n\tat Problem$.modp(tmppcjoumal.scala:13)\n\
    \tat Problem$.modp(tmppcjoumal.scala:13)\n\tat Problem$.modp(tmppcjoumal.scala:13)\n\
    \tat Problem$.modp(tmppcjoumal.scala:13)\n\tat Problem$.modp(tmppcjoumal.scala:13)\n\
    \tat Problem$.modp(tmppcjoumal.scala:13)\n\tat Problem$.modp(tmppcjoumal.scala:13)\n\
    \tat Problem$.modp(tmppcjoumal.scala:13)\n\tat Problem$.modp(tmppcjoumal.scala:13)\n\
    \tat Problem$.modp(tmppcjoumal.scala:13)\n\tat Problem$.modp(tmppcjoumal.scala:13)\n\
    \tat Problem$.modp(tmppcjoumal.scala:13)\n\tat Problem$.modp(tmppcjoumal.scala:13)\n\
    \tat Problem$.modp(tmppcjoumal.scala:13)\n\tat Problem$.modp(tmppcjoumal.scala:13)\n\
    \tat Problem$.modp(tmppcjoumal.scala:13)\n\tat Problem$.modp(tmppcjoumal.scala:13)\n\
    \tat Problem$.modp(tmppcjoumal.scala:13)\n\tat Problem$.modp(tmppcjoumal.scala:13)\n\
    \tat Problem$.modp(tmppcjoumal.scala:13)\n\tat Problem$.modp(tmppcjoumal.scala:13)\n\
    \tat Problem$.modp(tmppcjoumal.scala:13)\n\tat Problem$.modp(tmppcjoumal.scala:13)\n\
    \tat Problem$.modp(tmppcjoumal.scala:13)\n\tat Problem$.modp(tmppcjoumal.scala:13)\n\
    \tat Problem$.modp(tmppcjoumal.scala:13)\n\tat Problem$.modp(tmppcjoumal.scala:13)\n\
    \tat Problem$.modp(tmppcjoumal.scala:13)\n\tat Problem$.modp(tmppcjoumal.scala:13)\n\
    \tat Problem$.modp(tmppcjoumal.scala:13)\n\tat Problem$.modp(tmppcjoumal.scala:13)\n\
    \tat Problem$.modp(tmppcjoumal.scala:13)\n\tat Problem$.modp(tmppcjoumal.scala:13)\n\
    \tat Problem$.modp(tmppcjoumal.scala:13)\n\tat Problem$.modp(tmppcjoumal.scala:13)\n\
    \tat Problem$.modp(tmppcjoumal.scala:13)\n\tat Prob"
  stdout: ''
  timestamp: 1660010090
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (n < 0) r + p else r\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkmx49t3y.scala:11)\n\tat Problem.main(tmpkmx49t3y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010091
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n)\n        val s =\
    \ scala.math.mod(r, p)\n        val m = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val \n \
    \   }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp0noykahp.scala:57:11 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp0noykahp.scala:9:12 ----------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.mod(r,\
    \ p)\n\e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e\
    [0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0noykahp.scala:10:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = scala.math.mod(r, p)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp0noykahp.scala:11:12 ---------------------------\e[0m\e[0m\n\e[31m11\
    \ |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.mod(r, p)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already\
    \ defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0noykahp.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.mod(r,\
    \ p)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0noykahp.scala:13:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mva"
  stdout: ''
  timestamp: 1660010091
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        val q = p / r\n       \
    \ val r = p % r\n        val q = q * r\n        val r = q * r\n        val r =\
    \ r * r\n        val r = r * r\n        val r = r * r\n        val r = r * r\n\
    \        val r = r * r\n        val r = r * r\n        val r = r * r\n       \
    \ val r = r * r\n        val r = r * r\n        val r = r * r\n        val r =\
    \ r * r\n        val r = r * r\n        val r = r * r\n        val r = r * r\n\
    \        val r = r * r\n        val r = r * r\n        val r = r * r\n       \
    \ val r = r * r\n        val r = r * r\n        val r = r * r\n        val r =\
    \ r * r\n        val r = r * r\n        val r = r * r\n        val r = r * r\n\
    \        val r = r * r\n        val r = r * r\n        val r = r * r\n       \
    \ val r = r * r\n        val r = r * r\n        val r = r * r\n        val r =\
    \ r * r\n        val r = r * r\n        val r = r * r\n        val r = r * r\n\
    \        val r = r * r\n        val r = r * r\n        val r = r * r\n       \
    \ val r = r * r\n        val r = r * r\n        val r = r * r\n        val r =\
    \ r * r\n        val r = r * r\n        val r = r * r\n        val r = r * r\n\
    \        val r = r * r\n        val r = r * r\n        val r = r * r\n       \
    \ val r = r * r\n        val r = r * r\n        val r = r * r\n        val r =\
    \ r * r\n        val r = r * r\n        val r = r * r\n        val r = r * r\n\
    \        val r = r * r\n        val r = r * r\n        val r = r * r\n       \
    \ val r = r * r\n        val r = r * r\n        val r = r * r\n        val r =\
    \ r * r\n        val r = r * r\n        val r = r * r\n        val r = r * r\n\
    \        val r = r * r\n        val r = r * r\n        val r = r * r\n       \
    \ val r = r * r\n        val \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp2oewg_s6.scala:79:11 ---------------------------\e\
    [0m\e[0m\n\e[31m79 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp2oewg_s6.scala:8:12 ----------------------------\e\
    [0m\e[0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = p % r\n\e[31m\e\
    [31m  |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0mr is already defined as\
    \ \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m  |\e[0m\n\e[31m  |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp2oewg_s6.scala:9:12 ----------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mq\e[0m = q * r\n\e[31m\e\
    [31m  |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0mq is already defined as\
    \ \e[33mvalue\e[0m \e[35mq\e[0m\n\e[31m  |\e[0m\n\e[31m  |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp2oewg_s6.scala:10:12 ---------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = q * r\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined as\
    \ \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp2oewg_s6.scala:11:12 ---------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = r * r\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined as\
    \ \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp2oewg_s6.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = r * r\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined as\
    \ \e[33mvalue\e[0m \e[35"
  stdout: ''
  timestamp: 1660010091
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (r < 0) r + p else r\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp533txq2v.scala:11)\n\tat Problem.main(tmp533txq2v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val m = scala.math.pow(2,n)\n        val r = scala.math.mod(m,p)\n\
    \        val s = scala.math.signum(r)\n        if (s == 0) r else r + p\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfprrbaww.scala:7:27 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.mod(m,p)\n\
    \e[31m\e[31m  |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m      \
    \          value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1660010091
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.BigInt(n).modPow(scala.math.BigInt(p),\
    \ scala.math.BigInt(2))\n        r.toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpm_3f3kxa.scala:10)\n\tat Problem.main(tmpm_3f3kxa.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010078
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.mod(n, p)\n        if (n <\
    \ 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6n8a3br4.scala:6:27 -------------------------\e\
    [0m\e[0m\n\e[31m6 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.mod(n,\
    \ p)\n\e[31m\e[31m  |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m\
    \                value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (p < 0 || r < 0) r +\
    \ p\n        else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxeogd00o.scala:12)\n\tat Problem.main(tmpxeogd00o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010078
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n)\n        val m =\
    \ scala.math.mod(r, p)\n        val s = scala.math.signum(r)\n        if (s ==\
    \ 0) m else m\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpz0ocmqtg.scala:7:27 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = scala.math.mod(r,\
    \ p)\n\e[31m\e[31m  |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m\
    \                value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1660010085
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (r < 0) r + p else r\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp533txq2v.scala:11)\n\tat Problem.main(tmp533txq2v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val q = p + n\n        val r = p - (q % p)\n \
    \       val s = q - r\n        r % p\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprug4sy0t.scala:12)\n\tat Problem.main(tmprug4sy0t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010091
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p\n        else r\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqv6fihhk.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p\n\e[31m\e[31m  |\e[0m                   ^^^^^\e[0m\n\e[31m \
    \ |\e[0m                   Found:    Double\n\e[31m  |\e[0m                  \
    \ Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqv6fihhk.scala:8:13\
    \ ---------------------\e[0m\e[0m\n\e[31m8 |\e[0m        \e[33melse\e[0m r\n\e\
    [31m\e[31m  |\e[0m             ^\e[0m\n\e[31m  |\e[0m             Found:    (r\
    \ : Double)\n\e[31m  |\e[0m             Required: Long\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (r < 0) r + p else r\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp533txq2v.scala:11)\n\tat Problem.main(tmp533txq2v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val m = 1L\n        val r = n % p\n        val\
    \ q = p / r\n        val r = p % r\n        val s = (r + q * m) % p\n        s\
    \ % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp91enipml.scala:9:12 ----------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = p % r\n\e[31m\e\
    [31m  |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0mr is already defined as\
    \ \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m  |\e[0m\n\e[31m  |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010089
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (r == 0) r else p +\
    \ r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpshmpx8fe.scala:10)\n\tat Problem.main(tmpshmpx8fe.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010066
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n)\n        val m =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val \n \
    \   }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpi39ud9ie.scala:57:11 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpi39ud9ie.scala:8:12 ----------------------------\e\
    [0m\e[0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.mod(r,\
    \ p)\n\e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e\
    [0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi39ud9ie.scala:9:12\
    \ ----------------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = scala.math.mod(r, p)\n\e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m  |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m\
    \  |\e[0m\n\e[31m  |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi39ud9ie.scala:10:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = scala.math.mod(r, p)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpi39ud9ie.scala:11:12 ---------------------------\e[0m\e[0m\n\e[31m11\
    \ |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.mod(r, p)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already\
    \ defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi39ud9ie.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m"
  stdout: ''
  timestamp: 1660010093
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        val q = p / r\n       \
    \ val m = p * q\n        val r = n % m\n        val s = m / r\n        val r =\
    \ n % s\n        val t = s / r\n        val r = n % t\n        val u = t / r\n\
    \        val r = n % u\n        val v = u / r\n        val r = n % v\n       \
    \ val w = v / r\n        val r = n % w\n        val x = w / r\n        val r =\
    \ n % x\n        val y = x / r\n        val r = n % y\n        val z = y / r\n\
    \        val r = n % z\n        val a = z / r\n        val r = n % a\n       \
    \ val b = a / r\n        val r = n % b\n        val c = b / r\n        val r =\
    \ n % c\n        val d = c / r\n        val r = n % d\n        val e = d / r\n\
    \        val r = n % e\n        val f = e / r\n        val r = n % f\n       \
    \ val g = f / r\n        val r = n % g\n        val h = g / r\n        val r =\
    \ n % h\n        val i = h / r\n        val r = n % i\n        val j = i / r\n\
    \        val r = n % j\n        val k = j / r\n        val r = n % k\n       \
    \ val l = k / r\n        val r = n % l\n        val m = l / r\n        val r =\
    \ n % m\n        val n = m / r\n        val r = n % n\n        val o = n / r\n\
    \        val r = n % o\n        val p = o / r\n        val r = n % p\n       \
    \ val q = p / r\n        val r = n % q\n        val r = n % r\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpt7a6u4km.scala:9:12 ----------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = n % m\n\e[31m\e\
    [31m  |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0mr is already defined as\
    \ \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m  |\e[0m\n\e[31m  |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpt7a6u4km.scala:11:12 ---------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = n % s\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined as\
    \ \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpt7a6u4km.scala:13:12 ---------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = n % t\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined as\
    \ \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpt7a6u4km.scala:15:12 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = n % u\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined as\
    \ \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpt7a6u4km.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = n % v\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined as\
    \ \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpt7a6u4km.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = n % w\n\e[31m\e\
    [31m   |\e["
  stdout: ''
  timestamp: 1660010093
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.BigInt(n)\n        val q =\
    \ scala.math.BigInt(p)\n        val r = r.mod(q)\n        val r = r.toLong\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpiqer4mm_.scala:8:12 ----------------------------\e\
    [0m\e[0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = r.mod(q)\n\e[31m\e\
    [31m  |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m  |\e[0m\n\e[31m  |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpiqer4mm_.scala:9:12 ----------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = r.toLong\n\e[31m\e\
    [31m  |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m  |\e[0m\n\e[31m  |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpiqer4mm_.scala:10:5 ---------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010094
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (r < 0) r + p else r\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp533txq2v.scala:11)\n\tat Problem.main(tmp533txq2v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p\n        else r\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqv6fihhk.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p\n\e[31m\e[31m  |\e[0m                   ^^^^^\e[0m\n\e[31m \
    \ |\e[0m                   Found:    Double\n\e[31m  |\e[0m                  \
    \ Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqv6fihhk.scala:8:13\
    \ ---------------------\e[0m\e[0m\n\e[31m8 |\e[0m        \e[33melse\e[0m r\n\e\
    [31m\e[31m  |\e[0m             ^\e[0m\n\e[31m  |\e[0m             Found:    (r\
    \ : Double)\n\e[31m  |\e[0m             Required: Long\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (r < 0) r + p else r\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp533txq2v.scala:11)\n\tat Problem.main(tmp533txq2v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n)\n        val m =\
    \ scala.math.mod(r, p)\n        if (m == 0) r else r\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpslqqy3gz.scala:7:27 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = scala.math.mod(r,\
    \ p)\n\e[31m\e[31m  |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m\
    \                value mod is not a member of math\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpslqqy3gz.scala:8:20 ---------------------\e[0m\e[0m\n\
    \e[31m8 |\e[0m        \e[33mif\e[0m (m == \e[31m0\e[0m) r \e[33melse\e[0m r\n\e\
    [31m\e[31m  |\e[0m                    ^\e[0m\n\e[31m  |\e[0m                 \
    \   Found:    (r : Double)\n\e[31m  |\e[0m                    Required: Long\n\
    \e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpslqqy3gz.scala:8:27\
    \ ---------------------\e[0m\e[0m\n\e[31m8 |\e[0m        \e[33mif\e[0m (m == \e\
    [31m0\e[0m) r \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                        \
    \   ^\e[0m\n\e[31m  |\e[0m                           Found:    (r : Double)\n\e\
    [31m  |\e[0m                           Required: Long\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010096
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val q = p + n\n        val r = q % p\n       \
    \ val s = q - r\n        r + (s << 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmph1i22q91.scala:12)\n\tat Problem.main(tmph1i22q91.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010095
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.BigInt(n).mod(p)\n        if(r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpt4dvud55.scala:7:18\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m(r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                  ^^^^^\e\
    [0m\n\e[31m  |\e[0m                  Found:    BigInt\n\e[31m  |\e[0m        \
    \          Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpt4dvud55.scala:7:29\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m(r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                    \
    \         ^\e[0m\n\e[31m  |\e[0m                             Found:    (r : BigInt)\n\
    \e[31m  |\e[0m                             Required: Long\n\e[31m  |\e[0m\n\e\
    [31m  |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010096
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (n < 0) r + p else r\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkmx49t3y.scala:11)\n\tat Problem.main(tmpkmx49t3y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010091
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val m = BigInt(n)\n        val r = BigInt(p)\n\
    \        val s = BigInt(2)\n        val t = BigInt(m)\n        val r = BigInt(r)\n\
    \        val s = BigInt(s)\n        val t = BigInt(t)\n        val r = BigInt(r)\n\
    \        val s = BigInt(s)\n        val t = BigInt(t)\n        val r = BigInt(r)\n\
    \        val s = BigInt(s)\n        val t = BigInt(t)\n        val r = BigInt(r)\n\
    \        val s = BigInt(s)\n        val t = BigInt(t)\n        val r = BigInt(r)\n\
    \        val s = BigInt(s)\n        val t = BigInt(t)\n        val r = BigInt(r)\n\
    \        val s = BigInt(s)\n        val t = BigInt(t)\n        val r = BigInt(r)\n\
    \        val s = BigInt(s)\n        val t = BigInt(t)\n        val r = BigInt(r)\n\
    \        val s = BigInt(s)\n        val t = BigInt(t)\n        val r = BigInt(r)\n\
    \        val s = BigInt(s)\n        val t = BigInt(t)\n        val r = BigInt(r)\n\
    \        val s = BigInt(s)\n        val t = BigInt(t)\n        val r = BigInt(r)\n\
    \        val s = BigInt(s)\n        val t = BigInt(t)\n        val r = BigInt(r)\n\
    \        val s = BigInt(s)\n        val t = BigInt(t)\n        val r = BigInt(r)\n\
    \        val s = BigInt(s)\n        val t = BigInt(t)\n        val r = BigInt(r)\n\
    \        val s = BigInt(s)\n        val t = BigInt(t)\n        val r = BigInt(r)\n\
    \        val s = BigInt(s)\n        val t = BigInt(t)\n        val r = BigInt(r)\n\
    \        val s = BigInt(s)\n        val t = BigInt(t)\n        val r = BigInt(r)\n\
    \        val s = BigInt(s)\n        val t = BigInt(t)\n        val r = BigInt(r)\n\
    \        val s = BigInt(s)\n        val t = BigInt(t)\n        val r = BigInt(r)\n\
    \        val s = BigInt(s)\n        val t = BigInt(t)\n        val r = BigInt(r)\n\
    \        val s = BigInt(s)\n        val t = BigInt(t)\n        val r = BigInt(r)\n\
    \        val s = BigInt(s)\n        val t = BigInt(t)\n        val r = BigInt(r)\n\
    \        val s = BigInt(s)\n        val t = BigInt(t)\n        val r = BigInt(r)\n\
    \        val s = BigInt(s)\n        val t = BigInt(t)\n        \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmplro7c6og.scala:10:12 ---------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = BigInt(r)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmplro7c6og.scala:11:12 ---------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36ms\e[0m = BigInt(s)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ms is already defined\
    \ as \e[33mvalue\e[0m \e[35ms\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmplro7c6og.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mt\e[0m = BigInt(t)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mt is already defined\
    \ as \e[33mvalue\e[0m \e[35mt\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmplro7c6og.scala:13:12 ---------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = BigInt(r)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmplro7c6og.scala:14:12 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36ms\e[0m = BigInt(s)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ms is already defined\
    \ as \e[33mvalue\e[0m \e[35ms\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmplro7c6og.scala:15:12 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[3"
  stdout: ''
  timestamp: 1660010096
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.BigInt(n).mod(p)\n        if(r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpt4dvud55.scala:7:18\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m(r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                  ^^^^^\e\
    [0m\n\e[31m  |\e[0m                  Found:    BigInt\n\e[31m  |\e[0m        \
    \          Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpt4dvud55.scala:7:29\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m(r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                    \
    \         ^\e[0m\n\e[31m  |\e[0m                             Found:    (r : BigInt)\n\
    \e[31m  |\e[0m                             Required: Long\n\e[31m  |\e[0m\n\e\
    [31m  |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010096
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.BigInt(n).mod(p)\n        if(r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpt4dvud55.scala:7:18\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m(r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                  ^^^^^\e\
    [0m\n\e[31m  |\e[0m                  Found:    BigInt\n\e[31m  |\e[0m        \
    \          Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpt4dvud55.scala:7:29\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m(r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                    \
    \         ^\e[0m\n\e[31m  |\e[0m                             Found:    (r : BigInt)\n\
    \e[31m  |\e[0m                             Required: Long\n\e[31m  |\e[0m\n\e\
    [31m  |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010096
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val m = 2L\n        val r = n % p\n        val\
    \ s = p / r\n        val t = n % m\n        val u = p / t\n        val v = n %\
    \ m\n        val w = p / u\n        val x = p / v\n        val y = p / w\n   \
    \     val z = p / x\n        val a = p / y\n        val b = p / z\n        val\
    \ c = p / a\n        val d = p / b\n        val e = p / c\n        val f = p /\
    \ d\n        val g = p / e\n        val h = p / f\n        val i = p / g\n   \
    \     val j = p / h\n        val k = p / i\n        val l = p / j\n        val\
    \ m = p / k\n        val n = p / l\n        val o = p / m\n        val p = p /\
    \ n\n        val q = p / o\n        val r = p / q\n        val s = p / r\n   \
    \     val t = p / s\n        val u = p / t\n        val v = p / u\n        val\
    \ w = p / v\n        val x = p / w\n        val y = p / x\n        val z = p /\
    \ y\n        val a = p / z\n        val b = p / a\n        val c = p / b\n   \
    \     val d = p / c\n        val e = p / d\n        val f = p / e\n        val\
    \ g = p / f\n        val h = p / g\n        val i = p / h\n        val j = p /\
    \ i\n        val k = p / j\n        val l = p / k\n        val m = p / l\n   \
    \     val n = p / m\n        val o = p / n\n        val p = p / o\n        val\
    \ q = p / p\n        val r = p / q\n        val s = p / r\n        val t = p /\
    \ s\n        val u = p / t\n        val v = p / u\n        val w = p / v\n   \
    \     val x = p / w\n        val y = p / x\n        val z = p / y\n        val\
    \ a = p / z\n        val b = p / a\n        val c = p / b\n        val d = p /\
    \ c\n        val e = p / d\n        val f = p / e\n        val g = p / f\n   \
    \     val h = p / g\n        val i = p / h\n        val j = p / i\n        val\
    \ k = p / j\n        val l = p / \n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) ==\
    \ (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpvu2ciy6z.scala:79:19 ---------------------------\e\
    [0m\e[0m\n\e[31m79 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = p / \n\e[31m\e\
    [31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                   expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpvu2ciy6z.scala:28:12 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = p / k\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e\
    [0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpvu2ciy6z.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = p / q\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined as\
    \ \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpvu2ciy6z.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36ms\e[0m = p / r\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ms is already defined as\
    \ \e[33mvalue\e[0m \e[35ms\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpvu2ciy6z.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mt\e[0m = p / s\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mt is already defined as\
    \ \e[33mvalue\e[0m \e[35mt\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpvu2ciy6z.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mu\e[0m = p / t\n\e[31m\e\
    [31m   |\e[0m        ^^^^^"
  stdout: ''
  timestamp: 1660010096
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (r < 0) r + p else r\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp533txq2v.scala:11)\n\tat Problem.main(tmp533txq2v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val q = p / 2\n        val r = p % 2\n       \
    \ val s = n % q\n        val t = n % r\n        s * (q + r) + t\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpx_g89r1m.scala:14)\n\tat Problem.main(tmpx_g89r1m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010096
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val q = p / 2\n        val r = p % 2\n       \
    \ val s = n % q\n        val t = n / q\n        val u = (t * q + r) % p\n    \
    \    val v = (t * q + s) % p\n        ((u * q + v) % p) % p\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy4tkrqj8.scala:15)\n\tat Problem.main(tmpy4tkrqj8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010096
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n)\n        val m =\
    \ scala.math.mod(r, p)\n        if (m == 0) r else m\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpx4ty_qty.scala:7:27 -------------------------\e\
    [0m\e[0m\n\e[31m7 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = scala.math.mod(r,\
    \ p)\n\e[31m\e[31m  |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m\
    \                value mod is not a member of math\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpx4ty_qty.scala:8:20 ---------------------\e[0m\e[0m\n\
    \e[31m8 |\e[0m        \e[33mif\e[0m (m == \e[31m0\e[0m) r \e[33melse\e[0m m\n\e\
    [31m\e[31m  |\e[0m                    ^\e[0m\n\e[31m  |\e[0m                 \
    \   Found:    (r : Double)\n\e[31m  |\e[0m                    Required: Long\n\
    \e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx9uba4x.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m  |\e[0m                   ^^^^^\e\
    [0m\n\e[31m  |\e[0m                   Found:    Double\n\e[31m  |\e[0m       \
    \            Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsx9uba4x.scala:7:30 ---------------------\e[0m\e[0m\n\e[31m7\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m  |\e[0m                              ^\e[0m\n\e[31m  |\e[0m             \
    \                 Found:    (r : Double)\n\e[31m  |\e[0m                     \
    \         Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (r < 0) r + p else r\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp533txq2v.scala:11)\n\tat Problem.main(tmp533txq2v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n) % p\n        if (r\
    \ < 0) r + p\n        else r\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqv6fihhk.scala:7:19\
    \ ---------------------\e[0m\e[0m\n\e[31m7 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p\n\e[31m\e[31m  |\e[0m                   ^^^^^\e[0m\n\e[31m \
    \ |\e[0m                   Found:    Double\n\e[31m  |\e[0m                  \
    \ Required: Long\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqv6fihhk.scala:8:13\
    \ ---------------------\e[0m\e[0m\n\e[31m8 |\e[0m        \e[33melse\e[0m r\n\e\
    [31m\e[31m  |\e[0m             ^\e[0m\n\e[31m  |\e[0m             Found:    (r\
    \ : Double)\n\e[31m  |\e[0m             Required: Long\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n)\n        val q =\
    \ scala.math.pow(p, r)\n        val m = scala.math.mod(q, p)\n        m\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmk7702ug.scala:8:27 -------------------------\e\
    [0m\e[0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = scala.math.mod(q,\
    \ p)\n\e[31m\e[31m  |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m\
    \                value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1660010096
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (r < 0) r + p else r\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp533txq2v.scala:11)\n\tat Problem.main(tmp533txq2v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.BigInt(n).modPow(scala.math.BigInt(p),\
    \ scala.math.BigInt(p))\n        r.toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpm42zzvzg.scala:11)\n\tat Problem.main(tmpm42zzvzg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010096
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.BigInt(n).modPow(scala.math.BigInt(p),\
    \ scala.math.BigInt(2))\n        r.toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpm_3f3kxa.scala:10)\n\tat Problem.main(tmpm_3f3kxa.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010078
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = n % p\n        if (p < 0 || r < 0) r +\
    \ p\n        else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxeogd00o.scala:12)\n\tat Problem.main(tmpxeogd00o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010078
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    def modp(n : Long,\
    \ p : Long) : Long = {\n        val r = scala.math.pow(2, n)\n        val q =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val r =\
    \ scala.math.mod(r, p)\n        val r = scala.math.mod(r, p)\n        val \n \
    \   }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp9fq3cr_g.scala:57:11 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp9fq3cr_g.scala:8:12 ----------------------------\e\
    [0m\e[0m\n\e[31m8 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.mod(r,\
    \ p)\n\e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e\
    [0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9fq3cr_g.scala:9:12\
    \ ----------------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = scala.math.mod(r, p)\n\e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m  |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m\
    \  |\e[0m\n\e[31m  |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9fq3cr_g.scala:10:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = scala.math.mod(r, p)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp9fq3cr_g.scala:11:12 ---------------------------\e[0m\e[0m\n\e[31m11\
    \ |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.mod(r, p)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already\
    \ defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9fq3cr_g.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m"
  stdout: ''
  timestamp: 1660010068
