name: HumanEval_133_sum_squares
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a list of numbers.\n    // You need to return the sum of squared\
  \ numbers in the given list,\n    // round each element in the list to the upper\
  \ int(Ceiling) first.\n    // Examples:\n    def sumSquares(lst : List[Float]) :\
  \ Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(sumSquares((List[Float](1.0f.toFloat,\
  \ 2.0f.toFloat, 3.0f.toFloat))) == (14l));\n    assert(sumSquares((List[Float](1.0f.toFloat,\
  \ 2.0f.toFloat, 3.0f.toFloat))) == (14l));\n    assert(sumSquares((List[Float](1.0f.toFloat,\
  \ 3.0f.toFloat, 5.0f.toFloat, 7.0f.toFloat))) == (84l));\n    assert(sumSquares((List[Float](1.4f.toFloat,\
  \ 4.2f.toFloat, 0.0f.toFloat))) == (29l));\n    assert(sumSquares((List[Float](-2.4f.toFloat,\
  \ 1.0f.toFloat, 1.0f.toFloat))) == (6l));\n    assert(sumSquares((List[Float](100.0f.toFloat,\
  \ 1.0f.toFloat, 15.0f.toFloat, 2.0f.toFloat))) == (10230l));\n    assert(sumSquares((List[Float](10000.0f.toFloat,\
  \ 10000.0f.toFloat))) == (200000000l));\n    assert(sumSquares((List[Float](-1.4f.toFloat,\
  \ 4.6f.toFloat, 6.3f.toFloat))) == (75l));\n    assert(sumSquares((List[Float](-1.4f.toFloat,\
  \ 17.9f.toFloat, 18.9f.toFloat, 19.9f.toFloat))) == (1086l));\n    assert(sumSquares((List[Float](0.0f.toFloat)))\
  \ == (0l));\n    assert(sumSquares((List[Float](-1.0f.toFloat))) == (1l));\n   \
  \ assert(sumSquares((List[Float](-1.0f.toFloat, 1.0f.toFloat, 0.0f.toFloat))) ==\
  \ (2l));\n    }\n\n}\n"
completions: ["        val sumSquares = lst.foldLeft(0.0f) { (sum, num) =>\n     \
    \       val square = num * num\n            val rounded = math.ceil(square)\n\
    \            sum + rounded\n        }\n        sumSquares", "        val nums\
    \ = lst.map(_.toInt)\n        val sums = nums.map(x => x * x)\n        val sum\
    \ = sums.sum\n        val sumSquares = sums.map(x => x * x).sum\n        sumSquares\
    \ + sum", "        val sumSquares = lst.map(x => math.pow(x, 2)).sum\n       \
    \ sumSquares.toLong", "        val sumSquares = lst.foldLeft(0.0f) { (sum, element)\
    \ => sum + element * element }\n        sumSquares.toLong", "        val nums\
    \ = lst.map(_.toInt)\n        val sums = nums.map(x => x * x)\n        val sum\
    \ = sums.sum\n        val rounded = sums.map(x => math.ceil(x)).sum\n        rounded",
  "        val result = mutable.ArrayBuffer.empty[Float]\n        lst.foreach(x =>\
    \ result += math.pow(x, 2))\n        math.ceil(result.sum)", "        val sum\
    \ = 0\n        for(i <- 0 until lst.size) {\n            sum += lst(i) * lst(i)\n\
    \        }\n        sum", "        val sum = 0\n        for(i <- lst) sum += i\
    \ * i\n        sum", "        val sumSquares = mutable.ListBuffer.empty[Float]\n\
    \        for(i <- lst) {\n            sumSquares += math.pow(i,2)\n        }\n\
    \        sumSquares.sum", "        val sum = 0\n        val nums = lst.map(_.toInt)\n\
    \        val numsSorted = nums.sortWith((a, b) => a > b)\n        val numsSortedUp\
    \ = numsSorted.map(_.ceil)\n        val numsSortedUp2 = numsSorted.map(_.ceil.toInt)\n\
    \        val numsSortedUp3 = numsSorted.map(_.ceil.toInt)\n        val numsSortedUp4\
    \ = numsSorted.map(_.ceil.toInt)\n        val numsSortedUp5 = numsSorted.map(_.ceil.toInt)\n\
    \        val numsSortedUp6 = numsSorted.map(_.ceil.toInt)\n        val numsSortedUp7\
    \ = numsSorted.map(_.ceil.toInt)\n        val numsSortedUp8 = numsSorted.map(_.ceil.toInt)\n\
    \        val numsSortedUp9 = numsSorted.map(_.ceil.toInt)\n        val numsSortedUp10\
    \ = numsSorted.map(_.ceil.toInt)\n        val numsSortedUp11 = numsSorted.map(_.ceil.toInt)\n\
    \        val numsSortedUp12 = numsSorted.map(_.ceil.toInt)\n        val numsSortedUp13\
    \ = numsSorted.map(_.ceil.toInt)\n        val numsSortedUp14 = numsSorted.map(_.ceil.toInt)\n\
    \        val numsSortedUp15 = numsSorted.map(_.ceil.toInt)\n        val numsSortedUp16\
    \ = numsSorted.map(_.ceil.toInt)\n        val numsSortedUp17 = numsSorted.map(_.ceil.toInt)\n\
    \        val numsSortedUp18 = numsSorted.map(_.ceil.toInt)\n        val numsSortedUp19\
    \ = numsSorted.map(_.ceil.toInt)\n        val numsSortedUp20 = numsSorted.map(_.ceil.toInt)\n\
    \        val numsSortedUp21 = numsSorted.map(_.ceil.toInt)\n        val numsSortedUp22\
    \ = numsSorted.map(_.ceil.toInt)\n        val numsSortedUp23 = numsSorted.map(_.ceil.toInt)\n\
    \        val numsSortedUp24 = numsSorted.map(_.ceil.toInt)\n        val numsSortedUp25\
    \ = numsSorted.map(_.ceil.toInt)\n        val numsSortedUp26 = numsSorted.map(_.ceil.toInt",
  "        val sum = 0\n        for(i <- lst) sum += i * i\n        sum", "      \
    \  val sum = 0\n        lst.foreach(x => sum += math.pow(x, 2))\n        sum",
  "        val sum = 0\n        lst.foreach(x => sum += math.pow(x, 2))\n        sum",
  "        val sumSquares = lst.map(x => math.pow(x, 2)).sum\n        val roundToCeil\
    \ = lst.map(x => math.ceil(x)).sum\n        sumSquares + roundToCeil", "     \
    \   val result = mutable.ArrayBuffer.empty[Float]\n        lst.foreach(x => result\
    \ += math.pow(x, 2))\n        math.ceil(result.sum)", "        val sum = 0L\n\
    \        for(x <- lst) sum += x * x\n        sum", "        val result = mutable.ListBuffer.empty[Float]\n\
    \        lst.foreach(x => result += Math.ceil(x * x))\n        result.sum", " \
    \       val sum = 0\n        val nums = lst.map(x => math.ceil(x).toInt)\n   \
    \     nums.foreach(x => sum += math.pow(x, 2))\n        sum.toLong", "       \
    \ val sum = 0\n        lst.foreach(x => sum += math.pow(x, 2))\n        sum",
  "        val sum = 0\n        for(i <- lst) sum += i * i\n        sum", "      \
    \  val sum = 0\n        lst.foreach(x => sum += math.pow(x, 2))\n        sum",
  "        val sum = 0\n        lst.foreach(x => sum += math.pow(x, 2))\n        sum",
  "        val sum = 0\n        for(x <- lst) {\n            sum += x * x\n      \
    \  }\n        sum", "        val sum = 0L\n        lst.foreach(x => sum += math.pow(x,\
    \ 2))\n        sum", "        val sum = 0\n        lst.foreach(x => sum += math.pow(x,\
    \ 2))\n        sum.toLong", "        val sum = 0L\n        lst.foreach(x => sum\
    \ += math.pow(x, 2))\n        sum", "        val sum = 0\n        lst.foreach(x\
    \ => sum += math.pow(x, 2))\n        sum", "        val sumSquares = mutable.ListBuffer.empty[Float]\n\
    \        lst.foreach(x => sumSquares += math.pow(x, 2))\n        sumSquares.sum",
  "        val sumSquares = lst.foldLeft(0.0f) { (sum, element) => sum + element *\
    \ element }\n        sumSquares.toLong", "        val sum = 0\n        lst.foreach(x\
    \ => sum += math.pow(x, 2))\n        sum", "        val sum = 0\n        lst.foreach(x\
    \ => sum += math.pow(x, 2))\n        sum", "        val nums = lst.map(_.toInt)\n\
    \        val sums = nums.map(x => x * x)\n        val sumOfSquares = sums.sum\n\
    \        sumOfSquares", "        val sum = 0\n        lst.foreach(x => sum +=\
    \ math.pow(x, 2))\n        sum.toLong", "        val sum = 0\n        val nums\
    \ = lst.map(_.toInt)\n        nums.foreach(x => sum += x * x)\n        sum", " \
    \       val nums = lst.map(_.toInt)\n        val sums = nums.map(x => x * x)\n\
    \        val sumOfSquares = sums.sum\n        sumOfSquares", "        val sum\
    \ = 0\n        lst.foreach(x => sum += math.pow(x, 2))\n        sum", "      \
    \  val sum = 0\n        for(i <- lst) sum += i * i\n        sum", "        val\
    \ sum = 0\n        lst.foreach(x => sum += math.pow(x, 2))\n        sum.toLong",
  "        val sum = 0L\n        for(i <- lst) sum += i * i\n        sum", "     \
    \   val sum = 0L\n        lst.foreach(x => sum += math.pow(x, 2))\n        sum",
  "        val sumSquares = lst.foldLeft(0.0f) { (sum, num) =>\n            val roundedNum\
    \ = math.ceil(num * 100) / 100\n            sum + roundedNum * roundedNum\n  \
    \      }\n        sumSquares", "        val sum = 0L\n        for(x <- lst) {\n\
    \            val y = math.ceil(x)\n            sum += y * y\n        }\n     \
    \   sum", "        val nums = lst.map(_.toInt)\n        val sums = nums.map(x\
    \ => x * x)\n        val sumsSum = sums.sum\n        val sumsSumRounded = sumsSum.ceil.toLong\n\
    \        sumsSumRounded", "        val sum = 0L\n        lst.foreach(x => sum\
    \ += math.pow(x, 2))\n        sum", "        val sum = 0\n        for(i <- lst)\
    \ {\n            sum += i * i\n        }\n        sum", "        val nums = lst.map(x\
    \ => math.ceil(x).toInt)\n        val sum = 0L\n        for (i <- nums) {\n  \
    \          sum += i\n        }\n        sum", "        val sum = 0\n        lst.foreach(x\
    \ => sum += math.pow(x, 2))\n        sum", "        val nums = lst.map(_.toInt)\n\
    \        val sums = nums.map(x => x * x)\n        val sum = sums.sum\n       \
    \ val squareSums = sums.map(x => x * x)\n        val squareSum = squareSums.sum\n\
    \        val squareSumCeil = squareSums.map(x => math.ceil(x)).sum\n        val\
    \ squareSumFloor = squareSums.map(x => math.floor(x)).sum\n        val squareSumFloorCeil\
    \ = squareSums.map(x => math.floor(x)).map(math.ceil).sum\n        val squareSumFloorCeil2\
    \ = squareSums.map(x => math.floor(x)).map(math.ceil).map(math.ceil).sum\n   \
    \     val squareSumFloorCeil3 = squareSums.map(x => math.floor(x)).map(math.ceil).map(math.ceil).map(math.ceil).sum\n\
    \        val squareSumFloorCeil4 = squareSums.map(x => math.floor(x)).map(math.ceil).map(math.ceil).map(math.ceil).map(math.ceil).sum\n\
    \        val squareSumFloorCeil5 = squareSums.map(x => math.floor(x)).map(math.ceil).map(math.ceil).map(math.ceil).map(math.ceil).map(math.ceil).sum\n\
    \        val squareSumFloorCeil6 = squareSums.map(x => math.floor(x)).map(math.ceil).map(math.ceil).map(math.ceil).map(math.ceil).map(math.ceil).map(math.ceil).sum\n\
    \        val squareSumFloorCeil7 = squareSums.map(x => math.floor(x)).map(math.ceil).map(math.ceil).map(math.ceil).map(math.ceil).map(math.ceil).map(math.ceil).map(math.ceil).sum\n\
    \        val squareSumFloorCeil8 = squareSums.map(x => math.floor(x)).map(math.ceil).map(math.ceil).map(math.ceil).map(math.ceil).map(math.ceil).map(math.ceil).map(math.ceil).map(math.ceil).sum\n\
    \        val squareSumFloorCeil9 = squareSums.map(x => math.floor(x)).map(math.ceil).map(math.ceil).map(math.ceil).map(math.ceil).map(math.ceil).map(math.ceil).map(math.ceil).map(math.ceil).map(math.ceil).sum\n\
    \        val squareSumFloorCeil10 = squareSums.map(x => math.floor(x)).map(math.ceil).map(math.ceil).map(math.ceil).map(math.ceil).map(math.ceil).map(math.ceil).map(math.ceil).map(math.ceil).",
  "        val sumSquares = lst.foldLeft(0.0f) { (sum, elem) =>\n            val newSum\
    \ = sum + elem * elem\n            val newSum = math.ceil(newSum)\n          \
    \  newSum * newSum\n        }\n        sumSquares", "        val sum = 0\n   \
    \     lst.foreach(x => sum += math.pow(x, 2))\n        sum", "        val nums\
    \ = lst.map(_.toInt)\n        val sum = nums.sum\n        val squares = nums.map(x\
    \ => x * x)\n        squares.sum", "        val sum = 0\n        for(i <- lst)\
    \ sum += i * i\n        sum", "        val sum = 0\n        lst.foreach(x => sum\
    \ += math.pow(x, 2))\n        sum", "        val sum = 0\n        lst.foreach(x\
    \ => sum += math.pow(x, 2))\n        sum", "        val sumSquares = mutable.ListBuffer[Float]()\n\
    \        lst.foreach(x => sumSquares += math.pow(x, 2))\n        sumSquares.sum",
  "        val sum = 0\n        lst.foreach(x => sum += math.pow(x, 2))\n        sum",
  "        val sum = 0\n        lst.foreach(x => sum += math.pow(x, 2))\n        sum",
  "        val sum = 0L\n        for(i <- lst) {\n            sum += i * i\n     \
    \   }\n        sum", "        val sum = 0\n        lst.foreach(x => sum += math.pow(x,\
    \ 2))\n        sum", "        val sum = 0\n        for(x <- lst) sum += math.pow(x,\
    \ 2)\n        sum", "        val sum = 0\n        lst.foreach(x => sum += math.pow(x,\
    \ 2))\n        sum", "        val sum = 0\n        lst.foreach(x => sum += math.pow(x,\
    \ 2))\n        sum", "        val sumSquares = lst.foldLeft(0.0f) { (sum, num)\
    \ => sum + num * num }\n        sumSquares.toLong", "        val sum = 0\n   \
    \     lst.foreach(x => sum += math.pow(x, 2))\n        sum", "        val sum\
    \ = 0\n        lst.foreach(x => sum += math.pow(x, 2))\n        sum", "      \
    \  val sum = 0\n        lst.foreach(x => sum += math.pow(x, 2))\n        sum",
  "        val sum = 0\n        lst.foreach(x => sum += math.pow(x, 2))\n        sum",
  "        val sum = 0\n        for(i <- lst) sum += i * i\n        sum", "      \
    \  val sum = 0\n        lst.foreach(x => sum += math.pow(x, 2))\n        sum",
  "        val sum = 0\n        lst.foreach(x => sum += math.pow(x, 2))\n        sum",
  "        val sum = 0\n        lst.foreach(x => sum += math.pow(x, 2))\n        sum",
  "        val sum = 0\n        lst.foreach(x => sum += math.pow(x, 2))\n        sum.toLong",
  "        val sumSquares = lst.foldLeft(0.0f) { (sum, num) => sum + num * num }\n\
    \        sumSquares.toLong", "        val sum = 0\n        lst.foreach(x => sum\
    \ += math.pow(x, 2))\n        sum", "        val sum = 0L\n        lst.foreach(x\
    \ => sum += math.pow(x, 2))\n        sum", "        val sum = 0\n        for(i\
    \ <- lst) sum += i * i\n        sum", "        val sumSquares = lst.foldLeft(0.0f)\
    \ { (sum, num) =>\n            val roundedNum = math.ceil(num * 100) / 100\n \
    \           sum + roundedNum * roundedNum\n        }\n        sumSquares", " \
    \       val sum = 0\n        lst.foreach(x => sum += math.pow(x, 2))\n       \
    \ sum", "        val sum = 0\n        lst.foreach(x => sum += math.pow(x, 2))\n\
    \        sum", "        val sum = 0\n        for(i <- lst) sum += i * i\n    \
    \    sum", "        val sum = 0\n        lst.foreach(x => sum += math.pow(x, 2))\n\
    \        sum", "        val sumSquares = lst.foldLeft(0.0f) { (sum, element) =>\
    \ sum + element * element }\n        sumSquares.toLong", "        val sum = 0\n\
    \        lst.foreach(x => sum += math.pow(x, 2))\n        sum", "        val sum\
    \ = 0\n        for(x <- lst) sum += math.pow(x, 2)\n        sum.toLong", "   \
    \     val sum = 0\n        lst.foreach(x => sum += math.pow(x, 2))\n        sum",
  "        val sum = 0\n        lst.foreach(x => sum += math.pow(x, 2))\n        sum",
  "        val sum = 0\n        lst.foreach(x => sum += math.pow(x, 2))\n        sum.toLong",
  "        val sumSquares = lst.foldLeft(0.0f){ (sum, element) => sum + element *\
    \ element }\n        sumSquares.toLong", "        val sumSquares = mutable.ListBuffer[Float]()\n\
    \        lst.foreach(x => sumSquares += math.pow(x, 2))\n        sumSquares.sum",
  "        val sum = 0\n        lst.foreach(x => sum += math.pow(x, 2))\n        sum",
  "        val sum = 0\n        lst.foreach(x => sum += math.pow(x, 2))\n        sum",
  "        val sumSquares = lst.map(x => math.pow(x, 2)).sum\n        sumSquares.roundToInt",
  "        val sum = 0\n        lst.foreach(x => sum += math.pow(x, 2))\n        sum",
  "        val sum = 0\n        for(i <- lst) sum += i * i\n        sum", "      \
    \  val sum = 0\n        for(x <- lst) {\n            sum += math.pow(x, 2)\n \
    \       }\n        sum.toLong", "        val sum = 0\n        lst.foreach(x =>\
    \ sum += math.pow(x, 2))\n        sum", "        val sum = 0\n        lst.foreach(x\
    \ => sum += math.pow(x, 2))\n        sum", "        val result = mutable.ListBuffer.empty[Float]\n\
    \        lst.foreach(x => result += math.pow(x, 2))\n        result.sum", "  \
    \      val sum = 0\n        lst.foreach(x => sum += math.pow(x, 2))\n        sum",
  "        val nums = lst.map(_.round)\n        val sums = nums.map(math.pow(_, 2)).sum\n\
    \        sums.toLong", "        val sum = 0\n        for(i <- lst) sum += i *\
    \ i\n        sum", "        val nums = lst.map(_.toInt)\n        val sum = nums.sum\n\
    \        val sqr = nums.map(x => x * x).sum\n        val sqrSum = sqr + sum\n\
    \        sqrSum.toLong", "        val sum = 0\n        for(x <- lst) {\n     \
    \       sum += math.pow(x, 2)\n        }\n        sum", "        val sum = 0\n\
    \        lst.foreach(x => sum += math.pow(x, 2))\n        sum", "        val nums\
    \ = lst.map(_.toInt)\n        val sums = nums.map(x => x * x)\n        val sum\
    \ = sums.sum\n        val rounded = sums.map(x => math.ceil(x)).sum\n        rounded",
  "        val sumSquares = lst.foldLeft(0.0f) { (sum, num) =>\n            val newSum\
    \ = sum + num * num\n            val newNum = math.ceil(num)\n            newSum\
    \ * newNum\n        }\n        sumSquares", "        val sum = 0\n        lst.foreach(x\
    \ => sum += math.pow(x, 2))\n        sum.toLong", "        val sum = 0\n     \
    \   lst.foreach(x => sum += math.pow(x, 2))\n        sum", "        val sum =\
    \ 0\n        lst.foreach(x => sum += math.pow(x, 2))\n        sum.toLong", " \
    \       val sum = 0L\n        lst.foreach(x => sum += math.pow(x, 2))\n      \
    \  sum", "        val sumSquares = lst.foldLeft(0.0f) { (sum, num) => sum + num\
    \ * num }\n        sumSquares.toLong", "        val sum = 0\n        for(x <-\
    \ lst) {\n            sum += x * x\n        }\n        sum", "        val nums\
    \ = lst.map(_.toInt)\n        val sums = nums.map(x => x * x)\n        val sumsSum\
    \ = sums.sum\n        val sumsSumRounded = sumsSum.map(_.ceil.toInt)\n       \
    \ val sumsSumRoundedSum = sumsSumRounded.sum\n        sumsSumRoundedSum", "  \
    \      val sumSquares = lst.map(x => math.pow(x, 2)).sum\n        val roundedSum\
    \ = sumSquares.toInt\n        roundedSum", "        val nums = lst.map(x => math.ceil(x))\n\
    \        val sums = nums.map(x => math.pow(x, 2))\n        val sum = sums.sum\n\
    \        sum.toLong", "        val sum = 0\n        lst.foreach(x => sum += math.pow(x,\
    \ 2))\n        sum", "        val sum = 0\n        for(i <- lst) {\n         \
    \   sum += math.pow(i,2)\n        }\n        sum.toLong", "        val nums =\
    \ lst.map(_.toInt)\n        val sums = nums.map(x => x * x)\n        val sum =\
    \ sums.sum\n        val rounded = sums.map(_.ceil)\n        rounded.sum", "  \
    \      val nums = lst.map(_.toInt)\n        val sums = nums.map(x => x * x)\n\
    \        val sum = sums.sum\n        val rounded = sums.map(x => math.ceil(x).toInt)\n\
    \        val sumOfSquares = rounded.map(x => x * x).sum\n        sumOfSquares",
  "        val sum = 0L\n        lst.foreach(x => sum += math.pow(x, 2))\n       \
    \ sum", "        val sum = 0\n        for(i <- lst) sum += i * i\n        sum",
  "        val sumSquares = lst.foldLeft(0.0f){ (sum, element) =>\n            val\
    \ square = math.pow(element, 2)\n            val rounded = math.ceil(square)\n\
    \            sum + rounded\n        }\n        sumSquares", "        val sum =\
    \ 0\n        lst.foreach(x => sum += math.pow(x, 2))\n        sum.toLong", " \
    \       val sum = 0\n        lst.foreach(x => sum += math.pow(x, 2))\n       \
    \ sum", "        val sum = 0L\n        lst.foreach(x => sum += math.pow(x, 2))\n\
    \        sum", "        val sum = 0\n        for(i <- lst) sum += i\n        sum",
  "        val sum = 0\n        lst.foreach(x => sum += math.pow(x, 2))\n        sum",
  "        val sum = 0\n        lst.foreach(x => sum += math.pow(x, 2))\n        sum",
  "        val sum = 0\n        lst.foreach(x => sum += math.pow(x, 2))\n        sum",
  "        val sum = 0\n        lst.foreach(x => sum += math.pow(x, 2))\n        sum",
  "        val sum = 0\n        lst.foreach(x => sum += math.pow(x, 2))\n        sum",
  "        val sumSquares = lst.foldLeft(0.0f){ (sum, num) =>\n            val rounded\
    \ = math.ceil(num)\n            sum + rounded*rounded\n        }\n        return\
    \ sumSquares", "        val sum = 0L\n        lst.foreach(x => sum += math.pow(x,\
    \ 2))\n        sum", "        val sum = 0\n        lst.foreach(x => sum += math.pow(x,\
    \ 2))\n        sum", "        val sum = 0\n        lst.foreach(x => sum += math.pow(x,\
    \ 2))\n        sum", "        val sum = 0L\n        for(i <- lst) sum += i * i\n\
    \        sum", "        val sumSquares = lst.foldLeft(0.0f) { (sum, num) => sum\
    \ + num * num }\n        sumSquares.toLong", "        val sum = 0\n        lst.foreach(x\
    \ => sum += math.pow(x, 2))\n        sum", "        val sum = 0\n        for(i\
    \ <- lst) sum += i * i\n        sum", "        val sum = 0\n        lst.foreach(x\
    \ => sum += math.pow(x, 2))\n        sum", "        val sum = 0\n        lst.foreach(x\
    \ => sum += math.pow(x, 2))\n        sum", "        val sum = 0\n        lst.foreach(x\
    \ => sum += math.pow(x, 2))\n        sum", "        val sumSquares = lst.foldLeft(0.0f)\
    \ { (sum, num) =>\n            val rounded = math.ceil(num * 100) / 100\n    \
    \        sum + rounded\n        }\n        return sumSquares", "        val sum\
    \ = 0\n        for(x <- lst) sum += x * x\n        sum", "        val sum = 0L\n\
    \        for(i <- lst) sum += i * i\n        sum", "        val nums = lst.map(_.toInt)\n\
    \        val sums = nums.map(x => x * x)\n        val sum = sums.sum\n       \
    \ val sqSum = sums.map(x => x * x).sum\n        sqSum.toLong", "        val sum\
    \ = 0\n        lst.foreach(x => sum += math.pow(x, 2))\n        sum", "      \
    \  val sumSquares = lst.foldLeft(0.0f) { (sum, num) => sum + num * num }\n   \
    \     sumSquares.toLong", "        val sum = 0\n        for(x <- lst) sum += x\
    \ * x\n        sum", "        val sumSquares = mutable.ListBuffer.empty[Float]\n\
    \        lst.foreach(x => sumSquares += math.pow(x, 2))\n        sumSquares.sum",
  "        val sumSquares = lst.foldLeft(0.0f) { (sum, num) => sum + num * num }\n\
    \        sumSquares.toLong", "        val sumSquares = lst.foldLeft(0.0f) { (sum,\
    \ num) => sum + num * num }\n        sumSquares.toLong", "        val sumSquares\
    \ = lst.foldLeft(0.0f) { (sum, element) => sum + element * element }\n       \
    \ sumSquares.toLong", "        val sum = 0\n        lst.foreach(x => sum += math.pow(x,\
    \ 2))\n        sum", "        val sum = 0L\n        lst.foreach(x => sum += math.pow(x,\
    \ 2))\n        sum", "        val sumSquares = lst.foldLeft(0.0f) {\n        \
    \    case (acc, x) => acc + x * x\n        }\n        val roundedSum = sumSquares.toInt\n\
    \        roundedSum", "        val sumSquares = lst.foldLeft(0.0f) { (sum, elem)\
    \ => sum + math.pow(elem, 2.0) }\n        sumSquares.toLong", "        val sum\
    \ = 0\n        for(i <- lst) {\n            sum += i\n        }\n        sum",
  "        val sum = 0\n        lst.foreach(x => sum += math.pow(x, 2))\n        sum",
  "        val sum = 0\n        for(i <- lst) sum += i * i\n        sum", "      \
    \  val sum = 0\n        lst.foreach(x => sum += math.pow(x, 2))\n        sum",
  "        val sum = 0\n        lst.foreach(x => sum += math.pow(x, 2))\n        sum",
  "        val sumSquares = mutable.ListBuffer.empty[Float]\n        lst.foreach(x\
    \ => sumSquares += math.pow(x, 2))\n        sumSquares.sum", "        val sum\
    \ = 0\n        for(i <- lst) {\n            sum += i * i\n        }\n        sum",
  "        val sum = 0\n        for(i <- lst) {\n            sum += i * i\n      \
    \  }\n        sum", "        val sumSquares = lst.foldLeft(0.0f) { (sum, element)\
    \ =>\n            val square = math.pow(element, 2)\n            sum + square\n\
    \        }\n        sumSquares.toLong", "        val sumSquares = lst.foldLeft(0.0f)\
    \ { (sum, item) => sum + math.pow(item, 2) }\n        sumSquares.toLong", "  \
    \      val nums = lst.map(_.toInt)\n        val sums = nums.map(x => x * x)\n\
    \        val sum = sums.sum\n        val squareSums = sums.map(x => x * x)\n \
    \       val squareSum = squareSums.sum\n        val squareSumRound = squareSums.map(x\
    \ => math.ceil(x)).sum\n        val squareSumCeil = squareSums.map(x => math.ceil(x)).sum\n\
    \        val squareSumFloor = squareSums.map(x => math.floor(x)).sum\n       \
    \ val squareSumFloorCeil = squareSums.map(x => math.floor(x)).sum\n        val\
    \ squareSumFloorFloor = squareSums.map(x => math.floor(x)).sum\n        val squareSumFloorFloorCeil\
    \ = squareSums.map(x => math.floor(x)).sum\n        val squareSumFloorFloorFloorCeil\
    \ = squareSums.map(x => math.floor(x)).sum\n        val squareSumFloorFloorFloorCeil\
    \ = squareSums.map(x => math.floor(x)).sum\n        val squareSumFloorFloorFloorFloorCeil\
    \ = squareSums.map(x => math.floor(x)).sum\n        val squareSumFloorFloorFloorFloorFloorCeil\
    \ = squareSums.map(x => math.floor(x)).sum\n        val squareSumFloorFloorFloorFloorFloorFloorCeil\
    \ = squareSums.map(x => math.floor(x)).sum\n        val squareSumFloorFloorFloorFloorFloorFloorCeil\
    \ = squareSums.map(x => math.floor(x)).sum\n        val squareSumFloorFloorFloorFloorFloorFloorFloorCeil\
    \ = squareSums.map(x => math.floor(x)).sum\n        val squareSumFloorFloorFloorFloorFloorFloorFloorFloorCeil\
    \ = squareSums.map(x => math.floor(x)).sum\n        val squareSumFloorFloorFloorFloorFloorFloorFloorFloorFloorCeil\
    \ = squareSums.map(x => math.floor(x)).sum\n        val squareSumFloorFloorFloorFloorFloorFloorFloorFloorFloorCeil\
    \ = squareSums.map(x => math.floor(x)).sum\n        val squareSumFloorFloorFloorFloorFloorFloorFloorFloorFloorFloorCeil\
    \ = squareSums.map(x => math.floor(x)).sum\n        val squareSumFloorFloorFloorFloorFloorFloorFloorFloorFloorFloorFloorCeil\
    \ = squareSums.map(x => math.floor(x)).sum\n        val squareSumFloorFloorFloorFloorFloorFloorFloorFloorFloorFloorFloorFloorCeil",
  "        val sum = 0\n        lst.foreach(x => sum += math.pow(x, 2))\n        sum",
  "        val sumSquares = lst.foldLeft(0.0f) { (sum, num) => sum + num * num }\n\
    \        sumSquares.toLong", "        val sum = 0L\n        for(x <- lst) sum\
    \ += math.pow(x, 2)\n        sum", "        val nums = lst.map(_.round)\n    \
    \    val sum = nums.sum\n        val sq = nums.map(x => x * x).sum\n        sq.roundToInt",
  "        val sum = 0\n        for(i <- lst) {\n            sum += i * i\n      \
    \  }\n        sum", "        val sum = 0\n        val nums = lst.map(x => math.ceil(x).toInt)\n\
    \        nums.foreach(x => sum += math.pow(x, 2))\n        sum", "        val\
    \ sumSquares = lst.map(x => x * x).sum\n        sumSquares.toLong", "        val\
    \ sum = 0\n        for(i <- 0 until lst.size) {\n            val x = lst(i)\n\
    \            val y = math.ceil(x)\n            sum += y * y\n        }\n     \
    \   sum", "        val sum = 0\n        lst.foreach(x => sum += math.pow(x, 2))\n\
    \        sum", "        val nums = lst.map(_.toInt)\n        val sums = nums.map(x\
    \ => x * x)\n        val sum = sums.sum\n        val sum2 = sums.map(x => Math.ceil(x)).sum\n\
    \        sum + sum2", "        val sum = 0\n        lst.foreach(x => sum += math.pow(x,\
    \ 2))\n        sum", "        val sum = 0\n        lst.foreach(x => sum += math.pow(x,\
    \ 2))\n        sum", "        val sum = 0\n        for(i <- lst) sum += i * i\n\
    \        sum", "        val sum = 0\n        val nums = lst.map(_.toInt)\n   \
    \     nums.foreach(x => sum += x * x)\n        sum.toLong", "        val sumSquares\
    \ = lst.foldLeft(0.0f) { (sum, element) =>\n            val newSum = sum + element*element\n\
    \            newSum\n        }\n        sumSquares.toLong", "        val sum =\
    \ 0L\n        lst.foreach(x => sum += math.pow(x, 2))\n        sum", "       \
    \ val sum = 0\n        for(i <- lst) {\n            sum += i * i\n        }\n\
    \        sum", "        val sum = 0\n        lst.foreach(x => sum += math.pow(x,\
    \ 2))\n        sum", "        val sumSquares = lst.foldLeft(0.0f)( (acc, x) =>\
    \ acc + x * x )\n        sumSquares.toLong", "        val sum = 0\n        for(i\
    \ <- lst) sum += i * i\n        sum", "        val sumSquares = lst.foldLeft(0.0f)\
    \ { (sum, num) => sum + num * num }\n        sumSquares.toLong", "        val\
    \ sumSquares = lst.foldLeft(0.0f) { (sum, elem) => sum + math.pow(elem, 2.0) }\n\
    \        sumSquares.toLong", "        val sum = 0\n        for(i <- lst) {\n \
    \           sum += i * i\n        }\n        sum", "        val sum = 0\n    \
    \    lst.foreach(x => sum += math.pow(x, 2))\n        sum", "        val nums\
    \ = lst.map(_.toInt)\n        val sums = nums.map(x => x * x)\n        val sum\
    \ = sums.sum\n        val rounded = sums.map(x => math.ceil(x).toInt)\n      \
    \  rounded.sum", "        val sum = 0\n        lst.foreach(x => sum += math.pow(x,\
    \ 2))\n        sum", "        val sum = 0\n        lst.foreach(x => sum += math.pow(x,\
    \ 2))\n        sum", "        val sumSquares = lst.foldLeft(0.0f) { (sum, element)\
    \ => sum + element * element }\n        sumSquares.toLong", "        val sum =\
    \ 0\n        for(i <- lst) sum += i * i\n        sum", "        val sum = 0\n\
    \        val squares = mutable.ListBuffer[Float]()\n        lst.foreach(x => squares\
    \ += math.pow(x, 2))\n        squares.foreach(x => sum += math.round(x))\n   \
    \     sum.toLong", "        val sum = 0\n        for(i <- lst) sum += i * i\n\
    \        sum", "        val sumSquares = lst.foldLeft(0.0f) { (sum, elem) => sum\
    \ + math.pow(elem, 2) }\n        sumSquares.toLong"]
stop_tokens:
- "\n    }\n"
