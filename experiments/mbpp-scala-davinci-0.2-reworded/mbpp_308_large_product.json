{
  "name": "mbpp_308_large_product",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    def largeProduct(nums1 : List[Long], nums2 : List[Long], N : Long) : List[Long] = {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_308_large_product.py",
  "prompt_terminology": "reworded",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (3l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (4l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong))));\n    assert(largeProduct((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[Long](3l.toLong, 6l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 6l.toLong)), (5l)).equals((List[Long](60l.toLong, 54l.toLong, 50l.toLong, 48l.toLong, 45l.toLong))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (i <- 0 until nums1.length; j <- 0 until nums2.length) yield nums1(i) * nums2(j)\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n        pq.enqueue((sorted1(0) * sorted2(0), 0, 0))\n        val result = new ListBuffer[Long]\n        for (i <- 0 until N.toInt) {\n            val (product, index1, index2) = pq.dequeue\n            result += product\n            if (index1 < sorted1.length - 1) pq.enqueue((sorted1(index1 + 1) * sorted2(index2), index1 + 1, index2))\n            if (index2 < sorted2.length - 1) pq.enqueue((sorted1(index1) * sorted2(index2 + 1), index1, index2 + 1))\n        }\n        result.toList",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val pq = new PriorityQueue[Long]()(Ordering.Long.reverse)\n        for (num1 <- nums1; num2 <- nums2) {\n            pq.enqueue(num1 * num2)\n            if (pq.size > N) pq.dequeue\n        }\n        pq.toList",
    "        val nums1Sorted = nums1.sorted\n        val nums2Sorted = nums2.sorted\n        val nums1SortedReversed = nums1Sorted.reverse\n        val nums2SortedReversed = nums2Sorted.reverse\n        val nums1SortedReversedSet = nums1SortedReversed.toSet\n        val nums2SortedReversedSet = nums2SortedReversed.toSet\n        val nums1SortedReversedMap = nums1SortedReversed.zipWithIndex.toMap\n        val nums2SortedReversedMap = nums2SortedReversed.zipWithIndex.toMap\n        val nums1SortedReversedMap2 = nums1SortedReversed.zipWithIndex.map(x => (x._1, x._2 + 1)).toMap\n        val nums2SortedReversedMap2 = nums2SortedReversed.zipWithIndex.map(x => (x._1, x._2 + 1)).toMap\n        val nums1SortedReversedMap3 = nums1SortedReversed.zipWithIndex.map(x => (x._1, x._2 + 2)).toMap\n        val nums2SortedReversedMap3 = nums2SortedReversed.zipWithIndex.map(x => (x._1, x._2 + 2)).toMap\n        val nums1SortedReversedMap4 = nums1SortedReversed.zipWithIndex.map(x => (x._1, x._2 + 3)).toMap\n        val nums2SortedReversedMap4 = nums2SortedReversed.zipWithIndex.map(x => (x._1, x._2 + 3)).toMap\n        val nums1SortedReversedMap5 = nums1SortedReversed.zipWithIndex.map(x => (x._1, x._2 + 4)).toMap\n        val nums2SortedReversedMap5 = nums2SortedReversed.zipWithIndex.map(x => (",
    "        val sorted1 = nums1.sortWith(_ > _)\n        val sorted2 = nums2.sortWith(_ > _)\n        val result = new ListBuffer[Long]\n        var i = 0\n        var j = 0\n        while (result.length < N) {\n            if (sorted1(i) * sorted2(j) > sorted1(i) * sorted2(j + 1)) {\n                result += sorted1(i) * sorted2(j)\n                j += 1\n            } else {\n                result += sorted1(i) * sorted2(j + 1)\n                i += 1\n            }\n        }\n        result.toList",
    "        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)",
    "        val nums1Sorted = nums1.sorted\n        val nums2Sorted = nums2.sorted\n        val products = for (i <- 0 to nums1Sorted.length - 1; j <- 0 to nums2Sorted.length - 1) yield nums1Sorted(i) * nums2Sorted(j)\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (x <- nums1; y <- nums2) yield x * y\n        products.sorted.takeRight(N.toInt)",
    "        val sorted1 = nums1.sortWith(_ > _)\n        val sorted2 = nums2.sortWith(_ > _)\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n        for (i <- 0 until sorted1.length) {\n            for (j <- 0 until sorted2.length) {\n                val product = sorted1(i) * sorted2(j)\n                if (heap.size < N) heap.enqueue(product)\n                else if (product > heap.head) {\n                    heap.dequeue\n                    heap.enqueue(product)\n                }\n            }\n        }\n        heap.toList",
    "        val products = for (i <- 0 until nums1.length; j <- 0 until nums2.length) yield nums1(i) * nums2(j)\n        products.sorted.takeRight(N.toInt).toList",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val sorted1 = nums1.sortWith(_ > _)\n        val sorted2 = nums2.sortWith(_ > _)\n        val products = for (i <- 0 until sorted1.length; j <- 0 until sorted2.length) yield sorted1(i) * sorted2(j)\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val products = for (i <- 0 until nums1.length; j <- 0 until nums2.length) yield sorted1(i) * sorted2(j)\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for(i <- nums1; j <- nums2) yield i * j\n        products.sorted.takeRight(N.toInt)",
    "        val nums1Sorted = nums1.sorted\n        val nums2Sorted = nums2.sorted\n        val nums1SortedReversed = nums1Sorted.reverse\n        val nums2SortedReversed = nums2Sorted.reverse\n        val nums1SortedReversedSet = nums1SortedReversed.toSet\n        val nums2SortedReversedSet = nums2SortedReversed.toSet\n        val nums1SortedReversedSetSize = nums1SortedReversedSet.size\n        val nums2SortedReversedSetSize = nums2SortedReversedSet.size\n        val nums1SortedReversedSetArray = nums1SortedReversedSet.toArray\n        val nums2SortedReversedSetArray = nums2SortedReversedSet.toArray\n        val nums1SortedReversedSetArraySize = nums1SortedReversedSetArray.size\n        val nums2SortedReversedSetArraySize = nums2SortedReversedSetArray.size\n        val nums1SortedReversedSetArraySizeMinusOne = nums1SortedReversedSetArraySize - 1\n        val nums2SortedReversedSetArraySizeMinusOne = nums2SortedReversedSetArraySize - 1\n        val nums1SortedReversedSetArraySizeMinusOneMinusN = nums1SortedReversedSetArraySizeMinusOne - N\n        val nums2SortedReversedSetArraySizeMinusOneMinusN = nums2SortedReversedSetArraySizeMinusOne - N\n        val nums1SortedReversedSetArraySizeMinusOneMinusNPlusOne = nums1SortedReversedSetArraySizeMinusOneMinusN + 1\n        val nums2SortedReversedSetArraySizeMinusOneMinusNPlusOne = nums2SortedReversedSetArraySizeMinusOneMinusN + 1\n        val nums1SortedReversedSetArraySizeMinusOneMinusN",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (x <- nums1; y <- nums2) yield x * y\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (i <- 0 until nums1.length; j <- 0 until nums2.length) yield nums1(i) * nums2(j)\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val nums1Sorted = nums1.sorted\n        val nums2Sorted = nums2.sorted\n        var result = List[Long]()\n        var i = nums1Sorted.length - 1\n        var j = nums2Sorted.length - 1\n        for (k <- 0 until N.toInt) {\n            if (i < 0 || j < 0) return result\n            val num1 = nums1Sorted(i)\n            val num2 = nums2Sorted(j)\n            if (num1 > num2) {\n                result = num1 * num2 :: result\n                i -= 1\n            } else {\n                result = num1 * num2 :: result\n                j -= 1\n            }\n        }\n        result",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for(num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (x <- nums1; y <- nums2) yield x * y\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (x <- nums1; y <- nums2) yield x * y\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val sorted1 = nums1.sortWith(_ > _)\n        val sorted2 = nums2.sortWith(_ > _)\n        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        val max1 = sorted1.head\n        val max2 = sorted2.head\n        heap.enqueue((max1, max2, max1 * max2))\n        val result = new ListBuffer[Long]()\n        for (i <- 1 to N.toInt) {\n            val (x, y, z) = heap.dequeue\n            if (x != sorted1.last) {\n                heap.enqueue((x, sorted2.last, x * sorted2.last))\n            }\n            if (y != sorted2.last) {\n                heap.enqueue((sorted1.last, y, sorted1.last * y))\n            }\n            result += z\n        }\n        result.toList",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val sorted1 = nums1.sortWith(_ > _)\n        val sorted2 = nums2.sortWith(_ > _)\n        val products = for (i <- 0 until sorted1.length; j <- 0 until sorted2.length) yield sorted1(i) * sorted2(j)\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (x <- nums1; y <- nums2) yield x * y\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val nums1Sorted = nums1.sortWith(_ > _)\n        val nums2Sorted = nums2.sortWith(_ > _)\n        var result = List[Long]()\n        var i = 0\n        var j = 0\n        var count = 0\n        while (count < N) {\n            if (nums1Sorted(i) * nums2Sorted(j) > nums1Sorted(i) * nums2Sorted(j + 1)) {\n                result = nums1Sorted(i) * nums2Sorted(j) :: result\n                j += 1\n            } else {\n                result = nums1Sorted(i) * nums2Sorted(j + 1) :: result\n                i += 1\n            }\n            count += 1\n        }\n        result",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)",
    "        val nums1Sorted = nums1.sorted\n        val nums2Sorted = nums2.sorted\n        val nums1SortedRev = nums1Sorted.reverse\n        val nums2SortedRev = nums2Sorted.reverse\n        val nums1SortedRevSet = nums1SortedRev.toSet\n        val nums2SortedRevSet = nums2SortedRev.toSet\n        val nums1SortedRevSetSize = nums1SortedRevSet.size\n        val nums2SortedRevSetSize = nums2SortedRevSet.size\n        val nums1SortedRevSetSizeMinus1 = nums1SortedRevSetSize - 1\n        val nums2SortedRevSetSizeMinus1 = nums2SortedRevSetSize - 1\n        val nums1SortedRevSetSizeMinus1MinusN = nums1SortedRevSetSizeMinus1 - N\n        val nums2SortedRevSetSizeMinus1MinusN = nums2SortedRevSetSizeMinus1 - N\n        val nums1SortedRevSetSizeMinus1MinusNPlus1 = nums1SortedRevSetSizeMinus1MinusN + 1\n        val nums2SortedRevSetSizeMinus1MinusNPlus1 = nums2SortedRevSetSizeMinus1MinusN + 1\n        val nums1SortedRevSetSizeMinus1MinusNPlus1Minus1 = nums1SortedRevSetSizeMinus1MinusNPlus1 - 1\n        val nums2SortedRevSetSizeMinus1MinusNPlus1Minus1 = nums2SortedRevSetSizeMinus1MinusNPlus1 - 1\n        val nums1SortedRevSetSizeMinus1MinusNPlus1Minus1PlusN = nums1SortedRevSetSizeMinus1MinusNPlus1Minus1 + N\n        val nums2SortedRevSetSizeMinus1MinusNPlus1Minus1PlusN = nums2SortedRevSetSizeMinus1MinusNPlus1Minus1 + N\n        val nums1Sorted",
    "        val products = for (x <- nums1; y <- nums2) yield x * y\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (x <- nums1; y <- nums2) yield x * y\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = nums1.flatMap(x => nums2.map(y => x * y)).sorted\n        products.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (x <- nums1; y <- nums2) yield x * y\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (i <- 0 until nums1.length; j <- 0 until nums2.length) yield nums1(i) * nums2(j)\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (i <- 0 until nums1.length; j <- 0 until nums2.length) yield nums1(i) * nums2(j)\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.takeRight(N.toInt)",
    "        val products = nums1.map(x => nums2.map(y => x * y)).flatten\n        products.sorted.takeRight(N.toInt).toList",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (x <- nums1; y <- nums2) yield x * y\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (x <- nums1; y <- nums2) yield x * y\n        products.sorted.takeRight(N.toInt)",
    "        val sorted1 = nums1.sorted.reverse\n        val sorted2 = nums2.sorted.reverse\n        val products = for (i <- 0 until N.toInt) yield sorted1(i) * sorted2(i)\n        products.toList",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (x <- nums1; y <- nums2) yield x * y\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)",
    "        val sorted1 = nums1.sortWith(_ > _)\n        val sorted2 = nums2.sortWith(_ > _)\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until N.toInt) {\n            heap += ((sorted1(i) * sorted2(0), i))\n        }\n        val result = new ListBuffer[Long]()\n        for (i <- 0 until N.toInt) {\n            val (product, index) = heap.dequeue\n            result += product\n            if (index + 1 < N) heap += ((sorted1(index) * sorted2(index + 1), index + 1))\n        }\n        result.toList",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (i <- 0 until nums1.length; j <- 0 until nums2.length) yield nums1(i) * nums2(j)\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (x <- nums1; y <- nums2) yield x * y\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)",
    "        val nums1Sorted = nums1.sorted\n        val nums2Sorted = nums2.sorted\n        val nums1SortedReversed = nums1Sorted.reverse\n        val nums2SortedReversed = nums2Sorted.reverse\n        val nums1SortedReversedSet = nums1SortedReversed.toSet\n        val nums2SortedReversedSet = nums2SortedReversed.toSet\n        val nums1SortedReversedSetSize = nums1SortedReversedSet.size\n        val nums2SortedReversedSetSize = nums2SortedReversedSet.size\n        val nums1SortedReversedSetArray = nums1SortedReversedSet.toArray\n        val nums2SortedReversedSetArray = nums2SortedReversedSet.toArray\n        val nums1SortedReversedSetArraySize = nums1SortedReversedSetArray.size\n        val nums2SortedReversedSetArraySize = nums2SortedReversedSetArray.size\n        val nums1SortedReversedSetArraySizeMinusOne = nums1SortedReversedSetArraySize - 1\n        val nums2SortedReversedSetArraySizeMinusOne = nums2SortedReversedSetArraySize - 1\n        val nums1SortedReversedSetArraySizeMinusOneMinusN = nums1SortedReversedSetArraySizeMinusOne - N\n        val nums2SortedReversedSetArraySizeMinusOneMinusN = nums2SortedReversedSetArraySizeMinusOne - N\n        val nums1SortedReversedSetArraySizeMinusOneMinusNPlusOne = nums1SortedReversedSetArraySizeMinusOneMinusN + 1\n        val nums2SortedReversedSetArraySizeMinusOneMinusNPlusOne = nums2SortedReversedSetArraySizeMinusOneMinusN + 1\n        val nums1SortedReversedSetArraySizeMinusOneMinusN",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val pq = new PriorityQueue[Long]()(Ordering.Long.reverse)\n        for (num1 <- nums1; num2 <- nums2) {\n            pq.enqueue(num1 * num2)\n            if (pq.size > N) pq.dequeue\n        }\n        pq.toList",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val nums1Sorted = nums1.sortWith(_ > _)\n        val nums2Sorted = nums2.sortWith(_ > _)\n        val nums1SortedSet = nums1Sorted.toSet\n        val nums2SortedSet = nums2Sorted.toSet\n        val nums1SortedMap = nums1Sorted.zipWithIndex.toMap\n        val nums2SortedMap = nums2Sorted.zipWithIndex.toMap\n        val nums1SortedLength = nums1Sorted.length\n        val nums2SortedLength = nums2Sorted.length\n        val nums1SortedLast = nums1Sorted.last\n        val nums2SortedLast = nums2Sorted.last\n        val nums1SortedLastIndex = nums1SortedMap(nums1SortedLast)\n        val nums2SortedLastIndex = nums2SortedMap(nums2SortedLast)\n        val nums1SortedLast2 = nums1Sorted(nums1SortedLastIndex - 1)\n        val nums2SortedLast2 = nums2Sorted(nums2SortedLastIndex - 1)\n        val nums1SortedLast3 = nums1Sorted(nums1SortedLastIndex - 2)\n        val nums2SortedLast3 = nums2Sorted(nums2SortedLastIndex - 2)\n        val nums1SortedLast4 = nums1Sorted(nums1SortedLastIndex - 3)\n        val nums2SortedLast4 = nums2Sorted(nums2SortedLastIndex - 3)\n        val nums1SortedLast5 = nums1Sorted(nums1SortedLastIndex - 4)\n        val nums2SortedLast5 = nums2Sorted(nums2SortedLastIndex - 4)\n        val nums1SortedLast6 = nums1Sorted(nums1SortedLastIndex - 5)\n        val nums2SortedLast6 = nums2Sorted(nums2SortedLastIndex - 5)\n        val nums1",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val sorted1 = nums1.sortWith(_ > _)\n        val sorted2 = nums2.sortWith(_ > _)\n        val heap = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(_._1))\n        heap.enqueue((sorted1(0) * sorted2(0), 0, 0))\n        val result = new ArrayBuffer[Long]()\n        while (result.size < N) {\n            val (product, i, j) = heap.dequeue\n            result += product\n            if (i + 1 < sorted1.size) heap.enqueue((sorted1(i + 1) * sorted2(j), i + 1, j))\n            if (j + 1 < sorted2.size) heap.enqueue((sorted1(i) * sorted2(j + 1), i, j + 1))\n        }\n        result.toList",
    "        val sorted1 = nums1.sortWith(_ > _)\n        val sorted2 = nums2.sortWith(_ > _)\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until sorted1.length) {\n            for (j <- 0 until sorted2.length) {\n                val product = sorted1(i) * sorted2(j)\n                if (heap.size < N) heap.enqueue((product, sorted1(i)))\n                else if (product > heap.head._1) {\n                    heap.dequeue\n                    heap.enqueue((product, sorted1(i)))\n                }\n            }\n        }\n        heap.map(_._1).toList",
    "        val products = for (x <- nums1; y <- nums2) yield x * y\n        products.sortWith(_ > _).take(N.toInt)",
    "        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val pq = new PriorityQueue[Long]()(Ordering.Long.reverse)\n        for (i <- 0 until sorted1.length) {\n            for (j <- 0 until sorted2.length) {\n                val product = sorted1(i) * sorted2(j)\n                if (pq.size < N) pq.enqueue(product)\n                else if (product > pq.head) {\n                    pq.dequeue\n                    pq.enqueue(product)\n                }\n            }\n        }\n        pq.toList",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (x <- nums1; y <- nums2) yield x * y\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(x => -x._3))\n        for (i <- 0 until N.toInt) {\n            pq.enqueue((i, 0, sorted1(i) * sorted2(0)))\n        }\n        val res = new ListBuffer[Long]\n        while (res.size < N) {\n            val (i, j, product) = pq.dequeue\n            res += product\n            if (j + 1 < N) pq.enqueue((i, j + 1, sorted1(i) * sorted2(j + 1)))\n        }\n        res.toList",
    "        var products = new ListBuffer[Long]()\n        for (i <- 0 until nums1.length; j <- 0 until nums2.length) {\n            products += nums1(i) * nums2(j)\n        }\n        products.sorted.reverse.take(N.toInt)",
    "        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val products = for (i <- 0 until sorted1.length; j <- 0 until sorted2.length) yield sorted1(i) * sorted2(j)\n        products.sorted.reverse.take(N.toInt)",
    "        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val products = for (i <- 0 until sorted1.length; j <- 0 until sorted2.length) yield sorted1(i) * sorted2(j)\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val pq = new PriorityQueue[Long]()(Ordering.by(-_))\n        for (i <- 0 until sorted1.length) {\n            for (j <- 0 until sorted2.length) {\n                val product = sorted1(i) * sorted2(j)\n                if (pq.size < N) pq.enqueue(product)\n                else if (product > pq.head) {\n                    pq.dequeue\n                    pq.enqueue(product)\n                }\n            }\n        }\n        pq.toList",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (x <- nums1; y <- nums2) yield x * y\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (x <- nums1; y <- nums2) yield x * y\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.takeRight(N.toInt)",
    "        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val min1 = sorted1(0)\n        val min2 = sorted2(0)\n        val max1 = sorted1(sorted1.length - 1)\n        val max2 = sorted2(sorted2.length - 1)\n        val max = max1 * max2\n        val min = min1 * min2\n        val pq = new PriorityQueue[Long]()(Ordering.Long.reverse)\n        for (i <- 0 until sorted1.length) {\n            for (j <- 0 until sorted2.length) {\n                val product = sorted1(i) * sorted2(j)\n                if (product < max) {\n                    if (pq.size < N) pq.enqueue(product)\n                    else if (product > pq.head) {\n                        pq.dequeue\n                        pq.enqueue(product)\n                    }\n                }\n            }\n        }\n        pq.toList",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for(n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)",
    "        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val products = for (i <- 0 until nums1.length; j <- 0 until nums2.length) yield sorted1(i) * sorted2(j)\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (x <- nums1; y <- nums2) yield x * y\n        products.sorted.takeRight(N.toInt)",
    "        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val products = for (i <- 0 until nums1.length; j <- 0 until nums2.length) yield sorted1(i) * sorted2(j)\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)",
    "        val nums1Sorted = nums1.sorted\n        val nums2Sorted = nums2.sorted\n        val nums1SortedReversed = nums1Sorted.reverse\n        val nums2SortedReversed = nums2Sorted.reverse\n        val nums1SortedReversedSet = nums1SortedReversed.toSet\n        val nums2SortedReversedSet = nums2SortedReversed.toSet\n        val nums1SortedReversedSetSize = nums1SortedReversedSet.size\n        val nums2SortedReversedSetSize = nums2SortedReversedSet.size\n        val nums1SortedReversedSetArray = nums1SortedReversedSet.toArray\n        val nums2SortedReversedSetArray = nums2SortedReversedSet.toArray\n        val nums1SortedReversedSetArraySize = nums1SortedReversedSetArray.size\n        val nums2SortedReversedSetArraySize = nums2SortedReversedSetArray.size\n        val nums1SortedReversedSetArraySizeMinusOne = nums1SortedReversedSetArraySize - 1\n        val nums2SortedReversedSetArraySizeMinusOne = nums2SortedReversedSetArraySize - 1\n        val nums1SortedReversedSetArraySizeMinusOneMinusN = nums1SortedReversedSetArraySizeMinusOne - N\n        val nums2SortedReversedSetArraySizeMinusOneMinusN = nums2SortedReversedSetArraySizeMinusOne - N\n        val nums1SortedReversedSetArraySizeMinusOneMinusNPlusOne = nums1SortedReversedSetArraySizeMinusOneMinusN + 1\n        val nums2SortedReversedSetArraySizeMinusOneMinusNPlusOne = nums2SortedReversedSetArraySizeMinusOneMinusN + 1\n        val nums1SortedReversedSetArraySizeMinusOneMinusN",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (x <- nums1; y <- nums2) yield x * y\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val max1 = sorted1.takeRight(N.toInt)\n        val max2 = sorted2.takeRight(N.toInt)\n        val min1 = sorted1.take(N.toInt)\n        val min2 = sorted2.take(N.toInt)\n        val max = max1.flatMap(x => max2.map(y => x * y))\n        val min = min1.flatMap(x => min2.map(y => x * y))\n        (max ::: min).sorted.takeRight(N.toInt)",
    "        val sorted1 = nums1.sortWith(_ > _)\n        val sorted2 = nums2.sortWith(_ > _)\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until N.toInt) heap.enqueue((sorted1(i) * sorted2(0), i))\n        val result = new ListBuffer[Long]\n        for (i <- 0 until N.toInt) {\n            val (product, index) = heap.dequeue\n            result += product\n            if (index < N.toInt - 1) heap.enqueue((sorted1(index) * sorted2(index + 1), index + 1))\n        }\n        result.toList",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (x <- nums1; y <- nums2) yield x * y\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val pq = new PriorityQueue[Long]()(Ordering.by(-_))\n        for (i <- 0 until sorted1.length) {\n            for (j <- 0 until sorted2.length) {\n                val product = sorted1(i) * sorted2(j)\n                if (pq.size < N) pq.enqueue(product)\n                else if (product > pq.head) {\n                    pq.dequeue\n                    pq.enqueue(product)\n                }\n            }\n        }\n        pq.toList",
    "        val products = for (i <- 0 until nums1.length; j <- 0 until nums2.length) yield nums1(i) * nums2(j)\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (x <- nums1; y <- nums2) yield x * y\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (x <- nums1; y <- nums2) yield x * y\n        products.sorted.reverse.take(N.toInt)",
    "        val products = nums1.flatMap(x => nums2.map(y => x * y)).sorted.reverse.take(N.toInt)\n        products",
    "        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.takeRight(N.toInt)",
    "        val products = nums1.flatMap(x => nums2.map(y => x * y)).sorted.reverse\n        products.take(N.toInt)",
    "        val pq = new PriorityQueue[Long]()(Ordering.by(-_))\n        for (i <- nums1; j <- nums2) {\n            pq.enqueue(i * j)\n            if (pq.size > N) pq.dequeue\n        }\n        pq.toList",
    "        val products = for (i <- 0 until nums1.length; j <- 0 until nums2.length) yield nums1(i) * nums2(j)\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for(num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)",
    "        val sorted1 = nums1.sorted\n        val sorted2 = nums2.sorted\n        val products = for (i <- 0 until nums1.length; j <- 0 until nums2.length) yield sorted1(i) * sorted2(j)\n        products.sorted.reverse.take(N.toInt)",
    "        val products = for (num1 <- nums1; num2 <- nums2) yield num1 * num2\n        products.sorted.takeRight(N.toInt)",
    "        val products = for (n1 <- nums1; n2 <- nums2) yield n1 * n2\n        products.sorted.reverse.take(N.toInt)",
    "        val nums1Sorted = nums1.sorted\n        val nums2Sorted = nums2.sorted\n        val nums1SortedReverse = nums1Sorted.reverse\n        val nums2SortedReverse = nums2Sorted.reverse\n        val nums1SortedReverseSet = nums1SortedReverse.toSet\n        val nums2SortedReverseSet = nums2SortedReverse.toSet\n        val nums1SortedReverseSetSize = nums1SortedReverseSet.size\n        val nums2SortedReverseSetSize = nums2SortedReverseSet.size\n        val nums1SortedReverseSetArray = nums1SortedReverseSet.toArray\n        val nums2SortedReverseSetArray = nums2SortedReverseSet.toArray\n        val nums1SortedReverseSetArraySize = nums1SortedReverseSetArray.size\n        val nums2SortedReverseSetArraySize = nums2SortedReverseSetArray.size\n        val nums1SortedReverseSetArraySizeMinusOne = nums1SortedReverseSetArraySize - 1\n        val nums2SortedReverseSetArraySizeMinusOne = nums2SortedReverseSetArraySize - 1\n        val nums1SortedReverseSetArraySizeMinusOneMinusN = nums1SortedReverseSetArraySizeMinusOne - N\n        val nums2SortedReverseSetArraySizeMinusOneMinusN = nums2SortedReverseSetArraySizeMinusOne - N\n        val nums1SortedReverseSetArraySizeMinusOneMinusNPlusOne = nums1SortedReverseSetArraySizeMinusOneMinusN + 1\n        val nums2SortedReverseSetArraySizeMinusOneMinusNPlusOne = nums2SortedReverseSetArraySizeMinusOneMinusN + 1\n        val nums1SortedReverseSetArraySizeMinusOneMinusN",
    "        val products = for (i <- nums1; j <- nums2) yield i * j\n        products.sortWith(_ > _).take(N.toInt)",
    "        val products = for (i <- 0 until nums1.length; j <- 0 until nums2.length) yield nums1(i) * nums2(j)\n        products.sorted.reverse.take(N.toInt)"
  ]
}