{
  "name": "mbpp_630_get_coordinates",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to extract all the adjacent coordinates of the given coordinate tuple.\n    def getCoordinates(test_tup : Long) : List[List[Long]] = {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_630_get_coordinates.py",
  "prompt_terminology": "reworded",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(getCoordinates((3l, 4l)).equals((List[List[Long]](List[Long](2l.toLong, 3l.toLong), List[Long](2l.toLong, 4l.toLong), List[Long](2l.toLong, 5l.toLong), List[Long](3l.toLong, 3l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 5l.toLong), List[Long](4l.toLong, 3l.toLong), List[Long](4l.toLong, 4l.toLong), List[Long](4l.toLong, 5l.toLong)))));\n    assert(getCoordinates((4l, 5l)).equals((List[List[Long]](List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 5l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](4l.toLong, 4l.toLong), List[Long](4l.toLong, 5l.toLong), List[Long](4l.toLong, 6l.toLong), List[Long](5l.toLong, 4l.toLong), List[Long](5l.toLong, 5l.toLong), List[Long](5l.toLong, 6l.toLong)))));\n    assert(getCoordinates((5l, 6l)).equals((List[List[Long]](List[Long](4l.toLong, 5l.toLong), List[Long](4l.toLong, 6l.toLong), List[Long](4l.toLong, 7l.toLong), List[Long](5l.toLong, 5l.toLong), List[Long](5l.toLong, 6l.toLong), List[Long](5l.toLong, 7l.toLong), List[Long](6l.toLong, 5l.toLong), List[Long](6l.toLong, 6l.toLong), List[Long](6l.toLong, 7l.toLong)))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        val x = test_tup / 100\n        val y = test_tup % 100\n        val x_list = List(x - 1, x, x + 1)\n        val y_list = List(y - 1, y, y + 1)\n        val coordinates = for (i <- x_list; j <- y_list) yield List(i, j)\n        coordinates.filter(x => x != List(x, y))",
    "        val x = test_tup / 1000000\n        val y = test_tup % 1000000\n        val x_list = List(x - 1, x, x + 1)\n        val y_list = List(y - 1, y, y + 1)\n        val result = for (i <- x_list; j <- y_list) yield List(i, j)\n        result.filter(x => x != List(x, y))",
    "        var tup = test_tup\n        var list = List[Long]()\n        while (tup > 0) {\n            list = (tup % 10) :: list\n            tup /= 10\n        }\n        var list_of_lists = List[List[Long]]()\n        for (i <- 0 to list.length - 1) {\n            var temp_list = list.toBuffer\n            temp_list(i) = (temp_list(i) + 1) % 10\n            list_of_lists = temp_list.toList :: list_of_lists\n            temp_list(i) = (temp_list(i) + 8) % 10\n            list_of_lists = temp_list.toList :: list_of_lists\n        }\n        list_of_lists",
    "        var tup = test_tup\n        var tup_list = List[Long]()\n        while (tup > 0) {\n            tup_list = tup % 10 :: tup_list\n            tup /= 10\n        }\n        var result = List[List[Long]]()\n        for (i <- 0 to tup_list.length - 1) {\n            var temp = List[Long]()\n            for (j <- 0 to tup_list.length - 1) {\n                if (i != j) temp = tup_list(j) :: temp\n            }\n            result = temp.reverse.mkString(\"\").toLong :: result\n        }\n        return result",
    "        val x = test_tup._1\n        val y = test_tup._2\n        List(List(x-1, y-1), List(x-1, y), List(x-1, y+1), List(x, y-1), List(x, y+1), List(x+1, y-1), List(x+1, y), List(x+1, y+1))",
    "        val test_list = List(test_tup)\n        val test_list_2 = List(test_tup)\n        val test_list_3 = List(test_tup)\n        val test_list_4 = List(test_tup)\n        val test_list_5 = List(test_tup)\n        val test_list_6 = List(test_tup)\n        val test_list_7 = List(test_tup)\n        val test_list_8 = List(test_tup)\n        val test_list_9 = List(test_tup)\n        val test_list_10 = List(test_tup)\n        val test_list_11 = List(test_tup)\n        val test_list_12 = List(test_tup)\n        val test_list_13 = List(test_tup)\n        val test_list_14 = List(test_tup)\n        val test_list_15 = List(test_tup)\n        val test_list_16 = List(test_tup)\n        val test_list_17 = List(test_tup)\n        val test_list_18 = List(test_tup)\n        val test_list_19 = List(test_tup)\n        val test_list_20 = List(test_tup)\n        val test_list_21 = List(test_tup)\n        val test_list_22 = List(test_tup)\n        val test_list_23 = List(test_tup)\n        val test_list_24 = List(test_tup)\n        val test_list_25 = List(test_tup)\n        val test_list_26 = List(test_tup)\n        val test_list_27 = List(test_tup)\n        val test_list_28 = List(test_tup)\n        val test_list_29 = List(test_tup)\n        val test_list_30 = List(test_tup)\n        val test_list_31 = List(test_tup)\n        val test_list_32 = List(test_tup)\n       ",
    "        val x = test_tup % 100\n        val y = test_tup / 100\n        val x_list = List(x-1, x, x+1)\n        val y_list = List(y-1, y, y+1)\n        val xy_list = for {\n            x <- x_list\n            y <- y_list\n        } yield List(x, y)\n        xy_list.filter(x => x(0) >= 0 && x(1) >= 0)",
    "        val x = test_tup / 100\n        val y = test_tup % 100\n        val x_list = List(x - 1, x, x + 1)\n        val y_list = List(y - 1, y, y + 1)\n        val x_y_list = for (i <- x_list; j <- y_list) yield List(i, j)\n        x_y_list.filter(x => x != List(x, y))",
    "        val x = test_tup / 100\n        val y = test_tup % 100\n        val x_list = List(x - 1, x, x + 1)\n        val y_list = List(y - 1, y, y + 1)\n        val xy_list = for (i <- x_list; j <- y_list) yield List(i, j)\n        xy_list.filter(x => x(0) >= 0 && x(1) >= 0)",
    "        val x = test_tup % 100\n        val y = test_tup / 100\n        val x_list = List(x - 1, x, x + 1)\n        val y_list = List(y - 1, y, y + 1)\n        val coordinates = for (i <- x_list; j <- y_list) yield List(i, j)\n        coordinates.filter(x => x.head >= 0 && x.last >= 0)",
    "        val x = test_tup % 100\n        val y = test_tup / 100\n        val coords = List(List(x-1, y-1), List(x, y-1), List(x+1, y-1), List(x-1, y), List(x+1, y), List(x-1, y+1), List(x, y+1), List(x+1, y+1))\n        return coords",
    "        val x = test_tup / 100\n        val y = test_tup % 100\n        val x_list = List(x - 1, x, x + 1)\n        val y_list = List(y - 1, y, y + 1)\n        val coord_list = for (i <- x_list; j <- y_list) yield List(i, j)\n        coord_list.filter(x => x != List(x, y))",
    "        val x = test_tup / 100\n        val y = test_tup % 100\n        val coordinates = List(List(x - 1, y - 1), List(x - 1, y), List(x - 1, y + 1), List(x, y - 1), List(x, y + 1), List(x + 1, y - 1), List(x + 1, y), List(x + 1, y + 1))\n        coordinates.filter(x => x(0) >= 0 && x(1) >= 0)",
    "        val x = test_tup % 10\n        val y = test_tup / 10\n        val coords = List(List(x - 1, y), List(x + 1, y), List(x, y - 1), List(x, y + 1))\n        coords.filter(p => p(0) >= 0 && p(1) >= 0 && p(0) <= 9 && p(1) <= 9)",
    "        val x = test_tup % 100\n        val y = test_tup / 100\n        val x_list = List(x - 1, x, x + 1)\n        val y_list = List(y - 1, y, y + 1)\n        val coordinates = for (i <- x_list; j <- y_list) yield List(i, j)\n        coordinates.filter(x => x.head >= 0 && x.head < 8 && x.last >= 0 && x.last < 8)",
    "        val x = test_tup / 100\n        val y = test_tup % 100\n        val x_list = List(x - 1, x, x + 1)\n        val y_list = List(y - 1, y, y + 1)\n        val coord_list = for (i <- x_list; j <- y_list) yield List(i, j)\n        return coord_list",
    "        val test_list = List(test_tup)\n        val test_list_adj = List(List(test_tup - 1, test_tup + 1), List(test_tup - 10, test_tup + 10))\n        val test_list_adj_diag = List(List(test_tup - 11, test_tup - 9, test_tup + 9, test_tup + 11))\n        val test_list_adj_diag_2 = List(List(test_tup - 21, test_tup - 19, test_tup + 19, test_tup + 21))\n        val test_list_adj_diag_3 = List(List(test_tup - 22, test_tup - 18, test_tup + 18, test_tup + 22))\n        val test_list_adj_diag_4 = List(List(test_tup - 12, test_tup - 8, test_tup + 8, test_tup + 12))\n        val test_list_adj_diag_5 = List(List(test_tup - 2, test_tup + 2))\n        val test_list_adj_diag_6 = List(List(test_tup - 20, test_tup - 20, test_tup + 20, test_tup + 20))\n        val test_list_adj_diag_7 = List(List(test_tup - 22, test_tup - 18, test_tup + 18, test_tup + 22))\n        val test_list_adj_diag_8 = List(List(test_tup - 23, test_tup - 17, test_tup + 17, test_tup + 23))\n        val test_list_adj_diag_9 = List(List(test_tup - 13, test_tup - 7, test_tup + 7, test_tup + 13))\n        val test_list_adj_diag_10 = List(List(test_tup - 3, test_tup + 3))\n        val test_list_adj_diag_11 = List(List(test_tup - 21,",
    "        val test_tup_list = List(test_tup)\n        val test_tup_list_adj = List(test_tup_list)\n        val test_tup_list_adj_list = List(test_tup_list_adj)\n        test_tup_list_adj_list",
    "        val x = test_tup % 100\n        val y = test_tup / 100\n        val x_coords = List(x - 1, x, x + 1)\n        val y_coords = List(y - 1, y, y + 1)\n        val coords = for (i <- x_coords; j <- y_coords) yield List(i, j)\n        coords.filter(x => x(0) >= 0 && x(1) >= 0)",
    "        val x = test_tup / 100\n        val y = test_tup % 100\n        val x_list = List(x - 1, x, x + 1)\n        val y_list = List(y - 1, y, y + 1)\n        val x_list_comb = x_list.combinations(2).toList\n        val y_list_comb = y_list.combinations(2).toList\n        val x_list_comb_flat = x_list_comb.map(x => x.flatMap(y => List(y)))\n        val y_list_comb_flat = y_list_comb.map(x => x.flatMap(y => List(y)))\n        val x_list_comb_flat_tup = x_list_comb_flat.map(x => (x(0), x(1)))\n        val y_list_comb_flat_tup = y_list_comb_flat.map(x => (x(0), x(1)))\n        val x_list_comb_flat_tup_map = x_list_comb_flat_tup.map(x => x._1 * 100 + x._2)\n        val y_list_comb_flat_tup_map = y_list_comb_flat_tup.map(x => x._1 * 100 + x._2)\n        val x_list_comb_flat_tup_map_list = x_list_comb_flat_tup_map.map(x => List(x))\n        val y_list_comb_flat_tup_map_list = y_list_comb_flat_tup_map.map(x => List(x))\n        val x_list_comb_flat_tup_map_list_final = x_list_comb_flat_tup_map_list.map(x => x.filter(y => y >= 0 && y < 10000))\n        val y_list_comb_flat_tup_map_list_final = y_list_comb_flat_tup_map_list.map(x => x.filter(y => y >= 0 && y < 10000))\n        val x_list_comb_flat_t"
  ]
}