{
  "name": "mbpp_743_rotate_right",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to rotate a given list by specified number of items to the right direction. https://www.geeksforgeeks.org/scalathon-program-right-rotate-list-n/\n    def rotateRight(list : List[Long], m : Long) : List[Long] = {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_743_rotate_right.py",
  "prompt_terminology": "reworded",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(rotateRight((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 10l.toLong)), (3l)).equals((List[Long](8l.toLong, 9l.toLong, 10l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong))));\n    assert(rotateRight((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 10l.toLong)), (2l)).equals((List[Long](9l.toLong, 10l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong))));\n    assert(rotateRight((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 10l.toLong)), (5l)).equals((List[Long](6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        val n = list.length\n        val m1 = m % n\n        val (a, b) = list.splitAt(n - m1.toInt)\n        b ::: a",
    "        val n = list.length\n        val m1 = m % n\n        val m2 = n - m1\n        val (l1, l2) = list.splitAt(m2)\n        l1 ::: l2",
    "        val n = list.length\n        val m1 = m % n\n        val (a, b) = list.splitAt(n - m1.toInt)\n        b ::: a",
    "        val n = list.length\n        val m1 = m % n\n        if (m1 == 0) list\n        else list.drop(n - m1.toInt) ++ list.take(n - m1.toInt)",
    "        val n = list.length\n        val m1 = m % n\n        val m2 = n - m1\n        list.drop(m2) ++ list.take(m2)",
    "        val n = list.length\n        val r = m % n\n        val (left, right) = list.splitAt(n - r.toInt)\n        right ::: left",
    "        val n = list.length\n        val m1 = m % n\n        val m2 = n - m1\n        list.takeRight(m1.toInt) ++ list.take(m2.toInt)",
    "        val n = list.length\n        val m1 = m % n\n        list.slice(n - m1.toInt, n) ++ list.slice(0, n - m1.toInt)",
    "        val n = list.length\n        val m1 = m % n\n        val (l1, l2) = list.splitAt(n - m1.toInt)\n        l2 ::: l1",
    "        val n = list.length\n        val k = m % n\n        val (left, right) = list.splitAt(n - k.toInt)\n        right ::: left",
    "        val n = list.length\n        val r = m % n\n        val (left, right) = list.splitAt(n - r.toInt)\n        right ::: left",
    "        val n = list.length\n        val m1 = m % n\n        val list1 = list.slice(n - m1.toInt, n)\n        val list2 = list.slice(0, n - m1.toInt)\n        list1 ::: list2",
    "        val n = list.length\n        val mod = m % n\n        list.drop(n - mod.toInt) ::: list.take(n - mod.toInt)",
    "        val n = list.length\n        val m1 = m % n\n        list.drop(n - m1.toInt) ::: list.take(n - m1.toInt)",
    "        val n = list.length\n        val result = new Array[Long](n)\n        for (i <- 0 until n) {\n            val j = (i + m) % n\n            result(j) = list(i)\n        }\n        result.toList",
    "        val n = list.length\n        val m1 = m % n\n        list.drop(n - m1.toInt) ::: list.take(n - m1.toInt)",
    "        val n = list.length\n        val r = m % n\n        val (a, b) = list.splitAt(n - r.toInt)\n        b ::: a",
    "        val n = list.length\n        val r = m % n\n        val (left, right) = list.splitAt(n - r.toInt)\n        right ::: left",
    "        val n = list.length\n        val mod = m % n\n        list.drop(n - mod.toInt) ::: list.take(n - mod.toInt)",
    "        val n = list.length\n        val m1 = m % n\n        val m2 = n - m1\n        list.drop(m2) ::: list.take(m2)"
  ]
}