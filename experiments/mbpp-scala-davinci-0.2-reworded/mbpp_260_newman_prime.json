{
  "name": "mbpp_260_newman_prime",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the nth newman\u2013shanks\u2013williams prime number.\n    def newmanPrime(n : Long) : Long = {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_260_newman_prime.py",
  "prompt_terminology": "reworded",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(newmanPrime((3l)) == (7l));\n    assert(newmanPrime((4l)) == (17l));\n    assert(newmanPrime((5l)) == (41l));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p += 2L\n            if (BigInt(p).isProbablePrime(100)) i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        var p = 0L\n        var i = 0L\n        while (p < n) {\n            i += 1\n            if (BigInt(2).modPow(i, i * i - 1) == 1) p += 1\n        }\n        i * i - 1",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = p * 2 + 1\n            if (BigInt(p).isProbablePrime(10)) i += 1\n        }\n        p",
    "        var count = 0L\n        var i = 1L\n        while (count < n) {\n            i += 1\n            if (BigInt(i).isProbablePrime(10)) {\n                val s = (i - 1) / 2\n                val t = s * s\n                if (t % i == 1) count += 1\n            }\n        }\n        i",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = p * 2 + 1\n            if (BigInt(p).isProbablePrime(100)) i += 1\n        }\n        p",
    "        var p = 2L\n        var count = 0L\n        while (count < n) {\n            p = p + 1\n            if (isPrime(p) && isPrime((p - 1) / 2)) count = count + 1\n        }\n        p",
    "        var p = 2L\n        var count = 0L\n        while (count < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) count += 1\n        }\n        p",
    "        val primes = new ArrayBuffer[Long]\n        primes += 2\n        primes += 3\n        var k = 1\n        while (primes.length < n) {\n            val p = primes(k)\n            val q = primes(k - 1)\n            val candidate = p * p - 2 * q\n            if (isPrime(candidate)) primes += candidate\n            k += 1\n        }\n        primes.last",
    "        val primes = new ArrayBuffer[Long]\n        primes += 2\n        primes += 3\n        var i = 5\n        while (primes.size < n) {\n            if (primes.forall(i % _ != 0)) primes += i\n            i += 2\n        }\n        primes.last",
    "        var count = 0L\n        var i = 1L\n        while (count < n) {\n            i += 1\n            if (i % 2 == 1 && i % 3 == 1 && i % 5 == 1 && i % 7 == 1) {\n                count += 1\n            }\n        }\n        i",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        return p",
    "        var count = 0L\n        var i = 2L\n        while (count < n) {\n            if (isPrime(i) && isPrime(2 * i + 1)) count += 1\n            i += 1\n        }\n        i - 1",
    "        var p = 1L\n        var i = 1L\n        while(i <= n) {\n            p = p + 2 * i + 1\n            i = i + 1\n        }\n        return p",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        val primes = new ArrayBuffer[Long]\n        primes += 2\n        primes += 3\n        var i = 1\n        while (primes.length < n) {\n            val p = primes(i)\n            val q = primes(i - 1)\n            val candidate = p * p - q * q\n            if (isPrime(candidate)) primes += candidate\n            i += 1\n        }\n        primes(n - 1)",
    "        var i = 1;\n        var p = 2;\n        while (i < n) {\n            p = nextPrime(p);\n            if (p % 5 == 1) i += 1;\n        }\n        return p;",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        return p",
    "        var p = 1L\n        var i = 1L\n        while (i <= n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        return p",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        val primes = new ArrayBuffer[Long]\n        primes += 2\n        var p = 3\n        while (primes.size < n) {\n            var isPrime = true\n            for (i <- 0 until primes.size) {\n                if (p % primes(i) == 0) {\n                    isPrime = false\n                    break\n                }\n            }\n            if (isPrime) {\n                primes += p\n                p += 2\n            } else {\n                p += 2\n                while (primes.exists(p % _ == 0)) p += 2\n            }\n        }\n        primes(n.toInt - 1)",
    "        var p = 1L\n        var i = 1L\n        while (i <= n) {\n            p = p + 1\n            if (BigInt(p).isProbablePrime(100)) {\n                i = i + 1\n            }\n        }\n        return p",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextPrime(p)\n            if (isPrime(p - 2)) i += 1\n        }\n        p",
    "        var p = 2L;\n        var i = 1L;\n        while (i <= n) {\n            p = nextPrime(p);\n            if (p % 5 == 3) {\n                i += 1;\n            }\n        }\n        return p;",
    "        var count = 0L\n        var i = 1L\n        while (count < n) {\n            i += 1\n            if (i % 2 == 0) {\n                if (i % 4 == 3) {\n                    count += 1\n                }\n            } else {\n                if (BigInt(i).isProbablePrime(10)) {\n                    count += 1\n                }\n            }\n        }\n        i",
    "        def isPrime(n : Long) : Boolean = {\n            if (n <= 1) return false\n            if (n == 2) return true\n            if (n % 2 == 0) return false\n            for (i <- 3 to sqrt(n).toInt by 2) {\n                if (n % i == 0) return false\n            }\n            return true\n        }\n        var p = 1\n        var count = 0\n        while (count < n) {\n            p += 2\n            if (isPrime(p) && isPrime((p - 1) / 2)) count += 1\n        }\n        return p",
    "        var p = 2L\n        var count = 0L\n        while (count < n) {\n            p = p + 1\n            if (isPrime(p)) {\n                val q = (p - 1) / 2\n                if (isPrime(q)) {\n                    val a = pow(2, q).toLong\n                    val b = pow(2, p - 1).toLong\n                    if (a % p == 1 && b % p == 1) {\n                        count = count + 1\n                    }\n                }\n            }\n        }\n        return p",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        return p",
    "        var p = 2L;\n        var i = 1L;\n        while (i < n) {\n            p = nextPrime(p);\n            if (isPrime(p - 2)) i += 1;\n        }\n        return p;",
    "        var p = 1L\n        var i = 0L\n        while (i < n) {\n            p += 2 * p + 1\n            if (BigInt(p).isProbablePrime(10)) i += 1\n        }\n        p",
    "        var count = 0L\n        var i = 1L\n        while (count < n) {\n            i += 1\n            if (i % 2 == 1) {\n                if (BigInt(i).isProbablePrime(10)) {\n                    count += 1\n                }\n            }\n        }\n        i",
    "        var i = 1L;\n        var count = 0L;\n        while (count < n) {\n            i += 2;\n            if (BigInt(i).isProbablePrime(10)) {\n                val a = (i - 1) / 2;\n                val b = (i + 1) / 2;\n                if (BigInt(a).isProbablePrime(10) && BigInt(b).isProbablePrime(10)) {\n                    count += 1;\n                }\n            }\n        }\n        return i;",
    "        var i = 1L;\n        var count = 0L;\n        while (count < n) {\n            i += 2;\n            if (isPrime(i) && isPrime((i - 1) / 2)) count += 1;\n        }\n        return i;",
    "        var i = 0\n        var p = 2\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) i += 1\n        }\n        p",
    "        val primes = new ArrayBuffer[Long]\n        primes += 2\n        primes += 3\n        var i = 1\n        while (primes.length < n) {\n            val p = primes(i)\n            val q = primes(i - 1)\n            val candidate = (p * p - q * q) / 2\n            if (primes.forall(p => candidate % p != 0)) primes += candidate\n            i += 1\n        }\n        primes(n.toInt - 1)",
    "        var count = 0L\n        var i = 1L\n        while (count < n) {\n            i += 1\n            if (isPrime(i) && isPrime((i - 1) / 2)) count += 1\n        }\n        return i",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) i += 1\n        }\n        p",
    "        var p = 1L\n        var i = 1L\n        while (i <= n) {\n            p += 2 * p + 1\n            if (BigInt(p).isProbablePrime(100)) i += 1\n        }\n        p",
    "        var i = 0;\n        var p = 2;\n        while (i < n) {\n            p = nextPrime(p);\n            if (p % 4 == 3) i += 1;\n        }\n        return p;",
    "        var p = 2L\n        var c = 0L\n        while (c < n) {\n            p = p + 1\n            if (BigInt(p).isProbablePrime(10)) {\n                c = c + 1\n            }\n        }\n        return p",
    "        var count = 0L\n        var i = 1L\n        while (count < n) {\n            i += 2\n            if (BigInt(i).isProbablePrime(10)) {\n                val s = sqrt(i).toLong\n                if (s * s != i) count += 1\n            }\n        }\n        i",
    "        var count = 0L\n        var i = 1L\n        while (count < n) {\n            i += 2\n            if (BigInt(i).isProbablePrime(10)) {\n                val k = (i - 1) / 2\n                if (BigInt(k).isProbablePrime(10)) {\n                    val j = (i + 1) / 2\n                    if (BigInt(j).isProbablePrime(10)) {\n                        count += 1\n                    }\n                }\n            }\n        }\n        i",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 1L\n        while (i <= n) {\n            p = nextPrime(p)\n            if (p % 5 == 1 || p % 5 == 4) i += 1\n        }\n        p",
    "        var primes = new ArrayBuffer[Long]()\n        primes += 2\n        primes += 3\n        var p = 5\n        while (primes.length < n) {\n            var isPrime = true\n            for (i <- 0 until primes.length) {\n                if (primes(i) * primes(i) > p) {\n                    i = primes.length\n                } else if (p % primes(i) == 0) {\n                    isPrime = false\n                    i = primes.length\n                }\n            }\n            if (isPrime) primes += p\n            p += 2\n        }\n        primes(n.toInt - 1)",
    "        var p = 1L\n        var c = 0L\n        while (c < n) {\n            p += 2\n            if (BigInt(p).isProbablePrime(10)) {\n                var q = p - 1\n                while (q % 2 == 0) q /= 2\n                if (BigInt(q).isProbablePrime(10)) c += 1\n            }\n        }\n        p",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) i += 1\n        }\n        p",
    "        val primes = new ArrayBuffer[Long]();\n        primes += 2;\n        primes += 3;\n        primes += 5;\n        primes += 7;\n        primes += 11;\n        primes += 13;\n        primes += 17;\n        primes += 19;\n        primes += 23;\n        primes += 29;\n        primes += 31;\n        primes += 37;\n        primes += 41;\n        primes += 43;\n        primes += 47;\n        primes += 53;\n        primes += 59;\n        primes += 61;\n        primes += 67;\n        primes += 71;\n        primes += 73;\n        primes += 79;\n        primes += 83;\n        primes += 89;\n        primes += 97;\n        primes += 101;\n        primes += 103;\n        primes += 107;\n        primes += 109;\n        primes += 113;\n        primes += 127;\n        primes += 131;\n        primes += 137;\n        primes += 139;\n        primes += 149;\n        primes += 151;\n        primes += 157;\n        primes += 163;\n        primes += 167;\n        primes += 173;\n        primes += 179;\n        primes += 181;\n        primes += 191;\n        primes += 193;\n        primes += 197;\n        primes += 199;\n        primes += 211;\n        primes += 223;\n        primes += 227;\n        primes += 229;\n        primes += 233;\n        primes += 239;\n        primes += 241;\n        primes += 251;\n        primes += 257;\n        primes += 263;\n        primes += 269;\n        primes += 271;\n        primes += 277;\n        primes += 281;\n        primes += 283;\n        primes += 293;\n        primes += 307;\n        primes += 311;\n        primes += 313;\n        primes += 317;\n        primes += 331;\n        primes += 337;\n        primes += 347;\n        primes += 349;\n        primes += 353;\n       ",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) i += 1\n        }\n        p",
    "        val primes = new ArrayBuffer[Long]\n        primes += 2\n        primes += 3\n        primes += 5\n        primes += 7\n        primes += 11\n        primes += 13\n        primes += 17\n        primes += 19\n        primes += 23\n        primes += 29\n        primes += 31\n        primes += 37\n        primes += 41\n        primes += 43\n        primes += 47\n        primes += 53\n        primes += 59\n        primes += 61\n        primes += 67\n        primes += 71\n        primes += 73\n        primes += 79\n        primes += 83\n        primes += 89\n        primes += 97\n        primes += 101\n        primes += 103\n        primes += 107\n        primes += 109\n        primes += 113\n        primes += 127\n        primes += 131\n        primes += 137\n        primes += 139\n        primes += 149\n        primes += 151\n        primes += 157\n        primes += 163\n        primes += 167\n        primes += 173\n        primes += 179\n        primes += 181\n        primes += 191\n        primes += 193\n        primes += 197\n        primes += 199\n        primes += 211\n        primes += 223\n        primes += 227\n        primes += 229\n        primes += 233\n        primes += 239\n        primes += 241\n        primes += 251\n        primes += 257\n        primes += 263\n        primes += 269\n        primes += 271\n        primes += 277\n        primes += 281\n        primes += 283\n        primes += 293\n        primes += 307\n        primes += 311\n        primes += 313\n        primes += 317\n        primes += 331\n        primes += 337\n        primes += 347\n        primes += 349\n        primes += 353\n        primes += 359\n        primes += 367\n        primes += 373\n        primes += 379\n        primes += 383\n        primes += 389\n        primes += 397\n        primes += 401\n        primes += 409\n        primes += 419\n        primes += 421\n        primes += 431",
    "        val primes = new ArrayBuffer[Long]();\n        primes += 2;\n        primes += 3;\n        primes += 5;\n        var i = 7;\n        while (primes.length < n) {\n            if (primes.forall(p => i % p != 0)) {\n                primes += i;\n            }\n            i += 2;\n        }\n        primes(n.toInt - 1);",
    "        var p = 2L;\n        var i = 0L;\n        while (i < n) {\n            p = nextPrime(p);\n            if (p % 4 == 3) i += 1;\n        }\n        return p;",
    "        var p = 2L; var i = 1L\n        while (i < n) {\n            p = nextPrime(p); i += 1\n        }\n        p",
    "        var count = 0L\n        var i = 2L\n        while (count < n) {\n            if (isPrime(i) && isPrime(2 * i + 1)) count += 1\n            i += 1\n        }\n        i - 1",
    "        def isPrime(n : Long) : Boolean = {\n            if (n == 2) return true\n            if (n % 2 == 0) return false\n            for (i <- 3L to sqrt(n).toLong by 2) {\n                if (n % i == 0) return false\n            }\n            return true\n        }\n        var count = 0L\n        var i = 2L\n        while (count < n) {\n            if (isPrime(i)) {\n                count += 1\n                if (count == n) return i\n            }\n            i += 1\n        }\n        return -1",
    "        var i = 0;\n        var p = 2;\n        while (i < n) {\n            p = nextPrime(p);\n            if (p % 4 == 3) {\n                i += 1;\n            }\n        }\n        return p;",
    "        val primes = new ArrayBuffer[Long]\n        primes += 2\n        primes += 3\n        var i = 1\n        while (primes.length < n) {\n            val p = 6 * i + 1\n            if (isPrime(p)) primes += p\n            val q = 6 * i + 5\n            if (isPrime(q)) primes += q\n            i += 1\n        }\n        primes.last",
    "        val primes = new ArrayBuffer[Long](); primes += 2; primes += 3\n        def isPrime(n : Long) : Boolean = {\n            val limit = sqrt(n).toLong\n            primes.takeWhile(_ <= limit).forall(n % _ != 0)\n        }\n        def nextPrime(n : Long) : Long = {\n            var p = n + 2; while (!isPrime(p)) { p += 2 }; p\n        }\n        def nextNewmanPrime(n : Long) : Long = {\n            var p = n + 2; while (!isPrime(p) || !isPrime((p - 1) / 2)) { p += 2 }; p\n        }\n        var p = primes.last; while (primes.length < n) { p = nextNewmanPrime(p); primes += p }\n        primes(n.toInt - 1)",
    "        var p = 1L\n        var i = 0L\n        while (i < n) {\n            p += 2 * p + 1\n            if (BigInt(p).isProbablePrime(10)) i += 1\n        }\n        p",
    "        var p = 0L\n        var i = 0L\n        while (i < n) {\n            p += 2 * i + 1\n            i += 1\n        }\n        return p",
    "        var p = 2L\n        var count = 0L\n        while (count < n) {\n            if (isPrime(p)) {\n                val q = (p - 1) / 2\n                if (isPrime(q)) {\n                    count += 1\n                }\n            }\n            p += 1\n        }\n        p - 1",
    "        var p = 2L; var i = 1L\n        while (i < n) {\n            p = nextPrime(p)\n            i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        def isPrime(n : Long) : Boolean = {\n            if (n <= 1) return false\n            if (n == 2) return true\n            if (n % 2 == 0) return false\n            for (i <- 3 to sqrt(n).toInt by 2) {\n                if (n % i == 0) return false\n            }\n            return true\n        }\n        var i = 1\n        var count = 0\n        while (count < n) {\n            i += 2\n            if (isPrime(i) && isPrime((i - 1) / 2)) count += 1\n        }\n        return i",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        return p",
    "        var count = 0L\n        var i = 2L\n        while (count < n) {\n            if (isPrime(i)) {\n                if (isPrime(2 * i + 1)) {\n                    count += 1\n                    if (count == n) return i\n                }\n            }\n            i += 1\n        }\n        return -1",
    "        var count = 0L\n        var i = 1L\n        while (count < n) {\n            i += 1\n            if (BigInt(2).modPow(i, i) == 2 && BigInt(2).modPow(i - 1, i) != 1) count += 1\n        }\n        i",
    "        var p = 2L;\n        var i = 1L;\n        while (i <= n) {\n            p = nextPrime(p);\n            i += 1;\n        }\n        return p;",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextPrime(p)\n            if (isPrime(p * 2 + 1)) i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) i += 1\n        }\n        p",
    "        var count = 0L\n        var i = 1L\n        while (count < n) {\n            i += 2\n            if (BigInt(i).isProbablePrime(100)) {\n                count += 1\n                if (count == n) return i\n            }\n        }\n        return -1",
    "        var primes = new ListBuffer[Long]();\n        primes += 2;\n        primes += 3;\n        primes += 5;\n        primes += 7;\n        primes += 11;\n        primes += 13;\n        primes += 17;\n        primes += 19;\n        primes += 23;\n        primes += 29;\n        primes += 31;\n        primes += 37;\n        primes += 41;\n        primes += 43;\n        primes += 47;\n        primes += 53;\n        primes += 59;\n        primes += 61;\n        primes += 67;\n        primes += 71;\n        primes += 73;\n        primes += 79;\n        primes += 83;\n        primes += 89;\n        primes += 97;\n        primes += 101;\n        primes += 103;\n        primes += 107;\n        primes += 109;\n        primes += 113;\n        primes += 127;\n        primes += 131;\n        primes += 137;\n        primes += 139;\n        primes += 149;\n        primes += 151;\n        primes += 157;\n        primes += 163;\n        primes += 167;\n        primes += 173;\n        primes += 179;\n        primes += 181;\n        primes += 191;\n        primes += 193;\n        primes += 197;\n        primes += 199;\n        primes += 211;\n        primes += 223;\n        primes += 227;\n        primes += 229;\n        primes += 233;\n        primes += 239;\n        primes += 241;\n        primes += 251;\n        primes += 257;\n        primes += 263;\n        primes += 269;\n        primes += 271;\n        primes += 277;\n        primes += 281;\n        primes += 283;\n        primes += 293;\n        primes += 307;\n        primes += 311;\n        primes += 313;\n        primes += 317;\n        primes += 331;\n        primes += 337;\n        primes += 347;\n        primes += 349;\n        primes += 353;\n       ",
    "        var p = 2L\n        var i = 1L\n        while (i <= n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) i += 1\n        }\n        p",
    "        var count = 0L\n        var i = 0L\n        while (count < n) {\n            i += 1\n            if (isNewmanPrime(i)) count += 1\n        }\n        i",
    "        var p = 1L\n        var i = 0L\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) {\n                i += 1\n            }\n        }\n        p",
    "        var primes = new ArrayBuffer[Long]();\n        primes += 2;\n        primes += 3;\n        primes += 5;\n        primes += 7;\n        primes += 13;\n        primes += 17;\n        primes += 37;\n        primes += 73;\n        primes += 97;\n        primes += 193;\n        primes += 241;\n        primes += 257;\n        primes += 449;\n        primes += 577;\n        primes += 641;\n        primes += 673;\n        primes += 769;\n        primes += 929;\n        primes += 1153;\n        primes += 1217;\n        primes += 1409;\n        primes += 1433;\n        primes += 1489;\n        primes += 1601;\n        primes += 2113;\n        primes += 2177;\n        primes += 2309;\n        primes += 2393;\n        primes += 2417;\n        primes += 2689;\n        primes += 2753;\n        primes += 2833;\n        primes += 3073;\n        primes += 3137;\n        primes += 3457;\n        primes += 3529;\n        primes += 3553;\n        primes += 3713;\n        primes += 3841;\n        primes += 4129;\n        primes += 4481;\n        primes += 4609;\n        primes += 4993;\n        primes += 5041;\n        primes += 5153;\n        primes += 5441;\n        primes += 5569;\n        primes += 5633;\n        primes += 5761;\n        primes += 5857;\n        primes += 6177;\n        primes += 6273;\n        primes += 6401;\n        primes += 6593;\n        primes += 6689;\n        primes += 6833;\n        primes += 7057;\n        primes += 7169;\n        primes += 7297;\n        primes += 7393;\n        primes += 7537;\n        primes += 7649;\n        primes += 7793;\n        primes += 79",
    "        val primes = new ArrayBuffer[Long]\n        primes += 2\n        primes += 3\n        var i = 1\n        while (primes.length < n) {\n            val p = 6 * i + 1\n            if (isPrime(p)) primes += p\n            val q = 6 * i - 1\n            if (isPrime(q)) primes += q\n            i += 1\n        }\n        primes.last",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        val primes = new ArrayBuffer[Long]\n        primes += 2\n        primes += 3\n        var i = 2\n        while (primes.size < n) {\n            val p = primes(i - 1)\n            val q = primes(i - 2)\n            val candidate = p * p - q * q\n            if (isPrime(candidate)) {\n                primes += candidate\n                i += 1\n            }\n        }\n        primes(n - 1)",
    "        var p = 1L\n        var i = 0L\n        while (i < n) {\n            p = p + 1\n            if (isPrime(p) && isPrime((p - 1) / 2)) i = i + 1\n        }\n        p",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        return p",
    "        var count = 0L\n        var i = 1L\n        while (count < n) {\n            i += 2\n            if (BigInt(i).isProbablePrime(1)) {\n                val p = (i - 1) / 2\n                if (BigInt(p).isProbablePrime(1)) count += 1\n            }\n        }\n        i",
    "        val primes = new ArrayBuffer[Long]\n        primes += 2\n        primes += 3\n        primes += 5\n        primes += 7\n        var i = 0\n        var p = 11\n        while (i < n) {\n            var isPrime = true\n            for (prime <- primes) {\n                if (p % prime == 0) {\n                    isPrime = false\n                    break\n                }\n            }\n            if (isPrime) {\n                primes += p\n                i += 1\n            }\n            p += 2\n        }\n        primes(n.toInt - 1)",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = p * 2 + 1\n            if (BigInt(p).isProbablePrime(10)) i += 1\n        }\n        p",
    "        var p = 1L\n        var i = 0L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 5 == 1 || p % 5 == 4) i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        return p",
    "        var primes = new ArrayBuffer[Long]();\n        primes += 2;\n        primes += 3;\n        primes += 5;\n        primes += 7;\n        primes += 11;\n        primes += 13;\n        primes += 17;\n        primes += 19;\n        primes += 23;\n        primes += 29;\n        primes += 31;\n        primes += 37;\n        primes += 41;\n        primes += 43;\n        primes += 47;\n        primes += 53;\n        primes += 59;\n        primes += 61;\n        primes += 67;\n        primes += 71;\n        primes += 73;\n        primes += 79;\n        primes += 83;\n        primes += 89;\n        primes += 97;\n        primes += 101;\n        primes += 103;\n        primes += 107;\n        primes += 109;\n        primes += 113;\n        primes += 127;\n        primes += 131;\n        primes += 137;\n        primes += 139;\n        primes += 149;\n        primes += 151;\n        primes += 157;\n        primes += 163;\n        primes += 167;\n        primes += 173;\n        primes += 179;\n        primes += 181;\n        primes += 191;\n        primes += 193;\n        primes += 197;\n        primes += 199;\n        primes += 211;\n        primes += 223;\n        primes += 227;\n        primes += 229;\n        primes += 233;\n        primes += 239;\n        primes += 241;\n        primes += 251;\n        primes += 257;\n        primes += 263;\n        primes += 269;\n        primes += 271;\n        primes += 277;\n        primes += 281;\n        primes += 283;\n        primes += 293;\n        primes += 307;\n        primes += 311;\n        primes += 313;\n        primes += 317;\n        primes += 331;\n        primes += 337;\n        primes += 347;\n        primes += 349;\n        primes += 353;\n       ",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        val primes = new ArrayBuffer[Long]\n        primes += 2\n        var p = 3\n        while (primes.length < n) {\n            var isPrime = true\n            for (i <- 0 until primes.length) {\n                if (p % primes(i) == 0) {\n                    isPrime = false\n                    break\n                }\n            }\n            if (isPrime) {\n                primes += p\n            }\n            p += 2\n        }\n        primes(n.toInt - 1)",
    "        var count = 0L\n        var i = 2L\n        while (count < n) {\n            if (isPrime(i) && isPrime(2 * i + 1)) count += 1\n            i += 1\n        }\n        i - 1",
    "        var p = 2L\n        var count = 0L\n        while (count < n) {\n            p = nextNewmanPrime(p)\n            count += 1\n        }\n        return p",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        return p",
    "        var p = 2L\n        var count = 0L\n        while (count < n) {\n            p = nextNewmanPrime(p)\n            count += 1\n        }\n        return p",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) i += 1\n        }\n        p",
    "        var i = 1L\n        var count = 0L\n        while (count < n) {\n            i += 2\n            if (BigInt(i).isProbablePrime(10)) {\n                count += 1\n            }\n        }\n        return i",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        return p",
    "        var p = 2L;\n        var count = 0L;\n        while (count < n) {\n            p = nextPrime(p);\n            if (isNewmanPrime(p)) count += 1;\n        }\n        return p;",
    "        val primes = new ArrayBuffer[Long]();\n        primes += 2;\n        primes += 3;\n        primes += 5;\n        primes += 7;\n        primes += 11;\n        primes += 13;\n        primes += 17;\n        primes += 19;\n        primes += 23;\n        primes += 29;\n        primes += 31;\n        primes += 37;\n        primes += 41;\n        primes += 43;\n        primes += 47;\n        primes += 53;\n        primes += 59;\n        primes += 61;\n        primes += 67;\n        primes += 71;\n        primes += 73;\n        primes += 79;\n        primes += 83;\n        primes += 89;\n        primes += 97;\n        primes += 101;\n        primes += 103;\n        primes += 107;\n        primes += 109;\n        primes += 113;\n        primes += 127;\n        primes += 131;\n        primes += 137;\n        primes += 139;\n        primes += 149;\n        primes += 151;\n        primes += 157;\n        primes += 163;\n        primes += 167;\n        primes += 173;\n        primes += 179;\n        primes += 181;\n        primes += 191;\n        primes += 193;\n        primes += 197;\n        primes += 199;\n        primes += 211;\n        primes += 223;\n        primes += 227;\n        primes += 229;\n        primes += 233;\n        primes += 239;\n        primes += 241;\n        primes += 251;\n        primes += 257;\n        primes += 263;\n        primes += 269;\n        primes += 271;\n        primes += 277;\n        primes += 281;\n        primes += 283;\n        primes += 293;\n        primes += 307;\n        primes += 311;\n        primes += 313;\n        primes += 317;\n        primes += 331;\n        primes += 337;\n        primes += 347;\n        primes += 349;\n        primes += 353;\n       ",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        var primes = new ArrayBuffer[Long]();\n        primes += 2;\n        primes += 3;\n        primes += 5;\n        primes += 7;\n        var i = 11;\n        while (primes.length < n) {\n            var isPrime = true;\n            for (prime <- primes) {\n                if (i % prime == 0) {\n                    isPrime = false;\n                    break;\n                }\n            }\n            if (isPrime) primes += i;\n            i += 2;\n        }\n        return primes(n.toInt - 1);",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = nextPrime(p)\n            i += 1\n        }\n        p",
    "        var p = 2L;\n        var i = 1L;\n        while (i < n) {\n            p = nextPrime(p);\n            if (p % 5 == 1) i += 1;\n        }\n        return p;",
    "        val primes = ArrayBuffer[Long](2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201",
    "        var count = 0L\n        var i = 2L\n        while (count < n) {\n            if (isPrime(i) && isPrime(2 * i + 1)) count += 1\n            i += 1\n        }\n        i - 1",
    "        var p = 2L;\n        var i = 1L;\n        while (i <= n) {\n            p = nextPrime(p);\n            if (p % 5 == 1) i += 1;\n        }\n        return p;",
    "        def isPrime(n : Long) : Boolean = {\n            if (n == 1) return false\n            if (n == 2) return true\n            if (n % 2 == 0) return false\n            for (i <- 3 to sqrt(n).toInt by 2) {\n                if (n % i == 0) return false\n            }\n            return true\n        }\n        var count = 0\n        var i = 1\n        while (count < n) {\n            i += 2\n            if (isPrime(i) && isPrime((i - 1) / 2)) count += 1\n        }\n        return i",
    "        var p = 2L\n        var count = 0L\n        while (count < n) {\n            p = nextNewmanPrime(p)\n            count += 1\n        }\n        p",
    "        var p = 2L;\n        var i = 1L;\n        while (i < n) {\n            p = nextNewmanPrime(p);\n            i += 1;\n        }\n        return p;",
    "        var p = 1L\n        var i = 1L\n        while (i <= n) {\n            p += 2 * p + 1\n            if (BigInt(p).isProbablePrime(10)) i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = nextPrime(p)\n            i += 1\n        }\n        p",
    "        def isPrime(n : Long) = {\n            if (n <= 1) false\n            else if (n == 2) true\n            else !(2 to (sqrt(n).toInt + 1)).exists(x => n % x == 0)\n        }\n        def isNewmanPrime(n : Long) = {\n            if (n <= 1) false\n            else if (n == 2) true\n            else if (n % 2 == 0) false\n            else {\n                val m = n - 1\n                val s = m.toBinaryString.reverse.indexOf('1')\n                val d = m / pow(2, s).toLong\n                !(2 to (sqrt(n).toInt + 1)).exists(a => {\n                    val x = pow(a, d).toLong % n\n                    x == 1 || (1 to s).exists(r => x == pow(2, r).toLong % n)\n                })\n            }\n        }\n        def newmanPrimeRec(n : Long, i : Long) : Long = {\n            if (n == 1) i\n            else if (isNewmanPrime(i)) newmanPrimeRec(n - 1, i + 1)\n            else newmanPrimeRec(n, i + 1)\n        }\n        newmanPrimeRec(n, 1)",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        def isPrime(n : Long) : Boolean = {\n            if (n <= 1) return false\n            if (n == 2) return true\n            if (n % 2 == 0) return false\n            for (i <- 3 to sqrt(n).toInt by 2) {\n                if (n % i == 0) return false\n            }\n            return true\n        }\n        var count = 0\n        var i = 1\n        while (count < n) {\n            i += 2\n            if (isPrime(i) && isPrime((i - 1) / 2)) count += 1\n        }\n        return i",
    "        val primes = new ArrayBuffer[Long]();\n        primes += 2;\n        primes += 3;\n        primes += 5;\n        primes += 7;\n        primes += 11;\n        primes += 13;\n        primes += 17;\n        primes += 19;\n        primes += 23;\n        primes += 29;\n        primes += 31;\n        primes += 37;\n        primes += 41;\n        primes += 43;\n        primes += 47;\n        primes += 53;\n        primes += 59;\n        primes += 61;\n        primes += 67;\n        primes += 71;\n        primes += 73;\n        primes += 79;\n        primes += 83;\n        primes += 89;\n        primes += 97;\n        primes += 101;\n        primes += 103;\n        primes += 107;\n        primes += 109;\n        primes += 113;\n        primes += 127;\n        primes += 131;\n        primes += 137;\n        primes += 139;\n        primes += 149;\n        primes += 151;\n        primes += 157;\n        primes += 163;\n        primes += 167;\n        primes += 173;\n        primes += 179;\n        primes += 181;\n        primes += 191;\n        primes += 193;\n        primes += 197;\n        primes += 199;\n        primes += 211;\n        primes += 223;\n        primes += 227;\n        primes += 229;\n        primes += 233;\n        primes += 239;\n        primes += 241;\n        primes += 251;\n        primes += 257;\n        primes += 263;\n        primes += 269;\n        primes += 271;\n        primes += 277;\n        primes += 281;\n        primes += 283;\n        primes += 293;\n        primes += 307;\n        primes += 311;\n        primes += 313;\n        primes += 317;\n        primes += 331;\n        primes += 337;\n        primes += 347;\n        primes += 349;\n        primes += 353;\n       ",
    "        var count = 0L\n        var i = 2L\n        while (count < n) {\n            if (isPrime(i)) {\n                count += 1\n                if (count == n) return i\n            }\n            i += 1\n        }\n        return -1",
    "        var p = 1L\n        var count = 0L\n        while (count < n) {\n            p += 2\n            if (isPrime(p) && isPrime((p - 1) / 2)) count += 1\n        }\n        return p",
    "        var i = 0L\n        var p = 2L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        return p",
    "        var p = 1L\n        var i = 0L\n        while (i < n) {\n            p += 2 * p + 1\n            if (BigInt(p).isProbablePrime(10)) i += 1\n        }\n        p",
    "        var i = 0L\n        var p = 2L\n        while (i < n) {\n            p = nextPrime(p)\n            i += 1\n        }\n        p",
    "        var i = 0L;\n        var p = 2L;\n        while (i < n) {\n            p = nextPrime(p);\n            if (p % 4 == 3) i += 1;\n        }\n        return p;",
    "        val primes = new ArrayBuffer[Long]\n        primes += 2\n        primes += 3\n        var i = 0\n        while (primes.length < n) {\n            val p = primes(i)\n            val q = primes(i + 1)\n            val r = q * q - p * p\n            val s = 2 * p * q\n            val t = 2 * p * r\n            val u = 2 * q * r\n            val v = 2 * p * s\n            val w = 2 * q * s\n            val x = 2 * p * t\n            val y = 2 * q * t\n            val z = 2 * p * u\n            val a = 2 * q * u\n            val b = 2 * p * v\n            val c = 2 * q * v\n            val d = 2 * p * w\n            val e = 2 * q * w\n            val f = 2 * p * x\n            val g = 2 * q * x\n            val h = 2 * p * y\n            val j = 2 * q * y\n            val k = 2 * p * z\n            val l = 2 * q * z\n            val m = 2 * p * a\n            val o = 2 * q * a\n            val p1 = 2 * p * b\n            val q1 = 2 * q * b\n            val r1 = 2 * p * c\n            val s1 = 2 * q * c\n            val t1 = 2 * p * d\n            val u1 = 2 * q * d\n            val v1 = 2 * p * e\n            val w1 = 2 * q * e\n            val x1 = 2 * p * f\n            val y1 = 2 * q * f\n            val z1 = 2 * p * g\n            val a1 = 2 * q * g\n            val b1 = 2 * p * h\n            val c1 = 2 * q * h\n            val d1 = 2 * p * j\n            val e1 = 2 * q * j\n            val f1 = 2 * p * k\n            val g1 = 2 * q * k\n            val h1 = 2 * p * l\n            val j1 = 2 * q * l\n            val k1 =",
    "        var p = 2L;\n        var i = 1L;\n        while (i < n) {\n            p = nextNewmanPrime(p);\n            i += 1;\n        }\n        return p;",
    "        var p = 2L\n        var count = 0L\n        while (count < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) count += 1\n        }\n        p",
    "        var p = 2L\n        var c = 0L\n        while (c < n) {\n            p = nextPrime(p)\n            val q = (p - 1) / 2\n            if (isPrime(q)) c += 1\n        }\n        p",
    "        def isPrime(n : Long) : Boolean = {\n            if (n <= 1) return false\n            if (n == 2) return true\n            if (n % 2 == 0) return false\n            for (i <- 3 to sqrt(n).toInt by 2) {\n                if (n % i == 0) return false\n            }\n            return true\n        }\n        var count = 0\n        var i = 1\n        while (count < n) {\n            i += 2\n            if (isPrime(i)) {\n                var j = 1\n                while (j <= i) {\n                    if (isPrime(i - j)) {\n                        count += 1\n                        if (count == n) return i\n                    }\n                    j += 1\n                }\n            }\n        }\n        return -1",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        val primes = new ListBuffer[Long]\n        primes += 2\n        primes += 3\n        var i = 5\n        while (primes.size < n) {\n            var isPrime = true\n            for (p <- primes) {\n                if (p * p > i) break\n                if (i % p == 0) {\n                    isPrime = false\n                    break\n                }\n            }\n            if (isPrime) primes += i\n            i += 2\n        }\n        primes(n.toInt - 1)",
    "        var count = 0L\n        var i = 2L\n        while (count < n) {\n            if (isPrime(i)) {\n                count += 1\n                if (count == n) return i\n            }\n            i += 1\n        }\n        return 0",
    "        var p = 2L;\n        var i = 0L;\n        while (i < n) {\n            p = nextNewmanPrime(p);\n            i += 1;\n        }\n        return p;",
    "        val primes = new ArrayBuffer[Long]\n        primes += 2\n        primes += 3\n        var i = 4\n        while (primes.length < n) {\n            if (i % 2 == 0 || i % 3 == 0) {\n                i += 1\n                continue\n            }\n            var isPrime = true\n            for (p <- primes) {\n                if (p * p > i) break\n                if (i % p == 0) {\n                    isPrime = false\n                    break\n                }\n            }\n            if (isPrime) primes += i\n            i += 1\n        }\n        primes(n.toInt - 1)",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 0\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) i += 1\n        }\n        p",
    "        var count = 0L\n        var i = 2L\n        while (count < n) {\n            if (isPrime(i) && isPrime(2 * i + 1)) count += 1\n            i += 1\n        }\n        i - 1",
    "        var p = 1L\n        var i = 0L\n        while (i < n) {\n            p = p + 1\n            if (p % 2 == 0) {\n                if (p % 3 == 0) {\n                    if (p % 5 == 0) {\n                        if (p % 7 == 0) {\n                            if (p % 11 == 0) {\n                                if (p % 13 == 0) {\n                                    if (p % 17 == 0) {\n                                        if (p % 19 == 0) {\n                                            if (p % 23 == 0) {\n                                                if (p % 29 == 0) {\n                                                    if (p % 31 == 0) {\n                                                        if (p % 37 == 0) {\n                                                            if (p % 41 == 0) {\n                                                                if (p % 43 == 0) {\n                                                                    if (p % 47 == 0) {\n                                                                        if (p % 53 == 0) {\n                                                                            if (p % 59 == 0) {\n                                                                                if (p % 61 == 0) {\n                                                                                    if (p % 67 == 0) {\n                                                                                        if (p % 71 == 0) {\n                                                                                            if (p % 73 == 0) {\n                                                                                                if (p % 79 == 0) {\n                                                                                                    if (p % 83 == 0) {\n                                                                                                        if (p % 89 == 0) {\n                                                                                                            if (p % 97 == 0) {\n                                                                                                                if (p % 101 == 0) {\n                                                                                                                    if (p % 103 == 0) {\n                                                                                                                        if (p % 107 == 0) {\n                                                                                                                            if (p % 109 == 0) {\n                                                                                                                                if (p % 113 == 0) {\n                                                                                                                                    if (p % 127 == 0) {\n                                                                                                                                        if (p % 131 == 0) {\n                                                                                                                                            if (p % 137 == 0)",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        var p = 2L;\n        var i = 0L;\n        while (i < n) {\n            p = nextPrime(p);\n            if (p % 5 == 3) {\n                i += 1;\n            }\n        }\n        return p;",
    "        var p = 2L\n        var count = 0L\n        while (count < n) {\n            p = nextPrime(p)\n            if (isNewmanPrime(p)) count += 1\n        }\n        p",
    "        var p = 2L\n        var count = 0L\n        while (count < n) {\n            p = nextPrime(p)\n            if (isNewmanPrime(p)) count += 1\n        }\n        p",
    "        var count = 0L\n        var i = 1L\n        while (count < n) {\n            i += 2\n            if (BigInt(i).isProbablePrime(10)) count += 1\n        }\n        i",
    "        var p = 2L\n        var count = 0\n        while (count < n) {\n            p = nextPrime(p)\n            if (isNewmanPrime(p)) count += 1\n        }\n        p",
    "        var p = 1L\n        var i = 1L\n        while (i <= n) {\n            p += 2 * i + 1\n            if (BigInt(p).isProbablePrime(10)) i += 1\n        }\n        p",
    "        var count = 0L\n        var i = 2L\n        while (count < n) {\n            if (isPrime(i) && isPrime(2 * i + 1)) count += 1\n            i += 1\n        }\n        i - 1",
    "        var i = 0; var p = 2L; var q = 2L; var r = 2L\n        while (i < n) {\n            p = 6 * i + 1; q = 6 * i + 5; r = 6 * i + 7\n            if (BigInt(p).isProbablePrime(10)) i += 1\n            if (BigInt(q).isProbablePrime(10)) i += 1\n            if (BigInt(r).isProbablePrime(10)) i += 1\n        }\n        if (BigInt(p).isProbablePrime(10)) p\n        else if (BigInt(q).isProbablePrime(10)) q\n        else r",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) i += 1\n        }\n        p",
    "        val primes = new ArrayBuffer[Long]();\n        primes += 2;\n        primes += 3;\n        primes += 5;\n        primes += 7;\n        primes += 11;\n        primes += 13;\n        primes += 17;\n        primes += 19;\n        primes += 23;\n        primes += 29;\n        primes += 31;\n        primes += 37;\n        primes += 41;\n        primes += 43;\n        primes += 47;\n        primes += 53;\n        primes += 59;\n        primes += 61;\n        primes += 67;\n        primes += 71;\n        primes += 73;\n        primes += 79;\n        primes += 83;\n        primes += 89;\n        primes += 97;\n        primes += 101;\n        primes += 103;\n        primes += 107;\n        primes += 109;\n        primes += 113;\n        primes += 127;\n        primes += 131;\n        primes += 137;\n        primes += 139;\n        primes += 149;\n        primes += 151;\n        primes += 157;\n        primes += 163;\n        primes += 167;\n        primes += 173;\n        primes += 179;\n        primes += 181;\n        primes += 191;\n        primes += 193;\n        primes += 197;\n        primes += 199;\n        primes += 211;\n        primes += 223;\n        primes += 227;\n        primes += 229;\n        primes += 233;\n        primes += 239;\n        primes += 241;\n        primes += 251;\n        primes += 257;\n        primes += 263;\n        primes += 269;\n        primes += 271;\n        primes += 277;\n        primes += 281;\n        primes += 283;\n        primes += 293;\n        primes += 307;\n        primes += 311;\n        primes += 313;\n        primes += 317;\n        primes += 331;\n        primes += 337;\n        primes += 347;\n        primes += 349;\n        primes += 353;\n       ",
    "        var count = 0L\n        var i = 0L\n        while (count < n) {\n            i += 1\n            if (isPrime(i) && isPrime(2 * i + 1)) count += 1\n        }\n        2 * i + 1",
    "        val primes = new ArrayBuffer[Long](); primes += 2; primes += 3; primes += 5; primes += 7; primes += 11; primes += 13; primes += 17; primes += 19; primes += 23; primes += 29; primes += 31; primes += 37; primes += 41; primes += 43; primes += 47; primes += 53; primes += 59; primes += 61; primes += 67; primes += 71; primes += 73; primes += 79; primes += 83; primes += 89; primes += 97; primes += 101; primes += 103; primes += 107; primes += 109; primes += 113; primes += 127; primes += 131; primes += 137; primes += 139; primes += 149; primes += 151; primes += 157; primes += 163; primes += 167; primes += 173; primes += 179; primes += 181; primes += 191; primes += 193; primes += 197; primes += 199; primes += 211; primes += 223; primes += 227; primes += 229; primes += 233; primes += 239; primes += 241; primes += 251; primes += 257; primes += 263; primes += 269; primes += 271; primes += 277; primes += 281; primes += 283; primes += 293; primes += 307; primes += 311; primes += 313; primes += 317; primes += 331; primes += 337; primes += 347; primes += 349; primes += 353; primes += 359; primes += 367; primes += 373; primes += 379; primes += 383; primes += 389; primes += 397; primes += 401; primes += 409; primes += 419; primes += 421; primes += 431; primes += 433; primes += 439; primes += 443; primes += 449; primes += 457; primes += 461; primes += 463; primes += 467; primes += 479; primes += 487; primes += 491; primes += 499; primes += 503; primes += 509; primes +=",
    "        var primes = new ArrayBuffer[Long]()\n        primes += 2\n        primes += 3\n        primes += 5\n        primes += 7\n        primes += 11\n        primes += 13\n        primes += 17\n        primes += 19\n        primes += 23\n        primes += 29\n        primes += 31\n        primes += 37\n        primes += 41\n        primes += 43\n        primes += 47\n        primes += 53\n        primes += 59\n        primes += 61\n        primes += 67\n        primes += 71\n        primes += 73\n        primes += 79\n        primes += 83\n        primes += 89\n        primes += 97\n        primes += 101\n        primes += 103\n        primes += 107\n        primes += 109\n        primes += 113\n        primes += 127\n        primes += 131\n        primes += 137\n        primes += 139\n        primes += 149\n        primes += 151\n        primes += 157\n        primes += 163\n        primes += 167\n        primes += 173\n        primes += 179\n        primes += 181\n        primes += 191\n        primes += 193\n        primes += 197\n        primes += 199\n        primes += 211\n        primes += 223\n        primes += 227\n        primes += 229\n        primes += 233\n        primes += 239\n        primes += 241\n        primes += 251\n        primes += 257\n        primes += 263\n        primes += 269\n        primes += 271\n        primes += 277\n        primes += 281\n        primes += 283\n        primes += 293\n        primes += 307\n        primes += 311\n        primes += 313\n        primes += 317\n        primes += 331\n        primes += 337\n        primes += 347\n        primes += 349\n        primes += 353\n        primes += 359\n        primes += 367\n        primes += 373\n        primes += 379\n        primes += 383\n        primes += 389\n        primes += 397\n        primes += 401\n        primes += 409\n        primes += 419\n        primes += 421\n        primes += 4",
    "        var count = 0L\n        var i = 0L\n        while (count < n) {\n            i += 1\n            if (isPrime(i) && isPrime(2 * i + 1)) count += 1\n        }\n        2 * i + 1",
    "        var p = 1L\n        var i = 1L\n        while (i <= n) {\n            p += 2 * p + 1\n            if (BigInt(p).isProbablePrime(10)) i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        var result = 0L\n        var i = 1L\n        while (result < n) {\n            i += 1\n            if (BigInt(i).isProbablePrime(10)) {\n                val p = i\n                var j = 1L\n                var flag = true\n                while (flag && j < p) {\n                    if (BigInt(j).isProbablePrime(10)) {\n                        val q = j\n                        val k = (p - 1) / q\n                        if (BigInt(k).isProbablePrime(10)) {\n                            val r = k\n                            val a = (p - 1) / (q * r)\n                            if (BigInt(a).isProbablePrime(10)) {\n                                val b = a\n                                val c = (p - 1) / (q * r * b)\n                                if (BigInt(c).isProbablePrime(10)) {\n                                    val d = c\n                                    val e = (p - 1) / (q * r * b * d)\n                                    if (BigInt(e).isProbablePrime(10)) {\n                                        val f = e\n                                        val g = (p - 1) / (q * r * b * d * f)\n                                        if (BigInt(g).isProbablePrime(10)) {\n                                            val h = g\n                                            val i = (p - 1) / (q * r * b * d * f * h)\n                                            if (BigInt(i).isProbablePrime(10)) {\n                                                val j = i\n                                                val k = (p - 1) / (q * r * b * d * f * h * j)\n                                                if (BigInt(k).isProbablePrime(10)) {\n                                                    val l = k\n                                                    val m = (p - 1) / (q * r * b * d * f * h * j * l)\n                                                    if (BigInt(m).isProbablePrime(10)) {\n                                                        val n = m\n                                                        val o = (p - 1) / (q * r * b * d * f * h * j * l * n)",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextPrime(p)\n            if (isPrime(p - 2)) i += 1\n        }\n        p",
    "        var p = 2L\n        var count = 0L\n        while (count < n) {\n            p = nextPrime(p)\n            if (isNewmanPrime(p)) count += 1\n        }\n        p",
    "        var p = 2L\n        var count = 0L\n        while (count < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) count += 1\n        }\n        p",
    "        var count = 0L\n        var i = 1L\n        while (count < n) {\n            i += 1\n            if (isPrime(i) && isPrime((i - 1) / 2)) count += 1\n        }\n        i",
    "        var primes = new ListBuffer[Long]();\n        var i = 1;\n        while (primes.length < n) {\n            i += 1;\n            if (isPrime(i)) {\n                primes += i;\n            }\n        }\n        primes.last;",
    "        var count = 0L\n        var i = 2L\n        while (count < n) {\n            if (isPrime(i) && isPrime(2 * i + 1)) count += 1\n            i += 1\n        }\n        i - 1",
    "        val primes = new ArrayBuffer[Long]\n        primes += 2\n        primes += 3\n        var i = 1\n        while (primes.length < n) {\n            val p = primes(i)\n            val q = primes(i - 1)\n            val next = p + q - 1\n            if (BigInt(next).isProbablePrime(10)) primes += next\n            i += 1\n        }\n        primes(n - 1)",
    "        val primes = new ArrayBuffer[Long]();\n        primes += 2;\n        primes += 3;\n        var i = 4;\n        while (primes.length < n) {\n            var isPrime = true;\n            for (p <- primes) {\n                if (i % p == 0) {\n                    isPrime = false;\n                    break;\n                }\n            }\n            if (isPrime) {\n                primes += i;\n            }\n            i += 1;\n        }\n        return primes(n.toInt - 1);",
    "        var count = 0L\n        var i = 1L\n        while (count < n) {\n            i += 2\n            if (BigInt(i).isProbablePrime(100)) {\n                val p = (i - 1) / 2\n                if (BigInt(p).isProbablePrime(100)) {\n                    val q = (i + 1) / 2\n                    if (BigInt(q).isProbablePrime(100)) {\n                        count += 1\n                    }\n                }\n            }\n        }\n        i",
    "        var i = 1L\n        var p = 2L\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) i += 1\n        }\n        return p",
    "        var count = 0L\n        var i = 1L\n        while (count < n) {\n            i += 2\n            if (BigInt(i).isProbablePrime(100)) count += 1\n        }\n        i",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        return p",
    "        var count = 0L\n        var i = 1L\n        while (count < n) {\n            i += 1\n            if (BigInt(i).isProbablePrime(100)) {\n                val p = (i - 1) / 2\n                val q = (i + 1) / 2\n                if (BigInt(p).isProbablePrime(100) && BigInt(q).isProbablePrime(100)) count += 1\n            }\n        }\n        i",
    "        var i = 0\n        var p = 2L\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) i += 1\n        }\n        p",
    "        var p = 2L\n        var count = 0L\n        while (count < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) count += 1\n        }\n        p",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        val primes = new ArrayBuffer[Long]\n        primes += 2\n        primes += 3\n        var i = 5\n        while (primes.length < n) {\n            if (primes.forall(i % _ != 0)) primes += i\n            i += 2\n        }\n        primes.last",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = nextPrime(p)\n            i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) i += 1\n        }\n        return p",
    "        var p = 2L\n        var count = 0L\n        while (count < n) {\n            p = nextPrime(p)\n            if (isNewmanPrime(p)) count += 1\n        }\n        p",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        def isPrime(n : Long) : Boolean = {\n            if (n < 2) return false\n            if (n == 2 || n == 3) return true\n            if (n % 2 == 0 || n % 3 == 0) return false\n            var i = 5\n            while (i * i <= n) {\n                if (n % i == 0 || n % (i + 2) == 0) return false\n                i += 6\n            }\n            return true\n        }\n        def isNewmanPrime(n : Long) : Boolean = {\n            if (n % 2 == 0) return false\n            if (n % 3 == 0) return false\n            var i = 5\n            while (i * i <= n) {\n                if (n % i == 0 || n % (i + 2) == 0) return false\n                i += 6\n            }\n            return true\n        }\n        var count = 0\n        var i = 1\n        while (count < n) {\n            if (isNewmanPrime(i)) count += 1\n            i += 2\n        }\n        return i - 2",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) i += 1\n        }\n        p",
    "        val primes = new ArrayBuffer[Long]\n        primes += 2\n        primes += 3\n        var i = 5\n        while (primes.length < n) {\n            var isPrime = true\n            for (p <- primes) {\n                if (p > sqrt(i)) {\n                    isPrime = true\n                    break\n                }\n                if (i % p == 0) {\n                    isPrime = false\n                    break\n                }\n            }\n            if (isPrime) primes += i\n            i += 2\n        }\n        primes(n.toInt - 1)",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = nextPrime(p)\n            i += 1\n        }\n        return p",
    "        def isPrime(n : Long) : Boolean = {\n            if (n <= 1) return false\n            if (n == 2) return true\n            if (n % 2 == 0) return false\n            for (i <- 3 to sqrt(n).toInt by 2) {\n                if (n % i == 0) return false\n            }\n            return true\n        }\n        def isNewmanPrime(n : Long) : Boolean = {\n            if (n % 2 == 0) return false\n            val m = n - 1\n            val s = m.toBinaryString.length - 1\n            val d = m / pow(2, s).toLong\n            var a = 2\n            while (isPrime(a) == false || pow(a, d) % n == 1) {\n                a += 1\n            }\n            return pow(a, d) % n == n - 1\n        }\n        var count = 0\n        var i = 1\n        while (count < n) {\n            i += 1\n            if (isNewmanPrime(i)) count += 1\n        }\n        return i",
    "        var count = 0L\n        var i = 1L\n        while (count < n) {\n            i += 2\n            if (BigInt(i).isProbablePrime(10)) {\n                val p = (i - 1) / 2\n                if (BigInt(p).isProbablePrime(10)) {\n                    val q = (i + 1) / 2\n                    if (BigInt(q).isProbablePrime(10)) {\n                        count += 1\n                    }\n                }\n            }\n        }\n        i",
    "        var p = 1L\n        var i = 1L\n        while (i <= n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        return p",
    "        var c = 0\n        var i = 2L\n        while (c < n) {\n            if (isPrime(i)) {\n                val j = (i - 1) / 2\n                if (isPrime(j)) c += 1\n            }\n            i += 1\n        }\n        i - 1",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        return p",
    "        var p = 2L\n        var i = 0L\n        while (i < n) {\n            p = nextPrime(p)\n            if (p % 4 == 3) i += 1\n        }\n        p",
    "        var p = 2L\n        var i = 1L\n        while (i < n) {\n            p = p + 2 * (p - 1)\n            i += 1\n        }\n        p",
    "        var p = 2L\n        var count = 0L\n        while (count < n) {\n            p = nextPrime(p)\n            if (isNewmanPrime(p)) count += 1\n        }\n        return p",
    "        var count = 0L\n        var i = 2L\n        while (count < n) {\n            if (isPrime(i) && isPrime(2 * i + 1)) count += 1\n            i += 1\n        }\n        i - 1",
    "        var p = 2L\n        var count = 0L\n        while (count < n) {\n            p = nextPrime(p)\n            if (isNewmanPrime(p)) count += 1\n        }\n        p",
    "        var count = 0L\n        var i = 1L\n        while (count < n) {\n            i += 2\n            if (BigInt(i).isProbablePrime(10)) {\n                val p = (i - 1) / 2\n                if (BigInt(p).isProbablePrime(10)) {\n                    val q = (i + 1) / 2\n                    if (BigInt(q).isProbablePrime(10)) {\n                        count += 1\n                    }\n                }\n            }\n        }\n        i",
    "        var p = 1L\n        var i = 1L\n        while (i <= n) {\n            p = nextNewmanPrime(p)\n            i += 1\n        }\n        p"
  ]
}