{
  "name": "mbpp_129_magic_square_test",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to calculate whether the matrix is a magic square.\n    def magicSquareTest(my_matrix : List[List[Long]]) : Boolean = {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_129_magic_square_test.py",
  "prompt_terminology": "reworded",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(magicSquareTest((List[List[Long]](List[Long](7l.toLong, 12l.toLong, 1l.toLong, 14l.toLong), List[Long](2l.toLong, 13l.toLong, 8l.toLong, 11l.toLong), List[Long](16l.toLong, 3l.toLong, 10l.toLong, 5l.toLong), List[Long](9l.toLong, 6l.toLong, 15l.toLong, 4l.toLong)))) == (true));\n    assert(magicSquareTest((List[List[Long]](List[Long](2l.toLong, 7l.toLong, 6l.toLong), List[Long](9l.toLong, 5l.toLong, 1l.toLong), List[Long](4l.toLong, 3l.toLong, 8l.toLong)))) == (true));\n    assert(magicSquareTest((List[List[Long]](List[Long](2l.toLong, 7l.toLong, 6l.toLong), List[Long](9l.toLong, 5l.toLong, 1l.toLong), List[Long](4l.toLong, 3l.toLong, 7l.toLong)))) == (false));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val diag2 = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val all_sums = row_sums ++ col_sums ++ List(diag1, diag2)\n        all_sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_row = my_matrix.map(x => x.sum).toSet\n        val sum_col = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum).toSet\n        val sum_diag = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - x._2 - 1)).sum)\n        if (sum_row.size == 1 && sum_col.size == 1 && sum_diag.toSet.size == 1 && sum_row.head == sum_col.head && sum_col.head == sum_diag.head) true else false",
    "        val n = my_matrix.length\n        val magic_constant = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == magic_constant)",
    "        // Check if the matrix is a square matrix.\n        if (my_matrix.length != my_matrix(0).length) return false\n        // Check if the matrix is a magic square.\n        val n = my_matrix.length\n        val sum = my_matrix.flatten.sum\n        for (i <- 0 until n) {\n            if (my_matrix(i).sum != sum) return false\n            if (my_matrix.map(x => x(i)).sum != sum) return false\n        }\n        if (my_matrix.indices.map(i => my_matrix(i)(i)).sum != sum) return false\n        if (my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum != sum) return false\n        true",
    "        val n = my_matrix.length\n        val magic_constant = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_constant)",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 to n - 1).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(row_with_index => row_with_index._1(row_with_index._2)).sum, my_matrix.zipWithIndex.map(row_with_index => row_with_index._1(n - row_with_index._2 - 1)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - x._2 - 1)).sum)\n        if (row_sums.forall(_ == sum) && col_sums.forall(_ == sum) && diag_sums.forall(_ == sum)) true else false",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_col = (0 until n).map(i => (0 until m).map(j => my_matrix(j)(i)).sum).sum\n        val sum_diag = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        if (sum != sum_col || sum != sum_diag || sum != sum_diag2) return false\n        return true",
    "        val n = my_matrix.length\n        val magic_number = (n * (n * n + 1)) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(col => (0 until n).map(row => my_matrix(row)(col)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - x._2 - 1)).sum)\n        row_sums.forall(_ == sum) && col_sums.forall(_ == sum) && diag_sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val magic_constant = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(col => (0 until n).map(row => my_matrix(row)(col)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(sum => sum == magic_constant)",
    "        val n = my_matrix.length\n        val magic_constant = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(t => t._1(t._2)).sum, my_matrix.zipWithIndex.map(t => t._1(n - t._2 - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_constant)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_rows = my_matrix.map(_.sum)\n        val sum_cols = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val sum_diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        sum_rows.forall(_ == sum) && sum_cols.forall(_ == sum) && sum_diag1 == sum && sum_diag2 == sum",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_diag_1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag_2 = (0 until n).map(i => my_matrix(n - 1 - i)(i)).sum\n        val sum_col = (0 until n).map(i => my_matrix.map(_(i)).sum).sum\n        val sum_row = my_matrix.map(_.sum).sum\n        if (sum == sum_diag_1 && sum == sum_diag_2 && sum == sum_col && sum == sum_row) true else false",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val my_matrix_t = my_matrix.transpose\n        val my_matrix_d1 = (0 until n).map(i => my_matrix(i)(i)).toList\n        val my_matrix_d2 = (0 until n).map(i => my_matrix(i)(n - 1 - i)).toList\n        val my_matrix_d = my_matrix_d1 ::: my_matrix_d2\n        val my_matrix_l = my_matrix ::: my_matrix_t ::: my_matrix_d\n        my_matrix_l.forall(x => x.sum == sum)",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == magic_number)",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(row_i => row_i._1(row_i._2)).sum, my_matrix.zipWithIndex.map(row_i => row_i._1(n - 1 - row_i._2)).sum)\n        val sum_set = row_sums.toSet ++ col_sums.toSet ++ diag_sums.toSet\n        sum_set.size == 1 && sum_set.head == magic_number",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val rows = my_matrix.map(_.sum)\n        val cols = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val diag2 = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        val all = rows ++ cols ++ List(diag1, diag2)\n        all.forall(_ == sum)"
  ]
}