{
  "name": "mbpp_129_magic_square_test",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to calculate whether the matrix is a magic square.\n    def magicSquareTest(my_matrix : List[List[Long]]) : Boolean = {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_129_magic_square_test.py",
  "prompt_terminology": "reworded",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(magicSquareTest((List[List[Long]](List[Long](7l.toLong, 12l.toLong, 1l.toLong, 14l.toLong), List[Long](2l.toLong, 13l.toLong, 8l.toLong, 11l.toLong), List[Long](16l.toLong, 3l.toLong, 10l.toLong, 5l.toLong), List[Long](9l.toLong, 6l.toLong, 15l.toLong, 4l.toLong)))) == (true));\n    assert(magicSquareTest((List[List[Long]](List[Long](2l.toLong, 7l.toLong, 6l.toLong), List[Long](9l.toLong, 5l.toLong, 1l.toLong), List[Long](4l.toLong, 3l.toLong, 8l.toLong)))) == (true));\n    assert(magicSquareTest((List[List[Long]](List[Long](2l.toLong, 7l.toLong, 6l.toLong), List[Long](9l.toLong, 5l.toLong, 1l.toLong), List[Long](4l.toLong, 3l.toLong, 7l.toLong)))) == (false));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val diag2 = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val all_sums = row_sums ++ col_sums ++ List(diag1, diag2)\n        all_sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_row = my_matrix.map(x => x.sum).toSet\n        val sum_col = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum).toSet\n        val sum_diag = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - x._2 - 1)).sum)\n        if (sum_row.size == 1 && sum_col.size == 1 && sum_diag.toSet.size == 1 && sum_row.head == sum_col.head && sum_col.head == sum_diag.head) true else false",
    "        val n = my_matrix.length\n        val magic_constant = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == magic_constant)",
    "        // Check if the matrix is a square matrix.\n        if (my_matrix.length != my_matrix(0).length) return false\n        // Check if the matrix is a magic square.\n        val n = my_matrix.length\n        val sum = my_matrix.flatten.sum\n        for (i <- 0 until n) {\n            if (my_matrix(i).sum != sum) return false\n            if (my_matrix.map(x => x(i)).sum != sum) return false\n        }\n        if (my_matrix.indices.map(i => my_matrix(i)(i)).sum != sum) return false\n        if (my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum != sum) return false\n        true",
    "        val n = my_matrix.length\n        val magic_constant = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_constant)",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 to n - 1).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(row_with_index => row_with_index._1(row_with_index._2)).sum, my_matrix.zipWithIndex.map(row_with_index => row_with_index._1(n - row_with_index._2 - 1)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - x._2 - 1)).sum)\n        if (row_sums.forall(_ == sum) && col_sums.forall(_ == sum) && diag_sums.forall(_ == sum)) true else false",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_col = (0 until n).map(i => (0 until m).map(j => my_matrix(j)(i)).sum).sum\n        val sum_diag = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        if (sum != sum_col || sum != sum_diag || sum != sum_diag2) return false\n        return true",
    "        val n = my_matrix.length\n        val magic_number = (n * (n * n + 1)) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(col => (0 until n).map(row => my_matrix(row)(col)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - x._2 - 1)).sum)\n        row_sums.forall(_ == sum) && col_sums.forall(_ == sum) && diag_sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val magic_constant = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(col => (0 until n).map(row => my_matrix(row)(col)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(sum => sum == magic_constant)",
    "        val n = my_matrix.length\n        val magic_constant = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(t => t._1(t._2)).sum, my_matrix.zipWithIndex.map(t => t._1(n - t._2 - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_constant)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_rows = my_matrix.map(_.sum)\n        val sum_cols = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val sum_diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        sum_rows.forall(_ == sum) && sum_cols.forall(_ == sum) && sum_diag1 == sum && sum_diag2 == sum",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_diag_1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag_2 = (0 until n).map(i => my_matrix(n - 1 - i)(i)).sum\n        val sum_col = (0 until n).map(i => my_matrix.map(_(i)).sum).sum\n        val sum_row = my_matrix.map(_.sum).sum\n        if (sum == sum_diag_1 && sum == sum_diag_2 && sum == sum_col && sum == sum_row) true else false",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val my_matrix_t = my_matrix.transpose\n        val my_matrix_d1 = (0 until n).map(i => my_matrix(i)(i)).toList\n        val my_matrix_d2 = (0 until n).map(i => my_matrix(i)(n - 1 - i)).toList\n        val my_matrix_d = my_matrix_d1 ::: my_matrix_d2\n        val my_matrix_l = my_matrix ::: my_matrix_t ::: my_matrix_d\n        my_matrix_l.forall(x => x.sum == sum)",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == magic_number)",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(row_i => row_i._1(row_i._2)).sum, my_matrix.zipWithIndex.map(row_i => row_i._1(n - 1 - row_i._2)).sum)\n        val sum_set = row_sums.toSet ++ col_sums.toSet ++ diag_sums.toSet\n        sum_set.size == 1 && sum_set.head == magic_number",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val rows = my_matrix.map(_.sum)\n        val cols = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val diag2 = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        val all = rows ++ cols ++ List(diag1, diag2)\n        all.forall(_ == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val rows = my_matrix.map(_.sum)\n        val cols = my_matrix.transpose.map(_.sum)\n        val diag1 = my_matrix.indices.map(i => my_matrix(i)(i)).sum\n        val diag2 = my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum\n        (rows ++ cols ++ List(diag1, diag2)).forall(_ == sum)",
    "        // Check if the matrix is a square matrix.\n        if (my_matrix.length != my_matrix(0).length) return false\n        // Check if the matrix is a magic square.\n        val n = my_matrix.length\n        val sum = (1 to n).sum\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(x => (0 until n).map(y => my_matrix(y)(x)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        if (row_sums.forall(x => x == sum) && col_sums.forall(x => x == sum) && diag_sums.forall(x => x == sum)) return true\n        return false",
    "        val n = my_matrix.size\n        val sum = my_matrix.map(_.sum).sum\n        val magic_constant = n * (n * n + 1) / 2\n        if (sum != magic_constant) return false\n        for (i <- 0 until n) {\n            if (my_matrix(i).sum != magic_constant) return false\n            var sum = 0L\n            for (j <- 0 until n) sum += my_matrix(j)(i)\n            if (sum != magic_constant) return false\n        }\n        var sum = 0L\n        for (i <- 0 until n) sum += my_matrix(i)(i)\n        if (sum != magic_constant) return false\n        sum = 0L\n        for (i <- 0 until n) sum += my_matrix(i)(n - 1 - i)\n        if (sum != magic_constant) return false\n        true",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.flatten.sum\n        val sum_row = my_matrix.map(x => x.sum).toSet\n        val sum_col = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum).toSet\n        val sum_diag = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_anti_diag = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        sum_row.size == 1 && sum_col.size == 1 && sum_row.head == sum_col.head && sum_row.head == sum_diag && sum_row.head == sum_anti_diag",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        row_sums.forall(x => x == sum) && col_sums.forall(x => x == sum) && diag_sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_diag = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        val sum_rows = (0 until n).map(i => my_matrix(i).sum).toSet\n        val sum_cols = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum).toSet\n        return sum_rows.size == 1 && sum_cols.size == 1 && sum_rows.contains(sum) && sum_cols.contains(sum) && sum_diag == sum && sum_diag2 == sum",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val diagonal_sum = (0 until n).map(x => my_matrix(x)(x)).sum\n        val anti_diagonal_sum = (0 until n).map(x => my_matrix(x)(n - 1 - x)).sum\n        val row_sum = my_matrix.map(x => x.sum).toSet\n        val column_sum = (0 until n).map(x => my_matrix.map(y => y(x)).sum).toSet\n        if (sum == diagonal_sum && sum == anti_diagonal_sum && row_sum.size == 1 && column_sum.size == 1) true else false",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        val sum_cols = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum).toList\n        val sum_rows = my_matrix.map(_.sum)\n        if (sum_diag1 != sum || sum_diag2 != sum || sum_cols.exists(_ != sum) || sum_rows.exists(_ != sum)) false\n        else true",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(col => my_matrix.map(row => row(col)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        if (n != m) return false\n        val magic_sum = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        return sums.forall(sum => sum == magic_sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        val sum_rows = my_matrix.map(x => x.sum).toSet\n        val sum_cols = (0 until n).map(i => my_matrix.map(x => x(i)).sum).toSet\n        if (sum_rows.size == 1 && sum_cols.size == 1 && sum_rows.head == sum_cols.head && sum_rows.head == sum_diag1 && sum_rows.head == sum_diag2) true else false",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val diag_sums = (0 until n).map(i => my_matrix(i)(i)).sum :: (0 until n).map(i => my_matrix(i)(n - i - 1)).sum :: Nil\n        val sums = row_sums ::: col_sums ::: diag_sums\n        sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        row_sums.forall(x => x == sum) && col_sums.forall(x => x == sum) && diag_sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_row = my_matrix.map(_.sum)\n        val sum_col = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val sum_diag = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_anti_diag = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        sum_row.forall(_ == sum) && sum_col.forall(_ == sum) && sum_diag == sum && sum_anti_diag == sum",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(col => my_matrix.map(row => row(col)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(_ == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_diagonal = my_matrix.zipWithIndex.map(x => x._1(x._2)).sum\n        val sum_diagonal2 = my_matrix.zipWithIndex.map(x => x._1(n - x._2 - 1)).sum\n        val sum_columns = my_matrix.transpose.map(_.sum).sum\n        val sum_rows = my_matrix.map(_.sum).sum\n        if (sum == sum_diagonal && sum == sum_diagonal2 && sum == sum_columns && sum == sum_rows) true else false",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(row_with_index => row_with_index._1(row_with_index._2)).sum, my_matrix.zipWithIndex.map(row_with_index => row_with_index._1(n - row_with_index._2 - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        if (n != m) return false\n        val sum = my_matrix.map(x => x.sum).sum / n\n        for (i <- 0 until n) {\n            if (my_matrix(i).sum != sum) return false\n            if (my_matrix.map(x => x(i)).sum != sum) return false\n        }\n        if (my_matrix.map(x => x(x.length - 1 - my_matrix.indexOf(x))).sum != sum) return false\n        if (my_matrix.map(x => x(my_matrix.indexOf(x))).sum != sum) return false\n        true",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(col => my_matrix.map(row => row(col)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - x._2 - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - x._2 - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        if (n != m) return false\n        val sum = my_matrix.map(_.sum).sum / n\n        for (i <- 0 until n) {\n            if (my_matrix(i).sum != sum) return false\n            if (my_matrix.map(_(i)).sum != sum) return false\n        }\n        if (my_matrix.zipWithIndex.map(x => x._1(x._2)).sum != sum) return false\n        if (my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum != sum) return false\n        return true",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_row = my_matrix.map(x => x.sum)\n        val sum_col = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val sum_diag = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        if (sum_row.forall(x => x == sum) && sum_col.forall(x => x == sum) && sum_diag.forall(x => x == sum)) true else false",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_row = my_matrix.map(x => x.sum)\n        val sum_col = my_matrix.transpose.map(x => x.sum)\n        val sum_diag = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val sum_list = sum_row ::: sum_col ::: sum_diag\n        sum_list.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sum = (0 until n).map(i => my_matrix(i)(i)).sum\n        val anti_diag_sum = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        row_sums.forall(x => x == sum) && col_sums.forall(x => x == sum) && diag_sum == sum && anti_diag_sum == sum",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(col => (0 until n).map(row => my_matrix(row)(col)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(x => x == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)), my_matrix.zipWithIndex.map(x => x._1(n - x._2 - 1))).map(_.sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(row => row._1(row._2)).sum, my_matrix.zipWithIndex.map(row => row._1(n - 1 - row._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val rows = my_matrix.map(x => x.sum)\n        val cols = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val diag2 = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        rows.forall(x => x == sum) && cols.forall(x => x == sum) && diag1 == sum && diag2 == sum",
    "        val n = my_matrix.length\n        val magic_sum = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = my_matrix.transpose.map(col => col.sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_sum)",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_diag = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        val sum_row = (0 until n).map(i => my_matrix(i).sum).toSet\n        val sum_col = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum).toSet\n        if (sum_row.size == 1 && sum_col.size == 1 && sum_row.head == sum_col.head && sum_row.head == sum_diag && sum_row.head == sum_diag2) true else false",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_row = my_matrix.map(_.sum)\n        val sum_col = (0 until m).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val sum_diag = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sum_list = sum_row ++ sum_col ++ sum_diag\n        sum_list.forall(_ == sum)",
    "        val sum = my_matrix.map(_.sum).sum\n        val n = my_matrix.length\n        val diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val diag2 = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        return (sum == diag1 && sum == diag2 && row_sums.forall(_ == sum) && col_sums.forall(_ == sum))",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        val sum_rows = my_matrix.map(_.sum)\n        val sum_cols = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        sum_diag1 == sum && sum_diag2 == sum && sum_rows.forall(_ == sum) && sum_cols.forall(_ == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        if (n != m) return false\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == magic_number)",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        if (n != m) return false\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - x._2 - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        row_sums.forall(_ == sum) && col_sums.forall(_ == sum) && diag_sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        if (n != m) return false\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_row = my_matrix.map(x => x.sum)\n        val sum_col = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val sum_diag = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_anti_diag = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        if (sum_row.forall(x => x == sum) && sum_col.forall(x => x == sum) && sum_diag == sum && sum_anti_diag == sum) true else false",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val magic_constant = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(sum => sum == magic_constant)",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        row_sums.forall(_ == magic_number) && col_sums.forall(_ == magic_number) && diag_sums.forall(_ == magic_number)",
    "        val n = my_matrix.length\n        val magic_sum = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_sum)",
    "        var sum = 0L\n        for (i <- 0 until my_matrix.length) {\n            sum += my_matrix(i)(i)\n        }\n        for (i <- 0 until my_matrix.length) {\n            var sum2 = 0L\n            for (j <- 0 until my_matrix.length) {\n                sum2 += my_matrix(i)(j)\n            }\n            if (sum2 != sum) return false\n        }\n        for (j <- 0 until my_matrix.length) {\n            var sum2 = 0L\n            for (i <- 0 until my_matrix.length) {\n                sum2 += my_matrix(i)(j)\n            }\n            if (sum2 != sum) return false\n        }\n        return true",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_diagonal = my_matrix.zipWithIndex.map(x => x._1(x._2)).sum\n        val sum_anti_diagonal = my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum\n        val sum_row = my_matrix.map(_.sum).toSet\n        val sum_column = my_matrix.transpose.map(_.sum).toSet\n        sum_row.size == 1 && sum_column.size == 1 && sum_row.contains(sum) && sum_column.contains(sum) && sum_diagonal == sum && sum_anti_diagonal == sum",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(row_i => row_i._1(row_i._2)).sum, my_matrix.zipWithIndex.map(row_i => row_i._1(n - row_i._2 - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_diag1 = my_matrix.zipWithIndex.map(x => x._1(x._2)).sum\n        val sum_diag2 = my_matrix.zipWithIndex.map(x => x._1(n - x._2 - 1)).sum\n        val sum_row = my_matrix.map(x => x.sum).toSet.size == 1\n        val sum_col = my_matrix.transpose.map(x => x.sum).toSet.size == 1\n        val sum_diag = sum_diag1 == sum_diag2\n        val sum_all = sum_row && sum_col && sum_diag\n        sum_all && sum_diag1 == sum",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_row = my_matrix.map(_.sum)\n        val sum_col = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val sum_diag = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        if (sum_row.forall(_ == sum) && sum_col.forall(_ == sum) && sum_diag.forall(_ == sum)) true else false",
    "        val n = my_matrix.length\n        val magic_constant = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - x._2 - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(_ == magic_constant)",
    "        val n = my_matrix.size\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - x._2 - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        row_sums.forall(_ == sum) && col_sums.forall(_ == sum) && diag_sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        if (n != m) return false\n        val sum = my_matrix.map(x => x.sum).sum / n\n        for (i <- 0 until n) {\n            if (my_matrix(i).sum != sum) return false\n            if (my_matrix.map(x => x(i)).sum != sum) return false\n        }\n        if (my_matrix.map(x => x(x.length - 1 - x.indexOf(x.head))).sum != sum) return false\n        return true",
    "        val n = my_matrix.length\n        val sum_row = my_matrix.map(x => x.sum).toSet\n        val sum_col = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum).toSet\n        val sum_diag = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - x._2 - 1)).sum)\n        val sum_all = sum_row ++ sum_col ++ sum_diag\n        sum_all.size == 1",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_diag_1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag_2 = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        val sum_row = (0 until n).map(i => my_matrix(i).sum).toSet\n        val sum_col = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum).toSet\n        sum_row.size == 1 && sum_col.size == 1 && sum_row.head == sum_col.head && sum_row.head == sum && sum_diag_1 == sum && sum_diag_2 == sum",
    "        val n = my_matrix.length\n        val magic_sum = n * (n * n + 1) / 2\n        var sum_diag1 = 0L\n        var sum_diag2 = 0L\n        for (i <- 0 until n) {\n            var sum_row = 0L\n            var sum_col = 0L\n            for (j <- 0 until n) {\n                sum_row += my_matrix(i)(j)\n                sum_col += my_matrix(j)(i)\n            }\n            if (sum_row != magic_sum || sum_col != magic_sum) return false\n            sum_diag1 += my_matrix(i)(i)\n            sum_diag2 += my_matrix(i)(n - i - 1)\n        }\n        if (sum_diag1 != magic_sum || sum_diag2 != magic_sum) return false\n        return true",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val diagonal1 = (0 until n).map(x => my_matrix(x)(x)).sum\n        val diagonal2 = (0 until n).map(x => my_matrix(x)(n - x - 1)).sum\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(x => my_matrix.map(y => y(x)).sum)\n        if (sum == diagonal1 && sum == diagonal2 && row_sums.forall(x => x == sum) && col_sums.forall(x => x == sum)) true else false",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(row_with_index => row_with_index._1(row_with_index._2)).sum, my_matrix.zipWithIndex.map(row_with_index => row_with_index._1(n - 1 - row_with_index._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val diag1 = (0 until n).map(x => my_matrix(x)(x)).sum\n        val diag2 = (0 until n).map(x => my_matrix(x)(n - 1 - x)).sum\n        val cols = (0 until n).map(x => (0 until n).map(y => my_matrix(y)(x)).sum).toList\n        val rows = my_matrix.map(x => x.sum)\n        val all = rows ++ cols ++ List(diag1, diag2)\n        all.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        (row_sums.forall(x => x == sum) && col_sums.forall(x => x == sum) && diag_sums.forall(x => x == sum))",
    "        val n = my_matrix.length\n        val magic_sum = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_sum)",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val sum_row = my_matrix.map(x => x.sum).toSet.size == 1\n        val sum_col = (0 until n).map(i => (0 until m).map(j => my_matrix(j)(i)).sum).toSet.size == 1\n        val sum_diag = (0 until n).map(i => my_matrix(i)(i)).sum == sum && (0 until n).map(i => my_matrix(i)(n - i - 1)).sum == sum\n        sum_row && sum_col && sum_diag",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(row_i => row_i._1(row_i._2)).sum, my_matrix.zipWithIndex.map(row_i => row_i._1(n - row_i._2 - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_diag_1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag_2 = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        val sum_row = (0 until n).map(i => my_matrix(i).sum).toSet\n        val sum_col = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum).toSet\n        if (sum_row.size == 1 && sum_col.size == 1 && sum_row.head == sum_col.head && sum_diag_1 == sum && sum_diag_2 == sum) true else false",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(x => x == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val diagonal_sum = my_matrix.zipWithIndex.map(x => x._1(x._2)).sum\n        val anti_diagonal_sum = my_matrix.zipWithIndex.map(x => x._1(n - x._2 - 1)).sum\n        val row_sums = my_matrix.map(_.sum)\n        val column_sums = my_matrix.transpose.map(_.sum)\n        if (sum == diagonal_sum && sum == anti_diagonal_sum && row_sums.forall(_ == sum) && column_sums.forall(_ == sum)) true else false",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        if (row_sums.forall(_ == sum) && col_sums.forall(_ == sum) && diag_sums.forall(_ == sum)) true else false",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val sum_diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        val sum_row = my_matrix.map(x => x.sum).toSet\n        val sum_col = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum).toSet\n        sum_row.size == 1 && sum_col.size == 1 && sum_row.contains(sum) && sum_col.contains(sum) && sum_diag1 == sum && sum_diag2 == sum",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_row = my_matrix.map(_.sum).toSet\n        val sum_col = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum).toSet\n        val sum_diag = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        if (sum_row.size == 1 && sum_col.size == 1 && sum_diag.size == 1 && sum_row.head == sum_col.head && sum_col.head == sum_diag.head) true else false",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_diag = my_matrix.zipWithIndex.map(x => x._1(x._2)).sum\n        val sum_diag_rev = my_matrix.zipWithIndex.map(x => x._1(n - x._2 - 1)).sum\n        val sum_row = my_matrix.map(_.sum).toSet\n        val sum_col = my_matrix.transpose.map(_.sum).toSet\n        if (sum_row.size == 1 && sum_col.size == 1 && sum_row.head == sum_col.head && sum_row.head == sum_diag && sum_row.head == sum_diag_rev) true else false",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        if (n != m) return false\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_row = my_matrix.map(x => x.sum)\n        val sum_col = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val sum_diag = List(my_matrix.map(x => x(x.length - 1 - my_matrix.indexOf(x))).sum, my_matrix.map(x => x(my_matrix.indexOf(x))).sum)\n        if (sum_row.forall(x => x == sum) && sum_col.forall(x => x == sum) && sum_diag.forall(x => x == sum)) true else false",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        (row_sums ++ col_sums ++ diag_sums).forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val diag2 = (0 until n).map(i => my_matrix(n - 1 - i)(i)).sum\n        val row_sums = (0 until n).map(i => my_matrix(i).sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        return (sum == diag1 && sum == diag2 && row_sums.forall(_ == sum) && col_sums.forall(_ == sum))",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val diag2 = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        if (sum == diag1 && sum == diag2 && row_sums.forall(x => x == sum) && col_sums.forall(x => x == sum)) true else false",
    "        val n = my_matrix.length\n        val magic_constant = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.map(row => row(row.indices.last - row.indexOf(row.last))).sum, my_matrix.map(row => row(row.indexOf(row.last))).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(sum => sum == magic_constant)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val row_sum = my_matrix.map(x => x.sum).toSet\n        val col_sum = my_matrix.transpose.map(x => x.sum).toSet\n        val diag_sum = List(my_matrix.indices.map(x => my_matrix(x)(x)).sum, my_matrix.indices.map(x => my_matrix(x)(n - 1 - x)).sum)\n        val all_sum = row_sum ++ col_sum ++ diag_sum\n        return all_sum.size == 1",
    "        val n = my_matrix.length\n        val sum = my_matrix.flatten.sum\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(\n            (0 until n).map(i => my_matrix(i)(i)).sum,\n            (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        )\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val diag_sum = (0 until n).map(x => my_matrix(x)(x)).sum\n        val rev_diag_sum = (0 until n).map(x => my_matrix(x)(n - 1 - x)).sum\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(x => (0 until n).map(y => my_matrix(y)(x)).sum)\n        if (diag_sum != sum || rev_diag_sum != sum || row_sums.contains(sum) == false || col_sums.contains(sum) == false) false else true",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.map(x => x(x.length - 1 - x.indexOf(x.last))).sum, my_matrix.map(x => x(x.indexOf(x.last))).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val diagonal1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val diagonal2 = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        if (sum != diagonal1 || sum != diagonal2) return false\n        for (i <- 0 until n) {\n            val row_sum = my_matrix(i).sum\n            if (row_sum != sum) return false\n            val column_sum = (0 until n).map(j => my_matrix(j)(i)).sum\n            if (column_sum != sum) return false\n        }\n        return true",
    "        val n = my_matrix.length\n        val magic_constant = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_constant)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val magic_constant = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_constant)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_row = my_matrix.map(x => x.sum).toSet\n        val sum_col = (0 until n).map(i => my_matrix.map(x => x(i)).sum).toSet\n        val sum_diag = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_anti_diag = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        if (sum_row.size == 1 && sum_col.size == 1 && sum_diag == sum && sum_anti_diag == sum) true else false",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = my_matrix.transpose.map(_.sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val sum_rows = my_matrix.map(x => x.sum)\n        val sum_cols = (0 until n).map(x => my_matrix.map(y => y(x)).sum)\n        val sum_diag1 = (0 until n).map(x => my_matrix(x)(x)).sum\n        val sum_diag2 = (0 until n).map(x => my_matrix(x)(n - 1 - x)).sum\n        val sum_list = List(sum_rows, sum_cols, List(sum_diag1, sum_diag2))\n        sum_list.forall(x => x.forall(y => y == sum))",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag1_sum = (0 until n).map(i => my_matrix(i)(i)).sum\n        val diag2_sum = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        row_sums.forall(sum => sum == magic_number) && col_sums.forall(sum => sum == magic_number) && diag1_sum == magic_number && diag2_sum == magic_number",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val rows = my_matrix.map(x => x.sum)\n        val cols = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val diag2 = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        val sums = rows ++ cols ++ List(diag1, diag2)\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val magic_constant = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(row_with_index => row_with_index._1(row_with_index._2)).sum, my_matrix.zipWithIndex.map(row_with_index => row_with_index._1(n - row_with_index._2 - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_constant)",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        if (n != m) return false\n        val sum = my_matrix.map(_.sum).sum\n        if (sum % n != 0) return false\n        val magic_sum = sum / n\n        for (i <- 0 until n) {\n            if (my_matrix(i).sum != magic_sum) return false\n            if (my_matrix.map(_(i)).sum != magic_sum) return false\n        }\n        if (my_matrix.indices.map(i => my_matrix(i)(i)).sum != magic_sum) return false\n        if (my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum != magic_sum) return false\n        true",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        val sum_row = (0 until n).map(i => my_matrix(i).sum).toSet\n        val sum_col = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum).toSet\n        sum_row.size == 1 && sum_col.size == 1 && sum_row.head == sum_col.head && sum_row.head == sum && sum_diag1 == sum && sum_diag2 == sum",
    "        val n = my_matrix.length\n        val magic_sum = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == magic_sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        if (n != m) return false\n        val sum = my_matrix.map(x => x.sum).sum / n\n        for (i <- 0 until n) {\n            if (my_matrix(i).sum != sum) return false\n            if (my_matrix.map(x => x(i)).sum != sum) return false\n        }\n        if (my_matrix.map(x => x(x.length - 1 - my_matrix.indexOf(x))).sum != sum) return false\n        true",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(x => my_matrix.map(y => y(x)).sum)\n        val diag_sums = List(my_matrix.indices.map(x => my_matrix(x)(x)).sum, my_matrix.indices.map(x => my_matrix(x)(n - 1 - x)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        val sum_row = (0 until n).map(i => my_matrix(i).sum).toSet\n        val sum_col = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum).toSet\n        sum_row.size == 1 && sum_col.size == 1 && sum_row.head == sum && sum_col.head == sum && sum_diag1 == sum && sum_diag2 == sum",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - x._2 - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val magic_constant = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(row => row._1(row._2)).sum, my_matrix.zipWithIndex.map(row => row._1(n - 1 - row._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_constant)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val diag1 = my_matrix.indices.map(i => my_matrix(i)(i)).sum\n        val diag2 = my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum\n        val rows = my_matrix.map(x => x.sum)\n        val cols = my_matrix.indices.map(i => my_matrix.map(x => x(i)).sum)\n        if (diag1 != sum || diag2 != sum || rows.exists(x => x != sum) || cols.exists(x => x != sum)) false else true",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(_ == magic_number)",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        if (n != m) return false\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        if (row_sums.forall(x => x == sum) && col_sums.forall(x => x == sum) && diag_sums.forall(x => x == sum)) true else false",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val sum_rows = my_matrix.map(x => x.sum)\n        val sum_cols = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val sum_diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        sum_rows.forall(_ == sum) && sum_cols.forall(_ == sum) && sum_diag1 == sum && sum_diag2 == sum",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(\n            (0 until n).map(i => my_matrix(i)(i)).sum,\n            (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        )\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_col = (0 until n).map(i => (0 until m).map(j => my_matrix(j)(i)).sum).sum\n        val sum_diag = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        if (sum != sum_col || sum != sum_diag || sum != sum_diag2) return false\n        true",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_row = my_matrix.map(_.sum).toSet\n        val sum_col = my_matrix.transpose.map(_.sum).toSet\n        val sum_diag = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val sum_diag_set = sum_diag.toSet\n        if (sum_row.size == 1 && sum_col.size == 1 && sum_diag_set.size == 1 && sum_row.head == sum_col.head && sum_col.head == sum_diag_set.head) true else false",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        if (n != m) return false\n        val sum = my_matrix.map(x => x.sum).sum / n\n        for (i <- 0 until n) {\n            if (my_matrix(i).sum != sum) return false\n            if (my_matrix.map(x => x(i)).sum != sum) return false\n        }\n        if (my_matrix.map(x => x(x.length - 1 - x.indexOf(x.head))).sum != sum) return false\n        if (my_matrix.map(x => x(x.indexOf(x.head))).sum != sum) return false\n        true",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        if (n != m) return false\n        val sum = my_matrix.map(x => x.sum).sum / n\n        for (i <- 0 until n) {\n            if (my_matrix(i).sum != sum) return false\n            if (my_matrix.map(x => x(i)).sum != sum) return false\n        }\n        if (my_matrix.map(x => x(x.length - 1 - my_matrix.indexOf(x))).sum != sum) return false\n        if (my_matrix.map(x => x(my_matrix.indexOf(x))).sum != sum) return false\n        return true",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val diag2 = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        diag1 == sum && diag2 == sum && row_sums.forall(_ == sum) && col_sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val diagonal_sum = my_matrix.zipWithIndex.map(x => x._1(x._2)).sum\n        val anti_diagonal_sum = my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum\n        val row_sums = my_matrix.map(x => x.sum)\n        val column_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val all_sums = row_sums ++ column_sums ++ List(diagonal_sum, anti_diagonal_sum)\n        all_sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_row = my_matrix.map(_.sum)\n        val sum_col = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val sum_diag = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_anti_diag = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        sum_row.forall(_ == sum) && sum_col.forall(_ == sum) && sum_diag == sum && sum_anti_diag == sum",
    "        val n = my_matrix.length\n        val magic_constant = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(x => (0 until n).map(y => my_matrix(y)(x)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - x._2 - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == magic_constant)",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        if (row_sums.forall(x => x == sum) && col_sums.forall(x => x == sum) && diag_sums.forall(x => x == sum)) true else false",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_row = my_matrix.map(_.sum).toSet\n        val sum_col = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum).toSet\n        val sum_diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        val sum_set = Set(sum_row, sum_col, Set(sum_diag1, sum_diag2)).flatten\n        sum_set.size == 1 && sum_set.head == sum",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_rows = my_matrix.map(_.sum).toSet\n        val sum_cols = (0 until n).map(i => my_matrix.map(_(i)).sum).toSet\n        val sum_diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        val sum_diags = Set(sum_diag1, sum_diag2)\n        sum_rows.size == 1 && sum_cols.size == 1 && sum_diags.size == 1 && sum_rows.head == sum_cols.head && sum_cols.head == sum_diags.head",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        val sum_row = (0 until n).map(i => my_matrix(i).sum).toSet\n        val sum_col = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum).toSet\n        sum_row.size == 1 && sum_col.size == 1 && sum_row.head == sum_col.head && sum_row.head == sum_diag1 && sum_row.head == sum_diag2",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        if (n != m) return false\n        val sum = my_matrix.map(x => x.sum).sum / n\n        for (i <- 0 until n) {\n            if (my_matrix(i).sum != sum) return false\n            if (my_matrix.map(x => x(i)).sum != sum) return false\n        }\n        if (my_matrix.zipWithIndex.map(x => x._1(x._2)).sum != sum) return false\n        if (my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum != sum) return false\n        true",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val sum_rows = my_matrix.map(x => x.sum)\n        val sum_cols = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val sum_diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        if (sum_rows.forall(x => x == sum) && sum_cols.forall(x => x == sum) && sum_diag1 == sum && sum_diag2 == sum) true else false",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        val sum_row = my_matrix.map(_.sum).toSet\n        val sum_col = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum).toSet\n        if (sum_row.size == 1 && sum_col.size == 1 && sum_diag1 == sum && sum_diag2 == sum) true else false",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.map(x => x(x.length - 1 - x.indexOf(x.last))).sum, my_matrix.map(x => x(x.indexOf(x.last))).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_diagonal = my_matrix.zipWithIndex.map(x => x._1(x._2)).sum\n        val sum_diagonal_2 = my_matrix.zipWithIndex.map(x => x._1(n - x._2 - 1)).sum\n        val sum_row = my_matrix.map(x => x.sum).toSet\n        val sum_column = my_matrix.transpose.map(x => x.sum).toSet\n        if (sum_row.size == 1 && sum_column.size == 1 && sum_diagonal == sum && sum_diagonal_2 == sum) true else false",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until m).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_row = my_matrix.map(x => x.sum).toSet\n        val sum_col = (0 until m).map(i => (0 until n).map(j => my_matrix(j)(i)).sum).toSet\n        val sum_diag = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_anti_diag = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        val sum_set = Set(sum_row, sum_col, Set(sum_diag, sum_anti_diag)).flatten\n        sum_set.size == 1 && sum_set.head == sum",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        row_sums.forall(_ == sum) && col_sums.forall(_ == sum) && diag_sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_row = my_matrix.map(_.sum).toSet\n        val sum_col = (0 until n).map(i => my_matrix.map(_(i)).sum).toSet\n        val sum_diag = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_anti_diag = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        sum_row.size == 1 && sum_col.size == 1 && sum_diag == sum && sum_anti_diag == sum",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_row = my_matrix.map(_.sum).toSet\n        val sum_col = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum).toSet\n        val sum_diag = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        sum_row.size == 1 && sum_col.size == 1 && sum_diag.size == 1 && sum_row.head == sum_col.head && sum_col.head == sum_diag.head",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - x._2 - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_diagonal_1 = (0 until n).map(x => my_matrix(x)(x)).sum\n        val sum_diagonal_2 = (0 until n).map(x => my_matrix(x)(n - 1 - x)).sum\n        val sum_rows = my_matrix.map(x => x.sum).toSet\n        val sum_cols = (0 until n).map(x => (0 until n).map(y => my_matrix(y)(x)).sum).toSet\n        val sum_diagonals = Set(sum_diagonal_1, sum_diagonal_2)\n        val sum_all = sum_rows ++ sum_cols ++ sum_diagonals\n        sum_all.size == 1",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = for (i <- 0 until n) yield my_matrix.map(row => row(i)).sum\n        val diag_sums = List(my_matrix.zipWithIndex.map(row => row._1(row._2)).sum, my_matrix.zipWithIndex.map(row => row._1(n - 1 - row._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(x => my_matrix.map(y => y(x)).sum)\n        val diag_sums = List(my_matrix.indices.map(x => my_matrix(x)(x)).sum, my_matrix.indices.map(x => my_matrix(x)(n - 1 - x)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_row = my_matrix.map(x => x.sum).toSet\n        val sum_col = my_matrix.transpose.map(x => x.sum).toSet\n        val sum_diag = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val sum_set = sum_row ++ sum_col ++ sum_diag\n        sum_set.size == 1 && sum_set.head == sum",
    "        val n = my_matrix.length\n        val sum = (1 to n).sum\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        row_sums.forall(x => x == sum) && col_sums.forall(x => x == sum) && diag_sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val sums = row_sums ::: col_sums ::: diag_sums\n        sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        if (n != m) return false\n        val sum = my_matrix.map(_.sum).sum\n        val sum_row = my_matrix.map(_.sum)\n        val sum_col = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val sum_diag = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_anti_diag = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        sum_row.forall(_ == sum) && sum_col.forall(_ == sum) && sum_diag == sum && sum_anti_diag == sum",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val expected_sum = n * (n * n + 1) / 2\n        if (sum != expected_sum) return false\n        for (i <- 0 until n) {\n            val row_sum = my_matrix(i).sum\n            if (row_sum != expected_sum) return false\n            val col_sum = my_matrix.map(_(i)).sum\n            if (col_sum != expected_sum) return false\n        }\n        val diag_sum1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        if (diag_sum1 != expected_sum) return false\n        val diag_sum2 = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        if (diag_sum2 != expected_sum) return false\n        true",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(col => (0 until n).map(row => my_matrix(row)(col)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val magic_constant = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(row_i => row_i._1(row_i._2)).sum, my_matrix.zipWithIndex.map(row_i => row_i._1(n - row_i._2 - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_constant)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = (1 to n).sum\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        row_sums.forall(_ == sum) && col_sums.forall(_ == sum) && diag_sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val my_matrix_transpose = my_matrix.transpose\n        val diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val diag2 = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = my_matrix_transpose.map(_.sum)\n        (row_sums.forall(_ == sum) && col_sums.forall(_ == sum) && diag1 == sum && diag2 == sum)",
    "        val n = my_matrix.length\n        val magic_sum = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = my_matrix.transpose.map(x => x.sum)\n        val diag_sum1 = my_matrix.zipWithIndex.map(x => x._1(x._2)).sum\n        val diag_sum2 = my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum\n        val sums = row_sums ++ col_sums ++ List(diag_sum1, diag_sum2)\n        return sums.forall(x => x == magic_sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        var sum_list = List[Long]()\n        // Sum of each row\n        for (i <- 0 until my_matrix.length) {\n            var sum = 0L\n            for (j <- 0 until my_matrix(i).length) {\n                sum += my_matrix(i)(j)\n            }\n            sum_list = sum_list :+ sum\n        }\n        // Sum of each column\n        for (i <- 0 until my_matrix(0).length) {\n            var sum = 0L\n            for (j <- 0 until my_matrix.length) {\n                sum += my_matrix(j)(i)\n            }\n            sum_list = sum_list :+ sum\n        }\n        // Sum of diagonal\n        var sum = 0L\n        for (i <- 0 until my_matrix.length) {\n            sum += my_matrix(i)(i)\n        }\n        sum_list = sum_list :+ sum\n        sum = 0L\n        for (i <- 0 until my_matrix.length) {\n            sum += my_matrix(i)(my_matrix.length - 1 - i)\n        }\n        sum_list = sum_list :+ sum\n        // Test\n        val sum_set = sum_list.toSet\n        if (sum_set.size == 1) true else false",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        val sum_row = (0 until n).map(i => my_matrix(i).sum).toSet\n        val sum_col = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum).toSet\n        if (sum_row.size == 1 && sum_col.size == 1 && sum_row.head == sum_col.head && sum_diag1 == sum_diag2 && sum_diag1 == sum_row.head) true else false",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_row = my_matrix.map(_.sum).toSet\n        val sum_col = (0 until n).map(i => my_matrix.map(_(i)).sum).toSet\n        val sum_diag = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - x._2 - 1)).sum)\n        if (sum_row.size != 1 || sum_col.size != 1 || sum_diag.size != 1) return false\n        if (sum_row.head != sum || sum_col.head != sum || sum_diag.head != sum) return false\n        return true"
  ]
}