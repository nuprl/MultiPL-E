{
  "name": "mbpp_417_group_tuples",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find common first element in given list of tuple.\n    def groupTuples(Input : List[String]) : List[String] = {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_417_group_tuples.py",
  "prompt_terminology": "reworded",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(groupTuples((List[String]((\"x\", \"y\"), (\"x\", \"z\"), (\"w\", \"t\")))).equals((List[String]((\"x\", \"y\", \"z\"), (\"w\", \"t\")))));\n    assert(groupTuples((List[String]((\"a\", \"b\"), (\"a\", \"c\"), (\"d\", \"e\")))).equals((List[String]((\"a\", \"b\", \"c\"), (\"d\", \"e\")))));\n    assert(groupTuples((List[String]((\"f\", \"g\"), (\"f\", \"g\"), (\"h\", \"i\")))).equals((List[String]((\"f\", \"g\", \"g\"), (\"h\", \"i\")))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        Input.groupBy(_.split(\" \").head).map(_._2.head).toList",
    "        val tuples = Input.map(x => x.split(\",\").toList)\n        val grouped = tuples.groupBy(x => x.head)\n        val result = grouped.map(x => x._1 + \":\" + x._2.map(y => y.tail.mkString(\",\")).mkString(\"|\")).toList\n        result",
    "        val tuples = Input.map(x => x.split(\",\").toList)\n        val first = tuples.map(x => x.head)\n        val grouped = first.groupBy(x => x)\n        val result = grouped.map(x => x._1 + \":\" + x._2.length).toList\n        result",
    "        val map = new HashMap[String, List[String]]\n        for (i <- Input) {\n            val key = i.split(\",\")(0)\n            if (map.contains(key)) {\n                val value = map(key)\n                map(key) = i :: value\n            } else {\n                map(key) = List(i)\n            }\n        }\n        map.values.toList.flatten",
    "        val tuples = Input.map(x => x.split(\" \").toList)\n        val firstElements = tuples.map(x => x(0))\n        val groupedFirstElements = firstElements.groupBy(x => x)\n        val result = groupedFirstElements.map(x => x._1 + \" \" + x._2.size).toList\n        return result",
    "        val tuples = Input.map(x => x.split(\",\").toList)\n        val firstElements = tuples.map(x => x.head)\n        val firstElementsGrouped = firstElements.groupBy(x => x)\n        val firstElementsGroupedFiltered = firstElementsGrouped.filter(x => x._2.length > 1)\n        val firstElementsGroupedFilteredSorted = firstElementsGroupedFiltered.toList.sortBy(x => x._1)\n        val firstElementsGroupedFilteredSortedMapped = firstElementsGroupedFilteredSorted.map(x => x._1)\n        firstElementsGroupedFilteredSortedMapped",
    "        val tuples = Input.map(x => (x.split(\" \")(0), x.split(\" \")(1)))\n        val grouped = tuples.groupBy(_._1)\n        val result = grouped.map(x => x._1 + \" \" + x._2.map(_._2).mkString(\" \")).toList\n        result",
    "        val tuples = Input.map(x => x.split(\",\").toList).map(x => (x(0), x(1)))\n        val groups = tuples.groupBy(x => x._1)\n        groups.map(x => x._1 + \":\" + x._2.map(y => y._2).mkString(\",\")).toList",
    "        val tuples = Input.map(x => x.split(\",\"))\n        val first = tuples.map(x => x(0))\n        val groups = first.groupBy(x => x)\n        val result = groups.map(x => x._1 + \":\" + x._2.size).toList\n        result",
    "        var map = Map[String, List[String]]()\n        for (i <- Input) {\n            val key = i.split(\" \")(0)\n            if (map.contains(key)) {\n                map(key) = map(key) :+ i\n            } else {\n                map(key) = List(i)\n            }\n        }\n        var result = List[String]()\n        for (i <- map.values) {\n            result = result :+ i.mkString(\" \")\n        }\n        result",
    "        val map = new HashMap[String, ListBuffer[String]]\n        for (tuple <- Input) {\n            val key = tuple.split(\" \")(0)\n            if (map.contains(key)) {\n                map(key) += tuple\n            } else {\n                map += (key -> ListBuffer(tuple))\n            }\n        }\n        val result = new ListBuffer[String]\n        for (key <- map.keys) {\n            if (map(key).size > 1) {\n                result += map(key).mkString(\" \")\n            }\n        }\n        result.toList",
    "        val map = new HashMap[String, List[String]]\n        for (i <- Input) {\n            val key = i.split(\" \")(0)\n            if (map.contains(key)) {\n                val value = map(key)\n                map(key) = i :: value\n            } else {\n                map(key) = List(i)\n            }\n        }\n        map.values.toList.flatten",
    "        val result = Input.groupBy(x => x.split(\" \")(0)).map(x => x._1 + \" \" + x._2.size).toList\n        result",
    "        val tuples = Input.map(x => x.split(\",\"))\n        val firstElements = tuples.map(x => x(0))\n        val firstElementsMap = firstElements.groupBy(x => x)\n        val result = firstElementsMap.map(x => x._1 + \":\" + x._2.size)\n        result.toList",
    "        val tuples = Input.map(x => x.split(\",\"))\n        val firstElements = tuples.map(x => x(0))\n        val groupedElements = firstElements.groupBy(x => x)\n        val result = groupedElements.map(x => x._1 + \":\" + x._2.length).toList\n        result",
    "        val map = new HashMap[String, List[String]]\n        for (i <- Input) {\n            val key = i.split(\" \")(0)\n            val value = i.split(\" \")(1)\n            if (map.contains(key)) {\n                map(key) = map(key) :+ value\n            } else {\n                map(key) = List(value)\n            }\n        }\n        val result = new ListBuffer[String]\n        for ((k, v) <- map) {\n            result += k + \" \" + v.mkString(\" \")\n        }\n        result.toList",
    "        val groups = Input.groupBy(x => x.split(\" \")(0))\n        groups.map(x => x._1 + \" \" + x._2.length).toList",
    "        val tuples = Input.map(x => x.split(\",\").toList)\n        val first = tuples.map(x => x.head)\n        val firstGroup = first.groupBy(x => x)\n        val result = firstGroup.map(x => (x._1, x._2.length)).toList.sortBy(x => x._2).reverse.map(x => x._1)\n        result",
    "        val map = Map[String, List[String]]()\n        for (i <- Input) {\n            val key = i.split(\" \")(0)\n            if (map.contains(key)) {\n                val value = map(key)\n                map(key) = i :: value\n            } else {\n                map(key) = List(i)\n            }\n        }\n        map.values.toList.flatten",
    "        val result = new ListBuffer[String]\n        val map = new HashMap[String, Int]\n        for (tuple <- Input) {\n            val key = tuple.split(\",\")(0)\n            if (map.contains(key)) {\n                map(key) = map(key) + 1\n            } else {\n                map(key) = 1\n            }\n        }\n        for (tuple <- Input) {\n            val key = tuple.split(\",\")(0)\n            if (map(key) > 1) {\n                result += tuple\n            }\n        }\n        result.toList"
  ]
}