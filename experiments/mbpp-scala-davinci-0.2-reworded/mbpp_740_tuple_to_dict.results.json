{
  "name": "mbpp_740_tuple_to_dict",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_740_tuple_to_dict.py",
  "prompt_terminology": "reworded",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "results": [
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 1\n        while (i < test_tup) {\n            test_map += (i -> (i + 1))\n            i += 2\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn61p__31.scala:9:25 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m            test_map += (i -> (i + \u001b[31m1\u001b[0m))\n\u001b[31m\u001b[31m  |\u001b[0m                         ^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                         Found:    (Int, Int)\n\u001b[31m  |\u001b[0m                         Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn61p__31.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn61p__31.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn61p__31.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val tup = (1L to test_tup).toList\n        val dict = tup.zip(tup.tail)\n        dict.toMap\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmps9xkh5pe.scala:8:8 ----------------------\u001b[0m\u001b[0m\n\u001b[31m8 |\u001b[0m        dict.toMap\n\u001b[31m\u001b[31m  |\u001b[0m        ^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m        Found:    Map[Long, Long]\n\u001b[31m  |\u001b[0m        Required: \u001b[1m\u001b[32mcollection\u001b[0m\u001b[1m\u001b[32m.\u001b[0m\u001b[1m\u001b[32mmutable\u001b[0m\u001b[1m\u001b[32m.\u001b[0mMap[Long, Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmps9xkh5pe.scala:11:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmps9xkh5pe.scala:12:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmps9xkh5pe.scala:13:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val test_tup_list = test_tup.toString.toList.map(_.asDigit.toLong)\n        val test_tup_list_pairs = test_tup_list.sliding(2).toList\n        val test_tup_list_pairs_map = test_tup_list_pairs.map(x => (x(0),x(1))).toMap\n        test_tup_list_pairs_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509871,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpotorit_r.scala:9:8 ----------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        test_tup_list_pairs_map\n\u001b[31m\u001b[31m  |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m        Found:    (test_tup_list_pairs_map : Map[Long, Long])\n\u001b[31m  |\u001b[0m        Required: collection.mutable.Map[Long, Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpotorit_r.scala:12:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpotorit_r.scala:13:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpotorit_r.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_list = List[Long]()\n        var test_num = test_tup\n        while (test_num > 0) {\n            test_list = (test_num % 10) :: test_list\n            test_num /= 10\n        }\n        for (i <- 0 until test_list.length - 1) {\n            test_map += (test_list(i) -> test_list(i + 1))\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjwpuewvt.scala:19:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjwpuewvt.scala:20:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjwpuewvt.scala:21:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while(i < test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n            i += 1\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpb79rx1v_.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpb79rx1v_.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpb79rx1v_.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val tup = test_tup.toString.map(_.asDigit).toList\n        val tup_len = tup.length\n        val tup_map = Map[Long,Long]()\n        for (i <- 0 until tup_len - 1) {\n            tup_map += (tup(i) -> tup(i+1))\n        }\n        tup_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9m4eg7s8.scala:10:24 --------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m            tup_map += (tup(i) -> tup(i+\u001b[31m1\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Found:    (Int, Int)\n\u001b[31m   |\u001b[0m                        Required: (Long, Long)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9m4eg7s8.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9m4eg7s8.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9m4eg7s8.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var dict = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length - 1) {\n            dict += (test_tup.toString.charAt(i).toLong - 48) -> (test_tup.toString.charAt(i + 1).toLong - 48)\n            i += 1\n        }\n        dict\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwj73us0j.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwj73us0j.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwj73us0j.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        for (i <- 0 to test_tup.toString.length - 2) {\n            test_map += (test_tup.toString.charAt(i).toLong -> test_tup.toString.charAt(i + 1).toLong)\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqudpb0hh.scala:13:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqudpb0hh.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqudpb0hh.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n            i += 1\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2xn0sr7.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2xn0sr7.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2xn0sr7.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val tup = test_tup.toString.map(_.asDigit).toList\n        val tup_len = tup.length\n        val tup_map = Map[Long,Long]()\n        for (i <- 0 until tup_len - 1) {\n            tup_map += (tup(i).toLong -> tup(i + 1).toLong)\n        }\n        return tup_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7p18yrxo.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7p18yrxo.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7p18yrxo.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val tup_len = test_tup.toString.length\n        val tup_arr = test_tup.toString.toCharArray\n        val tup_arr_int = tup_arr.map(_.toString.toLong)\n        val tup_arr_int_pairs = tup_arr_int.sliding(2).toList\n        val tup_arr_int_pairs_map = tup_arr_int_pairs.map(x => (x(0),x(1))).toMap\n        return tup_arr_int_pairs_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9zbh8b95.scala:11:15 --------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mreturn\u001b[0m tup_arr_int_pairs_map\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               Found:    (tup_arr_int_pairs_map : Map[Long, Long])\n\u001b[31m   |\u001b[0m               Required: collection.mutable.Map[Long, Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9zbh8b95.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9zbh8b95.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9zbh8b95.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_list = List[Long]()\n        var test_tup_list = List[Long]()\n        var test_tup_list_rev = List[Long]()\n        var test_tup_list_rev_map = Map[Long,Long]()\n        var test_tup_list_rev_map_rev = Map[Long,Long]()\n        var test_tup_list_rev_map_rev_list = List[Long]()\n        var test_tup_list_rev_map_rev_list_rev = List[Long]()\n        var test_tup_list_rev_map_rev_list_rev_map = Map[Long,Long]()\n        var test_tup_list_rev_map_rev_list_rev_map_rev = Map[Long,Long]()\n        var test_tup_list_rev_map_rev_list_rev_map_rev_list = List[Long]()\n        var test_tup_list_rev_map_rev_list_rev_map_rev_list_rev = List[Long]()\n        var test_tup_list_rev_map_rev_list_rev_map_rev_list_rev_map = Map[Long,Long]()\n        var test_tup_list_rev_map_rev_list_rev_map_rev_list_rev_map_rev = Map[Long,Long]()\n        var test_tup_list_rev_map_rev_list_rev_map_rev_list_rev_map_rev_list = List[Long]()\n        var test_tup_list_rev_map_rev_list_rev_map_rev_list_rev_map_rev_list_rev = List[Long]()\n        var test_tup_list_rev_map_rev_list_rev_map_rev_list_rev_map_rev_list_rev_map = Map[Long,Long]()\n        var test_tup_list_rev_map_rev_list_rev_map_rev_list_rev_map_rev_list_rev_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp16dejkpg.scala:24:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp16dejkpg.scala:24:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: collection.mutable.Map[Long, Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp16dejkpg.scala:26:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp16dejkpg.scala:27:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp16dejkpg.scala:28:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).toLong -> test_tup.toString.charAt(i + 1).toLong)\n            i += 1\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpk9hgj9ec.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpk9hgj9ec.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpk9hgj9ec.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val test_tup_list = test_tup.toString.toList.map(_.asDigit.toLong)\n        val test_tup_list_pairs = test_tup_list.sliding(2).toList\n        val test_tup_list_pairs_map = test_tup_list_pairs.map(x => (x(0),x(1))).toMap\n        return test_tup_list_pairs_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprvkgg1pt.scala:9:15 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mreturn\u001b[0m test_tup_list_pairs_map\n\u001b[31m\u001b[31m  |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m               Found:    (test_tup_list_pairs_map : Map[Long, Long])\n\u001b[31m  |\u001b[0m               Required: collection.mutable.Map[Long, Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprvkgg1pt.scala:12:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprvkgg1pt.scala:13:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprvkgg1pt.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        var j = 1\n        while(j < test_tup.toString.length) {\n            test_map += (test_tup.toString.charAt(i).toLong -> test_tup.toString.charAt(j).toLong)\n            i += 1\n            j += 1\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprlcv0ig3.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprlcv0ig3.scala:18:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprlcv0ig3.scala:19:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val test_tup_list = test_tup.toString.toList.map(_.toString.toLong)\n        val test_tup_list_pairs = test_tup_list.zip(test_tup_list.tail)\n        val test_tup_dict = test_tup_list_pairs.toMap\n        return test_tup_dict\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpgw_kmhwn.scala:9:15 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mreturn\u001b[0m test_tup_dict\n\u001b[31m\u001b[31m  |\u001b[0m               ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m               Found:    (test_tup_dict : Map[Long, Long])\n\u001b[31m  |\u001b[0m               Required: collection.mutable.Map[Long, Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpgw_kmhwn.scala:12:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpgw_kmhwn.scala:13:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpgw_kmhwn.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_list = List[Long]()\n        var test_num = test_tup\n        while (test_num > 0) {\n            test_list = (test_num % 10) :: test_list\n            test_num /= 10\n        }\n        for (i <- 0 until test_list.length - 1) {\n            test_map += (test_list(i) -> test_list(i + 1))\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjwpuewvt.scala:19:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjwpuewvt.scala:20:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjwpuewvt.scala:21:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_tup_list = test_tup.toString.toList.map(_.toString.toLong)\n        var test_tup_list_pairs = test_tup_list.grouped(2).toList\n        var test_tup_list_pairs_map = Map[Long,Long]()\n        for (i <- 0 until test_tup_list_pairs.length) {\n            test_tup_list_pairs_map += (test_tup_list_pairs(i)(0) -> test_tup_list_pairs(i)(1))\n        }\n        return test_tup_list_pairs_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbecugjll.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbecugjll.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbecugjll.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val tup = (1L to test_tup).toList\n        val dict = Map[Long,Long]()\n        for (i <- 0 until tup.length - 1) {\n            dict += (tup(i) -> tup(i + 1))\n        }\n        dict\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp36gq662f.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp36gq662f.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp36gq662f.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map : Map[Long,Long] = Map()\n        var i : Long = 0\n        while (i < test_tup) {\n            test_map += (i -> (i+1))\n            i += 1\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpgi55nhs1.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpgi55nhs1.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpgi55nhs1.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val test_tup_list = test_tup.toString.toList.map(_.toString.toLong)\n        val test_tup_list_pairs = test_tup_list.sliding(2,2).toList\n        val test_tup_list_pairs_map = test_tup_list_pairs.map(x => (x(0),x(1))).toMap\n        return test_tup_list_pairs_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122690,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkx346kgg.scala:9:15 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mreturn\u001b[0m test_tup_list_pairs_map\n\u001b[31m\u001b[31m  |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m               Found:    (test_tup_list_pairs_map : Map[Long, Long])\n\u001b[31m  |\u001b[0m               Required: collection.mutable.Map[Long, Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkx346kgg.scala:12:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkx346kgg.scala:13:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkx346kgg.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var result = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length - 1) {\n            result += (test_tup.toString.charAt(i).toLong -> test_tup.toString.charAt(i + 1).toLong)\n            i += 1\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122689,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprc5sgpd4.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprc5sgpd4.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprc5sgpd4.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while(i < test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n            i += 1\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122690,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnj3d15ct.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnj3d15ct.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnj3d15ct.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var result = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length - 1) {\n            result += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n            i += 1\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122689,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphjctm78z.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphjctm78z.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphjctm78z.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while(i < test_tup.toString.length) {\n            if(i+1 < test_tup.toString.length) {\n                test_map += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i+1).asDigit.toLong)\n            }\n            i += 1\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122689,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpxstr3908.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpxstr3908.scala:18:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpxstr3908.scala:19:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_list = List[Long]()\n        var test_list_rev = List[Long]()\n        var test_list_rev_2 = List[Long]()\n        var test_list_rev_3 = List[Long]()\n        var test_list_rev_4 = List[Long]()\n        var test_list_rev_5 = List[Long]()\n        var test_list_rev_6 = List[Long]()\n        var test_list_rev_7 = List[Long]()\n        var test_list_rev_8 = List[Long]()\n        var test_list_rev_9 = List[Long]()\n        var test_list_rev_10 = List[Long]()\n        var test_list_rev_11 = List[Long]()\n        var test_list_rev_12 = List[Long]()\n        var test_list_rev_13 = List[Long]()\n        var test_list_rev_14 = List[Long]()\n        var test_list_rev_15 = List[Long]()\n        var test_list_rev_16 = List[Long]()\n        var test_list_rev_17 = List[Long]()\n        var test_list_rev_18 = List[Long]()\n        var test_list_rev_19 = List[Long]()\n        var test_list_rev_20 = List[Long]()\n        var test_list_rev_21 = List[Long]()\n        var test_list_rev_22 = List[Long]()\n        var test_list_rev_23 = List[Long]()\n        var test_list_rev_24 = List[Long]()\n        var test_list_rev_25 = List[Long]()\n        var test_list_rev_26 = List[Long]()\n        var test_list_rev_27 = List[Long]()\n        var test_list_rev_28 = List[Long]()\n        var test_list_rev_29 = List[Long]()\n        var test_list_rev_30 = List[Long]()\n        var test_list_rev\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122690,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpv5no3qae.scala:39:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv5no3qae.scala:39:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: collection.mutable.Map[Long, Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv5no3qae.scala:41:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv5no3qae.scala:42:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv5no3qae.scala:43:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_dict = Map[Long,Long]()\n        var test_list = List[Long]()\n        var test_num = test_tup\n        while (test_num > 0) {\n            test_list = (test_num % 10) :: test_list\n            test_num /= 10\n        }\n        for (i <- 0 until test_list.length - 1) {\n            test_dict += (test_list(i) -> test_list(i + 1))\n        }\n        return test_dict\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122691,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5iqqpjes.scala:19:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5iqqpjes.scala:20:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5iqqpjes.scala:21:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        for (i <- 0 to test_tup.toString.length - 1) {\n            if (i == test_tup.toString.length - 1) {\n                test_map += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(0).asDigit.toLong)\n            }\n            else {\n                test_map += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n            }\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122690,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpyrhrprwh.scala:18:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpyrhrprwh.scala:19:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpyrhrprwh.scala:20:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val tup = (1L to test_tup).toList\n        val tup_pairs = tup.sliding(2).toList\n        val tup_dict = tup_pairs.map(x => (x(0),x(1))).toMap\n        tup_dict\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122691,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2dv6wx9.scala:9:8 ----------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        tup_dict\n\u001b[31m\u001b[31m  |\u001b[0m        ^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m        Found:    (tup_dict : Map[Long, Long])\n\u001b[31m  |\u001b[0m        Required: collection.mutable.Map[Long, Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2dv6wx9.scala:12:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2dv6wx9.scala:13:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2dv6wx9.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).toLong -> test_tup.toString.charAt(i + 1).toLong)\n            i += 1\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpk9hgj9ec.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpk9hgj9ec.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpk9hgj9ec.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_list = List[Long]()\n        var test_list_rev = List[Long]()\n        var test_list_rev_rev = List[Long]()\n        var test_list_rev_rev_rev = List[Long]()\n        var test_list_rev_rev_rev_rev = List[Long]()\n        var test_list_rev_rev_rev_rev_rev = List[Long]()\n        var test_list_rev_rev_rev_rev_rev_rev = List[Long]()\n        var test_list_rev_rev_rev_rev_rev_rev_rev = List[Long]()\n        var test_list_rev_rev_rev_rev_rev_rev_rev_rev = List[Long]()\n        var test_list_rev_rev_rev_rev_rev_rev_rev_rev_rev = List[Long]()\n        var test_list_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev = List[Long]()\n        var test_list_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev = List[Long]()\n        var test_list_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev = List[Long]()\n        var test_list_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev = List[Long]()\n        var test_list_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev = List[Long]()\n        var test_list_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev = List[Long]()\n        var test_list_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev = List[Long]()\n        var test_list_rev_rev_rev_rev_rev_rev_rev_rev\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122691,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpeg2seoj2.scala:25:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpeg2seoj2.scala:25:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: collection.mutable.Map[Long, Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpeg2seoj2.scala:27:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpeg2seoj2.scala:28:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpeg2seoj2.scala:29:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_list = List[Long]()\n        var test_tup_list = test_tup.toString.toList.map(x => x.toString.toLong)\n        for (i <- 0 until test_tup_list.length) {\n            if (i % 2 == 0) {\n                test_map += (test_tup_list(i) -> test_tup_list(i + 1))\n            }\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122690,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5ri24sof.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5ri24sof.scala:18:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5ri24sof.scala:19:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        var j = 1\n        while (j < test_tup.toString.length) {\n            test_map += (test_tup.toString.charAt(i).toLong -> test_tup.toString.charAt(j).toLong)\n            i += 1\n            j += 1\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122691,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkp_zp887.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkp_zp887.scala:18:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkp_zp887.scala:19:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val tup_list = test_tup.toString.toList.map(_.toString.toLong)\n        val tup_list_pairs = tup_list.sliding(2).toList\n        val tup_list_pairs_map = tup_list_pairs.map(x => (x(0),x(1))).toMap\n        return tup_list_pairs_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122690,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpuv5fr8zx.scala:9:15 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mreturn\u001b[0m tup_list_pairs_map\n\u001b[31m\u001b[31m  |\u001b[0m               ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m               Found:    (tup_list_pairs_map : Map[Long, Long])\n\u001b[31m  |\u001b[0m               Required: collection.mutable.Map[Long, Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpuv5fr8zx.scala:12:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpuv5fr8zx.scala:13:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpuv5fr8zx.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        var j = 1\n        while (j < test_tup.toString.length) {\n            test_map += (test_tup.toString.charAt(i).toString.toLong -> test_tup.toString.charAt(j).toString.toLong)\n            i += 2\n            j += 2\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122691,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp45il2v5l.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp45il2v5l.scala:18:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp45il2v5l.scala:19:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 1\n        while(i < test_tup) {\n            test_map += (i -> (i+1))\n            i += 2\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122690,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt6b3lzk3.scala:9:25 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m            test_map += (i -> (i+\u001b[31m1\u001b[0m))\n\u001b[31m\u001b[31m  |\u001b[0m                         ^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                         Found:    (Int, Int)\n\u001b[31m  |\u001b[0m                         Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt6b3lzk3.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt6b3lzk3.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt6b3lzk3.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length) {\n            if (i == test_tup.toString.length - 1) {\n                test_map += (test_tup.toString.charAt(i).asDigit.toLong -> 0)\n            }\n            else {\n                test_map += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n            }\n            i += 1\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122691,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpd91mbhbm.scala:20:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpd91mbhbm.scala:21:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpd91mbhbm.scala:22:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val tup = (1 to test_tup.toInt).toList\n        val tup_pairs = tup.sliding(2).toList\n        val tup_pairs_map = tup_pairs.map(x => (x.head, x.last))\n        tup_pairs_map.toMap\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122691,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmph3rhy7gl.scala:9:8 ----------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        tup_pairs_map.toMap\n\u001b[31m\u001b[31m  |\u001b[0m        ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m        Found:    Map[Int, Int]\n\u001b[31m  |\u001b[0m        Required: collection.mutable.Map[Long, Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmph3rhy7gl.scala:12:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmph3rhy7gl.scala:13:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmph3rhy7gl.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val tup = (1 to test_tup.toInt).toList\n        var dict = Map[Long,Long]()\n        for (i <- 0 to tup.length - 2) {\n            dict += (tup(i) -> tup(i+1))\n        }\n        return dict\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122691,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbod7s04t.scala:9:21 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m            dict += (tup(i) -> tup(i+\u001b[31m1\u001b[0m))\n\u001b[31m\u001b[31m  |\u001b[0m                     ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                     Found:    (Int, Int)\n\u001b[31m  |\u001b[0m                     Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbod7s04t.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbod7s04t.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbod7s04t.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 1\n        while (i < test_tup) {\n            test_map += (i -> (i+1))\n            i += 2\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122691,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmptfo8wyig.scala:9:25 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m            test_map += (i -> (i+\u001b[31m1\u001b[0m))\n\u001b[31m\u001b[31m  |\u001b[0m                         ^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                         Found:    (Int, Int)\n\u001b[31m  |\u001b[0m                         Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmptfo8wyig.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmptfo8wyig.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmptfo8wyig.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while(i < test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).toLong -> test_tup.toString.charAt(i + 1).toLong)\n            i += 1\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122690,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppnvu65df.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppnvu65df.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppnvu65df.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).toString.toLong -> test_tup.toString.charAt(i+1).toString.toLong)\n            i += 1\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122691,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpefxtdptc.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpefxtdptc.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpefxtdptc.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val test_tup_list = test_tup.toString.toList.map(_.toString.toLong)\n        val test_tup_list_pairs = test_tup_list.sliding(2,2).toList\n        val test_tup_list_pairs_map = test_tup_list_pairs.map(x => (x(0),x(1))).toMap\n        return test_tup_list_pairs_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122690,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkx346kgg.scala:9:15 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mreturn\u001b[0m test_tup_list_pairs_map\n\u001b[31m\u001b[31m  |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m               Found:    (test_tup_list_pairs_map : Map[Long, Long])\n\u001b[31m  |\u001b[0m               Required: collection.mutable.Map[Long, Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkx346kgg.scala:12:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkx346kgg.scala:13:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkx346kgg.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map : Map[Long,Long] = Map()\n        var test_tup_list = test_tup.toString.toList.map(_.asDigit.toLong)\n        for (i <- 0 until test_tup_list.length - 1) {\n            test_map += (test_tup_list(i) -> test_tup_list(i+1))\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122690,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphg1kqzto.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphg1kqzto.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphg1kqzto.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n            i += 1\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2xn0sr7.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2xn0sr7.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2xn0sr7.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var dict = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length - 1) {\n            dict += (test_tup.toString.charAt(i).toLong - 48) -> (test_tup.toString.charAt(i + 1).toLong - 48)\n            i += 1\n        }\n        dict\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwj73us0j.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwj73us0j.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwj73us0j.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val test_tup_list = test_tup.toString.toList.map(_.toString.toLong)\n        val test_tup_list_pairs = test_tup_list.sliding(2).toList\n        val test_tup_list_pairs_map = test_tup_list_pairs.map(x => (x(0), x(1))).toMap\n        return test_tup_list_pairs_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122690,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9ek20vof.scala:9:15 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mreturn\u001b[0m test_tup_list_pairs_map\n\u001b[31m\u001b[31m  |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m               Found:    (test_tup_list_pairs_map : Map[Long, Long])\n\u001b[31m  |\u001b[0m               Required: collection.mutable.Map[Long, Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9ek20vof.scala:12:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9ek20vof.scala:13:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9ek20vof.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_tup_list = test_tup.toString.toList.map(_.toString.toLong)\n        for (i <- 0 until test_tup_list.length - 1) {\n            test_map += (test_tup_list(i) -> test_tup_list(i + 1))\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122704,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp82m46ija.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp82m46ija.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp82m46ija.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val tup_len = test_tup.toString.length\n        val tup_list = test_tup.toString.toList.map(_.toString.toLong)\n        var tup_dict = Map[Long,Long]()\n        for (i <- 0 until tup_len - 1) {\n            tup_dict += (tup_list(i) -> tup_list(i + 1))\n        }\n        tup_dict\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122705,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphvch_ujg.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphvch_ujg.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphvch_ujg.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n            i += 1\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2xn0sr7.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2xn0sr7.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2xn0sr7.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val test_tup_list = test_tup.toString.toList.map(_.toString.toLong)\n        val test_tup_list_pairs = test_tup_list.sliding(2).toList\n        val test_tup_list_pairs_map = test_tup_list_pairs.map(x => (x(0), x(1))).toMap\n        return test_tup_list_pairs_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122690,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9ek20vof.scala:9:15 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mreturn\u001b[0m test_tup_list_pairs_map\n\u001b[31m\u001b[31m  |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m               Found:    (test_tup_list_pairs_map : Map[Long, Long])\n\u001b[31m  |\u001b[0m               Required: collection.mutable.Map[Long, Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9ek20vof.scala:12:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9ek20vof.scala:13:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9ek20vof.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while(i < test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).toLong -> test_tup.toString.charAt(i + 1).toLong)\n            i += 1\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122705,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt8ldvx39.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt8ldvx39.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt8ldvx39.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var dict = Map[Long,Long]()\n        var i = 0\n        while(i < test_tup.toString.length - 1) {\n            dict += (test_tup.toString.charAt(i).toLong -> test_tup.toString.charAt(i + 1).toLong)\n            i += 1\n        }\n        dict\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122704,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpyus3qti7.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpyus3qti7.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpyus3qti7.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_list = List[Long]()\n        var temp = test_tup\n        while (temp > 0) {\n            test_list = (temp % 10) :: test_list\n            temp /= 10\n        }\n        for (i <- 0 until test_list.length - 1) {\n            test_map += (test_list(i) -> test_list(i + 1))\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122705,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpx719z2_n.scala:19:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpx719z2_n.scala:20:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpx719z2_n.scala:21:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_list = List[Long]()\n        var test_list_rev = List[Long]()\n        var test_list_rev_map = Map[Long,Long]()\n        var test_list_rev_map_rev = Map[Long,Long]()\n        var test_list_rev_map_rev_list = List[Long]()\n        var test_list_rev_map_rev_list_rev = List[Long]()\n        var test_list_rev_map_rev_list_rev_map = Map[Long,Long]()\n        var test_list_rev_map_rev_list_rev_map_rev = Map[Long,Long]()\n        var test_list_rev_map_rev_list_rev_map_rev_list = List[Long]()\n        var test_list_rev_map_rev_list_rev_map_rev_list_rev = List[Long]()\n        var test_list_rev_map_rev_list_rev_map_rev_list_rev_map = Map[Long,Long]()\n        var test_list_rev_map_rev_list_rev_map_rev_list_rev_map_rev = Map[Long,Long]()\n        var test_list_rev_map_rev_list_rev_map_rev_list_rev_map_rev_list = List[Long]()\n        var test_list_rev_map_rev_list_rev_map_rev_list_rev_map_rev_list_rev = List[Long]()\n        var test_list_rev_map_rev_list_rev_map_rev_list_rev_map_rev_list_rev_map = Map[Long,Long]()\n        var test_list_rev_map_rev_list_rev_map_rev_list_rev_map_rev_list_rev_map_rev = Map[Long,Long]()\n        var test_list_rev_map_rev_list_rev_map_rev_list_rev_map_rev_list_rev_map_rev_list = List[Long]()\n        var test_list\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122705,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmps_simauj.scala:25:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmps_simauj.scala:25:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: collection.mutable.Map[Long, Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmps_simauj.scala:27:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmps_simauj.scala:28:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmps_simauj.scala:29:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_tup_list = test_tup.toString.toList.map(x => x.asDigit.toLong)\n        for (i <- 0 until test_tup_list.length - 1) {\n            test_map += (test_tup_list(i) -> test_tup_list(i + 1))\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122706,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpooqgpem9.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpooqgpem9.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpooqgpem9.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_list = List[Long]()\n        var temp = test_tup\n        while(temp != 0) {\n            test_list = (temp % 10) :: test_list\n            temp = temp / 10\n        }\n        for(i <- 0 to test_list.length - 2) {\n            test_map += (test_list(i) -> test_list(i + 1))\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122706,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpitqj3mim.scala:19:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpitqj3mim.scala:20:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpitqj3mim.scala:21:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while(i < test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).toLong -> test_tup.toString.charAt(i + 1).toLong)\n            i += 1\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122690,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppnvu65df.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppnvu65df.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppnvu65df.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n            i += 1\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2xn0sr7.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2xn0sr7.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2xn0sr7.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val test_tup_list = test_tup.toString.toList.map(_.asDigit.toLong)\n        val test_tup_list_pairs = test_tup_list.sliding(2).toList\n        val test_tup_list_pairs_map = test_tup_list_pairs.map(x => (x(0),x(1))).toMap\n        return test_tup_list_pairs_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprvkgg1pt.scala:9:15 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mreturn\u001b[0m test_tup_list_pairs_map\n\u001b[31m\u001b[31m  |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m               Found:    (test_tup_list_pairs_map : Map[Long, Long])\n\u001b[31m  |\u001b[0m               Required: collection.mutable.Map[Long, Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprvkgg1pt.scala:12:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprvkgg1pt.scala:13:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprvkgg1pt.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val tup_len = test_tup.toString.length\n        val tup_list = test_tup.toString.toList.map(_.toString.toLong)\n        val tup_list_pairs = tup_list.sliding(2).toList\n        val tup_list_pairs_map = tup_list_pairs.map(x => (x(0),x(1))).toMap\n        return tup_list_pairs_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122706,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpiru_pc1a.scala:10:15 --------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mreturn\u001b[0m tup_list_pairs_map\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               Found:    (tup_list_pairs_map : Map[Long, Long])\n\u001b[31m   |\u001b[0m               Required: collection.mutable.Map[Long, Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpiru_pc1a.scala:13:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpiru_pc1a.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpiru_pc1a.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n            i += 1\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2xn0sr7.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2xn0sr7.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2xn0sr7.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n            i += 1\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2xn0sr7.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2xn0sr7.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2xn0sr7.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_list = List[Long]()\n        var test_num = test_tup\n        while (test_num > 0) {\n            test_list = (test_num % 10) :: test_list\n            test_num /= 10\n        }\n        for (i <- 0 until test_list.length - 1) {\n            test_map += (test_list(i) -> test_list(i + 1))\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122705,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_6nrk2e_.scala:19:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_6nrk2e_.scala:20:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_6nrk2e_.scala:21:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val test_tup_list = test_tup.toString.toList.map(_.asDigit)\n        val test_tup_list_pairs = test_tup_list.grouped(2).toList\n        val test_tup_list_pairs_map = test_tup_list_pairs.map(x => (x.head.toLong, x.last.toLong))\n        test_tup_list_pairs_map.toMap\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122706,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqu0r9nb9.scala:9:8 ----------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        test_tup_list_pairs_map.toMap\n\u001b[31m\u001b[31m  |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m        Found:    Map[Long, Long]\n\u001b[31m  |\u001b[0m        Required: \u001b[1m\u001b[32mcollection\u001b[0m\u001b[1m\u001b[32m.\u001b[0m\u001b[1m\u001b[32mmutable\u001b[0m\u001b[1m\u001b[32m.\u001b[0mMap[Long, Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqu0r9nb9.scala:12:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqu0r9nb9.scala:13:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqu0r9nb9.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_tup_list = test_tup.toString.toList\n        for (i <- 0 to test_tup_list.length - 2) {\n            test_map += (test_tup_list(i).toString.toLong -> test_tup_list(i + 1).toString.toLong)\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122705,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0fb9674y.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0fb9674y.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0fb9674y.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val test_tup_list = test_tup.toString.toList.map(_.toString.toLong)\n        val test_tup_list_pairs = test_tup_list.sliding(2,2).toList\n        val test_tup_list_pairs_map = test_tup_list_pairs.map(x => (x(0),x(1))).toMap\n        test_tup_list_pairs_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122706,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp08ihpqho.scala:9:8 ----------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        test_tup_list_pairs_map\n\u001b[31m\u001b[31m  |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m        Found:    (test_tup_list_pairs_map : Map[Long, Long])\n\u001b[31m  |\u001b[0m        Required: collection.mutable.Map[Long, Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp08ihpqho.scala:12:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp08ihpqho.scala:13:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp08ihpqho.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_list = List[Long]()\n        var temp = test_tup\n        while(temp > 0) {\n            test_list = (temp % 10) :: test_list\n            temp /= 10\n        }\n        for(i <- 0 until test_list.length - 1) {\n            test_map += (test_list(i) -> test_list(i + 1))\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122706,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_sc2npqs.scala:19:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_sc2npqs.scala:20:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_sc2npqs.scala:21:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_dict = Map[Long,Long]()\n        var test_list = List[Long]()\n        var test_list_rev = List[Long]()\n        var test_list_rev_iter = List[Long]()\n        var test_list_iter = List[Long]()\n        var test_list_iter_rev = List[Long]()\n        var test_list_iter_rev_iter = List[Long]()\n        var test_list_iter_iter = List[Long]()\n        var test_list_iter_iter_rev = List[Long]()\n        var test_list_iter_iter_rev_iter = List[Long]()\n        var test_list_iter_iter_iter = List[Long]()\n        var test_list_iter_iter_iter_rev = List[Long]()\n        var test_list_iter_iter_iter_rev_iter = List[Long]()\n        var test_list_iter_iter_iter_iter = List[Long]()\n        var test_list_iter_iter_iter_iter_rev = List[Long]()\n        var test_list_iter_iter_iter_iter_rev_iter = List[Long]()\n        var test_list_iter_iter_iter_iter_iter = List[Long]()\n        var test_list_iter_iter_iter_iter_iter_rev = List[Long]()\n        var test_list_iter_iter_iter_iter_iter_rev_iter = List[Long]()\n        var test_list_iter_iter_iter_iter_iter_iter = List[Long]()\n        var test_list_iter_iter_iter_iter_iter_iter_rev = List[Long]()\n        var test_list_iter_iter_iter_iter_iter_iter_rev_iter = List[Long]()\n        var test_list_iter_iter_iter_iter_iter_iter_iter = List[Long]()\n        var test_list_iter_iter_iter_iter_iter_iter_iter_rev = List[Long]()\n        var test_list_iter_iter_iter_iter_iter_iter_iter_rev_iter\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122706,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpmgbmq154.scala:31:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmgbmq154.scala:31:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: collection.mutable.Map[Long, Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmgbmq154.scala:33:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmgbmq154.scala:34:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmgbmq154.scala:35:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while(i < test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).toLong - 48) -> (test_tup.toString.charAt(i + 1).toLong - 48)\n            i += 1\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122706,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpremde_pg.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpremde_pg.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpremde_pg.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val tup = (1L to test_tup).toList\n        val tup_map = tup.grouped(2).map{case List(x,y) => (x,y)}.toMap\n        return tup_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122707,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmplao2o_4e.scala:8:15 ---------------------\u001b[0m\u001b[0m\n\u001b[31m8 |\u001b[0m        \u001b[33mreturn\u001b[0m tup_map\n\u001b[31m\u001b[31m  |\u001b[0m               ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m               Found:    (tup_map : Map[Long, Long])\n\u001b[31m  |\u001b[0m               Required: collection.mutable.Map[Long, Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmplao2o_4e.scala:11:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmplao2o_4e.scala:12:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmplao2o_4e.scala:13:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_tup_list = test_tup.toString.toList\n        for (i <- 0 until test_tup_list.length - 1) {\n            test_map += (test_tup_list(i).toString.toLong -> test_tup_list(i + 1).toString.toLong)\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122706,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwblk3kii.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwblk3kii.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwblk3kii.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_list = List[Long]()\n        var temp = test_tup\n        while(temp > 0) {\n            test_list = (temp % 10) :: test_list\n            temp = temp / 10\n        }\n        for(i <- 0 until test_list.length - 1) {\n            test_map += (test_list(i) -> test_list(i + 1))\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122706,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpuw_r_90j.scala:19:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpuw_r_90j.scala:20:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpuw_r_90j.scala:21:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var dict = Map[Long,Long]()\n        for (i <- 0 to test_tup.toString.length - 2) {\n            dict += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n        }\n        return dict\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122706,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmptyy7464h.scala:13:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmptyy7464h.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmptyy7464h.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val tup_list = test_tup.toString.toList.map(_.asDigit.toLong)\n        val tup_list_pairs = tup_list.sliding(2,2).toList\n        val tup_list_pairs_map = tup_list_pairs.map(x => (x(0),x(1))).toMap\n        return tup_list_pairs_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122706,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2ii_wi4f.scala:9:15 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mreturn\u001b[0m tup_list_pairs_map\n\u001b[31m\u001b[31m  |\u001b[0m               ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m               Found:    (tup_list_pairs_map : Map[Long, Long])\n\u001b[31m  |\u001b[0m               Required: collection.mutable.Map[Long, Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2ii_wi4f.scala:12:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2ii_wi4f.scala:13:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2ii_wi4f.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_list = List[Long]()\n        var test_tup_list = List[Long]()\n        var test_tup_list_rev = List[Long]()\n        var test_tup_list_rev_rev = List[Long]()\n        var test_tup_list_rev_rev_rev = List[Long]()\n        var test_tup_list_rev_rev_rev_rev = List[Long]()\n        var test_tup_list_rev_rev_rev_rev_rev = List[Long]()\n        var test_tup_list_rev_rev_rev_rev_rev_rev = List[Long]()\n        var test_tup_list_rev_rev_rev_rev_rev_rev_rev = List[Long]()\n        var test_tup_list_rev_rev_rev_rev_rev_rev_rev_rev = List[Long]()\n        var test_tup_list_rev_rev_rev_rev_rev_rev_rev_rev_rev = List[Long]()\n        var test_tup_list_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev = List[Long]()\n        var test_tup_list_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev = List[Long]()\n        var test_tup_list_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev = List[Long]()\n        var test_tup_list_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev = List[Long]()\n        var test_tup_list_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev = List[Long]()\n        var test_tup_list_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev = List[Long]()\n        var test_t\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122707,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp6rdanerw.scala:25:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6rdanerw.scala:25:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: collection.mutable.Map[Long, Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6rdanerw.scala:27:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6rdanerw.scala:28:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6rdanerw.scala:29:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map : Map[Long,Long] = Map()\n        var test_list : List[Long] = List()\n        var test_num : Long = test_tup\n        while (test_num > 0) {\n            test_list = (test_num % 10) :: test_list\n            test_num /= 10\n        }\n        for (i <- 0 until test_list.length - 1) {\n            test_map += (test_list(i) -> test_list(i + 1))\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122707,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt42fy46y.scala:19:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt42fy46y.scala:20:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt42fy46y.scala:21:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var dict = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length - 1) {\n            dict += (test_tup.toString.charAt(i).toLong - 48) -> (test_tup.toString.charAt(i + 1).toLong - 48)\n            i += 1\n        }\n        dict\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwj73us0j.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwj73us0j.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwj73us0j.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).toLong -> test_tup.toString.charAt(i + 1).toLong)\n            i += 1\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpk9hgj9ec.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpk9hgj9ec.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpk9hgj9ec.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var dict = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length - 1) {\n            dict += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n            i += 1\n        }\n        dict\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122719,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpni2j8g08.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpni2j8g08.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpni2j8g08.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while(i < test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n            i += 1\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122690,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnj3d15ct.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnj3d15ct.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnj3d15ct.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val tup = (1L to test_tup).toList\n        val tup_pairs = tup.zip(tup.tail)\n        val tup_dict = tup_pairs.toMap\n        tup_dict\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122720,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpakt7pjcm.scala:9:8 ----------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        tup_dict\n\u001b[31m\u001b[31m  |\u001b[0m        ^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m        Found:    (tup_dict : Map[Long, Long])\n\u001b[31m  |\u001b[0m        Required: collection.mutable.Map[Long, Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpakt7pjcm.scala:12:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpakt7pjcm.scala:13:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpakt7pjcm.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var dict = Map[Long,Long]()\n        var i = 0\n        while(i < test_tup.toString.length - 1) {\n            dict += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n            i += 1\n        }\n        dict\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122720,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv9ml5d9i.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv9ml5d9i.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv9ml5d9i.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var res = Map[Long,Long]()\n        var i = 0\n        while(i < test_tup.toString.length - 1) {\n            res += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n            i += 1\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122719,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp83ahvsmw.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp83ahvsmw.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp83ahvsmw.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while(i < test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n            i += 1\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122690,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnj3d15ct.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnj3d15ct.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnj3d15ct.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var tup_list = List[Long]()\n        var tup_list_rev = List[Long]()\n        var tup_list_rev_rev = List[Long]()\n        var tup_list_rev_rev_rev = List[Long]()\n        var tup_list_rev_rev_rev_rev = List[Long]()\n        var tup_list_rev_rev_rev_rev_rev = List[Long]()\n        var tup_list_rev_rev_rev_rev_rev_rev = List[Long]()\n        var tup_list_rev_rev_rev_rev_rev_rev_rev = List[Long]()\n        var tup_list_rev_rev_rev_rev_rev_rev_rev_rev = List[Long]()\n        var tup_list_rev_rev_rev_rev_rev_rev_rev_rev_rev = List[Long]()\n        var tup_list_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev = List[Long]()\n        var tup_list_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev = List[Long]()\n        var tup_list_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev = List[Long]()\n        var tup_list_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev = List[Long]()\n        var tup_list_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev = List[Long]()\n        var tup_list_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev = List[Long]()\n        var tup_list_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev = List[Long]()\n        var tup\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122720,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpuxf383qx.scala:25:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpuxf383qx.scala:25:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: collection.mutable.Map[Long, Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpuxf383qx.scala:27:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpuxf383qx.scala:28:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpuxf383qx.scala:29:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val tup_list = test_tup.toString.map(_.asDigit).toList\n        val tup_list_pairs = tup_list.sliding(2).toList\n        val tup_list_pairs_map = tup_list_pairs.map(x => (x(0).toLong, x(1).toLong)).toMap\n        return tup_list_pairs_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122722,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp47y27974.scala:9:15 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mreturn\u001b[0m tup_list_pairs_map\n\u001b[31m\u001b[31m  |\u001b[0m               ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m               Found:    (tup_list_pairs_map : Map[Long, Long])\n\u001b[31m  |\u001b[0m               Required: collection.mutable.Map[Long, Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp47y27974.scala:12:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp47y27974.scala:13:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp47y27974.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val tup = (1L to test_tup).toList\n        val dict = Map[Long,Long]()\n        for (i <- 0 until tup.length - 1) {\n            dict += (tup(i) -> tup(i + 1))\n        }\n        dict\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp36gq662f.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp36gq662f.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp36gq662f.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 1\n        while (i < test_tup) {\n            test_map += (i -> (i+1))\n            i += 2\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122721,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwruc8xi2.scala:9:25 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m            test_map += (i -> (i+\u001b[31m1\u001b[0m))\n\u001b[31m\u001b[31m  |\u001b[0m                         ^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                         Found:    (Int, Int)\n\u001b[31m  |\u001b[0m                         Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwruc8xi2.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwruc8xi2.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwruc8xi2.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_list = List[Long]()\n        var temp = test_tup\n        while(temp > 0) {\n            test_list = (temp % 10) :: test_list\n            temp /= 10\n        }\n        for(i <- 0 until test_list.length - 1) {\n            test_map += (test_list(i) -> test_list(i + 1))\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122706,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_sc2npqs.scala:19:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_sc2npqs.scala:20:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_sc2npqs.scala:21:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_list = List[Long]()\n        var test_num = test_tup\n        while (test_num > 0) {\n            test_list = (test_num % 10) :: test_list\n            test_num /= 10\n        }\n        for (i <- 0 until test_list.length - 1) {\n            test_map += (test_list(i) -> test_list(i + 1))\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122705,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_6nrk2e_.scala:19:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_6nrk2e_.scala:20:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_6nrk2e_.scala:21:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).toLong -> test_tup.toString.charAt(i + 1).toLong)\n            i += 1\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpk9hgj9ec.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpk9hgj9ec.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpk9hgj9ec.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_list = List[Long]()\n        var test_tup_list = List[Long]()\n        var i = 0\n        while(test_tup > 0) {\n            test_tup_list = (test_tup % 10) :: test_tup_list\n            test_tup = test_tup / 10\n        }\n        while(i < test_tup_list.length) {\n            test_map += (test_tup_list(i) -> test_tup_list(i+1))\n            i += 2\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122721,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpx701lpxr.scala:12:21 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            test_tup = test_tup / \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val test_tup\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpx701lpxr.scala:21:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpx701lpxr.scala:22:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpx701lpxr.scala:23:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_list = List[Long]()\n        var i = 0\n        while (test_tup > 0) {\n            test_list = (test_tup % 10) :: test_list\n            test_tup = test_tup / 10\n        }\n        while (i < test_list.length - 1) {\n            test_map += (test_list(i) -> test_list(i + 1))\n            i += 1\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122721,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpds8zvaal.scala:11:21 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            test_tup = test_tup / \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val test_tup\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpds8zvaal.scala:20:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpds8zvaal.scala:21:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpds8zvaal.scala:22:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val tup = (1L to test_tup).toList\n        val tup_pairs = tup.sliding(2).toList\n        val tup_pairs_map = tup_pairs.map(x => (x(0), x(1))).toMap\n        return tup_pairs_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122722,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt5tnnks7.scala:9:15 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mreturn\u001b[0m tup_pairs_map\n\u001b[31m\u001b[31m  |\u001b[0m               ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m               Found:    (tup_pairs_map : Map[Long, Long])\n\u001b[31m  |\u001b[0m               Required: collection.mutable.Map[Long, Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt5tnnks7.scala:12:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt5tnnks7.scala:13:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt5tnnks7.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var map = Map[Long,Long]()\n        var i = 0\n        while(i < test_tup.toString.length - 1) {\n            map += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n            i += 1\n        }\n        map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122721,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2c81kf4l.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2c81kf4l.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2c81kf4l.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_list = List[Long]()\n        var temp = test_tup\n        while(temp > 0) {\n            test_list = (temp % 10) :: test_list\n            temp /= 10\n        }\n        for(i <- 0 until test_list.length - 1) {\n            test_map += (test_list(i) -> test_list(i + 1))\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122706,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_sc2npqs.scala:19:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_sc2npqs.scala:20:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_sc2npqs.scala:21:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var dict = Map[Long,Long]()\n        var tup = test_tup\n        var i = 0\n        while(tup > 0) {\n            var rem = tup % 10\n            tup = tup / 10\n            if(i % 2 == 0) {\n                dict += (rem -> 0)\n            } else {\n                dict(rem) = dict(rem) + 1\n            }\n            i += 1\n        }\n        return dict\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122722,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpckhhodpy.scala:22:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpckhhodpy.scala:23:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpckhhodpy.scala:24:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val tup = (1 to test_tup.toInt).toList\n        val tup_pairs = tup.sliding(2).toList\n        val tup_dict = tup_pairs.map(x => (x(0),x(1))).toMap\n        return tup_dict\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122722,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmptetknerr.scala:9:15 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mreturn\u001b[0m tup_dict\n\u001b[31m\u001b[31m  |\u001b[0m               ^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m               Found:    (tup_dict : Map[Int, Int])\n\u001b[31m  |\u001b[0m               Required: collection.mutable.Map[Long, Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmptetknerr.scala:12:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmptetknerr.scala:13:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmptetknerr.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        for (i <- 0 to test_tup.toString.length - 2) {\n            test_map += (test_tup.toString.charAt(i).toString.toLong -> test_tup.toString.charAt(i + 1).toString.toLong)\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122722,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcc6oqzwx.scala:13:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcc6oqzwx.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcc6oqzwx.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_tup_list = test_tup.toString.toList.map(_.toString.toLong)\n        for (i <- 0 until test_tup_list.length - 1) {\n            test_map += (test_tup_list(i) -> test_tup_list(i+1))\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122722,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmps3d0rdgo.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmps3d0rdgo.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmps3d0rdgo.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while(i < test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n            i += 1\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122690,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnj3d15ct.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnj3d15ct.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnj3d15ct.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while(i < test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).toLong -> test_tup.toString.charAt(i + 1).toLong)\n            i += 1\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122690,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppnvu65df.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppnvu65df.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppnvu65df.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val tup = test_tup.toString.map(_.asDigit).toList\n        val tup_len = tup.length\n        val tup_map = Map[Long,Long]()\n        for (i <- 0 until tup_len - 1) {\n            tup_map += (tup(i).toLong -> tup(i + 1).toLong)\n        }\n        tup_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122721,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnmoxapre.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnmoxapre.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnmoxapre.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length) {\n            test_map += (test_tup.toString.charAt(i).toString.toLong -> test_tup.toString.charAt(i+1).toString.toLong)\n            i += 2\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122721,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppn_u5ocn.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppn_u5ocn.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppn_u5ocn.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while(i < test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).toLong -> test_tup.toString.charAt(i+1).toLong)\n            i += 1\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122722,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpk9fr3bs0.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpk9fr3bs0.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpk9fr3bs0.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length) {\n            if (i == test_tup.toString.length - 1) {\n                test_map += (test_tup.toString.charAt(i).toLong -> 0)\n            } else {\n                test_map += (test_tup.toString.charAt(i).toLong -> test_tup.toString.charAt(i + 1).toLong)\n            }\n            i += 1\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122722,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpvnn004e1.scala:19:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpvnn004e1.scala:20:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpvnn004e1.scala:21:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val test_tup_list = test_tup.toString.toList.map(_.toString.toLong)\n        val test_tup_list_pairs = test_tup_list.grouped(2).toList\n        val test_tup_list_pairs_map = test_tup_list_pairs.map(x => (x(0),x(1))).toMap\n        return test_tup_list_pairs_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122722,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpppxznv_d.scala:9:15 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mreturn\u001b[0m test_tup_list_pairs_map\n\u001b[31m\u001b[31m  |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m               Found:    (test_tup_list_pairs_map : Map[Long, Long])\n\u001b[31m  |\u001b[0m               Required: collection.mutable.Map[Long, Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpppxznv_d.scala:12:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpppxznv_d.scala:13:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpppxznv_d.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_list = List[Long]()\n        var test_list_rev = List[Long]()\n        var test_list_rev_map = List[Long]()\n        var test_list_rev_map_rev = List[Long]()\n        var test_list_rev_map_rev_map = List[Long]()\n        var test_list_rev_map_rev_map_rev = List[Long]()\n        var test_list_rev_map_rev_map_rev_map = List[Long]()\n        var test_list_rev_map_rev_map_rev_map_rev = List[Long]()\n        var test_list_rev_map_rev_map_rev_map_rev_map = List[Long]()\n        var test_list_rev_map_rev_map_rev_map_rev_map_rev = List[Long]()\n        var test_list_rev_map_rev_map_rev_map_rev_map_rev_map = List[Long]()\n        var test_list_rev_map_rev_map_rev_map_rev_map_rev_map_rev = List[Long]()\n        var test_list_rev_map_rev_map_rev_map_rev_map_rev_map_rev_map = List[Long]()\n        var test_list_rev_map_rev_map_rev_map_rev_map_rev_map_rev_map_rev = List[Long]()\n        var test_list_rev_map_rev_map_rev_map_rev_map_rev_map_rev_map_rev_map = List[Long]()\n        var test_list_rev_map_rev_map_rev_map_rev_map_rev_map_rev_map_rev_map_rev = List[Long]()\n        var test_list_rev_map_rev_map_rev_map_rev_map_rev_map_rev_map_rev_map_rev_map = List[Long]()\n        var test_list_rev_map_rev_map_rev_map_rev_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122722,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpvdurdria.scala:25:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpvdurdria.scala:25:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: collection.mutable.Map[Long, Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpvdurdria.scala:27:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpvdurdria.scala:28:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpvdurdria.scala:29:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        for (i <- 0 until test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122722,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjv2qokfb.scala:13:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjv2qokfb.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjv2qokfb.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_tup_list = test_tup.toString.toList.map(_.toString.toLong)\n        for (i <- 0 to test_tup_list.length - 2) {\n            test_map += (test_tup_list(i) -> test_tup_list(i+1))\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122723,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpxa9na6yb.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpxa9na6yb.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpxa9na6yb.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString().length - 1) {\n            test_map += (test_tup.toString()(i).toString().toLong -> test_tup.toString()(i + 1).toString().toLong)\n            i += 1\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122734,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpon8ovdh6.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpon8ovdh6.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpon8ovdh6.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_list = List[Long]()\n        var test_num = test_tup\n        while (test_num > 0) {\n            test_list = (test_num % 10) :: test_list\n            test_num /= 10\n        }\n        for (i <- 0 until test_list.length - 1) {\n            test_map += (test_list(i) -> test_list(i + 1))\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjwpuewvt.scala:19:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjwpuewvt.scala:20:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjwpuewvt.scala:21:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        for (i <- 0 to test_tup.toString.length - 1) {\n            if (i == test_tup.toString.length - 1) {\n                test_map += (test_tup.toString.charAt(i).toLong -> 0)\n            }\n            else {\n                test_map += (test_tup.toString.charAt(i).toLong -> test_tup.toString.charAt(i + 1).toLong)\n            }\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122736,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpgcrwqr3n.scala:19:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpgcrwqr3n.scala:20:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpgcrwqr3n.scala:21:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val tup_list = test_tup.toString.toList.map(_.toString.toLong)\n        val tup_list_pairs = tup_list.sliding(2,2).toList\n        val tup_list_pairs_map = tup_list_pairs.map(x => (x(0),x(1))).toMap\n        tup_list_pairs_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122735,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8igzxpav.scala:9:8 ----------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        tup_list_pairs_map\n\u001b[31m\u001b[31m  |\u001b[0m        ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m        Found:    (tup_list_pairs_map : Map[Long, Long])\n\u001b[31m  |\u001b[0m        Required: collection.mutable.Map[Long, Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8igzxpav.scala:12:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8igzxpav.scala:13:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8igzxpav.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var dict = Map[Long,Long]()\n        var i = 0\n        while(i < test_tup.toString.length - 1) {\n            dict += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n            i += 1\n        }\n        dict\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122720,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv9ml5d9i.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv9ml5d9i.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv9ml5d9i.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while(i < test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n            i += 1\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122690,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnj3d15ct.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnj3d15ct.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnj3d15ct.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString().length - 1) {\n            test_map += (test_tup.toString()(i).asDigit.toLong -> test_tup.toString()(i + 1).asDigit.toLong)\n            i += 1\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122736,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpi27jubml.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpi27jubml.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpi27jubml.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val tup = (1L to test_tup).toList\n        val tup_len = tup.length\n        val tup_dict = Map[Long,Long]()\n        for (i <- 0 until tup_len - 1) {\n            tup_dict += (tup(i) -> tup(i+1))\n        }\n        tup_dict\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122736,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppjhzq_ys.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppjhzq_ys.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppjhzq_ys.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var dict = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length - 1) {\n            dict += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n            i += 1\n        }\n        dict\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122719,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpni2j8g08.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpni2j8g08.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpni2j8g08.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).toLong -> test_tup.toString.charAt(i + 1).toLong)\n            i += 1\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpk9hgj9ec.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpk9hgj9ec.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpk9hgj9ec.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_dict = Map[Long,Long]()\n        var test_tup_list = test_tup.toString.toList.map(_.toString.toLong)\n        for (i <- 0 until test_tup_list.length - 1) {\n            test_dict += (test_tup_list(i) -> test_tup_list(i+1))\n        }\n        return test_dict\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122735,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpshofbb3c.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpshofbb3c.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpshofbb3c.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val tup_list = test_tup.toString.toList.map(_.toString.toLong)\n        val tup_list_pairs = tup_list.sliding(2,1).toList\n        val tup_list_pairs_map = tup_list_pairs.map(x => (x.head, x.last)).toMap\n        return tup_list_pairs_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122737,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpq4el82g_.scala:9:15 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mreturn\u001b[0m tup_list_pairs_map\n\u001b[31m\u001b[31m  |\u001b[0m               ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m               Found:    (tup_list_pairs_map : Map[Long, Long])\n\u001b[31m  |\u001b[0m               Required: collection.mutable.Map[Long, Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpq4el82g_.scala:12:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpq4el82g_.scala:13:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpq4el82g_.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_dict = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length) {\n            if (i == test_tup.toString.length - 1) {\n                test_dict += (test_tup.toString.charAt(i).asDigit.toLong -> 0)\n            } else {\n                test_dict += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n            }\n            i += 1\n        }\n        return test_dict\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122737,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmplqp95xus.scala:19:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmplqp95xus.scala:20:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmplqp95xus.scala:21:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val tup = (1 to test_tup).toList\n        val tup_map = tup.sliding(2).map(x => (x(0),x(1))).toMap\n        return tup_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122737,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpc3lwtyao.scala:6:24 ---------------------\u001b[0m\u001b[0m\n\u001b[31m6 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mtup\u001b[0m = (\u001b[31m1\u001b[0m to test_tup).toList\n\u001b[31m\u001b[31m  |\u001b[0m                        ^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                        Found:    (test_tup : Long)\n\u001b[31m  |\u001b[0m                        Required: Int\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpc3lwtyao.scala:8:15 ---------------------\u001b[0m\u001b[0m\n\u001b[31m8 |\u001b[0m        \u001b[33mreturn\u001b[0m tup_map\n\u001b[31m\u001b[31m  |\u001b[0m               ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m               Found:    (tup_map : Map[Int, Int])\n\u001b[31m  |\u001b[0m               Required: collection.mutable.Map[Long, Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpc3lwtyao.scala:11:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpc3lwtyao.scala:12:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_list = List[Long]()\n        var test_list_rev = List[Long]()\n        var test_list_rev_final = List[Long]()\n        var test_list_final = List[Long]()\n        var test_list_final_rev = List[Long]()\n        var test_list_final_rev_final = List[Long]()\n        var test_list_final_final = List[Long]()\n        var test_list_final_final_rev = List[Long]()\n        var test_list_final_final_rev_final = List[Long]()\n        var test_list_final_final_final = List[Long]()\n        var test_list_final_final_final_rev = List[Long]()\n        var test_list_final_final_final_rev_final = List[Long]()\n        var test_list_final_final_final_final = List[Long]()\n        var test_list_final_final_final_final_rev = List[Long]()\n        var test_list_final_final_final_final_rev_final = List[Long]()\n        var test_list_final_final_final_final_final = List[Long]()\n        var test_list_final_final_final_final_final_rev = List[Long]()\n        var test_list_final_final_final_final_final_rev_final = List[Long]()\n        var test_list_final_final_final_final_final_final = List[Long]()\n        var test_list_final_final_final_final_final_final_rev = List[Long]()\n        var test_list_final_final_final_final_final_final_rev_final = List[Long]()\n        var test_list_final_final_final_final_final_final_final = List[Long]()\n        var test_list_final_final_final_final_final_final_final_rev = List[Long]()\n        var test_list_final_final_final_final_final_final_final_rev_final\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122738,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpddkxdquz.scala:31:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpddkxdquz.scala:31:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: collection.mutable.Map[Long, Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpddkxdquz.scala:33:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpddkxdquz.scala:34:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpddkxdquz.scala:35:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n            i += 1\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2xn0sr7.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2xn0sr7.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2xn0sr7.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).toLong -> test_tup.toString.charAt(i + 1).toLong)\n            i += 1\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpk9hgj9ec.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpk9hgj9ec.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpk9hgj9ec.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while(i < test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n            i += 1\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122690,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnj3d15ct.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnj3d15ct.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnj3d15ct.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_dict = Map[Long,Long]()\n        val test_list = test_tup.toString.toList.map(_.toString.toLong)\n        for (i <- 0 until test_list.length - 1) {\n            test_dict += (test_list(i) -> test_list(i + 1))\n        }\n        return test_dict\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122737,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjwypd9nn.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjwypd9nn.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjwypd9nn.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var dict = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length - 1) {\n            dict += (test_tup.toString.charAt(i).toLong -> test_tup.toString.charAt(i + 1).toLong)\n            i += 1\n        }\n        dict\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122737,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0fdiuo9i.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0fdiuo9i.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0fdiuo9i.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_list = List[Long]()\n        var test_tup_list = test_tup.toString.toList.map(x => x.toString.toLong)\n        for (i <- 0 until test_tup_list.length) {\n            if (i % 2 == 0) {\n                test_map += (test_tup_list(i) -> test_tup_list(i+1))\n            }\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122738,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6_e8va2g.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6_e8va2g.scala:18:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6_e8va2g.scala:19:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val tup_list = List(test_tup)\n        val tup_list_len = tup_list.length\n        val tup_list_range = 0 until tup_list_len\n        val tup_list_range_pairs = tup_list_range.sliding(2,1)\n        val tup_list_range_pairs_list = tup_list_range_pairs.toList\n        val tup_list_range_pairs_list_map = tup_list_range_pairs_list.map(x => (x(0),x(1)))\n        val tup_list_range_pairs_list_map_dict = tup_list_range_pairs_list_map.toMap\n        return tup_list_range_pairs_list_map_dict\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122738,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpf9av86vr.scala:13:15 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mreturn\u001b[0m tup_list_range_pairs_list_map_dict\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          Found:    (tup_list_range_pairs_list_map_dict : Map[Int, Int])\n\u001b[31m   |\u001b[0m          Required: collection.mutable.Map[Long, Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpf9av86vr.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpf9av86vr.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpf9av86vr.scala:18:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val tup = test_tup.toString.map(_.asDigit).toList\n        val tup_len = tup.length\n        val tup_map = Map[Long,Long]()\n        for (i <- 0 until tup_len - 1) {\n            tup_map(tup(i)) = tup(i + 1)\n        }\n        tup_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122738,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt4xi2fga.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt4xi2fga.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt4xi2fga.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val test_tup_list = test_tup.toString.toList.map(_.toString.toLong)\n        val test_tup_list_pairs = test_tup_list.zip(test_tup_list.tail)\n        val test_tup_dict = test_tup_list_pairs.toMap\n        return test_tup_dict\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpgw_kmhwn.scala:9:15 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mreturn\u001b[0m test_tup_dict\n\u001b[31m\u001b[31m  |\u001b[0m               ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m               Found:    (test_tup_dict : Map[Long, Long])\n\u001b[31m  |\u001b[0m               Required: collection.mutable.Map[Long, Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpgw_kmhwn.scala:12:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpgw_kmhwn.scala:13:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpgw_kmhwn.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_tup_list = test_tup.toString.toList.map(_.toString.toLong)\n        for (i <- 0 to test_tup_list.length - 2) {\n            test_map += (test_tup_list(i) -> test_tup_list(i + 1))\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122738,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp61b7ui7x.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp61b7ui7x.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp61b7ui7x.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        var j = 1\n        while(j < test_tup.toString.length) {\n            test_map += (test_tup.toString.charAt(i).toLong -> test_tup.toString.charAt(j).toLong)\n            i += 2\n            j += 2\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122738,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkdcli8n3.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkdcli8n3.scala:18:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkdcli8n3.scala:19:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val tup = (1 to test_tup.toInt).toList\n        val tup_map = tup.sliding(2).map(x => (x(0),x(1))).toMap\n        tup_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122738,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpblh2y1z3.scala:8:8 ----------------------\u001b[0m\u001b[0m\n\u001b[31m8 |\u001b[0m        tup_map\n\u001b[31m\u001b[31m  |\u001b[0m        ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m        Found:    (tup_map : Map[Int, Int])\n\u001b[31m  |\u001b[0m        Required: collection.mutable.Map[Long, Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpblh2y1z3.scala:11:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpblh2y1z3.scala:12:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpblh2y1z3.scala:13:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_list = List[Long]()\n        var temp = test_tup\n        while (temp > 0) {\n            test_list = (temp % 10) :: test_list\n            temp /= 10\n        }\n        for (i <- 0 until test_list.length - 1) {\n            test_map += (test_list(i) -> test_list(i + 1))\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122737,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp24ueswhn.scala:19:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp24ueswhn.scala:20:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp24ueswhn.scala:21:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_list = List[Long]()\n        var i = 0\n        while (test_tup > 0) {\n            test_list = (test_tup % 10) :: test_list\n            test_tup /= 10\n        }\n        while (i < test_list.length - 1) {\n            test_map += (test_list(i) -> test_list(i + 1))\n            i += 1\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122738,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpm4y0a4y7.scala:11:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            test_tup /= \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value /= is not a member of Long - did you mean test_tup.!=?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpm4y0a4y7.scala:20:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpm4y0a4y7.scala:21:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpm4y0a4y7.scala:22:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Lo",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 1\n        while (i < test_tup.toString.length) {\n            test_map += (test_tup.toString.charAt(i-1).asDigit.toLong -> test_tup.toString.charAt(i).asDigit.toLong)\n            i += 2\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122738,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpyjbzzazo.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpyjbzzazo.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpyjbzzazo.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val test_tup_list = test_tup.toString.toList.map(_.asDigit.toLong)\n        val test_tup_list_pairs = test_tup_list.sliding(2).toList\n        val test_tup_list_pairs_map = test_tup_list_pairs.map(x => (x(0),x(1))).toMap\n        return test_tup_list_pairs_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprvkgg1pt.scala:9:15 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mreturn\u001b[0m test_tup_list_pairs_map\n\u001b[31m\u001b[31m  |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m               Found:    (test_tup_list_pairs_map : Map[Long, Long])\n\u001b[31m  |\u001b[0m               Required: collection.mutable.Map[Long, Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprvkgg1pt.scala:12:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprvkgg1pt.scala:13:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprvkgg1pt.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_list = List[Long]()\n        var temp = test_tup\n        while (temp > 0) {\n            test_list = (temp % 10) :: test_list\n            temp /= 10\n        }\n        for (i <- 0 until test_list.length - 1) {\n            test_map += (test_list(i) -> test_list(i + 1))\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122737,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp24ueswhn.scala:19:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp24ueswhn.scala:20:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp24ueswhn.scala:21:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var tup_list = test_tup.toString.toList\n        for (i <- 0 until tup_list.length - 1) {\n            test_map += (tup_list(i).asDigit.toLong -> tup_list(i + 1).asDigit.toLong)\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122738,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpvfwsvp9c.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpvfwsvp9c.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpvfwsvp9c.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).toString.toLong -> test_tup.toString.charAt(i + 1).toString.toLong)\n            i += 1\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122738,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpf78pkwzg.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpf78pkwzg.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpf78pkwzg.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var res : Map[Long,Long] = Map()\n        var i : Long = 0\n        while (i < test_tup) {\n            res += (i -> (i + 1))\n            i += 1\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122749,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprv2u95c7.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprv2u95c7.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprv2u95c7.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val tup_list = test_tup.toString.toList.map(_.asDigit.toLong)\n        val tup_list_pairs = tup_list.sliding(2,2).toList\n        val tup_list_pairs_map = tup_list_pairs.map(x => (x(0), x(1))).toMap\n        return tup_list_pairs_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122751,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpowvykkx2.scala:9:15 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mreturn\u001b[0m tup_list_pairs_map\n\u001b[31m\u001b[31m  |\u001b[0m               ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m               Found:    (tup_list_pairs_map : Map[Long, Long])\n\u001b[31m  |\u001b[0m               Required: collection.mutable.Map[Long, Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpowvykkx2.scala:12:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpowvykkx2.scala:13:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpowvykkx2.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val test_tup_list = test_tup.toString.map(_.asDigit).toList\n        val test_tup_list_pairs = test_tup_list.sliding(2).toList\n        val test_tup_list_pairs_map = test_tup_list_pairs.map(x => (x(0).toLong, x(1).toLong)).toMap\n        return test_tup_list_pairs_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122752,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp10i72a_b.scala:9:15 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mreturn\u001b[0m test_tup_list_pairs_map\n\u001b[31m\u001b[31m  |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m               Found:    (test_tup_list_pairs_map : Map[Long, Long])\n\u001b[31m  |\u001b[0m               Required: collection.mutable.Map[Long, Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp10i72a_b.scala:12:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp10i72a_b.scala:13:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp10i72a_b.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val tup = test_tup.toString.map(_.asDigit).toList\n        val tup_len = tup.length\n        var i = 0\n        var dict = Map[Long,Long]()\n        while (i < tup_len - 1) {\n            dict += (tup(i) -> tup(i + 1))\n            i += 1\n        }\n        dict\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122750,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpgbzvj7y9.scala:11:21 --------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            dict += (tup(i) -> tup(i + \u001b[31m1\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Found:    (Int, Int)\n\u001b[31m   |\u001b[0m                     Required: (Long, Long)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpgbzvj7y9.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpgbzvj7y9.scala:18:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpgbzvj7y9.scala:19:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val tup = (1L to test_tup).toList\n        val dict = Map[Long,Long]()\n        for (i <- 0 until tup.length - 1) {\n            dict += (tup(i) -> tup(i + 1))\n        }\n        dict\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp36gq662f.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp36gq662f.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp36gq662f.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n            i += 1\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2xn0sr7.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2xn0sr7.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2xn0sr7.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map : Map[Long,Long] = Map()\n        var test_list : List[Long] = List()\n        var test_list_rev : List[Long] = List()\n        var test_list_rev_2 : List[Long] = List()\n        var test_list_rev_3 : List[Long] = List()\n        var test_list_rev_4 : List[Long] = List()\n        var test_list_rev_5 : List[Long] = List()\n        var test_list_rev_6 : List[Long] = List()\n        var test_list_rev_7 : List[Long] = List()\n        var test_list_rev_8 : List[Long] = List()\n        var test_list_rev_9 : List[Long] = List()\n        var test_list_rev_10 : List[Long] = List()\n        var test_list_rev_11 : List[Long] = List()\n        var test_list_rev_12 : List[Long] = List()\n        var test_list_rev_13 : List[Long] = List()\n        var test_list_rev_14 : List[Long] = List()\n        var test_list_rev_15 : List[Long] = List()\n        var test_list_rev_16 : List[Long] = List()\n        var test_list_rev_17 : List[Long] = List()\n        var test_list_rev_18 : List[Long] = List()\n        var test_list_rev_19 : List[Long] = List()\n        var test_list_rev_20 : List[Long] = List()\n        var test_list_rev_21 : List[Long] = List()\n        var test_list_rev_22 : List[Long] = List()\n        var test_list_rev_23 : List[Long] = List()\n        var test_list_rev_24 : List[Long] = List()\n        var test_list_rev_25 : List[Long] = List()\n        var test_list_rev_26 : List[Long] = List()\n        var test_list_rev_27 : List[Long] =\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122751,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp_f0qffaf.scala:34:43 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mtest_list_rev_27\u001b[0m : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m] =\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_f0qffaf.scala:35:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: collection.mutable.Map[Long, Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_f0qffaf.scala:37:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_f0qffaf.scala:38:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explai",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_list = List[Long]()\n        var test_list_rev = List[Long]()\n        var test_list_rev_2 = List[Long]()\n        var test_list_rev_3 = List[Long]()\n        var test_list_rev_4 = List[Long]()\n        var test_list_rev_5 = List[Long]()\n        var test_list_rev_6 = List[Long]()\n        var test_list_rev_7 = List[Long]()\n        var test_list_rev_8 = List[Long]()\n        var test_list_rev_9 = List[Long]()\n        var test_list_rev_10 = List[Long]()\n        var test_list_rev_11 = List[Long]()\n        var test_list_rev_12 = List[Long]()\n        var test_list_rev_13 = List[Long]()\n        var test_list_rev_14 = List[Long]()\n        var test_list_rev_15 = List[Long]()\n        var test_list_rev_16 = List[Long]()\n        var test_list_rev_17 = List[Long]()\n        var test_list_rev_18 = List[Long]()\n        var test_list_rev_19 = List[Long]()\n        var test_list_rev_20 = List[Long]()\n        var test_list_rev_21 = List[Long]()\n        var test_list_rev_22 = List[Long]()\n        var test_list_rev_23 = List[Long]()\n        var test_list_rev_24 = List[Long]()\n        var test_list_rev_25 = List[Long]()\n        var test_list_rev_26 = List[Long]()\n        var test_list_rev_27 = List[Long]()\n        var test_list_rev_28 = List[Long]()\n        var test_list_rev_29 = List[Long]()\n        var test_list_rev_30 = List[Long]()\n        var test_list_rev\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122690,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpv5no3qae.scala:39:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv5no3qae.scala:39:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: collection.mutable.Map[Long, Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv5no3qae.scala:41:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv5no3qae.scala:42:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv5no3qae.scala:43:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var map = Map[Long,Long]()\n        var i = 0\n        while(i < test_tup.toString.length) {\n            if(i == test_tup.toString.length - 1) {\n                map += (test_tup.toString.charAt(i).toLong -> 0)\n            } else {\n                map += (test_tup.toString.charAt(i).toLong -> test_tup.toString.charAt(i + 1).toLong)\n            }\n            i += 1\n        }\n        return map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122750,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpw_4c96qi.scala:19:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpw_4c96qi.scala:20:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpw_4c96qi.scala:21:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while(i < test_tup.toString.length - 1) {\n            test_map += test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong\n            i += 1\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122751,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprqq6m8vq.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprqq6m8vq.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprqq6m8vq.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val tup = (1L to test_tup).toList\n        val tup_map = tup.sliding(2).map(x => (x(0), x(1))).toMap\n        return tup_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122754,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpvgac30_1.scala:8:15 ---------------------\u001b[0m\u001b[0m\n\u001b[31m8 |\u001b[0m        \u001b[33mreturn\u001b[0m tup_map\n\u001b[31m\u001b[31m  |\u001b[0m               ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m               Found:    (tup_map : Map[Long, Long])\n\u001b[31m  |\u001b[0m               Required: collection.mutable.Map[Long, Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpvgac30_1.scala:11:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpvgac30_1.scala:12:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpvgac30_1.scala:13:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var dict = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length - 1) {\n            dict += (test_tup.toString.charAt(i).toLong - 48) -> (test_tup.toString.charAt(i + 1).toLong - 48)\n            i += 1\n        }\n        dict\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwj73us0j.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwj73us0j.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwj73us0j.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val tup = (1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L, 12L, 13L, 14L, 15L, 16L, 17L, 18L, 19L, 20L, 21L, 22L, 23L, 24L, 25L, 26L, 27L, 28L, 29L, 30L, 31L, 32L, 33L, 34L, 35L, 36L, 37L, 38L, 39L, 40L, 41L, 42L, 43L, 44L, 45L, 46L, 47L, 48L, 49L, 50L, 51L, 52L, 53L, 54L, 55L, 56L, 57L, 58L, 59L, 60L, 61L, 62L, 63L, 64L, 65L, 66L, 67L, 68L, 69L, 70L, 71L, 72L, 73L, 74L, 75L, 76L, 77L, 78L, 79L, 80L, 81L, 82L, 83L, 84L, 85L, 86L, 87L, 88L, 89L, 90L, 91L, 92L, 93L, 94L, 95L, 96L, 97L, 98L, 99L, 100L, 101L, 102L, 103L, 104L, 105L, 106L, 107L, 108L, 109L, 110L, 111L, 112L, 113L, 114L, 115L, 116L, 117L, 118L, 119L, 120L, 121L, 122L, 123L, 124L, 125L, 126L, 127L, 128L, 129L, 130L, 131L, 132L, 133L, 134L, 135L, 136L, 137L, 138L, 139L, 140L, 141L, 142L, 143L, 144L, 145L, 146L, 147L, 148L, 149L, 150L, 151L, 152L, 153L, 154L, 155L, 156L, 157L, 158L, 159L, 160L, 161L, 162L, 163L, 164L, 165L, 166L, 167L, 168L, 169\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122752,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpd0xyf605.scala:7:4 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m7 |\u001b[0m    }\n\u001b[31m\u001b[31m  |\u001b[0m    ^\u001b[0m\n\u001b[31m  |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpd0xyf605.scala:7:5 ----------------------\u001b[0m\u001b[0m\n\u001b[31m7 |\u001b[0m    }\n\u001b[31m\u001b[31m  |\u001b[0m     ^\u001b[0m\n\u001b[31m  |\u001b[0m     Found:    Unit\n\u001b[31m  |\u001b[0m     Required: collection.mutable.Map[Long, Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpd0xyf605.scala:9:23 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m  |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m  |\u001b[0m                       Required: Long\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpd0xyf605.scala:10:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpd0xyf605.scala:11:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while(i < test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n            i += 1\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122690,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnj3d15ct.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnj3d15ct.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnj3d15ct.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_list = List[Long]()\n        var temp = test_tup\n        while(temp > 0) {\n            test_list = (temp % 10) :: test_list\n            temp /= 10\n        }\n        for(i <- 0 until test_list.length - 1) {\n            test_map += (test_list(i) -> test_list(i + 1))\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122753,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpvfvc2t1a.scala:19:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpvfvc2t1a.scala:20:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpvfvc2t1a.scala:21:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while(i < test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).toString.toLong -> test_tup.toString.charAt(i + 1).toString.toLong)\n            i += 1\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122751,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpp5y4ddwg.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpp5y4ddwg.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpp5y4ddwg.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while(i < test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n            i += 1\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpb79rx1v_.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpb79rx1v_.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpb79rx1v_.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_list = List[Long]()\n        var test_num = test_tup\n        while (test_num > 0) {\n            test_list = (test_num % 10) :: test_list\n            test_num /= 10\n        }\n        for (i <- 0 until test_list.length - 1) {\n            test_map += (test_list(i) -> test_list(i + 1))\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122705,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_6nrk2e_.scala:19:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_6nrk2e_.scala:20:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_6nrk2e_.scala:21:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_list = List[Long]()\n        var test_tup_list = test_tup.toString.toList.map(x => x.toString.toLong)\n        for (i <- 0 until test_tup_list.length) {\n            if (i % 2 == 0) {\n                test_list = test_list :+ test_tup_list(i)\n            } else {\n                test_list = test_list :+ test_tup_list(i)\n                test_map += (test_list(0) -> test_list(1))\n                test_list = List[Long]()\n            }\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122753,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp19fk_af2.scala:21:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp19fk_af2.scala:22:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp19fk_af2.scala:23:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_list = List[Long]()\n        var temp = test_tup\n        while(temp > 0) {\n            test_list = (temp % 10) :: test_list\n            temp /= 10\n        }\n        for(i <- 0 until test_list.length - 1) {\n            test_map += (test_list(i) -> test_list(i + 1))\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122706,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_sc2npqs.scala:19:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_sc2npqs.scala:20:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_sc2npqs.scala:21:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val tup = (1L to test_tup).toList\n        val tup_pairs = tup.sliding(2).toList\n        val tup_dict = tup_pairs.map(x => (x(0),x(1))).toMap\n        return tup_dict\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122754,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmqjplihw.scala:9:15 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mreturn\u001b[0m tup_dict\n\u001b[31m\u001b[31m  |\u001b[0m               ^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m               Found:    (tup_dict : Map[Long, Long])\n\u001b[31m  |\u001b[0m               Required: collection.mutable.Map[Long, Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmqjplihw.scala:12:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmqjplihw.scala:13:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmqjplihw.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        for (i <- 0 to test_tup.toString.length - 2) {\n            test_map += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122753,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpibgcp3o3.scala:13:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpibgcp3o3.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpibgcp3o3.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var dict = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length - 1) {\n            dict += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n            i += 1\n        }\n        dict\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122719,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpni2j8g08.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpni2j8g08.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpni2j8g08.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var result = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length - 1) {\n            result += (test_tup.toString.charAt(i).toString.toLong -> test_tup.toString.charAt(i + 1).toString.toLong)\n            i += 1\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122753,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv8tmks2h.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv8tmks2h.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv8tmks2h.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while(i < test_tup) {\n            test_map += (i -> (i+1))\n            i += 1\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122753,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfuag5lzq.scala:9:25 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m            test_map += (i -> (i+\u001b[31m1\u001b[0m))\n\u001b[31m\u001b[31m  |\u001b[0m                         ^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                         Found:    (Int, Int)\n\u001b[31m  |\u001b[0m                         Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfuag5lzq.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfuag5lzq.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfuag5lzq.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n            i += 1\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2xn0sr7.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2xn0sr7.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2xn0sr7.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_list = List[Long]()\n        var test_num = test_tup\n        while (test_num > 0) {\n            test_list = (test_num % 10) :: test_list\n            test_num /= 10\n        }\n        var test_list_len = test_list.length\n        for (i <- 0 until test_list_len - 1) {\n            test_map += (test_list(i) -> test_list(i + 1))\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122754,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpx_j6ph0m.scala:20:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpx_j6ph0m.scala:21:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpx_j6ph0m.scala:22:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_list = List[Long]()\n        var test_list_rev = List[Long]()\n        var test_list_rev_2 = List[Long]()\n        var test_list_rev_3 = List[Long]()\n        var test_list_rev_4 = List[Long]()\n        var test_list_rev_5 = List[Long]()\n        var test_list_rev_6 = List[Long]()\n        var test_list_rev_7 = List[Long]()\n        var test_list_rev_8 = List[Long]()\n        var test_list_rev_9 = List[Long]()\n        var test_list_rev_10 = List[Long]()\n        var test_list_rev_11 = List[Long]()\n        var test_list_rev_12 = List[Long]()\n        var test_list_rev_13 = List[Long]()\n        var test_list_rev_14 = List[Long]()\n        var test_list_rev_15 = List[Long]()\n        var test_list_rev_16 = List[Long]()\n        var test_list_rev_17 = List[Long]()\n        var test_list_rev_18 = List[Long]()\n        var test_list_rev_19 = List[Long]()\n        var test_list_rev_20 = List[Long]()\n        var test_list_rev_21 = List[Long]()\n        var test_list_rev_22 = List[Long]()\n        var test_list_rev_23 = List[Long]()\n        var test_list_rev_24 = List[Long]()\n        var test_list_rev_25 = List[Long]()\n        var test_list_rev_26 = List[Long]()\n        var test_list_rev_27 = List[Long]()\n        var test_list_rev_28 = List[Long]()\n        var test_list_rev_29 = List[Long]()\n        var test_list_rev_30 = List[Long]()\n        var test_list_rev\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122690,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpv5no3qae.scala:39:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv5no3qae.scala:39:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: collection.mutable.Map[Long, Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv5no3qae.scala:41:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv5no3qae.scala:42:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv5no3qae.scala:43:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).toString.toLong -> test_tup.toString.charAt(i + 1).toString.toLong)\n            i += 1\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122738,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpf78pkwzg.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpf78pkwzg.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpf78pkwzg.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        for (i <- 0 until test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122754,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpq4smp_wj.scala:13:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpq4smp_wj.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpq4smp_wj.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while(i < test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n            i += 1\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122690,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnj3d15ct.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnj3d15ct.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnj3d15ct.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_dict = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length - 1) {\n            test_dict += (test_tup.toString.charAt(i).toLong -> test_tup.toString.charAt(i + 1).toLong)\n            i += 1\n        }\n        return test_dict\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122753,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2s9ink8l.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2s9ink8l.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2s9ink8l.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val tup = (1L to test_tup).toList\n        val tup_pairs = tup.sliding(2).toList\n        val tup_pairs_map = tup_pairs.map(x => (x(0),x(1))).toMap\n        return tup_pairs_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122754,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5d27wtjo.scala:9:15 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mreturn\u001b[0m tup_pairs_map\n\u001b[31m\u001b[31m  |\u001b[0m               ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m               Found:    (tup_pairs_map : Map[Long, Long])\n\u001b[31m  |\u001b[0m               Required: collection.mutable.Map[Long, Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5d27wtjo.scala:12:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5d27wtjo.scala:13:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5d27wtjo.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_list = List[Long]()\n        var i = 0\n        while(test_tup > 0) {\n            test_list = (test_tup % 10) :: test_list\n            test_tup = test_tup / 10\n        }\n        while(i < test_list.length) {\n            test_map += (test_list(i) -> test_list(i+1))\n            i += 2\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122754,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmprbd2cm88.scala:11:21 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            test_tup = test_tup / \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val test_tup\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprbd2cm88.scala:20:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprbd2cm88.scala:21:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprbd2cm88.scala:22:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n            i += 1\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2xn0sr7.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2xn0sr7.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2xn0sr7.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var dict = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length - 1) {\n            dict += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n            i += 1\n        }\n        dict\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122719,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpni2j8g08.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpni2j8g08.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpni2j8g08.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 1\n        while (i <= test_tup) {\n            test_map += (i -> (i+1))\n            i += 2\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122754,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpeql4c4ob.scala:9:25 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m            test_map += (i -> (i+\u001b[31m1\u001b[0m))\n\u001b[31m\u001b[31m  |\u001b[0m                         ^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                         Found:    (Int, Int)\n\u001b[31m  |\u001b[0m                         Required: (Long, Long)\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpeql4c4ob.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpeql4c4ob.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpeql4c4ob.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var dict = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length - 1) {\n            dict += (test_tup.toString.charAt(i).toString.toLong -> test_tup.toString.charAt(i + 1).toString.toLong)\n            i += 1\n        }\n        dict\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122754,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcwfd5zoh.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcwfd5zoh.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcwfd5zoh.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while(i < test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n            i += 1\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpb79rx1v_.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpb79rx1v_.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpb79rx1v_.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n            i += 1\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2xn0sr7.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2xn0sr7.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2xn0sr7.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var temp_tup = test_tup\n        var temp_tup_len = test_tup.toString.length\n        var temp_tup_len_half = temp_tup_len/2\n        var temp_tup_len_half_int = temp_tup_len_half.toInt\n        var temp_tup_len_half_int_minus_1 = temp_tup_len_half_int - 1\n        var temp_tup_len_half_int_minus_2 = temp_tup_len_half_int - 2\n        var temp_tup_len_half_int_minus_3 = temp_tup_len_half_int - 3\n        var temp_tup_len_half_int_minus_4 = temp_tup_len_half_int - 4\n        var temp_tup_len_half_int_minus_5 = temp_tup_len_half_int - 5\n        var temp_tup_len_half_int_minus_6 = temp_tup_len_half_int - 6\n        var temp_tup_len_half_int_minus_7 = temp_tup_len_half_int - 7\n        var temp_tup_len_half_int_minus_8 = temp_tup_len_half_int - 8\n        var temp_tup_len_half_int_minus_9 = temp_tup_len_half_int - 9\n        var temp_tup_len_half_int_minus_10 = temp_tup_len_half_int - 10\n        var temp_tup_len_half_int_minus_11 = temp_tup_len_half_int - 11\n        var temp_tup_len_half_int_minus_12 = temp_tup_len_half_int - 12\n        var temp_tup_len_half_int_minus_13 = temp_tup_len_half_int - 13\n        var temp_tup_len_half_int_minus_14 = temp_tup_len_half_int - 14\n       \n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122760,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2rg1oix8.scala:26:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: collection.mutable.Map[Long, Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2rg1oix8.scala:28:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2rg1oix8.scala:29:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2rg1oix8.scala:30:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_list = test_tup.toString.toList\n        for (i <- 0 until test_list.length - 1) {\n            test_map += (test_list(i).toString.toLong -> test_list(i + 1).toString.toLong)\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122760,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbk5oejhm.scala:14:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbk5oejhm.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbk5oejhm.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while(i < test_tup.toString().length - 1) {\n            test_map += (test_tup.toString()(i).asDigit.toLong -> test_tup.toString()(i + 1).asDigit.toLong)\n            i += 1\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122760,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphlo8bwv6.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphlo8bwv6.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphlo8bwv6.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var dict = Map[Long,Long]()\n        var i = 0\n        while(i < test_tup.toString.length - 1) {\n            dict += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n            i += 1\n        }\n        dict\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122720,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv9ml5d9i.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv9ml5d9i.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv9ml5d9i.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_list = List[Long]()\n        var test_tup_list = test_tup.toString.toList.map(_.toString.toLong)\n        for (i <- 0 until test_tup_list.length - 1) {\n            test_map += (test_tup_list(i) -> test_tup_list(i + 1))\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122760,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdwhljknn.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdwhljknn.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdwhljknn.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n            i += 1\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122760,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9did3i4b.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9did3i4b.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9did3i4b.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var result = Map[Long,Long]()\n        var i = 0\n        while(i < test_tup.toString.length - 1) {\n            result += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n            i += 1\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122760,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4n7cs3k3.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4n7cs3k3.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4n7cs3k3.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var result = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length - 1) {\n            result += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n            i += 1\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122689,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphjctm78z.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphjctm78z.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphjctm78z.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_list = List[Long]()\n        var test_list_2 = List[Long]()\n        var test_list_3 = List[Long]()\n        var test_list_4 = List[Long]()\n        var test_list_5 = List[Long]()\n        var test_list_6 = List[Long]()\n        var test_list_7 = List[Long]()\n        var test_list_8 = List[Long]()\n        var test_list_9 = List[Long]()\n        var test_list_10 = List[Long]()\n        var test_list_11 = List[Long]()\n        var test_list_12 = List[Long]()\n        var test_list_13 = List[Long]()\n        var test_list_14 = List[Long]()\n        var test_list_15 = List[Long]()\n        var test_list_16 = List[Long]()\n        var test_list_17 = List[Long]()\n        var test_list_18 = List[Long]()\n        var test_list_19 = List[Long]()\n        var test_list_20 = List[Long]()\n        var test_list_21 = List[Long]()\n        var test_list_22 = List[Long]()\n        var test_list_23 = List[Long]()\n        var test_list_24 = List[Long]()\n        var test_list_25 = List[Long]()\n        var test_list_26 = List[Long]()\n        var test_list_27 = List[Long]()\n        var test_list_28 = List[Long]()\n        var test_list_29 = List[Long]()\n        var test_list_30 = List[Long]()\n        var test_list_31 = List[Long]()\n        var test_list_32 = List[Long]()\n        var test_list_33 = List[Long]()\n        var test_list_34 = List[Long]()\n        var test_list_35 = List[Long]()\n        var test_list_36 = List\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122760,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwix0t4dw.scala:43:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: collection.mutable.Map[Long, Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwix0t4dw.scala:45:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwix0t4dw.scala:46:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwix0t4dw.scala:47:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_list = List[Long]()\n        var test_num = test_tup\n        while(test_num > 0) {\n            test_list = (test_num % 10) :: test_list\n            test_num /= 10\n        }\n        for(i <- 0 until test_list.length - 1) {\n            test_map += (test_list(i) -> test_list(i + 1))\n        }\n        return test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122760,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnn25bxpq.scala:19:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnn25bxpq.scala:20:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnn25bxpq.scala:21:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var test_list = List[Long]()\n        var temp = test_tup\n        while (temp > 0) {\n            test_list = (temp % 10) :: test_list\n            temp /= 10\n        }\n        for (i <- 0 until test_list.length - 1) {\n            test_map += (test_list(i) -> test_list(i + 1))\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122705,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpx719z2_n.scala:19:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpx719z2_n.scala:20:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpx719z2_n.scala:21:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_map = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length - 1) {\n            test_map += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n            i += 1\n        }\n        test_map\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1665509870,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2xn0sr7.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2xn0sr7.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2xn0sr7.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var dict = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length - 1) {\n            dict += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n            i += 1\n        }\n        dict\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122719,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpni2j8g08.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpni2j8g08.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpni2j8g08.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        var test_dict = Map[Long,Long]()\n        var i = 0\n        while (i < test_tup.toString.length - 1) {\n            test_dict += (test_tup.toString.charAt(i).asDigit.toLong -> test_tup.toString.charAt(i + 1).asDigit.toLong)\n            i += 1\n        }\n        return test_dict\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122760,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpx3bfgdbw.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpx3bfgdbw.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpx3bfgdbw.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m -> \u001b[31m12l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to convert the given tuple to a key-value map using adjacent elements. https://www.geeksforgeeks.org/scalathon-convert-tuple-to-adjacent-pair-map/\n    def tupleToDict(test_tup : Long) : Map[Long,Long] = {\n        val tup_len = test_tup.toString.length\n        val tup_list = test_tup.toString.toList\n        val tup_list_int = tup_list.map(_.asDigit)\n        val tup_list_int_pairs = tup_list_int.grouped(2).toList\n        val tup_list_int_pairs_map = tup_list_int_pairs.map(x => (x(0).toLong, x(1).toLong))\n        val tup_list_int_pairs_map_dict = tup_list_int_pairs_map.toMap\n        return tup_list_int_pairs_map_dict\n    }\n    def main(args: Array[String]) = {\n    assert(tupleToDict((1l, 5l, 7l, 10l, 13l, 5l)).equals((Map[Long,Long](1l -> 5l, 7l -> 10l, 13l -> 5l))));\n    assert(tupleToDict((1l, 2l, 3l, 4l, 5l, 6l)).equals((Map[Long,Long](1l -> 2l, 3l -> 4l, 5l -> 6l))));\n    assert(tupleToDict((7l, 8l, 9l, 10l, 11l, 12l)).equals((Map[Long,Long](7l -> 8l, 9l -> 10l, 11l -> 12l))));\n    }\n\n}\n",
      "timestamp": 1666122760,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpywcrw6fq.scala:12:15 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mreturn\u001b[0m tup_list_int_pairs_map_dict\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               Found:    (tup_list_int_pairs_map_dict : Map[Long, Long])\n\u001b[31m   |\u001b[0m               Required: collection.mutable.Map[Long, Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpywcrw6fq.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m, \u001b[31m5l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m5l\u001b[0m, \u001b[31m7l\u001b[0m -> \u001b[31m10l\u001b[0m, \u001b[31m13l\u001b[0m -> \u001b[31m5l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpywcrw6fq.scala:16:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m    assert(tupleToDict((\u001b[31m1l\u001b[0m, \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m, \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m, \u001b[31m6l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m1l\u001b[0m -> \u001b[31m2l\u001b[0m, \u001b[31m3l\u001b[0m -> \u001b[31m4l\u001b[0m, \u001b[31m5l\u001b[0m -> \u001b[31m6l\u001b[0m))));\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (Long, Long, Long, Long, Long, Long)\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpywcrw6fq.scala:17:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    assert(tupleToDict((\u001b[31m7l\u001b[0m, \u001b[31m8l\u001b[0m, \u001b[31m9l\u001b[0m, \u001b[31m10l\u001b[0m, \u001b[31m11l\u001b[0m, \u001b[31m12l\u001b[0m)).equals((Map[\u001b[35mLong\u001b[0m,\u001b[35mLong\u001b[0m](\u001b[31m7l\u001b[0m -> \u001b[31m8l\u001b[0m, \u001b[31m9l",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}