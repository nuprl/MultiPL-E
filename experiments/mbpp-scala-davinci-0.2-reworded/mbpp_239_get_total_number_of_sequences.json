{
  "name": "mbpp_239_get_total_number_of_sequences",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n    def getTotalNumberOfSequences(m : Long, n : Long) : Long = {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_239_get_total_number_of_sequences.py",
  "prompt_terminology": "reworded",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(getTotalNumberOfSequences((10l), (4l)) == (4l));\n    assert(getTotalNumberOfSequences((5l), (2l)) == (6l));\n    assert(getTotalNumberOfSequences((16l), (3l)) == (84l));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        val dp = Array.ofDim[Long](n.toInt + 1, m.toInt + 1)\n        for (i <- 0 to n.toInt) {\n            for (j <- 0 to m.toInt) {\n                if (i == 0) dp(i)(j) = 1\n                else if (j == 0) dp(i)(j) = 0\n                else {\n                    dp(i)(j) = dp(i)(j - 1)\n                    if (j >= 2) dp(i)(j) += dp(i - 1)(j / 2)\n                }\n            }\n        }\n        dp(n.toInt)(m.toInt)",
    "        val dp = Array.fill(n.toInt + 1)(0L)\n        dp(0) = 1\n        for (i <- 1 to n.toInt) {\n            for (j <- 2 to m.toInt) {\n                if (i - j >= 0) dp(i) += dp(i - j)\n            }\n        }\n        dp(n.toInt)",
    "        val dp = Array.fill(n.toInt + 1)(0L)\n        dp(0) = 1\n        for (i <- 1 to n.toInt) {\n            for (j <- 1 to m.toInt) {\n                if (j >= 2 * i) dp(i) += dp(i - 1)\n            }\n        }\n        dp(n.toInt)",
    "        val dp = Array.ofDim[Long](n.toInt + 1, m.toInt + 1)\n        for (i <- 1 to m.toInt) {\n            dp(1)(i) = 1\n        }\n        for (i <- 2 to n.toInt) {\n            for (j <- 2 to m.toInt) {\n                for (k <- 2 * j to j) {\n                    dp(i)(j) += dp(i - 1)(k)\n                }\n            }\n        }\n        dp(n.toInt).sum",
    "        val dp = Array.fill(n.toInt + 1)(0L)\n        dp(0) = 1\n        for (i <- 1 to n.toInt) {\n            for (j <- 2 to m.toInt) {\n                if (i - j >= 0) dp(i) += dp(i - j)\n            }\n        }\n        dp(n.toInt)",
    "        // This is a dynamic programming problem.\n        // Let dp(i) be the number of sequences of length i.\n        // Then dp(i) = sum(dp(j) for j in [0, i - 1] where 2 * j <= i <= m)\n        val dp = Array.fill(n.toInt + 1)(0L)\n        dp(0) = 1\n        for (i <- 1 to n.toInt) {\n            for (j <- 0 until i) {\n                if (2 * j <= i && i <= m) {\n                    dp(i) += dp(j)\n                }\n            }\n        }\n        dp(n.toInt)",
    "        val dp = Array.fill[Long](n.toInt + 1)(0)\n        dp(0) = 1\n        for (i <- 1 to n.toInt) {\n            for (j <- 1 to m.toInt) {\n                if (j >= 2 * i) dp(i) += dp(i - 1)\n            }\n        }\n        dp(n.toInt)",
    "        val dp = Array.fill(n.toInt + 1)(0L)\n        dp(0) = 1\n        for (i <- 1 to n.toInt) {\n            for (j <- 2 to m.toInt) {\n                if (i - j >= 0) dp(i) += dp(i - j)\n            }\n        }\n        dp(n.toInt)",
    "        val dp = Array.fill(n.toInt + 1, m.toInt + 1)(0L)\n        for (i <- 1 to m.toInt) {\n            dp(1)(i) = 1\n        }\n        for (i <- 2 to n.toInt) {\n            for (j <- 2 to m.toInt) {\n                for (k <- 2 * j to j) {\n                    dp(i)(j) += dp(i - 1)(k)\n                }\n            }\n        }\n        var result = 0L\n        for (i <- 1 to m.toInt) {\n            result += dp(n.toInt)(i)\n        }\n        result",
    "        // We can use dynamic programming to solve this problem.\n        // Let f(m, n) be the number of sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n        // Then f(m, n) = f(m, n - 1) + f(m - 1, n - 1) + f(m - 2, n - 1) + ... + f(2, n - 1) + f(1, n - 1)\n        // We can use a 2D array to store the values of f(m, n) for all m and n.\n        // The time complexity is O(m * n).\n        // The space complexity is O(m * n).\n        val f = Array.ofDim[Long](m.toInt + 1, n.toInt + 1)\n        for (i <- 1 to m.toInt) f(i)(1) = 1\n        for (i <- 1 to n.toInt) f(1)(i) = 1\n        for (i <- 2 to m.toInt; j <- 2 to n.toInt) {\n            for (k <- 1 to i / 2) f(i)(j) += f(k)(j - 1)\n        }\n        f(m.toInt)(n.toInt)",
    "        val dp = Array.fill(n.toInt + 1)(0L)\n        dp(0) = 1\n        for (i <- 1 to n.toInt) {\n            for (j <- 1 to m.toInt) {\n                if (j >= 2 * i) dp(i) += dp(i - 1)\n            }\n        }\n        dp(n.toInt)",
    "        val dp = Array.fill(n.toInt + 1)(0L)\n        dp(0) = 1\n        for (i <- 1 to n.toInt) {\n            for (j <- 1 to m.toInt) {\n                if (j >= 2 * i) dp(i) += dp(i - 1)\n            }\n        }\n        dp(n.toInt)",
    "        // Create a 2D array to store the number of sequences of length n, such that the last element is i and the maximum element is m.\n        val dp = Array.ofDim[Long](n.toInt + 1, m.toInt + 1)\n        // Base case:\n        // If n = 1, then the only possible sequence is (1).\n        for (i <- 1 to m.toInt) dp(1)(i) = 1\n        // Iterate through the length of the sequence.\n        for (i <- 2 to n.toInt) {\n            // Iterate through the maximum element.\n            for (j <- 1 to m.toInt) {\n                // Iterate through the last element.\n                for (k <- 1 to j) {\n                    // If the last element is greater than or equal to twice the previous element, then add the number of sequences of length n - 1, such that the last element is k and the maximum element is j / 2.\n                    if (k >= 2 * (j / 2)) dp(i)(j) += dp(i - 1)(j / 2)\n                }\n            }\n        }\n        // Return the number of sequences of length n, such that the last element is 1 and the maximum element is m.\n        dp(n.toInt)(m.toInt)",
    "        val dp = Array.fill(n.toInt + 1)(0L)\n        dp(0) = 1\n        for (i <- 1 to n.toInt) {\n            for (j <- 1 to m.toInt) {\n                if (j >= 2 * i) dp(i) += dp(i - 1)\n            }\n        }\n        dp(n.toInt)",
    "        val dp = Array.fill(n.toInt + 1)(0L)\n        dp(0) = 1\n        for (i <- 1 to n.toInt) {\n            for (j <- 1 to m.toInt) {\n                if (j >= 2 * i) dp(i) += dp(i - 1)\n            }\n        }\n        dp(n.toInt)",
    "        val dp = Array.fill(n.toInt + 1)(0L)\n        dp(0) = 1\n        for (i <- 1 to n.toInt) {\n            for (j <- 1 to m.toInt) {\n                if (j >= 2 * i) dp(i) += dp(i - 1)\n            }\n        }\n        dp(n.toInt)",
    "        val dp = Array.ofDim[Long](n.toInt + 1, m.toInt + 1)\n        for (i <- 0 to m.toInt) dp(1)(i) = 1\n        for (i <- 2 to n.toInt) {\n            for (j <- 0 to m.toInt) {\n                for (k <- 0 to j) {\n                    if (k * 2 <= j) dp(i)(j) += dp(i - 1)(k)\n                }\n            }\n        }\n        dp(n.toInt).sum",
    "        val dp = Array.ofDim[Long](n.toInt + 1, m.toInt + 1)\n        for (i <- 1 to m.toInt) {\n            dp(1)(i) = 1\n        }\n        for (i <- 2 to n.toInt) {\n            for (j <- 1 to m.toInt) {\n                for (k <- 2 * j to m.toInt) {\n                    dp(i)(j) += dp(i - 1)(k)\n                }\n            }\n        }\n        dp(n.toInt).sum",
    "        val dp = Array.ofDim[Long](n.toInt + 1, m.toInt + 1)\n        for (i <- 1 to m.toInt) dp(1)(i) = 1\n        for (i <- 2 to n.toInt) {\n            for (j <- 2 to m.toInt) {\n                for (k <- 2 * j to j) {\n                    dp(i)(j) += dp(i - 1)(k)\n                }\n            }\n        }\n        dp(n.toInt).sum",
    "        val mod = 1000000007L\n        val dp = Array.ofDim[Long](n.toInt + 1, m.toInt + 1)\n        for (i <- 0 to m.toInt) dp(1)(i) = 1\n        for (i <- 2 to n.toInt) {\n            for (j <- 2 to m.toInt) {\n                dp(i)(j) = (dp(i)(j - 1) + dp(i - 1)(j / 2)) % mod\n            }\n        }\n        dp(n.toInt)(m.toInt)"
  ]
}