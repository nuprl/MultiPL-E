{
  "name": "mbpp_141_pancake_sort",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to sort a list of elements.\n    def pancakeSort(nums : List[Long]) : List[Long] = {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_141_pancake_sort.py",
  "prompt_terminology": "reworded",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(pancakeSort((List[Long](15l.toLong, 79l.toLong, 25l.toLong, 38l.toLong, 69l.toLong))).equals((List[Long](15l.toLong, 25l.toLong, 38l.toLong, 69l.toLong, 79l.toLong))));\n    assert(pancakeSort((List[Long](98l.toLong, 12l.toLong, 54l.toLong, 36l.toLong, 85l.toLong))).equals((List[Long](12l.toLong, 36l.toLong, 54l.toLong, 85l.toLong, 98l.toLong))));\n    assert(pancakeSort((List[Long](41l.toLong, 42l.toLong, 32l.toLong, 12l.toLong, 23l.toLong))).equals((List[Long](12l.toLong, 23l.toLong, 32l.toLong, 41l.toLong, 42l.toLong))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            result = (index + 1) :: result\n            current = current.take(index).reverse ::: current.drop(index)\n            result = (current.length) :: result\n            current = current.reverse\n        }\n        result.reverse",
    "        val sorted = nums.sorted\n        val result = new ListBuffer[Long]\n        var current = nums\n        for (i <- sorted.length - 1 to 0 by -1) {\n            val index = current.indexOf(sorted(i))\n            result += index + 1\n            current = current.take(index + 1).reverse ++ current.drop(index + 1)\n            result += i + 1\n            current = current.take(i + 1).reverse ++ current.drop(i + 1)\n        }\n        result.toList",
    "        val n = nums.length\n        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(k)\n            b.reverse ::: a\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = 0\n            for (i <- 1 until k) {\n                if (nums(i) > nums(max)) max = i\n            }\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 1) nums\n            else {\n                val max = findMax(nums, k)\n                if (max == k - 1) sort(nums, k - 1)\n                else {\n                    val nums1 = flip(nums, max + 1)\n                    val nums2 = flip(nums1, k)\n                    sort(nums2, k - 1)\n                }\n            }\n        }\n        sort(nums, n)",
    "        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) return nums\n            val max = nums.take(k).max\n            val index = nums.take(k).indexOf(max)\n            val first = nums.take(index + 1).reverse\n            val second = nums.drop(index + 1)\n            val third = second.take(k - index - 1).reverse\n            val fourth = second.drop(k - index - 1)\n            sort(first ::: third ::: fourth, k - 1)\n        }\n        sort(nums, nums.length)",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(k)\n            b.reverse ::: a\n        }\n        def pancakeSortHelper(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val max = nums.indexOf(nums.max)\n                val nums1 = flip(nums, max + 1)\n                val nums2 = flip(nums1, k)\n                pancakeSortHelper(nums2, k - 1)\n            }\n        }\n        pancakeSortHelper(nums, nums.length)",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var list = nums\n        for (i <- 0 until nums.length) {\n            val index = list.indexOf(sorted(i))\n            if (index != 0) {\n                result = result :+ (index + 1).toLong\n                list = list.take(index).reverse ::: list.drop(index)\n            }\n            result = result :+ (list.length - i).toLong\n            list = list.take(list.length - i - 1).reverse ::: list.drop(list.length - i - 1)\n        }\n        result",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (first, second) = nums.splitAt(k)\n            second.reverse ::: first\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = 0\n            for (i <- 0 until k) {\n                if (nums(i) > nums(max)) max = i\n            }\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val max = findMax(nums, k)\n                val flipped = flip(nums, max + 1)\n                sort(flip(flipped, k), k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        nums.sortWith(_ > _)",
    "        val n = nums.length\n        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until n) {\n            val index = current.indexOf(sorted(i))\n            result = (index + 1) :: result\n            current = current.take(index).reverse ::: current.drop(index)\n            result = (n - i) :: result\n            current = current.take(n - i).reverse ::: current.drop(n - i)\n        }\n        result.reverse",
    "        val result = ListBuffer[Long]()\n        for (i <- nums.size - 1 to 1 by -1) {\n            val maxIndex = nums.take(i + 1).zipWithIndex.maxBy(_._1)._2\n            if (maxIndex != i) {\n                result += maxIndex + 1\n                result += i + 1\n            }\n        }\n        result.toList",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            if (index != 0) {\n                result = index + 1 :: result\n                current = current.take(index + 1).reverse ::: current.drop(index + 1)\n            }\n            result = 1 :: result\n            current = current.take(1).reverse ::: current.drop(1)\n        }\n        result",
    "        var result = ListBuffer[Long]()\n        var list = nums\n        while (list.length > 0) {\n            val max = list.max\n            val index = list.indexOf(max)\n            result += (index + 1)\n            result += (list.length)\n            list = list.take(index).reverse ++ list.drop(index + 1)\n            list = list.take(list.length - 1).reverse\n        }\n        result.toList",
    "        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val maxIndex = current.indexOf(current.max)\n            result = result :+ (maxIndex + 1)\n            result = result :+ (current.length - i)\n            current = current.take(maxIndex).reverse ::: current.drop(maxIndex + 1)\n            current = current.take(current.length - i).reverse ::: current.drop(current.length - i)\n        }\n        result",
    "        val n = nums.length\n        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- n - 1 to 1 by -1) {\n            val index = current.indexOf(sorted(i))\n            result = (index + 1) :: result\n            current = current.take(index).reverse ::: current.drop(index)\n            result = (i + 1) :: result\n            current = current.take(i + 1).reverse ::: current.drop(i + 1)\n        }\n        result",
    "        var result = List[Long]()\n        var current = nums\n        while (current.length > 0) {\n            val max = current.max\n            val index = current.indexOf(max)\n            result = max :: result\n            current = current.slice(0, index).reverse ::: current.slice(index + 1, current.length)\n            result = current.head :: result\n            current = current.slice(1, current.length)\n        }\n        result.reverse",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(k)\n            b.reverse ::: a\n        }\n        def findMax(nums : List[Long]) : (Int, Long) = {\n            var max = Long.MinValue\n            var index = 0\n            for (i <- 0 until nums.length) {\n                if (nums(i) > max) {\n                    max = nums(i)\n                    index = i\n                }\n            }\n            (index, max)\n        }\n        def sort(nums : List[Long], result : List[Long]) : List[Long] = {\n            if (nums.length == 0) result\n            else {\n                val (index, max) = findMax(nums)\n                val nums1 = flip(nums, index + 1)\n                val nums2 = flip(nums1, nums1.length)\n                sort(nums2.tail, result :+ nums2.length)\n            }\n        }\n        sort(nums, List())",
    "        val sorted = nums.sorted\n        val result = ListBuffer[Long]()\n        for (i <- 0 until sorted.length) {\n            val index = nums.indexOf(sorted(i))\n            if (index != i) {\n                result += index + 1\n                result += i + 1\n            }\n        }\n        result.toList",
    "        val sorted = nums.sorted\n        val result = new ListBuffer[Long]\n        var current = nums\n        for (i <- 0 until sorted.length) {\n            val index = current.indexOf(sorted(i))\n            if (index != 0) {\n                result += index + 1\n                current = current.take(index + 1).reverse ++ current.drop(index + 1)\n            }\n            result += 1\n            current = current.take(1).reverse ++ current.drop(1)\n        }\n        result.toList",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        while (current != sorted) {\n            val max = current.max\n            val maxIndex = current.indexOf(max)\n            result = maxIndex + 1 :: result\n            current = current.take(maxIndex).reverse ::: current.drop(maxIndex)\n            result = current.length :: result\n            current = current.reverse\n        }\n        result",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until sorted.length) {\n            val index = current.indexOf(sorted(i))\n            result = result :+ (index + 1)\n            current = (current.take(index + 1).reverse ::: current.drop(index + 1)).reverse\n            result = result :+ (current.length)\n            current = current.reverse\n        }\n        result"
  ]
}