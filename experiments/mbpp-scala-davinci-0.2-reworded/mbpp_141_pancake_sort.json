{
  "name": "mbpp_141_pancake_sort",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to sort a list of elements.\n    def pancakeSort(nums : List[Long]) : List[Long] = {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_141_pancake_sort.py",
  "prompt_terminology": "reworded",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(pancakeSort((List[Long](15l.toLong, 79l.toLong, 25l.toLong, 38l.toLong, 69l.toLong))).equals((List[Long](15l.toLong, 25l.toLong, 38l.toLong, 69l.toLong, 79l.toLong))));\n    assert(pancakeSort((List[Long](98l.toLong, 12l.toLong, 54l.toLong, 36l.toLong, 85l.toLong))).equals((List[Long](12l.toLong, 36l.toLong, 54l.toLong, 85l.toLong, 98l.toLong))));\n    assert(pancakeSort((List[Long](41l.toLong, 42l.toLong, 32l.toLong, 12l.toLong, 23l.toLong))).equals((List[Long](12l.toLong, 23l.toLong, 32l.toLong, 41l.toLong, 42l.toLong))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            result = (index + 1) :: result\n            current = current.take(index).reverse ::: current.drop(index)\n            result = (current.length) :: result\n            current = current.reverse\n        }\n        result.reverse",
    "        val sorted = nums.sorted\n        val result = new ListBuffer[Long]\n        var current = nums\n        for (i <- sorted.length - 1 to 0 by -1) {\n            val index = current.indexOf(sorted(i))\n            result += index + 1\n            current = current.take(index + 1).reverse ++ current.drop(index + 1)\n            result += i + 1\n            current = current.take(i + 1).reverse ++ current.drop(i + 1)\n        }\n        result.toList",
    "        val n = nums.length\n        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(k)\n            b.reverse ::: a\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = 0\n            for (i <- 1 until k) {\n                if (nums(i) > nums(max)) max = i\n            }\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 1) nums\n            else {\n                val max = findMax(nums, k)\n                if (max == k - 1) sort(nums, k - 1)\n                else {\n                    val nums1 = flip(nums, max + 1)\n                    val nums2 = flip(nums1, k)\n                    sort(nums2, k - 1)\n                }\n            }\n        }\n        sort(nums, n)",
    "        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) return nums\n            val max = nums.take(k).max\n            val index = nums.take(k).indexOf(max)\n            val first = nums.take(index + 1).reverse\n            val second = nums.drop(index + 1)\n            val third = second.take(k - index - 1).reverse\n            val fourth = second.drop(k - index - 1)\n            sort(first ::: third ::: fourth, k - 1)\n        }\n        sort(nums, nums.length)",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(k)\n            b.reverse ::: a\n        }\n        def pancakeSortHelper(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val max = nums.indexOf(nums.max)\n                val nums1 = flip(nums, max + 1)\n                val nums2 = flip(nums1, k)\n                pancakeSortHelper(nums2, k - 1)\n            }\n        }\n        pancakeSortHelper(nums, nums.length)",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var list = nums\n        for (i <- 0 until nums.length) {\n            val index = list.indexOf(sorted(i))\n            if (index != 0) {\n                result = result :+ (index + 1).toLong\n                list = list.take(index).reverse ::: list.drop(index)\n            }\n            result = result :+ (list.length - i).toLong\n            list = list.take(list.length - i - 1).reverse ::: list.drop(list.length - i - 1)\n        }\n        result",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (first, second) = nums.splitAt(k)\n            second.reverse ::: first\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = 0\n            for (i <- 0 until k) {\n                if (nums(i) > nums(max)) max = i\n            }\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val max = findMax(nums, k)\n                val flipped = flip(nums, max + 1)\n                sort(flip(flipped, k), k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        nums.sortWith(_ > _)",
    "        val n = nums.length\n        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until n) {\n            val index = current.indexOf(sorted(i))\n            result = (index + 1) :: result\n            current = current.take(index).reverse ::: current.drop(index)\n            result = (n - i) :: result\n            current = current.take(n - i).reverse ::: current.drop(n - i)\n        }\n        result.reverse",
    "        val result = ListBuffer[Long]()\n        for (i <- nums.size - 1 to 1 by -1) {\n            val maxIndex = nums.take(i + 1).zipWithIndex.maxBy(_._1)._2\n            if (maxIndex != i) {\n                result += maxIndex + 1\n                result += i + 1\n            }\n        }\n        result.toList",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            if (index != 0) {\n                result = index + 1 :: result\n                current = current.take(index + 1).reverse ::: current.drop(index + 1)\n            }\n            result = 1 :: result\n            current = current.take(1).reverse ::: current.drop(1)\n        }\n        result",
    "        var result = ListBuffer[Long]()\n        var list = nums\n        while (list.length > 0) {\n            val max = list.max\n            val index = list.indexOf(max)\n            result += (index + 1)\n            result += (list.length)\n            list = list.take(index).reverse ++ list.drop(index + 1)\n            list = list.take(list.length - 1).reverse\n        }\n        result.toList",
    "        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val maxIndex = current.indexOf(current.max)\n            result = result :+ (maxIndex + 1)\n            result = result :+ (current.length - i)\n            current = current.take(maxIndex).reverse ::: current.drop(maxIndex + 1)\n            current = current.take(current.length - i).reverse ::: current.drop(current.length - i)\n        }\n        result",
    "        val n = nums.length\n        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- n - 1 to 1 by -1) {\n            val index = current.indexOf(sorted(i))\n            result = (index + 1) :: result\n            current = current.take(index).reverse ::: current.drop(index)\n            result = (i + 1) :: result\n            current = current.take(i + 1).reverse ::: current.drop(i + 1)\n        }\n        result",
    "        var result = List[Long]()\n        var current = nums\n        while (current.length > 0) {\n            val max = current.max\n            val index = current.indexOf(max)\n            result = max :: result\n            current = current.slice(0, index).reverse ::: current.slice(index + 1, current.length)\n            result = current.head :: result\n            current = current.slice(1, current.length)\n        }\n        result.reverse",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(k)\n            b.reverse ::: a\n        }\n        def findMax(nums : List[Long]) : (Int, Long) = {\n            var max = Long.MinValue\n            var index = 0\n            for (i <- 0 until nums.length) {\n                if (nums(i) > max) {\n                    max = nums(i)\n                    index = i\n                }\n            }\n            (index, max)\n        }\n        def sort(nums : List[Long], result : List[Long]) : List[Long] = {\n            if (nums.length == 0) result\n            else {\n                val (index, max) = findMax(nums)\n                val nums1 = flip(nums, index + 1)\n                val nums2 = flip(nums1, nums1.length)\n                sort(nums2.tail, result :+ nums2.length)\n            }\n        }\n        sort(nums, List())",
    "        val sorted = nums.sorted\n        val result = ListBuffer[Long]()\n        for (i <- 0 until sorted.length) {\n            val index = nums.indexOf(sorted(i))\n            if (index != i) {\n                result += index + 1\n                result += i + 1\n            }\n        }\n        result.toList",
    "        val sorted = nums.sorted\n        val result = new ListBuffer[Long]\n        var current = nums\n        for (i <- 0 until sorted.length) {\n            val index = current.indexOf(sorted(i))\n            if (index != 0) {\n                result += index + 1\n                current = current.take(index + 1).reverse ++ current.drop(index + 1)\n            }\n            result += 1\n            current = current.take(1).reverse ++ current.drop(1)\n        }\n        result.toList",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        while (current != sorted) {\n            val max = current.max\n            val maxIndex = current.indexOf(max)\n            result = maxIndex + 1 :: result\n            current = current.take(maxIndex).reverse ::: current.drop(maxIndex)\n            result = current.length :: result\n            current = current.reverse\n        }\n        result",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until sorted.length) {\n            val index = current.indexOf(sorted(i))\n            result = result :+ (index + 1)\n            current = (current.take(index + 1).reverse ::: current.drop(index + 1)).reverse\n            result = result :+ (current.length)\n            current = current.reverse\n        }\n        result",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            result = (index + 1) :: result\n            current = current.take(index).reverse ::: current.drop(index)\n            result = (i + 1) :: result\n            current = current.take(i + 1).reverse ::: current.drop(i + 1)\n        }\n        result.reverse",
    "        val n = nums.length\n        val sorted = nums.sorted\n        val map = new HashMap[Long, Int]\n        for (i <- 0 until n) map(nums(i)) = i\n        var result = List[Long]()\n        for (i <- 0 until n) {\n            val j = map(sorted(i))\n            if (j != i) {\n                result = (j + 1) :: result\n                result = (i + 1) :: result\n            }\n        }\n        result",
    "        val n = nums.length\n        val sorted = nums.sorted\n        val map = new HashMap[Long, Int]\n        for (i <- 0 until n) map(sorted(i)) = i\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until n) {\n            val index = map(current(i))\n            if (index != 0) {\n                result = (index + 1) :: result\n                current = current.take(index + 1).reverse ::: current.drop(index + 1)\n            }\n            result = (i + 1) :: result\n            current = current.take(i + 1).reverse ::: current.drop(i + 1)\n        }\n        result",
    "        val n = nums.length\n        val result = new ArrayBuffer[Long]\n        for (i <- n to 1 by -1) {\n            val index = nums.indexOf(i)\n            if (index != i - 1) {\n                if (index != 0) {\n                    result += index + 1\n                    nums.take(index + 1).reverse.foreach(println)\n                }\n                result += i\n                nums.take(i).reverse.foreach(println)\n            }\n        }\n        result.toList",
    "        val n = nums.length\n        val sorted = nums.sorted\n        var result = List[Long]()\n        for (i <- 0 until n) {\n            val index = nums.indexOf(sorted(i))\n            if (index != i) {\n                result = (index + 1) :: result\n                result = (i + 1) :: result\n            }\n        }\n        result",
    "        val n = nums.length\n        val sorted = nums.sorted\n        val result = new ListBuffer[Long]\n        for (i <- n - 1 to 0 by -1) {\n            val index = nums.indexOf(sorted(i))\n            if (index != i) {\n                result += (index + 1).toLong\n                result += (i + 1).toLong\n            }\n        }\n        result.toList",
    "        val n = nums.length\n        val sorted = nums.sorted\n        val map = new HashMap[Long, Int]\n        for (i <- 0 until n) map(sorted(i)) = i\n        var ans = List[Long]()\n        var cur = nums\n        for (i <- 0 until n) {\n            val x = cur(i)\n            val j = map(x)\n            if (j != i) {\n                ans = (n - j) :: ans\n                ans = (n - i) :: ans\n                cur = cur.take(j).reverse ::: cur.drop(j)\n                cur = cur.take(i + 1).reverse ::: cur.drop(i + 1)\n            }\n        }\n        ans",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        for (i <- 0 until nums.length) {\n            val index = nums.indexOf(sorted(i))\n            result = result :+ (index + 1)\n            result = result :+ (nums.length - i)\n            nums.take(index + 1).reverse.foreach(x => nums.remove(nums.indexOf(x)))\n            nums.reverse.foreach(x => nums.remove(nums.indexOf(x)))\n            nums = sorted(i) :: nums\n        }\n        result",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            val flip = current.take(index + 1).reverse\n            result = result :+ (index + 1).toLong\n            current = flip ::: current.drop(index + 1)\n            val flip2 = current.take(i + 1).reverse\n            result = result :+ (i + 1).toLong\n            current = flip2 ::: current.drop(i + 1)\n        }\n        result",
    "        def reverse(nums : List[Long], k : Int) : List[Long] = {\n            nums.take(k).reverse ::: nums.drop(k)\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = 0\n            for (i <- 1 until k) {\n                if (nums(i) > nums(max)) max = i\n            }\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 1) nums\n            else {\n                val max = findMax(nums, k)\n                val nums1 = reverse(nums, max + 1)\n                val nums2 = reverse(nums1, k)\n                sort(nums2, k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            result = (index + 1) :: result\n            current = current.take(index).reverse ::: current.drop(index)\n            result = (i + 1) :: result\n            current = current.take(i + 1).reverse ::: current.drop(i + 1)\n        }\n        result.reverse",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(k)\n            b.reverse ::: a\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = 0\n            for (i <- 0 until k) if (nums(i) > nums(max)) max = i\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val max = findMax(nums, k)\n                val nums1 = flip(nums, max + 1)\n                val nums2 = flip(nums1, k)\n                sort(nums2, k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        def pancakeSort(nums : List[Long], result : List[Long]) : List[Long] = {\n            if (nums.length == 0) result\n            else {\n                val max = nums.max\n                val maxIndex = nums.indexOf(max)\n                val (first, second) = nums.splitAt(maxIndex + 1)\n                pancakeSort(second.tail.reverse ++ first.reverse, max :: result)\n            }\n        }\n        pancakeSort(nums, Nil).reverse",
    "        val sorted = nums.sorted\n        val n = nums.length\n        val result = new ListBuffer[Long]\n        for (i <- 0 until n) {\n            val index = nums.indexOf(sorted(i))\n            if (index != 0) {\n                result += index + 1\n                nums.take(index + 1).reverse.foreach(x => result += x)\n            }\n        }\n        result.toList",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            if (index == 0) {\n                current = current.tail\n                result = result :+ 1\n            } else {\n                current = current.take(index + 1).reverse ::: current.drop(index + 1)\n                result = result :+ (index + 1)\n                current = current.tail\n                result = result :+ 1\n            }\n        }\n        result",
    "        var result = List[Long]()\n        var list = nums\n        while (list.length > 0) {\n            val max = list.max\n            val index = list.indexOf(max)\n            result = result :+ (index + 1)\n            list = list.take(index).reverse ::: list.drop(index + 1)\n            result = result :+ (list.length)\n            list = list.reverse\n        }\n        result",
    "        var result = nums\n        for (i <- 0 until nums.length) {\n            val maxIndex = result.indexOf(result.max)\n            result = result.take(maxIndex + 1).reverse ++ result.drop(maxIndex + 1)\n            result = result.take(i + 1).reverse ++ result.drop(i + 1)\n        }\n        result",
    "        val sorted = nums.sorted\n        val result = new ListBuffer[Long]\n        var current = nums\n        while (current != sorted) {\n            val max = current.max\n            val index = current.indexOf(max)\n            result += (index + 1).toLong\n            result += (current.length).toLong\n            current = current.take(index).reverse ++ current.drop(index + 1)\n            current = current.reverse\n        }\n        result.toList",
    "        var list = nums\n        var result = List[Long]()\n        for (i <- 0 to nums.length - 1) {\n            val max = list.max\n            val index = list.indexOf(max)\n            list = list.take(index).reverse ::: list.drop(index)\n            result = result :+ index.toLong + 1\n            list = list.reverse\n            result = result :+ list.length.toLong\n            list = list.dropRight(1)\n        }\n        result",
    "        val n = nums.length\n        val result = new ListBuffer[Long]\n        for (i <- n - 1 to 1 by -1) {\n            val maxIndex = nums.slice(0, i + 1).zipWithIndex.maxBy(_._1)._2\n            if (maxIndex != i) {\n                result += maxIndex + 1\n                result += i + 1\n            }\n        }\n        result.toList",
    "        val sorted = nums.sorted\n        val n = nums.length\n        var result = List[Long]()\n        for (i <- 0 until n) {\n            val index = nums.indexOf(sorted(i))\n            if (index != i) {\n                result = result :+ (index + 1)\n                result = result :+ (i + 1)\n            }\n        }\n        result",
    "        val n = nums.length\n        val sorted = nums.sorted\n        val map = new HashMap[Long, Int]\n        for (i <- 0 until n) map(sorted(i)) = i\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until n) {\n            val index = map(current(0))\n            result = (index + 1) :: result\n            current = current.take(index).reverse ::: current.drop(index)\n            result = (n - i) :: result\n            current = current.take(n - i).reverse ::: current.drop(n - i)\n        }\n        result",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        for (i <- sorted.length - 1 to 0 by -1) {\n            val index = nums.indexOf(sorted(i))\n            result = result :+ (index + 1).toLong\n            nums.take(index + 1).reverse\n            result = result :+ (i + 1).toLong\n            nums.take(i + 1).reverse\n        }\n        result",
    "        var result = nums\n        for (i <- 0 until nums.length) {\n            val maxIndex = result.indexOf(result.max)\n            result = result.take(maxIndex + 1).reverse ++ result.drop(maxIndex + 1)\n            result = result.take(i + 1).reverse ++ result.drop(i + 1)\n        }\n        result",
    "        val n = nums.length\n        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until n) {\n            val index = current.indexOf(sorted(i))\n            result = (index + 1) :: result\n            current = current.take(index).reverse ::: current.drop(index)\n            result = (n - i) :: result\n            current = current.take(n - i).reverse ::: current.drop(n - i)\n        }\n        result",
    "        var result = List[Long]()\n        var nums2 = nums\n        for (i <- 0 until nums.length) {\n            val max = nums2.max\n            val index = nums2.indexOf(max)\n            result = result :+ (index + 1) :+ (nums2.length - i)\n            nums2 = nums2.take(index).reverse ::: nums2.drop(index + 1)\n            nums2 = nums2.take(nums2.length - i).reverse ::: nums2.drop(nums2.length - i)\n        }\n        result",
    "        if (nums.length == 0) return nums\n        var maxIndex = 0\n        for (i <- 1 until nums.length) if (nums(i) > nums(maxIndex)) maxIndex = i\n        var result = List[Long]()\n        if (maxIndex != nums.length - 1) {\n            result = pancakeSort(nums.slice(0, maxIndex + 1).reverse) ::: pancakeSort(nums.slice(maxIndex + 1, nums.length))\n        } else {\n            result = pancakeSort(nums.slice(0, nums.length - 1)) ::: List(nums(nums.length - 1))\n        }\n        result",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(k)\n            b.reverse ::: a\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = 0\n            for (i <- 0 until k) {\n                if (nums(i) > nums(max)) max = i\n            }\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val max = findMax(nums, k)\n                sort(flip(nums, max + 1), max)\n                sort(flip(nums, k), k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        val n = nums.length\n        val result = new Array[Long](n)\n        for (i <- 0 until n) {\n            val max = nums.max\n            val index = nums.indexOf(max)\n            result(n - i - 1) = index + 1\n            nums.take(index).reverse ++ nums.drop(index + 1)\n        }\n        result.toList",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            result = result :+ (index + 1).toLong\n            current = current.take(index).reverse ::: current.drop(index)\n            result = result :+ (current.length - i).toLong\n            current = current.take(current.length - i).reverse ::: current.drop(current.length - i)\n        }\n        result",
    "        val n = nums.length\n        val result = new ListBuffer[Long]\n        for (i <- n to 1 by -1) {\n            val index = nums.indexOf(i)\n            if (index != i - 1) {\n                result += index + 1\n                result += i\n            }\n        }\n        result.toList",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(k)\n            b.reverse ::: a\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = 0\n            for (i <- 1 until k) if (nums(i) > nums(max)) max = i\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val max = findMax(nums, k)\n                if (max == k - 1) sort(nums, k - 1)\n                else {\n                    val nums1 = flip(nums, max + 1)\n                    val nums2 = flip(nums1, k)\n                    sort(nums2, k - 1)\n                }\n            }\n        }\n        sort(nums, nums.length)",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            result = result :+ (index + 1).toLong\n            current = current.take(index).reverse ::: current.drop(index)\n            result = result :+ (current.length - i).toLong\n            current = current.take(current.length - i - 1).reverse ::: current.drop(current.length - i - 1)\n        }\n        result",
    "        val n = nums.length\n        val result = ListBuffer[Long]()\n        for (i <- n - 1 to 1 by -1) {\n            val maxIndex = nums.indexOf(nums.max)\n            if (maxIndex != i) {\n                result += maxIndex + 1\n                result += i + 1\n            }\n            val newNums = nums.take(maxIndex).reverse ++ nums.drop(maxIndex + 1)\n            val newNums2 = newNums.take(i).reverse ++ newNums.drop(i + 1)\n            nums = newNums2\n        }\n        result.toList",
    "        var list = nums\n        var result = List[Long]()\n        while (list.length > 0) {\n            val max = list.max\n            val maxIndex = list.indexOf(max)\n            result = max :: result\n            list = list.take(maxIndex).reverse ::: list.drop(maxIndex + 1)\n            result = (list.length) :: result\n            list = list.reverse\n        }\n        result.reverse",
    "        var result = nums\n        for (i <- 0 until nums.length) {\n            val maxIndex = result.indexOf(result.max)\n            result = result.take(maxIndex + 1).reverse ++ result.drop(maxIndex + 1)\n            result = result.take(i + 1).reverse ++ result.drop(i + 1)\n        }\n        result",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(k)\n            b.reverse ::: a\n        }\n        def findMax(nums : List[Long]) : (Int, Long) = {\n            var max = 0\n            var index = 0\n            for (i <- 0 until nums.length) {\n                if (nums(i) > max) {\n                    max = nums(i)\n                    index = i\n                }\n            }\n            (index, max)\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) return nums\n            val (index, max) = findMax(nums)\n            val nums1 = flip(nums, index + 1)\n            val nums2 = flip(nums1, k)\n            sort(nums2, k - 1)\n        }\n        sort(nums, nums.length)",
    "        val n = nums.length\n        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until n) {\n            val index = current.indexOf(sorted(i))\n            result = (index + 1) :: result\n            current = current.take(index).reverse ::: current.drop(index)\n            result = (n - i) :: result\n            current = current.take(n - i).reverse ::: current.drop(n - i)\n        }\n        result.reverse",
    "        var result = List[Long]()\n        var nums2 = nums\n        while (nums2.length > 0) {\n            val max = nums2.max\n            val index = nums2.indexOf(max)\n            result = result :+ (index + 1)\n            result = result :+ (nums2.length)\n            nums2 = nums2.take(index).reverse ::: nums2.drop(index + 1)\n            nums2 = nums2.reverse\n        }\n        result",
    "        if (nums.length == 1) return nums\n        var maxIndex = 0\n        var max = nums(0)\n        for (i <- 1 until nums.length) {\n            if (nums(i) > max) {\n                max = nums(i)\n                maxIndex = i\n            }\n        }\n        var newNums = nums.slice(0, maxIndex + 1).reverse ::: nums.slice(maxIndex + 1, nums.length)\n        newNums = newNums.reverse ::: newNums.slice(1, newNums.length)\n        return pancakeSort(newNums.slice(0, newNums.length - 1)) :+ newNums.last",
    "        var result = List[Long]()\n        var nums2 = nums\n        while (nums2.length > 0) {\n            val max = nums2.max\n            val maxIndex = nums2.indexOf(max)\n            result = max :: result\n            nums2 = nums2.take(maxIndex).reverse ::: nums2.drop(maxIndex + 1)\n            result = nums2.length.toLong :: result\n            nums2 = nums2.reverse\n        }\n        result.reverse",
    "        var result = List[Long]()\n        var current = nums\n        while (current.length > 0) {\n            val max = current.max\n            val index = current.indexOf(max)\n            result = result :+ (index + 1)\n            current = current.take(index).reverse ::: current.drop(index + 1)\n            result = result :+ current.length\n            current = current.reverse\n        }\n        result",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            if (index != 0) {\n                result = result :+ (index + 1).toLong\n                current = current.take(index).reverse ::: current.drop(index)\n            }\n            result = result :+ (current.length - i).toLong\n            current = current.take(current.length - i - 1).reverse ::: current.drop(current.length - i - 1)\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 0 until nums.length) {\n            val max = nums.indexOf(nums.max)\n            result = (max + 1) :: result\n            result = (i + 1) :: result\n        }\n        result.reverse",
    "        val n = nums.length\n        val result = new Array[Long](n)\n        for (i <- 0 until n) {\n            val maxIndex = nums.indexOf(nums.max)\n            result(n - i - 1) = maxIndex + 1\n            result(n - i - 2) = maxIndex + 1\n            val newNums = nums.take(maxIndex + 1).reverse ++ nums.drop(maxIndex + 1)\n            val newNums2 = newNums.take(n - i - 1).reverse ++ newNums.drop(n - i - 1)\n            nums = newNums2\n        }\n        result.toList",
    "        def flip(nums : List[Long], i : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(i)\n            b.reverse ::: a\n        }\n        def findMax(nums : List[Long], i : Int) : Int = {\n            var max = 0\n            for (j <- 0 until i) {\n                if (nums(j) > nums(max)) max = j\n            }\n            max\n        }\n        def sort(nums : List[Long], i : Int) : List[Long] = {\n            if (i == 0) nums\n            else {\n                val max = findMax(nums, i)\n                if (max == i - 1) sort(nums, i - 1)\n                else {\n                    val nums1 = flip(nums, max + 1)\n                    val nums2 = flip(nums1, i)\n                    sort(nums2, i - 1)\n                }\n            }\n        }\n        sort(nums, nums.length)",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        var i = 0\n        while (current != sorted) {\n            val max = current.max\n            val index = current.indexOf(max)\n            result = (index + 1) :: result\n            current = current.take(index).reverse ::: current.drop(index)\n            result = (current.length) :: result\n            current = current.reverse\n            i += 1\n        }\n        result.reverse",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            val reversed = current.take(index + 1).reverse\n            result = result :+ (index + 1).toLong\n            current = reversed ::: current.drop(index + 1)\n            val reversed2 = current.take(i + 1).reverse\n            result = result :+ (i + 1).toLong\n            current = reversed2 ::: current.drop(i + 1)\n        }\n        result",
    "        val n = nums.length\n        val sorted = nums.sorted\n        var result = ListBuffer[Long]()\n        for (i <- 0 until n) {\n            val index = nums.indexOf(sorted(i))\n            if (index != i) {\n                result += index + 1\n                result += i + 1\n            }\n        }\n        result.toList",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        for (i <- 0 until nums.length) {\n            val index = nums.indexOf(sorted(i))\n            result = result :+ (index + 1)\n            result = result :+ (nums.length - i)\n        }\n        result",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(k)\n            b.reverse ::: a\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = nums(0)\n            var index = 0\n            for (i <- 1 until k) {\n                if (nums(i) > max) {\n                    max = nums(i)\n                    index = i\n                }\n            }\n            index\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val index = findMax(nums, k)\n                val nums1 = flip(nums, index + 1)\n                val nums2 = flip(nums1, k)\n                sort(nums2, k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        val n = nums.length\n        val sorted = nums.sorted\n        val sortedIndex = nums.map(sorted.indexOf(_))\n        val sortedIndexWithIndex = sortedIndex.zipWithIndex\n        val sortedIndexWithIndexSorted = sortedIndexWithIndex.sortBy(_._1)\n        val sortedIndexWithIndexSortedIndex = sortedIndexWithIndexSorted.map(_._2)\n        val sortedIndexWithIndexSortedIndexWithIndex = sortedIndexWithIndexSortedIndex.zipWithIndex\n        val sortedIndexWithIndexSortedIndexWithIndexSorted = sortedIndexWithIndexSortedIndexWithIndex.sortBy(_._1)\n        val sortedIndexWithIndexSortedIndexWithIndexSortedIndex = sortedIndexWithIndexSortedIndexWithIndexSorted.map(_._2)\n        val sortedIndexWithIndexSortedIndexWithIndexSortedIndexWithIndex = sortedIndexWithIndexSortedIndexWithIndexSortedIndex.zipWithIndex\n        val sortedIndexWithIndexSortedIndexWithIndexSortedIndexWithIndexSorted = sortedIndexWithIndexSortedIndexWithIndexSortedIndexWithIndex.sortBy(_._1)\n        val sortedIndexWithIndexSortedIndexWithIndexSortedIndexWithIndexSortedIndex = sortedIndexWithIndexSortedIndexWithIndexSortedIndexWithIndexSorted.map(_._2)\n        val sortedIndexWithIndexSortedIndexWithIndexSortedIndexWithIndexSortedIndexWithIndex = sortedIndexWithIndexSortedIndexWithIndexSortedIndexWithIndexSortedIndex.zipWithIndex\n        val sortedIndexWithIndexSortedIndexWithIndexSortedIndexWithIndexSortedIndexWithIndexSorted = sortedIndexWithIndexSortedIndexWithIndexSortedIndexWithIndexSortedIndexWithIndex.sortBy(_._1)\n        val sortedIndexWithIndexSortedIndexWithIndexSortedIndexWithIndexSortedIndexWithIndexSortedIndex = sortedIndexWithIndexSortedIndexWithIndexSortedIndexWithIndexSortedIndexWithIndexSorted.map(_._2)\n        val sortedIndexWithIndexSortedIndexWithIndexSortedIndexWithIndexSortedIndexWithIndexSortedIndexWithIndex = sortedIndexWithIndexSortedIndexWithIndexSortedIndexWithIndexSortedIndexWithIndexSortedIndex.zipWithIndex\n        val sortedIndexWithIndexSorted",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(k)\n            b.reverse ::: a\n        }\n        def findMax(nums : List[Long]) : (Int, Long) = {\n            var max = Long.MinValue\n            var maxIndex = -1\n            for (i <- 0 until nums.length) {\n                if (nums(i) > max) {\n                    max = nums(i)\n                    maxIndex = i\n                }\n            }\n            (maxIndex, max)\n        }\n        def sort(nums : List[Long]) : List[Long] = {\n            if (nums.length == 1) nums\n            else {\n                val (maxIndex, max) = findMax(nums)\n                val nums1 = flip(nums, maxIndex + 1)\n                val nums2 = flip(nums1, nums1.length)\n                nums2.head :: sort(nums2.tail)\n            }\n        }\n        sort(nums)",
    "        val n = nums.length\n        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until n) {\n            val index = current.indexOf(sorted(i))\n            result = (index + 1) :: result\n            current = current.take(index).reverse ::: current.drop(index)\n            result = (n - i) :: result\n            current = current.take(n - i).reverse ::: current.drop(n - i)\n        }\n        result.reverse",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- sorted.length - 1 to 0 by -1) {\n            val index = current.indexOf(sorted(i))\n            result = (index + 1) :: result\n            current = current.take(index).reverse ::: current.drop(index)\n            result = (current.length) :: result\n            current = current.reverse\n        }\n        result",
    "        var result = List[Long]()\n        var current = nums\n        for (i <- nums.length - 1 to 1 by -1) {\n            val max = current.max\n            val index = current.indexOf(max)\n            if (index != i) {\n                result = result :+ (index + 1).toLong\n                current = current.take(index + 1).reverse ::: current.drop(index + 1)\n                result = result :+ (i + 1).toLong\n                current = current.take(i + 1).reverse ::: current.drop(i + 1)\n            }\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- nums.length - 1 to 0 by -1) {\n            val max = nums.indexOf(nums.max)\n            if (max != i) {\n                result = result :+ (max + 1).toLong\n                result = result :+ (i + 1).toLong\n            }\n            val (left, right) = nums.splitAt(max + 1)\n            nums = right.reverse ::: left.reverse\n        }\n        result",
    "        val n = nums.length\n        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until n) {\n            val max = current.indexOf(sorted(n - 1 - i))\n            if (max != n - 1 - i) {\n                result = result :+ (max + 1).toLong\n                current = current.take(max + 1).reverse ++ current.drop(max + 1)\n                result = result :+ (n - i).toLong\n                current = current.take(n - i).reverse ++ current.drop(n - i)\n            }\n        }\n        result",
    "        var l = nums\n        var result = List[Long]()\n        for (i <- 0 until l.length) {\n            val max = l.max\n            val index = l.indexOf(max)\n            result = result :+ (index + 1)\n            l = l.take(index).reverse ::: l.drop(index)\n            result = result :+ (l.length - i)\n            l = l.reverse\n        }\n        result",
    "        val sorted = nums.sorted\n        val n = nums.length\n        val result = new ListBuffer[Long]\n        for (i <- 0 until n) {\n            val index = nums.indexOf(sorted(i))\n            if (index != i) {\n                result += (index + 1).toLong\n                result += (i + 1).toLong\n            }\n        }\n        result.toList",
    "        var result = List[Long]()\n        var current = nums\n        while (current.length > 0) {\n            val max = current.max\n            val maxIndex = current.indexOf(max)\n            current = current.take(maxIndex).reverse ::: current.drop(maxIndex + 1)\n            current = current.reverse\n            result = max :: result\n        }\n        result",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(k)\n            b.reverse ::: a\n        }\n        def findMax(nums : List[Long]) : (Int, Long) = {\n            var max = Long.MinValue\n            var maxIndex = -1\n            for (i <- 0 until nums.length) {\n                if (nums(i) > max) {\n                    max = nums(i)\n                    maxIndex = i\n                }\n            }\n            (maxIndex, max)\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) return nums\n            val (maxIndex, max) = findMax(nums)\n            val nums1 = flip(nums, maxIndex + 1)\n            val nums2 = flip(nums1, k)\n            sort(nums2, k - 1)\n        }\n        sort(nums, nums.length)",
    "        val sorted = nums.sorted\n        val result = ListBuffer[Long]()\n        var current = nums\n        while (current != sorted) {\n            val max = current.max\n            val maxIndex = current.indexOf(max)\n            result += (maxIndex + 1).toLong\n            result += (current.length).toLong\n            current = current.take(maxIndex).reverse ++ current.drop(maxIndex + 1)\n            current = current.reverse\n        }\n        result.toList",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            if (index == 0) {\n                current = current.tail\n                result = result :+ 1\n            } else {\n                current = current.slice(0, index + 1).reverse ++ current.slice(index + 1, current.length)\n                result = result :+ (index + 1)\n                current = current.tail\n                result = result :+ 1\n            }\n        }\n        result",
    "        def sort(nums : List[Long], result : List[Long]) : List[Long] = {\n            if (nums.length == 0) result\n            else {\n                val max = nums.max\n                val index = nums.indexOf(max)\n                val newNums = nums.take(index).reverse ::: nums.drop(index)\n                sort(newNums.drop(1), result :+ newNums.length)\n            }\n        }\n        sort(nums, List())",
    "        val n = nums.length\n        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until n) {\n            val index = current.indexOf(sorted(i))\n            if (index != 0) {\n                result = (index + 1) :: result\n                current = current.take(index + 1).reverse ::: current.drop(index + 1)\n            }\n            result = (n - i) :: result\n            current = current.take(n - i).reverse ::: current.drop(n - i)\n        }\n        result.reverse",
    "        val sorted = nums.sorted\n        val result = new ListBuffer[Long]\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            if (index != 0) {\n                result += (index + 1).toLong\n                current = current.take(index + 1).reverse ++ current.drop(index + 1)\n            }\n            result += 1\n            current = current.reverse\n        }\n        result.toList",
    "        val n = nums.length\n        val sorted = nums.sorted\n        var result = List[Long]()\n        var index = 0\n        while (index < n) {\n            val max = sorted(n - index - 1)\n            val maxIndex = nums.indexOf(max)\n            if (maxIndex == n - index - 1) {\n                index += 1\n            } else {\n                if (maxIndex != 0) {\n                    result = maxIndex + 1 :: result\n                    nums.take(maxIndex + 1).reverse.foreach(x => nums.remove(nums.indexOf(x)))\n                    nums.insertAll(0, nums.take(maxIndex + 1).reverse)\n                }\n                result = (n - index) :: result\n                nums.take(n - index).reverse.foreach(x => nums.remove(nums.indexOf(x)))\n                nums.insertAll(0, nums.take(n - index).reverse)\n                index += 1\n            }\n        }\n        result",
    "        val n = nums.length\n        val sorted = nums.sorted\n        val map = new HashMap[Long, Int]\n        for (i <- 0 until n) map += (sorted(i) -> i)\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until n) {\n            val index = map(current(0))\n            if (index != 0) {\n                result = (index + 1) :: result\n                current = current.take(index + 1).reverse ::: current.drop(index + 1)\n            }\n            result = (n - i) :: result\n            current = current.take(n - i).reverse ::: current.drop(n - i)\n        }\n        result",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            result = result :+ index.toLong\n            current = (current.take(index).reverse ::: current.drop(index)).reverse\n        }\n        result",
    "        val n = nums.length\n        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until n) {\n            val index = current.indexOf(sorted(i))\n            val flipped = current.take(index + 1).reverse ++ current.drop(index + 1)\n            result = result :+ (index + 1).toLong\n            current = flipped.reverse\n            result = result :+ (n - i).toLong\n            current = current.reverse\n        }\n        result",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (first, second) = nums.splitAt(k)\n            second.reverse ::: first\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = 0\n            for (i <- 1 until k) {\n                if (nums(i) > nums(max)) max = i\n            }\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val max = findMax(nums, k)\n                val flipped = flip(nums, max + 1)\n                val flipped2 = flip(flipped, k)\n                sort(flipped2, k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        var result = List[Long]()\n        var list = nums\n        while (list.size > 0) {\n            val max = list.max\n            val maxIndex = list.indexOf(max)\n            if (maxIndex != list.size - 1) {\n                result = max :: result\n                list = list.take(maxIndex).reverse ::: list.drop(maxIndex)\n                result = list.size.toLong :: result\n                list = list.reverse\n            }\n            list = list.dropRight(1)\n        }\n        result",
    "        var result = List[Long]()\n        var nums2 = nums\n        for (i <- 0 to nums.length - 1) {\n            val max = nums2.max\n            val index = nums2.indexOf(max)\n            result = result :+ (index + 1)\n            result = result :+ (nums.length - i)\n            nums2 = nums2.take(index).reverse ::: nums2.drop(index + 1)\n            nums2 = nums2.take(nums.length - i).reverse ::: nums2.drop(nums.length - i)\n        }\n        result",
    "        val sorted = nums.sorted\n        val result = new ListBuffer[Long]\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            result += (index + 1)\n            result += (i + 1)\n            current = current.take(index).reverse ++ current.drop(index + 1)\n            current = current.take(i + 1).reverse ++ current.drop(i + 1)\n        }\n        result.toList",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            result = result :+ (index + 1)\n            result = result :+ (i + 1)\n            current = current.take(index).reverse ::: current.drop(index)\n            current = current.take(i + 1).reverse ::: current.drop(i + 1)\n        }\n        result",
    "        if (nums.size == 1) return nums\n        var max = nums.max\n        var index = nums.indexOf(max)\n        var result = nums.take(index + 1).reverse ++ nums.drop(index + 1)\n        result = result.take(result.size - 1).reverse ++ result.drop(result.size - 1)\n        return result",
    "        val sorted = nums.sorted\n        val result = ListBuffer[Long]()\n        var current = nums\n        while (current != sorted) {\n            val max = current.max\n            val index = current.indexOf(max)\n            result += (index + 1).toLong\n            result += (current.length).toLong\n            current = current.take(index).reverse ++ current.drop(index)\n            current = current.takeRight(current.length - 1).reverse ++ current.takeRight(1)\n        }\n        result.toList",
    "        val n = nums.length\n        var result = List[Long]()\n        for (i <- n - 1 to 1 by -1) {\n            val max = nums.slice(0, i + 1).max\n            val maxIndex = nums.slice(0, i + 1).indexOf(max)\n            if (maxIndex != i) {\n                result = maxIndex + 1 :: result\n                result = i + 1 :: result\n            }\n        }\n        result",
    "        // Find the index of the largest element.\n        def findLargestIndex(nums : List[Long]) : Int = {\n            var index = 0\n            var max = Long.MinValue\n            for (i <- 0 until nums.length) {\n                if (nums(i) > max) {\n                    max = nums(i)\n                    index = i\n                }\n            }\n            index\n        }\n        // Reverse a list of elements.\n        def reverse(nums : List[Long], start : Int, end : Int) : List[Long] = {\n            var result = nums.slice(0, start)\n            for (i <- start to end) {\n                result = result :+ nums(end - i + start)\n            }\n            result ++ nums.slice(end + 1, nums.length)\n        }\n        // Sort a list of elements.\n        def sort(nums : List[Long]) : List[Long] = {\n            if (nums.length == 1) return nums\n            var index = findLargestIndex(nums)\n            var result = reverse(nums, 0, index)\n            result = reverse(result, 0, result.length - 1)\n            result\n        }\n        sort(nums)",
    "        val n = nums.length\n        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until n) {\n            val index = current.indexOf(sorted(n - i - 1))\n            if (index != n - i - 1) {\n                result = (n - index) :: result\n                current = current.take(index + 1).reverse ::: current.drop(index + 1)\n                result = (n - i) :: result\n                current = current.take(i + 1).reverse ::: current.drop(i + 1)\n            }\n        }\n        result",
    "        val n = nums.length\n        val sorted = nums.sorted\n        var result = List[Long]()\n        var cur = nums\n        for (i <- 0 until n) {\n            val index = cur.indexOf(sorted(i))\n            if (index != i) {\n                result = (index + 1) :: result\n                cur = cur.take(index + 1).reverse ::: cur.drop(index + 1)\n                result = (i + 1) :: result\n                cur = cur.take(i + 1).reverse ::: cur.drop(i + 1)\n            }\n        }\n        result.reverse",
    "        var result = nums\n        for (i <- 0 until nums.length) {\n            val maxIndex = result.indexOf(result.max)\n            result = result.take(maxIndex + 1).reverse ++ result.drop(maxIndex + 1)\n            result = result.take(i + 1).reverse ++ result.drop(i + 1)\n        }\n        result",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            result = result :+ (index + 1).toLong\n            current = current.take(index).reverse ::: current.drop(index)\n            result = result :+ (i + 1).toLong\n            current = current.take(i).reverse ::: current.drop(i)\n        }\n        result",
    "        var result = nums\n        for (i <- nums.length - 1 to 1 by -1) {\n            val max = result.slice(0, i + 1).max\n            val maxIndex = result.indexOf(max)\n            result = result.slice(0, maxIndex).reverse ::: result.slice(maxIndex, i + 1)\n            result = result.slice(0, i + 1).reverse ::: result.slice(i + 1, result.length)\n        }\n        result",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(k)\n            b.reverse ::: a\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = 0\n            for (i <- 0 until k) {\n                if (nums(i) > nums(max)) max = i\n            }\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val max = findMax(nums, k)\n                val nums1 = flip(nums, max + 1)\n                val nums2 = flip(nums1, k + 1)\n                sort(nums2, k - 1)\n            }\n        }\n        sort(nums, nums.length - 1)",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(k)\n            b.reverse ::: a\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val max = nums.indexOf(nums.max)\n                val nums1 = flip(nums, max + 1)\n                val nums2 = flip(nums1, k)\n                sort(nums2, k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        var result = List[Long]()\n        var nums2 = nums\n        while (nums2.length > 0) {\n            val max = nums2.max\n            val maxIndex = nums2.indexOf(max)\n            result = max :: result\n            nums2 = nums2.slice(0, maxIndex).reverse ::: nums2.slice(maxIndex + 1, nums2.length)\n            result = nums2.length.toLong :: result\n            nums2 = nums2.reverse\n        }\n        result.reverse",
    "        val n = nums.length\n        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until n) {\n            val index = current.indexOf(sorted(i))\n            result = (index + 1) :: result\n            current = current.take(index).reverse ::: current.drop(index)\n            result = (n - i) :: result\n            current = current.take(n - i).reverse ::: current.drop(n - i)\n        }\n        result.reverse",
    "        val n = nums.length\n        val sorted = nums.sorted\n        val result = new ListBuffer[Long]\n        for (i <- 0 until n) {\n            val index = nums.indexOf(sorted(i))\n            if (index != i) {\n                result += (index + 1).toLong\n                result += (i + 1).toLong\n            }\n        }\n        result.toList",
    "        // Sort the list in ascending order.\n        val sorted = nums.sorted\n        // Create a map to store the index of each element.\n        val indexMap = new HashMap[Long, Int]()\n        for (i <- 0 until nums.length) indexMap(nums(i)) = i\n        // Create a map to store the index of each element in the sorted list.\n        val sortedIndexMap = new HashMap[Long, Int]()\n        for (i <- 0 until nums.length) sortedIndexMap(sorted(i)) = i\n        // Create a list to store the result.\n        val result = new ListBuffer[Long]()\n        // Iterate through the sorted list.\n        for (i <- 0 until nums.length) {\n            // If the element is already in the correct position, skip it.\n            if (indexMap(sorted(i)) == i) continue\n            // Otherwise, find the index of the element in the original list.\n            val index = indexMap(sorted(i))\n            // If the element is not at the beginning of the list, flip the list up to the element.\n            if (index != 0) result += index + 1\n            // Flip the list up to the correct position.\n            result += i + 1\n        }\n        result.toList",
    "        var result = List[Long]()\n        var list = nums\n        for (i <- 0 until nums.length) {\n            val max = list.max\n            val index = list.indexOf(max)\n            if (index != 0) {\n                result = result :+ (index + 1)\n                list = list.take(index).reverse ::: list.drop(index)\n            }\n            result = result :+ (list.length - i)\n            list = list.take(list.length - i - 1).reverse ::: list.drop(list.length - i - 1)\n        }\n        result",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            result = result :+ (index + 1).toLong\n            current = current.take(index).reverse ::: current.drop(index)\n            result = result :+ (current.length - i).toLong\n            current = current.take(current.length - i - 1).reverse ::: current.drop(current.length - i - 1)\n        }\n        result",
    "        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val max = current.max\n            val maxIndex = current.indexOf(max)\n            result = result :+ (maxIndex + 1)\n            result = result :+ (maxIndex + 1)\n            current = current.take(maxIndex).reverse ::: current.drop(maxIndex + 1)\n            current = current.reverse\n        }\n        result",
    "        val n = nums.length\n        var res = List[Long]()\n        for (i <- n - 1 to 1 by -1) {\n            val max = nums.slice(0, i + 1).max\n            val maxIndex = nums.slice(0, i + 1).indexOf(max)\n            res = res :+ (maxIndex + 1).toLong\n            res = res :+ (i + 1).toLong\n        }\n        res",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (first, second) = nums.splitAt(k)\n            second.reverse ::: first\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = 0\n            for (i <- 0 until k) {\n                if (nums(i) > nums(max)) max = i\n            }\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val max = findMax(nums, k)\n                val nums1 = flip(nums, max + 1)\n                val nums2 = flip(nums1, k)\n                sort(nums2, k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (first, second) = nums.splitAt(k)\n            second.reverse ::: first\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = 0\n            for (i <- 1 to k) {\n                if (nums(i) > nums(max)) max = i\n            }\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val max = findMax(nums, k)\n                val newNums = flip(nums, max + 1)\n                val newNums2 = flip(newNums, k + 1)\n                sort(newNums2, k - 1)\n            }\n        }\n        sort(nums, nums.length - 1)",
    "        val sorted = nums.sorted\n        val n = nums.length\n        val result = new ListBuffer[Long]\n        for (i <- 0 until n) {\n            val index = nums.indexOf(sorted(i))\n            result += (index + 1).toLong\n            result += (n - i).toLong\n        }\n        result.toList",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        for (i <- 0 until nums.length) {\n            val index = nums.indexOf(sorted(i))\n            if (index != i) {\n                result = result :+ index.toLong + 1\n                result = result :+ (i + 1).toLong\n            }\n        }\n        result",
    "        val sorted = nums.sorted\n        val n = nums.length\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until n) {\n            val index = current.indexOf(sorted(i))\n            result = (index + 1) :: result\n            current = current.take(index).reverse ::: current.drop(index)\n            result = (n - i) :: result\n            current = current.take(n - i).reverse ::: current.drop(n - i)\n        }\n        result",
    "        var result = List[Long]()\n        var nums2 = nums\n        while (nums2.length > 0) {\n            val max = nums2.max\n            val maxIndex = nums2.indexOf(max)\n            result = max :: result\n            nums2 = nums2.take(maxIndex).reverse ::: nums2.drop(maxIndex + 1)\n            result = nums2.length.toLong :: result\n            nums2 = nums2.reverse\n        }\n        result",
    "        val n = nums.length\n        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until n) {\n            val index = current.indexOf(sorted(i))\n            result = (index + 1) :: result\n            current = current.take(index + 1).reverse ::: current.drop(index + 1)\n            result = (n - i) :: result\n            current = current.take(n - i).reverse ::: current.drop(n - i)\n        }\n        result",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        while (current != sorted) {\n            val max = current.max\n            val index = current.indexOf(max)\n            result = result :+ (index + 1)\n            current = current.take(index).reverse ::: current.drop(index)\n            result = result :+ (current.length)\n            current = current.reverse\n        }\n        result",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (first, second) = nums.splitAt(k)\n            second.reverse ::: first\n        }\n        def findMax(nums : List[Long]) : (Int, Long) = {\n            val max = nums.max\n            val index = nums.indexOf(max)\n            (index, max)\n        }\n        def sort(nums : List[Long]) : List[Long] = {\n            if (nums.length == 1) nums\n            else {\n                val (index, max) = findMax(nums)\n                val flipped = flip(nums, index + 1)\n                val sorted = flip(flipped, flipped.length)\n                sorted.head :: sort(sorted.tail)\n            }\n        }\n        sort(nums)",
    "        val n = nums.length\n        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until n - 1) {\n            val index = current.indexOf(sorted(i))\n            result = (index + 1) :: result\n            current = current.take(index + 1).reverse ::: current.drop(index + 1)\n            result = (n - i) :: result\n            current = current.take(n - i).reverse ::: current.drop(n - i)\n        }\n        result",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (first, second) = nums.splitAt(k)\n            second.reverse ::: first\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = 0\n            for (i <- 1 until k) {\n                if (nums(i) > nums(max)) max = i\n            }\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 1) nums\n            else {\n                val max = findMax(nums, k)\n                val flipped = flip(nums, max + 1)\n                val flipped2 = flip(flipped, k)\n                sort(flipped2, k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        var result = List[Long]()\n        for (i <- nums.length - 1 to 0 by -1) {\n            val index = nums.indexOf(i + 1)\n            if (index != i) {\n                result = (index + 1) :: result\n                result = (i + 1) :: result\n            }\n        }\n        result",
    "        val n = nums.length\n        var result = List[Long]()\n        for (i <- n to 1 by -1) {\n            val index = nums.indexOf(i)\n            if (index != i - 1) {\n                result = result :+ (index + 1)\n                result = result :+ (i)\n            }\n        }\n        result",
    "        val sorted = nums.sorted\n        val n = nums.length\n        val result = new ListBuffer[Long]\n        for (i <- 0 until n) {\n            val index = nums.indexOf(sorted(i))\n            result += (index + 1).toLong\n            result += (n - i).toLong\n        }\n        result.toList",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- sorted.length - 1 to 0 by -1) {\n            val index = current.indexOf(sorted(i))\n            result = result :+ (index + 1)\n            current = current.take(index).reverse ::: current.drop(index)\n            result = result :+ (current.length)\n            current = current.reverse\n        }\n        result",
    "        val n = nums.length\n        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until n) {\n            val index = current.indexOf(sorted(i))\n            result = (index + 1) :: result\n            current = current.take(index + 1).reverse ::: current.drop(index + 1)\n        }\n        result",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            result = (index + 1) :: result\n            current = current.take(index).reverse ::: current.drop(index)\n            result = (current.length - i) :: result\n            current = current.reverse\n        }\n        result.reverse",
    "        if (nums.length == 1) return nums\n        var max = nums.max\n        var maxIndex = nums.indexOf(max)\n        var newNums = nums.take(maxIndex + 1).reverse ++ nums.drop(maxIndex + 1)\n        return pancakeSort(newNums.drop(1)) :+ max",
    "        var result = nums\n        for (i <- nums.length - 1 to 1 by -1) {\n            val max = result.slice(0, i + 1).max\n            val index = result.indexOf(max)\n            result = result.slice(0, index + 1).reverse ++ result.slice(index + 1, result.length)\n            result = result.slice(0, i + 1).reverse ++ result.slice(i + 1, result.length)\n        }\n        result",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 to nums.length - 1) {\n            val index = current.indexOf(sorted(i))\n            if (index != 0) {\n                result = result :+ index.toLong + 1\n                current = current.take(index).reverse ::: current.drop(index)\n            }\n            result = result :+ (current.length - i).toLong\n            current = current.take(current.length - i - 1).reverse ::: current.drop(current.length - i - 1)\n        }\n        result",
    "        val n = nums.length\n        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until n) {\n            val index = current.indexOf(sorted(n - i - 1))\n            val flipped = current.take(index + 1).reverse ::: current.drop(index + 1)\n            result = (index + 1) :: result\n            current = flipped.take(n - i - 1).reverse ::: flipped.drop(n - i - 1)\n        }\n        result",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until sorted.length) {\n            val index = current.indexOf(sorted(i))\n            result = (index + 1) :: result\n            current = current.take(index).reverse ::: current.drop(index)\n            result = (current.length) :: result\n            current = current.reverse\n        }\n        result.reverse",
    "        var result = List[Long]()\n        var nums2 = nums\n        while (nums2.size > 0) {\n            val max = nums2.max\n            val index = nums2.indexOf(max)\n            result = result :+ (index + 1)\n            result = result :+ (nums2.size)\n            nums2 = nums2.take(index).reverse ::: nums2.drop(index + 1)\n            nums2 = nums2.reverse\n        }\n        result",
    "        val n = nums.length\n        val result = ArrayBuffer[Long]()\n        for (i <- n - 1 to 0 by -1) {\n            val maxIndex = nums.slice(0, i + 1).zipWithIndex.maxBy(_._1)._2\n            if (maxIndex != i) {\n                result += maxIndex + 1\n                result += i + 1\n            }\n        }\n        result.toList",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            if (index != 0) {\n                result = result :+ (index + 1)\n                current = current.take(index).reverse ::: current.drop(index)\n            }\n            result = result :+ (current.length - i)\n            current = current.take(current.length - i - 1).reverse ::: current.drop(current.length - i - 1)\n        }\n        result",
    "        val n = nums.length\n        val sorted = nums.sorted\n        val map = new HashMap[Long, Int]\n        for (i <- 0 until n) map(sorted(i)) = i\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until n) {\n            val x = current(i)\n            val index = map(x)\n            if (index != i) {\n                result = (n - index) :: (i + 1) :: result\n                current = current.take(index + 1).reverse ::: current.drop(index + 1)\n                current = current.take(i + 1).reverse ::: current.drop(i + 1)\n            }\n        }\n        result",
    "        val n = nums.length\n        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until n) {\n            val index = current.indexOf(sorted(i))\n            result = (index + 1) :: result\n            current = current.take(index).reverse ::: current.drop(index)\n            result = (n - i) :: result\n            current = current.take(n - i).reverse ::: current.drop(n - i)\n        }\n        result.reverse",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val max = current.max\n            val index = current.indexOf(max)\n            result = result :+ (index + 1)\n            result = result :+ (current.length - i)\n            current = current.take(index).reverse ::: current.drop(index + 1)\n            current = current.reverse\n        }\n        result",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (first, second) = nums.splitAt(k)\n            second.reverse ::: first\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = 0\n            for (i <- 1 to k) {\n                if (nums(i) > nums(max)) max = i\n            }\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val max = findMax(nums, k)\n                val nums1 = flip(nums, max + 1)\n                val nums2 = flip(nums1, k + 1)\n                sort(nums2, k - 1)\n            }\n        }\n        sort(nums, nums.length - 1)",
    "        val sorted = nums.sorted\n        val result = new ListBuffer[Long]\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            if (index != 0) {\n                result += index + 1\n                current = current.take(index + 1).reverse ++ current.drop(index + 1)\n            }\n            result += 1\n            current = current.take(1).reverse ++ current.drop(1)\n        }\n        result.toList",
    "        var result = List[Long]()\n        var list = nums\n        while (list.length > 0) {\n            val max = list.max\n            val index = list.indexOf(max)\n            result = result :+ (index + 1)\n            result = result :+ (list.length)\n            list = list.take(index).reverse ::: list.drop(index + 1)\n            list = list.reverse\n        }\n        result",
    "        var result = List[Long]()\n        var nums2 = nums\n        while (nums2.length > 0) {\n            val max = nums2.max\n            val maxIndex = nums2.indexOf(max)\n            result = max :: result\n            result = (nums2.length - maxIndex).toLong :: result\n            nums2 = nums2.take(maxIndex).reverse ::: nums2.drop(maxIndex + 1)\n            nums2 = nums2.reverse\n        }\n        result",
    "        var result = nums\n        for (i <- 0 until nums.length) {\n            var maxIndex = 0\n            for (j <- 0 until nums.length - i) {\n                if (result(j) > result(maxIndex)) maxIndex = j\n            }\n            result = result.take(maxIndex + 1).reverse ::: result.drop(maxIndex + 1)\n            result = result.take(nums.length - i).reverse ::: result.drop(nums.length - i)\n        }\n        result",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until sorted.length) {\n            val index = current.indexOf(sorted(i))\n            result = (index + 1) :: result\n            current = current.take(index).reverse ::: current.drop(index)\n            result = (current.length) :: result\n            current = current.reverse\n        }\n        result",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(k)\n            b.reverse ::: a\n        }\n        def findMax(nums : List[Long]) : (Int, Long) = {\n            var max = 0\n            var maxValue = nums(0)\n            for (i <- 1 until nums.length) {\n                if (nums(i) > maxValue) {\n                    max = i\n                    maxValue = nums(i)\n                }\n            }\n            (max, maxValue)\n        }\n        def sort(nums : List[Long], result : List[Long]) : List[Long] = {\n            if (nums.length == 1) result\n            else {\n                val (max, maxValue) = findMax(nums)\n                val nums1 = flip(nums, max + 1)\n                val nums2 = flip(nums1, nums1.length)\n                sort(nums2.tail, maxValue :: result)\n            }\n        }\n        sort(nums, List())",
    "        if (nums.length == 0) return List()\n        val max = nums.max\n        val index = nums.indexOf(max)\n        val result = List(index + 1, nums.length)\n        pancakeSort(nums.take(index).reverse ::: nums.drop(index + 1)) ::: result",
    "        var list = nums\n        var result = List[Long]()\n        while (list.length > 0) {\n            val max = list.max\n            val maxIndex = list.indexOf(max)\n            result = max :: result\n            list = list.take(maxIndex).reverse ::: list.drop(maxIndex + 1)\n            result = list.length.toLong :: result\n            list = list.reverse\n        }\n        result.reverse",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(k)\n            b.reverse ::: a\n        }\n        def findMax(nums : List[Long]) : (Long, Int) = {\n            var max = Long.MinValue\n            var index = -1\n            for (i <- 0 until nums.length) {\n                if (nums(i) > max) {\n                    max = nums(i)\n                    index = i\n                }\n            }\n            (max, index)\n        }\n        def findMin(nums : List[Long]) : (Long, Int) = {\n            var min = Long.MaxValue\n            var index = -1\n            for (i <- 0 until nums.length) {\n                if (nums(i) < min) {\n                    min = nums(i)\n                    index = i\n                }\n            }\n            (min, index)\n        }\n        def sort(nums : List[Long], result : List[Long]) : List[Long] = {\n            if (nums.length == 0) result\n            else {\n                val (max, index) = findMax(nums)\n                val (min, index2) = findMin(nums)\n                val nums2 = flip(nums, index + 1)\n                val nums3 = flip(nums2, nums2.length)\n                val nums4 = flip(nums3, index2 + 1)\n                sort(nums4.slice(0, nums4.length - 1), result ::: List(index + 1, nums4.length, index2 + 1))\n            }\n        }\n        sort(nums, List())",
    "        var list = nums\n        var result = List[Long]()\n        while (list.length > 0) {\n            val max = list.max\n            val index = list.indexOf(max)\n            result = result :+ (index + 1)\n            result = result :+ (list.length)\n            list = list.take(index).reverse ::: list.drop(index + 1)\n            list = list.reverse\n        }\n        result",
    "        var result = List[Long]()\n        var list = nums\n        for (i <- 0 until list.length) {\n            val max = list.max\n            val index = list.indexOf(max)\n            result = result :+ (index + 1)\n            list = list.take(index).reverse ::: list.drop(index)\n            result = result :+ (list.length)\n            list = list.reverse\n        }\n        result",
    "        val n = nums.length\n        val sorted = nums.sorted\n        var current = nums\n        var result = List[Long]()\n        for (i <- 0 until n) {\n            val index = current.indexOf(sorted(i))\n            if (index == 0) {\n                current = current.tail\n            } else {\n                result = result :+ index.toLong\n                current = current.take(index).reverse ::: current.drop(index)\n                result = result :+ n.toLong\n                current = current.reverse\n            }\n        }\n        result",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        for (i <- 0 until sorted.length) {\n            val index = nums.indexOf(sorted(i))\n            if (index != i) {\n                result = (index + 1) :: result\n                result = (i + 1) :: result\n            }\n        }\n        result.reverse",
    "        val sorted = nums.sorted\n        val n = nums.length\n        val result = new ListBuffer[Long]\n        for (i <- n - 1 to 0 by -1) {\n            val index = nums.indexOf(sorted(i))\n            if (index != i) {\n                result += index + 1\n                result += i + 1\n            }\n        }\n        result.toList",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        while (current != sorted) {\n            val max = current.max\n            val index = current.indexOf(max)\n            result = result :+ (index + 1).toLong\n            current = current.take(index).reverse ::: current.drop(index)\n            result = result :+ (current.length).toLong\n            current = current.reverse\n        }\n        result",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        for (i <- 0 until sorted.length) {\n            val index = nums.indexOf(sorted(i))\n            if (index != i) {\n                result = (index + 1) :: result\n                result = (i + 1) :: result\n            }\n        }\n        result",
    "        val sorted = nums.sorted\n        val result = new ListBuffer[Long]\n        for (i <- sorted.indices) {\n            val index = nums.indexOf(sorted(i))\n            if (index != i) {\n                result += (index + 1)\n                result += (i + 1)\n            }\n        }\n        result.toList",
    "        def swap(nums : List[Long], i : Int, j : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(i)\n            a ++ b.reverse.take(j - i + 1).reverse ++ b.drop(j - i + 1)\n        }\n        def helper(nums : List[Long], i : Int, j : Int, result : List[(Int, Int)]) : List[(Int, Int)] = {\n            if (i == j) result\n            else {\n                val max = nums.indexOf(nums.max)\n                val newNums = swap(nums, 0, max)\n                helper(swap(newNums, 0, j), i, j - 1, (max, j) :: result)\n            }\n        }\n        val result = helper(nums, 0, nums.length - 1, Nil)\n        result.map(x => x._1.toLong) ++ result.map(x => x._2.toLong)",
    "        val sorted = nums.sorted\n        val result = new ListBuffer[Long]\n        var current = nums\n        for (i <- sorted.length - 1 to 0 by -1) {\n            val index = current.indexOf(sorted(i))\n            result += index + 1\n            current = current.take(index).reverse ++ current.drop(index)\n            result += current.length\n            current = current.reverse\n        }\n        result.toList",
    "        var result = List[Long]()\n        var list = nums\n        while (list.length > 0) {\n            val max = list.max\n            val index = list.indexOf(max)\n            result = result :+ max\n            list = list.take(index).reverse ::: list.drop(index + 1)\n            result = result :+ list.length.toLong\n            list = list.reverse\n        }\n        result",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (first, second) = nums.splitAt(k)\n            second.reverse ::: first\n        }\n        def findMax(nums : List[Long]) : (Int, Long) = {\n            var max = Long.MinValue\n            var index = -1\n            for (i <- 0 until nums.length) {\n                if (nums(i) > max) {\n                    max = nums(i)\n                    index = i\n                }\n            }\n            (index, max)\n        }\n        def helper(nums : List[Long], result : List[Long]) : List[Long] = {\n            if (nums.length == 0) result\n            else {\n                val (index, max) = findMax(nums)\n                val newNums = flip(nums, index + 1)\n                val newResult = result ::: List(index + 1)\n                helper(newNums.tail, newResult)\n            }\n        }\n        helper(nums, List())",
    "        var result = List[Long]()\n        var nums2 = nums\n        while (nums2.length > 0) {\n            val max = nums2.max\n            val index = nums2.indexOf(max)\n            result = result :+ (index + 1)\n            result = result :+ (nums2.length)\n            nums2 = nums2.take(index).reverse ::: nums2.drop(index + 1)\n            nums2 = nums2.reverse\n        }\n        result",
    "        var result = List[Long]()\n        var nums2 = nums\n        while (nums2.length > 0) {\n            val max = nums2.max\n            val maxIndex = nums2.indexOf(max)\n            result = max :: result\n            result = (nums2.length - maxIndex) :: result\n            nums2 = nums2.take(maxIndex).reverse ::: nums2.drop(maxIndex + 1)\n            nums2 = nums2.reverse\n        }\n        result",
    "        val n = nums.length\n        val sorted = nums.sorted\n        val map = HashMap[Long, Int]()\n        for (i <- 0 until n) map(sorted(i)) = i\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until n) {\n            val index = map(current(0))\n            if (index != 0) {\n                result = (index + 1) :: result\n                current = current.slice(0, index + 1).reverse ::: current.slice(index + 1, n)\n            }\n            result = (n - i) :: result\n            current = current.slice(0, n - i).reverse ::: current.slice(n - i, n)\n        }\n        result.reverse",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        while (current != sorted) {\n            val max = current.max\n            val index = current.indexOf(max)\n            result = (index + 1) :: result\n            current = current.take(index).reverse ::: current.drop(index)\n            result = current.length :: result\n            current = current.reverse\n        }\n        result",
    "        val sorted = nums.sorted\n        val map = new HashMap[Long, Int]\n        for (i <- 0 until nums.length) map(nums(i)) = i\n        var result = List[Long]()\n        for (i <- 0 until nums.length) {\n            val index = map(sorted(i))\n            if (index != i) {\n                if (index != 0) {\n                    result = index + 1 :: result\n                    val temp = nums.slice(0, index + 1).reverse\n                    for (j <- 0 to index) nums(j) = temp(j)\n                }\n                result = (nums.length - i) :: result\n                val temp = nums.slice(0, nums.length - i).reverse\n                for (j <- 0 until nums.length - i) nums(j) = temp(j)\n            }\n        }\n        result",
    "        var result = List[Long]()\n        var current = nums\n        var i = 0\n        while (i < nums.length) {\n            var maxIndex = 0\n            for (j <- 0 until current.length) {\n                if (current(j) > current(maxIndex)) maxIndex = j\n            }\n            result = result :+ (maxIndex + 1)\n            result = result :+ (current.length - i)\n            current = current.take(maxIndex).reverse ::: current.drop(maxIndex + 1)\n            current = current.take(current.length - i).reverse ::: current.drop(current.length - i)\n            i += 1\n        }\n        result",
    "        val sorted = nums.sorted\n        val result = new ListBuffer[Long]\n        for (i <- 0 until sorted.length) {\n            val index = nums.indexOf(sorted(i))\n            if (index != i) {\n                result += (index + 1)\n                result += (i + 1)\n            }\n        }\n        result.toList",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            result = (index + 1) :: result\n            current = current.take(index).reverse ::: current.drop(index)\n            result = (current.length) :: result\n            current = current.reverse\n        }\n        result.reverse",
    "        var result = List[Long]()\n        var current = nums\n        while (current.length > 1) {\n            val max = current.max\n            val maxIndex = current.indexOf(max)\n            result = max :: result\n            current = current.take(maxIndex).reverse ::: current.drop(maxIndex)\n            result = current.length.toLong :: result\n            current = current.reverse\n        }\n        result",
    "        val n = nums.length\n        val result = new ListBuffer[Long]\n        for (i <- n to 1 by -1) {\n            val index = nums.indexOf(i)\n            if (index != i - 1) {\n                if (index != 0) {\n                    result += index + 1\n                    nums.take(index + 1).reverse.foreach(println)\n                    nums.take(index + 1).reverse.foreach(println)\n                    nums.take(index + 1).reverse.foreach(println)\n                    nums.take(index + 1).reverse.foreach(println)\n                    nums.take(index + 1).reverse.foreach(println)\n                    nums.take(index + 1).reverse.foreach(println)\n                    nums.take(index + 1).reverse.foreach(println)\n                    nums.take(index + 1).reverse.foreach(println)\n                    nums.take(index + 1).reverse.foreach(println)\n                    nums.take(index + 1).reverse.foreach(println)\n                    nums.take(index + 1).reverse.foreach(println)\n                    nums.take(index + 1).reverse.foreach(println)\n                    nums.take(index + 1).reverse.foreach(println)\n                    nums.take(index + 1).reverse.foreach(println)\n                    nums.take(index + 1).reverse.foreach(println)\n                    nums.take(index + 1).reverse.foreach(println)\n                    nums.take(index + 1).reverse.foreach(println)\n                    nums.take(index + 1).reverse.foreach(println)\n                    nums.take(index + 1).reverse.foreach(println)\n                    nums.take(index + 1).reverse.foreach(println)\n                    nums.take(index + 1).reverse.foreach(println)\n                    nums.take(index + 1).reverse.foreach(println)\n                    nums.take(index + 1).reverse.foreach(println)\n                    nums.take(index + 1).reverse.foreach(println)\n                    nums.take",
    "        if (nums.size == 1) return nums\n        val max = nums.max\n        val index = nums.indexOf(max)\n        val first = nums.slice(0, index + 1).reverse\n        val second = nums.slice(index + 1, nums.size)\n        pancakeSort(first ::: second)",
    "        var result = List[Long]()\n        var nums2 = nums\n        while (nums2.length > 1) {\n            val max = nums2.max\n            val maxIndex = nums2.indexOf(max)\n            result = result :+ (maxIndex + 1).toLong\n            nums2 = nums2.take(maxIndex).reverse ::: nums2.drop(maxIndex + 1)\n            result = result :+ nums2.length.toLong\n            nums2 = nums2.reverse\n        }\n        result",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(k)\n            b.reverse ::: a\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = 0\n            for (i <- 1 to k) {\n                if (nums(i) > nums(max)) max = i\n            }\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val max = findMax(nums, k)\n                val nums1 = flip(nums, max + 1)\n                val nums2 = flip(nums1, k + 1)\n                sort(nums2, k - 1)\n            }\n        }\n        sort(nums, nums.length - 1)",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        for (i <- 0 until sorted.length) {\n            val index = nums.indexOf(sorted(i))\n            result = (index + 1) :: result\n            result = (i + 1) :: result\n        }\n        result.reverse",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(k)\n            b.reverse ::: a\n        }\n        def findMax(nums : List[Long]) : (Int, Long) = {\n            var max = nums.head\n            var maxIndex = 0\n            for (i <- 1 until nums.length) {\n                if (nums(i) > max) {\n                    max = nums(i)\n                    maxIndex = i\n                }\n            }\n            (maxIndex, max)\n        }\n        def sort(nums : List[Long], result : List[Long]) : List[Long] = {\n            if (nums.length == 0) result\n            else {\n                val (maxIndex, max) = findMax(nums)\n                val nums1 = flip(nums, maxIndex + 1)\n                val nums2 = flip(nums1, nums1.length)\n                sort(nums2.tail, max :: result)\n            }\n        }\n        sort(nums, Nil)",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            if (index != 0) {\n                result = result :+ (index + 1)\n                current = current.take(index).reverse ::: current.drop(index)\n            }\n            result = result :+ (current.length - i)\n            current = current.take(current.length - i).reverse ::: current.drop(current.length - i)\n        }\n        result",
    "        val n = nums.length\n        val result = new Array[Long](n)\n        for (i <- 0 until n) {\n            val max = nums.max\n            val index = nums.indexOf(max)\n            result(n - i - 1) = index + 1\n            nums.take(index).reverse ++ nums.drop(index + 1)\n        }\n        result.toList",
    "        val n = nums.length\n        var result = List[Long]()\n        var current = nums\n        for (i <- n to 1 by -1) {\n            val maxIndex = current.indexOf(current.max)\n            result = result :+ (maxIndex + 1).toLong\n            current = current.take(maxIndex).reverse ::: current.drop(maxIndex)\n            result = result :+ i.toLong\n            current = current.take(i).reverse ::: current.drop(i)\n        }\n        result",
    "        def flip(nums : List[Long], k : Int) : List[Long] = {\n            val (a, b) = nums.splitAt(k)\n            b.reverse ::: a\n        }\n        def findMax(nums : List[Long], k : Int) : (Int, Long) = {\n            var max = (0, nums.head)\n            for (i <- 1 until k) {\n                if (nums(i) > max._2) max = (i, nums(i))\n            }\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val (i, _) = findMax(nums, k)\n                val a = flip(nums, i + 1)\n                val b = flip(a, k)\n                sort(b, k - 1)\n            }\n        }\n        sort(nums, nums.length)",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            result = (index + 1) :: result\n            current = current.take(index).reverse ::: current.drop(index)\n            result = (current.length - i) :: result\n            current = current.reverse\n        }\n        result.reverse",
    "        val n = nums.length\n        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until n) {\n            val index = current.indexOf(sorted(i))\n            if (index != 0) {\n                result = result :+ (index + 1).toLong\n                current = current.take(index).reverse ::: current.drop(index)\n            }\n            result = result :+ (n - i).toLong\n            current = current.take(n - i).reverse ::: current.drop(n - i)\n        }\n        result",
    "        val sorted = nums.sorted\n        val result = new ListBuffer[Long]\n        var current = nums\n        while (current != sorted) {\n            val max = current.max\n            val maxIndex = current.indexOf(max)\n            result += maxIndex + 1\n            result += max\n            current = current.take(maxIndex).reverse ++ current.drop(maxIndex + 1)\n            current = current.take(current.length - 1).reverse\n        }\n        result.toList",
    "        val n = nums.length\n        val res = ListBuffer[Long]()\n        for (i <- n to 2 by -1) {\n            val max = nums.indexOf(nums.take(i).max)\n            if (max != i - 1) {\n                if (max != 0) {\n                    res += (max + 1).toLong\n                    nums.take(max + 1).reverse.foreach(println)\n                }\n                res += i.toLong\n                nums.take(i).reverse.foreach(println)\n            }\n        }\n        res.toList",
    "        val sorted = nums.sorted\n        val n = nums.length\n        val result = new ArrayBuffer[Long]\n        for (i <- 0 until n) {\n            val index = nums.indexOf(sorted(i))\n            if (index != i) {\n                result += (index + 1)\n                result += (i + 1)\n            }\n        }\n        result.toList",
    "        var result = List[Long]()\n        var current = nums\n        var max = current.max\n        var index = current.indexOf(max)\n        while (current.length > 0) {\n            if (index != 0) {\n                result = result :+ index + 1\n                current = current.take(index).reverse ::: current.drop(index)\n            }\n            result = result :+ current.length\n            current = current.reverse\n            max = current.max\n            index = current.indexOf(max)\n        }\n        result",
    "        val sorted = nums.sorted\n        val result = new ListBuffer[Long]\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            result += (index + 1)\n            result += (i + 1)\n            current = current.take(index).reverse ::: current.drop(index + 1)\n            current = current.take(i + 1).reverse ::: current.drop(i + 1)\n        }\n        result.toList",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            if (index != 0) {\n                result = result :+ (index + 1).toLong\n                current = current.take(index).reverse ::: current.drop(index)\n            }\n            result = result :+ (current.length - i).toLong\n            current = current.take(current.length - i - 1).reverse ::: current.drop(current.length - i - 1)\n        }\n        result",
    "        def reverse(nums : List[Long], k : Int) : List[Long] = {\n            nums.take(k).reverse ::: nums.drop(k)\n        }\n        def findMax(nums : List[Long], k : Int) : Int = {\n            var max = 0\n            for (i <- 0 until k) {\n                if (nums(i) > nums(max)) max = i\n            }\n            max\n        }\n        def sort(nums : List[Long], k : Int) : List[Long] = {\n            if (k == 0) nums\n            else {\n                val max = findMax(nums, k)\n                val nums1 = reverse(nums, max + 1)\n                val nums2 = reverse(nums1, k + 1)\n                sort(nums2, k - 1)\n            }\n        }\n        sort(nums, nums.length - 1)",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            val flipped = current.take(index + 1).reverse ++ current.drop(index + 1)\n            result = result :+ (index + 1).toLong\n            current = flipped.take(current.length - i).reverse ++ flipped.drop(current.length - i)\n            result = result :+ (current.length - i).toLong\n        }\n        result",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        for (i <- 0 until sorted.length) {\n            val index = nums.indexOf(sorted(i))\n            if (index != i) {\n                result = result :+ (index + 1)\n                result = result :+ (i + 1)\n            }\n        }\n        result",
    "        val n = nums.length\n        val sorted = nums.sorted\n        val result = new ListBuffer[Long]\n        var current = nums\n        for (i <- 0 until n) {\n            val index = current.indexOf(sorted(i))\n            result += (index + 1).toLong\n            result += (n - i).toLong\n            current = current.take(index).reverse ++ current.drop(index + 1)\n            current = current.take(n - i).reverse ++ current.drop(n - i)\n        }\n        result.toList",
    "        val n = nums.length\n        val result = new ListBuffer[Long]\n        for (i <- n - 1 to 0 by -1) {\n            val maxIndex = nums.indexOf(nums.max)\n            if (maxIndex != i) {\n                result += (maxIndex + 1)\n                result += (i + 1)\n                nums.take(maxIndex + 1).reverse.foreach(x => nums.remove(0))\n                nums.take(i + 1).reverse.foreach(x => nums.remove(0))\n            }\n        }\n        result.toList",
    "        val sorted = nums.sorted\n        val result = new ListBuffer[Long]\n        var current = nums\n        while (current != sorted) {\n            val max = current.max\n            val maxIndex = current.indexOf(max)\n            result += (maxIndex + 1).toLong\n            current = current.take(maxIndex).reverse ++ current.drop(maxIndex + 1)\n            result += (current.length).toLong\n            current = current.reverse\n        }\n        result.toList",
    "        val sorted = nums.sorted\n        val result = new ListBuffer[Long]\n        var current = nums\n        while (current != sorted) {\n            val max = current.max\n            val maxIndex = current.indexOf(max)\n            result += (maxIndex + 1)\n            result += (current.length)\n            current = current.take(maxIndex).reverse ++ current.drop(maxIndex + 1)\n            current = current.take(current.length - 1).reverse\n        }\n        result.toList",
    "        val sorted = nums.sorted\n        var result = List[Long]()\n        var current = nums\n        for (i <- 0 until nums.length) {\n            val index = current.indexOf(sorted(i))\n            result = (index + 1) :: result\n            current = current.take(index).reverse ::: current.drop(index)\n            result = (current.length) :: result\n            current = current.reverse\n        }\n        result.reverse"
  ]
}