{
  "name": "mbpp_286_max_sub_array_sum_repeated",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the largest sum of a contiguous list in the modified list which is formed by repeating the given list k times.\n    def maxSubArraySumRepeated(a : List[Long], n : Long, k : Long) : Long = {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_286_max_sub_array_sum_repeated.py",
  "prompt_terminology": "reworded",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(maxSubArraySumRepeated((List[Long](10l.toLong, 20l.toLong, -30l.toLong, -1l.toLong)), (4l), (3l)) == (30l));\n    assert(maxSubArraySumRepeated((List[Long](-1l.toLong, 10l.toLong, 20l.toLong)), (3l), (2l)) == (59l));\n    assert(maxSubArraySumRepeated((List[Long](-1l.toLong, -2l.toLong, -3l.toLong)), (3l), (3l)) == (-1l));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        val sum = a.sum\n        val max = a.max\n        if (max < 0) return max * k\n        val maxSum = maxSubArraySum(a)\n        if (maxSum > 0) return maxSum * k\n        val maxSumRepeated = maxSubArraySumRepeated(a, n, k - 1)\n        if (maxSumRepeated > 0) return maxSumRepeated + sum\n        return maxSumRepeated",
    "        val b = a.map(x => x * k)\n        var max_so_far = Long.MinValue\n        var max_ending_here = 0L\n        for (i <- 0 until n) {\n            max_ending_here = max_ending_here + b(i)\n            if (max_so_far < max_ending_here) max_so_far = max_ending_here\n            if (max_ending_here < 0) max_ending_here = 0\n        }\n        max_so_far",
    "        val sum = a.sum\n        val maxSubArraySum = maxSubArraySum(a)\n        if (sum > 0) maxSubArraySum * k + sum * (k - 1) * k / 2\n        else maxSubArraySum",
    "        val b = ListBuffer[Long]()\n        for (i <- 1 to k.toInt) b ++= a\n        val c = b.toList\n        val d = c.scanLeft(0L)(_ + _).tail\n        var max = Long.MinValue\n        for (i <- 0 until n.toInt) {\n            for (j <- i until n.toInt) {\n                val sum = d(j) - d(i)\n                if (sum > max) max = sum\n            }\n        }\n        max",
    "        val m = a.map(x => x * k).toArray\n        var max_so_far = 0L\n        var max_ending_here = 0L\n        for (i <- 0 until m.length) {\n            max_ending_here = max(m(i), max_ending_here + m(i))\n            max_so_far = max(max_so_far, max_ending_here)\n        }\n        max_so_far",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = sum * k\n            if (maxSumRepeated > maxSum) maxSumRepeated else maxSum\n        } else maxSum",
    "        val prefixSum = Array.ofDim[Long](n.toInt)\n        prefixSum(0) = a(0)\n        for (i <- 1 until n.toInt) prefixSum(i) = prefixSum(i - 1) + a(i)\n        var maxSum = Long.MinValue\n        for (i <- 0 until n.toInt) {\n            val sum = prefixSum(i) + (k - 1) * prefixSum(n.toInt - 1) - (k - 1) * prefixSum(i)\n            if (sum > maxSum) maxSum = sum\n        }\n        maxSum",
    "        val b = a.map(x => x * k)\n        val s = b.sum\n        val m = b.max\n        val l = b.min\n        val p = b.filter(x => x > 0).sum\n        val n = b.filter(x => x < 0).sum\n        if (s > 0) s\n        else if (m > 0) m\n        else if (l < 0) l\n        else if (p > 0) p\n        else n",
    "        val sum = a.sum\n        val max = a.max\n        if (max <= 0) max * k\n        else if (sum <= 0) max\n        else {\n            val maxSum = maxSubArraySum(a)\n            if (maxSum <= 0) maxSum\n            else {\n                val maxSumRepeated = maxSum * k\n                val sumRepeated = sum * k\n                val maxSumRepeatedWithLast = maxSumRepeated + (sumRepeated - sum)\n                max(maxSumRepeated, maxSumRepeatedWithLast)\n            }\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        val maxPrefix = a.scanLeft(0L)(_ + _).max\n        val maxSuffix = a.scanRight(0L)(_ + _).max\n        val maxSumRepeated = max(max(maxPrefix, maxSuffix), maxSum + (k - 2) * sum)\n        maxSumRepeated",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = sum * k\n            val maxSumRepeatedWithOverlap = sum * (k - 1) + maxSum\n            max(maxSumRepeated, maxSumRepeatedWithOverlap)\n        } else maxSum",
    "        val b = a.map(x => x * k)\n        val c = b.map(x => if (x > 0) x else 0)\n        val d = b.map(x => if (x < 0) x else 0)\n        val e = c.sum\n        val f = d.sum\n        val g = b.sum\n        if (e > 0) e + max(g, 0) else max(g, f)",
    "        val sum = a.sum\n        val max = a.max\n        if (max <= 0) return max * k\n        val maxSum = a.scanLeft(0L)(_ + _).max\n        val maxPrefix = a.scanLeft(0L)(_ + _).init.max\n        val maxSuffix = a.scanRight(0L)(_ + _).init.max\n        val maxSingle = max(maxPrefix + maxSuffix, maxSum)\n        val maxDouble = max(maxSingle, maxPrefix + maxSuffix + sum)\n        max(maxDouble, maxSingle + (k - 2) * sum)",
    "        val sums = new Array[Long](n.toInt)\n        var sum = 0L\n        for (i <- 0 until n.toInt) {\n            sum += a(i)\n            sums(i) = sum\n        }\n        var max = Long.MinValue\n        for (i <- 0 until n.toInt) {\n            val sum = sums(i)\n            if (sum > max) max = sum\n            for (j <- i + 1 until n.toInt) {\n                val sum = sums(j) - sums(i)\n                if (sum > max) max = sum\n            }\n        }\n        max * k",
    "        val sum = a.sum\n        val max = a.max\n        if (sum > 0) {\n            val maxSum = max * k + sum * (k - 1)\n            val minSum = max * k + sum * (k - 2) + a.min\n            max(maxSum, minSum)\n        } else {\n            max * k\n        }",
    "        val b = a.map(x => x * k)\n        var max_so_far = Long.MinValue\n        var max_ending_here = 0L\n        for (i <- 0 until n) {\n            max_ending_here = max_ending_here + b(i)\n            if (max_so_far < max_ending_here) max_so_far = max_ending_here\n            if (max_ending_here < 0) max_ending_here = 0\n        }\n        max_so_far",
    "        val sum = a.sum\n        val maxSum = a.scanLeft(0L)(_ + _).max\n        if (sum < 0) maxSum\n        else max(maxSum, sum * (k - 2) + maxSubArraySum(a, n))",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum < 0) maxSum\n        else {\n            val maxSumRepeated = sum * k\n            val maxSumCircular = maxSumRepeated - (a.map(x => min(x, 0)).sum)\n            max(maxSumRepeated, maxSumCircular)\n        }",
    "        val b = a.map(x => x * k)\n        val c = b.map(x => if (x > 0) x else 0)\n        val d = b.map(x => if (x < 0) x else 0)\n        val e = c.sum\n        val f = d.sum\n        val g = abs(f)\n        val h = e + g\n        val i = b.sum\n        val j = max(h, i)\n        return j",
    "        val b = a.map(x => x * k)\n        val prefixSum = b.scanLeft(0L)(_ + _).tail\n        val maxSum = prefixSum.max\n        val minSum = prefixSum.min\n        val maxPrefixSum = prefixSum.scanLeft(0L)(max(_, _)).tail\n        val minPrefixSum = prefixSum.scanLeft(0L)(min(_, _)).tail\n        val maxSuffixSum = prefixSum.reverse.scanLeft(0L)(max(_, _)).tail.reverse\n        val minSuffixSum = prefixSum.reverse.scanLeft(0L)(min(_, _)).tail.reverse\n        val maxSum1 = (0 until n.toInt).map(i => max(maxPrefixSum(i), maxSuffixSum(i + 1))).max\n        val minSum1 = (0 until n.toInt).map(i => min(minPrefixSum(i), minSuffixSum(i + 1))).min\n        max(maxSum, maxSum1, maxSum - minSum, maxSum - minSum1)"
  ]
}