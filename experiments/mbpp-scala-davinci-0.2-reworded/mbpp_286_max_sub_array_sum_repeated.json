{
  "name": "mbpp_286_max_sub_array_sum_repeated",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the largest sum of a contiguous list in the modified list which is formed by repeating the given list k times.\n    def maxSubArraySumRepeated(a : List[Long], n : Long, k : Long) : Long = {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_286_max_sub_array_sum_repeated.py",
  "prompt_terminology": "reworded",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(maxSubArraySumRepeated((List[Long](10l.toLong, 20l.toLong, -30l.toLong, -1l.toLong)), (4l), (3l)) == (30l));\n    assert(maxSubArraySumRepeated((List[Long](-1l.toLong, 10l.toLong, 20l.toLong)), (3l), (2l)) == (59l));\n    assert(maxSubArraySumRepeated((List[Long](-1l.toLong, -2l.toLong, -3l.toLong)), (3l), (3l)) == (-1l));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        val sum = a.sum\n        val max = a.max\n        if (max < 0) return max * k\n        val maxSum = maxSubArraySum(a)\n        if (maxSum > 0) return maxSum * k\n        val maxSumRepeated = maxSubArraySumRepeated(a, n, k - 1)\n        if (maxSumRepeated > 0) return maxSumRepeated + sum\n        return maxSumRepeated",
    "        val b = a.map(x => x * k)\n        var max_so_far = Long.MinValue\n        var max_ending_here = 0L\n        for (i <- 0 until n) {\n            max_ending_here = max_ending_here + b(i)\n            if (max_so_far < max_ending_here) max_so_far = max_ending_here\n            if (max_ending_here < 0) max_ending_here = 0\n        }\n        max_so_far",
    "        val sum = a.sum\n        val maxSubArraySum = maxSubArraySum(a)\n        if (sum > 0) maxSubArraySum * k + sum * (k - 1) * k / 2\n        else maxSubArraySum",
    "        val b = ListBuffer[Long]()\n        for (i <- 1 to k.toInt) b ++= a\n        val c = b.toList\n        val d = c.scanLeft(0L)(_ + _).tail\n        var max = Long.MinValue\n        for (i <- 0 until n.toInt) {\n            for (j <- i until n.toInt) {\n                val sum = d(j) - d(i)\n                if (sum > max) max = sum\n            }\n        }\n        max",
    "        val m = a.map(x => x * k).toArray\n        var max_so_far = 0L\n        var max_ending_here = 0L\n        for (i <- 0 until m.length) {\n            max_ending_here = max(m(i), max_ending_here + m(i))\n            max_so_far = max(max_so_far, max_ending_here)\n        }\n        max_so_far",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = sum * k\n            if (maxSumRepeated > maxSum) maxSumRepeated else maxSum\n        } else maxSum",
    "        val prefixSum = Array.ofDim[Long](n.toInt)\n        prefixSum(0) = a(0)\n        for (i <- 1 until n.toInt) prefixSum(i) = prefixSum(i - 1) + a(i)\n        var maxSum = Long.MinValue\n        for (i <- 0 until n.toInt) {\n            val sum = prefixSum(i) + (k - 1) * prefixSum(n.toInt - 1) - (k - 1) * prefixSum(i)\n            if (sum > maxSum) maxSum = sum\n        }\n        maxSum",
    "        val b = a.map(x => x * k)\n        val s = b.sum\n        val m = b.max\n        val l = b.min\n        val p = b.filter(x => x > 0).sum\n        val n = b.filter(x => x < 0).sum\n        if (s > 0) s\n        else if (m > 0) m\n        else if (l < 0) l\n        else if (p > 0) p\n        else n",
    "        val sum = a.sum\n        val max = a.max\n        if (max <= 0) max * k\n        else if (sum <= 0) max\n        else {\n            val maxSum = maxSubArraySum(a)\n            if (maxSum <= 0) maxSum\n            else {\n                val maxSumRepeated = maxSum * k\n                val sumRepeated = sum * k\n                val maxSumRepeatedWithLast = maxSumRepeated + (sumRepeated - sum)\n                max(maxSumRepeated, maxSumRepeatedWithLast)\n            }\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        val maxPrefix = a.scanLeft(0L)(_ + _).max\n        val maxSuffix = a.scanRight(0L)(_ + _).max\n        val maxSumRepeated = max(max(maxPrefix, maxSuffix), maxSum + (k - 2) * sum)\n        maxSumRepeated",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = sum * k\n            val maxSumRepeatedWithOverlap = sum * (k - 1) + maxSum\n            max(maxSumRepeated, maxSumRepeatedWithOverlap)\n        } else maxSum",
    "        val b = a.map(x => x * k)\n        val c = b.map(x => if (x > 0) x else 0)\n        val d = b.map(x => if (x < 0) x else 0)\n        val e = c.sum\n        val f = d.sum\n        val g = b.sum\n        if (e > 0) e + max(g, 0) else max(g, f)",
    "        val sum = a.sum\n        val max = a.max\n        if (max <= 0) return max * k\n        val maxSum = a.scanLeft(0L)(_ + _).max\n        val maxPrefix = a.scanLeft(0L)(_ + _).init.max\n        val maxSuffix = a.scanRight(0L)(_ + _).init.max\n        val maxSingle = max(maxPrefix + maxSuffix, maxSum)\n        val maxDouble = max(maxSingle, maxPrefix + maxSuffix + sum)\n        max(maxDouble, maxSingle + (k - 2) * sum)",
    "        val sums = new Array[Long](n.toInt)\n        var sum = 0L\n        for (i <- 0 until n.toInt) {\n            sum += a(i)\n            sums(i) = sum\n        }\n        var max = Long.MinValue\n        for (i <- 0 until n.toInt) {\n            val sum = sums(i)\n            if (sum > max) max = sum\n            for (j <- i + 1 until n.toInt) {\n                val sum = sums(j) - sums(i)\n                if (sum > max) max = sum\n            }\n        }\n        max * k",
    "        val sum = a.sum\n        val max = a.max\n        if (sum > 0) {\n            val maxSum = max * k + sum * (k - 1)\n            val minSum = max * k + sum * (k - 2) + a.min\n            max(maxSum, minSum)\n        } else {\n            max * k\n        }",
    "        val b = a.map(x => x * k)\n        var max_so_far = Long.MinValue\n        var max_ending_here = 0L\n        for (i <- 0 until n) {\n            max_ending_here = max_ending_here + b(i)\n            if (max_so_far < max_ending_here) max_so_far = max_ending_here\n            if (max_ending_here < 0) max_ending_here = 0\n        }\n        max_so_far",
    "        val sum = a.sum\n        val maxSum = a.scanLeft(0L)(_ + _).max\n        if (sum < 0) maxSum\n        else max(maxSum, sum * (k - 2) + maxSubArraySum(a, n))",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum < 0) maxSum\n        else {\n            val maxSumRepeated = sum * k\n            val maxSumCircular = maxSumRepeated - (a.map(x => min(x, 0)).sum)\n            max(maxSumRepeated, maxSumCircular)\n        }",
    "        val b = a.map(x => x * k)\n        val c = b.map(x => if (x > 0) x else 0)\n        val d = b.map(x => if (x < 0) x else 0)\n        val e = c.sum\n        val f = d.sum\n        val g = abs(f)\n        val h = e + g\n        val i = b.sum\n        val j = max(h, i)\n        return j",
    "        val b = a.map(x => x * k)\n        val prefixSum = b.scanLeft(0L)(_ + _).tail\n        val maxSum = prefixSum.max\n        val minSum = prefixSum.min\n        val maxPrefixSum = prefixSum.scanLeft(0L)(max(_, _)).tail\n        val minPrefixSum = prefixSum.scanLeft(0L)(min(_, _)).tail\n        val maxSuffixSum = prefixSum.reverse.scanLeft(0L)(max(_, _)).tail.reverse\n        val minSuffixSum = prefixSum.reverse.scanLeft(0L)(min(_, _)).tail.reverse\n        val maxSum1 = (0 until n.toInt).map(i => max(maxPrefixSum(i), maxSuffixSum(i + 1))).max\n        val minSum1 = (0 until n.toInt).map(i => min(minPrefixSum(i), minSuffixSum(i + 1))).min\n        max(maxSum, maxSum1, maxSum - minSum, maxSum - minSum1)",
    "        val sum = a.sum\n        val max = a.max\n        if (sum > 0) {\n            val maxSum = max * k + sum * (k - 1)\n            val minSum = max * k + sum * (k - 2) + a.min\n            max(maxSum, minSum)\n        }\n        else max * k",
    "        var sum = 0L\n        var maxSum = 0L\n        var maxSumSoFar = 0L\n        var maxSumEndingHere = 0L\n        for (i <- 0 until n.toInt) {\n            sum += a(i)\n            maxSumEndingHere = max(maxSumEndingHere + a(i), 0)\n            maxSumSoFar = max(maxSumSoFar, maxSumEndingHere)\n        }\n        maxSum = maxSumSoFar * k\n        if (sum > 0) maxSum += (k - 1) * sum\n        maxSum",
    "        val sum = a.sum\n        val maxSum = a.max\n        val maxSumRepeated = max(sum * k, maxSum)\n        val maxSumRepeated2 = max(maxSumRepeated, maxSubArraySum(a, n))\n        maxSumRepeated2",
    "        val b = a.map(x => x * k)\n        var max_so_far = Long.MinValue\n        var max_ending_here = 0L\n        for (i <- 0 until n) {\n            max_ending_here = max_ending_here + b(i)\n            if (max_so_far < max_ending_here) max_so_far = max_ending_here\n            if (max_ending_here < 0) max_ending_here = 0\n        }\n        max_so_far",
    "        val sum = a.sum\n        val max = a.max\n        if (sum > 0) sum * k\n        else max * k",
    "        val sum = a.sum\n        val max = a.max\n        if (sum < 0) max\n        else {\n            val sumRepeated = sum * k\n            val maxRepeated = max * k\n            val maxSubArraySum = maxSubArraySum(a, n)\n            if (maxSubArraySum > 0) max(maxSubArraySum, sumRepeated - maxSubArraySum + max)\n            else maxRepeated\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum <= 0) return maxSum * k\n        val maxSumRepeated = max(sum * k, maxSum + sum * (k - 1))\n        maxSumRepeated",
    "        val b = a.map(x => x * k)\n        val prefix = Array.fill(b.length + 1)(0L)\n        for (i <- 0 until b.length) prefix(i + 1) = prefix(i) + b(i)\n        val max = Array.fill(b.length + 1)(0L)\n        var result = 0L\n        for (i <- 1 to b.length) {\n            max(i) = max(i - 1)\n            for (j <- 1 to i) {\n                val sum = prefix(i) - prefix(j - 1)\n                if (sum > max(i)) max(i) = sum\n            }\n            if (max(i) > result) result = max(i)\n        }\n        result",
    "        val sum = a.sum\n        val max = a.max\n        if (max <= 0) return max * k\n        val prefix = Array.fill(n.toInt)(0L)\n        val suffix = Array.fill(n.toInt)(0L)\n        prefix(0) = a(0)\n        suffix(n.toInt - 1) = a(n.toInt - 1)\n        for (i <- 1 until n.toInt) {\n            prefix(i) = max(prefix(i - 1) + a(i), a(i))\n            suffix(n.toInt - 1 - i) = max(suffix(n.toInt - i) + a(n.toInt - 1 - i), a(n.toInt - 1 - i))\n        }\n        var result = max(prefix.max, suffix.max)\n        for (i <- 0 until n.toInt - 1) {\n            result = max(result, prefix(i) + suffix(i + 1))\n        }\n        result + (k - 2) * sum",
    "        val sum = a.sum\n        val max = a.max\n        if (sum > 0) sum * k\n        else if (k == 1) max\n        else {\n            val maxSum = a.scanLeft(0L)(_ + _).max\n            if (maxSum > 0) maxSum\n            else max\n        }",
    "        val sum = a.sum\n        val max = a.max\n        if (sum < 0) max\n        else if (sum * k < 0) max * k\n        else {\n            val maxSum = a.scanLeft(0L)((x, y) => x + y).max\n            val maxPrefix = a.scanLeft(0L)((x, y) => x + y).init.max\n            val maxSuffix = a.scanRight(0L)((x, y) => x + y).tail.max\n            val maxMiddle = maxPrefix + maxSuffix\n            val maxSumRepeated = max(maxSum, maxMiddle)\n            maxSumRepeated\n        }",
    "        val m = a.map(x => x * k).toArray\n        var max_so_far = 0L\n        var max_ending_here = 0L\n        for (i <- 0 until m.length) {\n            max_ending_here = max_ending_here + m(i)\n            if (max_ending_here < 0) max_ending_here = 0\n            if (max_so_far < max_ending_here) max_so_far = max_ending_here\n        }\n        max_so_far",
    "        val sum = a.sum\n        val max = a.max\n        if (max < 0) max\n        else if (sum < 0) maxSubArraySum(a, n)\n        else maxSubArraySum(a, n) + (k - 2) * sum",
    "        val sums = new Array[Long](a.length + 1)\n        for (i <- 1 to a.length) {\n            sums(i) = sums(i - 1) + a(i - 1)\n        }\n        var max = 0L\n        for (i <- 0 to a.length) {\n            for (j <- i + 1 to a.length) {\n                val sum = sums(j) - sums(i)\n                max = max max (sum * (k - 2) + sum max (sums(a.length) - sums(i)))\n            }\n        }\n        max",
    "        val b = a.map(x => x * k)\n        val c = b.map(x => x - n)\n        val d = c.map(x => x + n)\n        val e = d.map(x => x % n)\n        val f = e.map(x => if (x < 0) x + n else x)\n        val g = f.map(x => x % k)\n        val h = g.map(x => if (x == 0) n else x)\n        val i = h.map(x => x - 1)\n        val j = i.map(x => x * n)\n        val l = j.map(x => x / k)\n        val m = l.map(x => x + a(i.indexOf(x)))\n        val o = m.map(x => x % n)\n        val p = o.map(x => if (x < 0) x + n else x)\n        val q = p.map(x => x % k)\n        val r = q.map(x => if (x == 0) n else x)\n        val s = r.map(x => x - 1)\n        val t = s.map(x => x * n)\n        val u = t.map(x => x / k)\n        val v = u.map(x => x + a(s.indexOf(x)))\n        val w = v.map(x => x % n)\n        val x = w.map(x => if (x < 0) x + n else x)\n        val y = x.map(x => x % k)\n        val z = y.map(x => if (x == 0) n else x)\n        val aa = z.map(x => x - 1)\n        val ab = aa.map(x => x * n)\n        val ac = ab.map(x => x / k)\n        val ad = ac.map(x => x + a(aa.indexOf(x)))\n        val ae = ad.map(x => x % n)\n        val af = ae.map(x => if (x < 0) x + n else x)\n       ",
    "        val sums = new Array[Long](n.toInt)\n        sums(0) = a(0)\n        for (i <- 1 until n.toInt) sums(i) = sums(i - 1) + a(i)\n        var max = sums(0)\n        for (i <- 0 until n.toInt) {\n            val sum = sums(i) + (k - 1) * (sums(n.toInt - 1) - sums(i))\n            if (sum > max) max = sum\n        }\n        max",
    "        val b = a.map(x => x * k)\n        var max_so_far = b(0)\n        var curr_max = b(0)\n        for (i <- 1 until b.length) {\n            curr_max = max(b(i), curr_max + b(i))\n            max_so_far = max(max_so_far, curr_max)\n        }\n        max_so_far",
    "        val b = a.map(x => x * k)\n        val sum = b.sum\n        val max = b.max\n        val min = b.min\n        val maxSum = max(max, sum - min)\n        maxSum",
    "        val sum = a.foldLeft(0L)(_ + _)\n        val max = a.foldLeft(0L)((m, x) => max(m, x))\n        if (max <= 0) return max * k\n        val maxSum = maxSubArraySum(a, n)\n        val maxPrefixSum = maxPrefixSumRepeated(a, n, k)\n        val maxSuffixSum = maxSuffixSumRepeated(a, n, k)\n        max(maxSum, maxPrefixSum + maxSuffixSum + sum * (k - 2))",
    "        val sum = a.sum\n        val max = a.max\n        if (max <= 0) max * k\n        else {\n            val maxSum = maxSubArraySum(a, n)\n            val maxSumRepeated = maxSubArraySumRepeated(a, n, k - 1)\n            max(maxSum, maxSumRepeated, maxSum + sum * (k - 1))\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum < 0) maxSum\n        else {\n            val maxSumRepeated = sum * k\n            val maxSumCircular = maxSumRepeated - (a.map(x => min(x, 0)).sum)\n            max(maxSumRepeated, maxSumCircular)\n        }",
    "        val sum = a.sum\n        val max = a.max\n        if (sum > 0) sum * k\n        else max * k",
    "        val sum = a.sum\n        val maxSum = max(sum * k, maxSubArraySum(a, n))\n        maxSum",
    "        val sum = a.sum\n        val max = a.max\n        if (sum > 0) (sum * k) max (max + maxSubArraySumRepeated(a, n, k - 1))\n        else max",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = sum * k\n            if (maxSumRepeated > maxSum) maxSumRepeated else maxSum\n        } else maxSum",
    "        val b = a.map(x => x * k)\n        var max_so_far = Long.MinValue\n        var max_ending_here = 0L\n        for (i <- 0 until n) {\n            max_ending_here = max(b(i), max_ending_here + b(i))\n            max_so_far = max(max_so_far, max_ending_here)\n        }\n        max_so_far",
    "        var sum = 0L\n        var max_sum = 0L\n        var max_ending_here = 0L\n        for (i <- 0 until n) {\n            sum += a(i)\n        }\n        max_sum = sum * k\n        for (i <- 0 until n) {\n            max_ending_here += a(i)\n            if (max_ending_here < 0) max_ending_here = 0\n            else max_sum = max(max_sum, max_ending_here * k)\n        }\n        max_sum",
    "        var max_so_far = Long.MinValue\n        var max_ending_here = 0L\n        var start = 0L\n        var end = 0L\n        var s = 0L\n        for (i <- 0L until n) {\n            max_ending_here = max_ending_here + a(i.toInt)\n            if (max_so_far < max_ending_here) {\n                max_so_far = max_ending_here\n                start = s\n                end = i\n            }\n            if (max_ending_here < 0) {\n                max_ending_here = 0\n                s = i + 1\n            }\n        }\n        var max_wrap = 0L\n        var temp = 0L\n        for (i <- 0L until n) {\n            temp += a(i.toInt)\n            if (temp > max_wrap) max_wrap = temp\n        }\n        var max_non_wrap = 0L\n        for (i <- 0L until n) {\n            max_non_wrap += a(i.toInt)\n            a(i.toInt) = -a(i.toInt)\n        }\n        max_non_wrap = max_non_wrap + maxSubArraySumRepeated(a, n, k)\n        if (max_wrap > max_non_wrap) max_wrap else max_non_wrap",
    "        val sum = a.sum\n        val max = a.max\n        if (sum < 0) max\n        else if (sum * k < 0) max\n        else sum * k",
    "        val sum = a.sum\n        val max = a.max\n        if (sum > 0) {\n            val maxSum = sum * k\n            if (maxSum > max) maxSum else max\n        } else max",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum <= 0) maxSum\n        else {\n            val maxSumRepeated = sum * k\n            val maxSumNonRepeated = maxSubArraySum(a, n)\n            max(maxSumRepeated, maxSumNonRepeated)\n        }",
    "        val prefix = new Array[Long](a.length + 1)\n        for (i <- 0 until a.length) prefix(i + 1) = prefix(i) + a(i)\n        val max = new Array[Long](a.length + 1)\n        for (i <- 0 until a.length) max(i + 1) = max(i) max prefix(i + 1)\n        val min = new Array[Long](a.length + 1)\n        for (i <- 0 until a.length) min(i + 1) = min(i) min prefix(i + 1)\n        var result = Long.MinValue\n        for (i <- 0 until a.length) {\n            val sum = prefix(i + 1) + k * (prefix(a.length) - prefix(i + 1))\n            result = result max (sum - min(i + 1))\n            result = result max (sum - max(i + 1))\n        }\n        result",
    "        val sum = a.sum\n        val max = a.max\n        if (max <= 0) return max * k\n        val sum2 = a.map(x => x * x).sum\n        val max2 = a.map(x => x * x).max\n        val sum3 = a.map(x => x * x * x).sum\n        val max3 = a.map(x => x * x * x).max\n        val sum4 = a.map(x => x * x * x * x).sum\n        val max4 = a.map(x => x * x * x * x).max\n        val sum5 = a.map(x => x * x * x * x * x).sum\n        val max5 = a.map(x => x * x * x * x * x).max\n        val sum6 = a.map(x => x * x * x * x * x * x).sum\n        val max6 = a.map(x => x * x * x * x * x * x).max\n        val sum7 = a.map(x => x * x * x * x * x * x * x).sum\n        val max7 = a.map(x => x * x * x * x * x * x * x).max\n        val sum8 = a.map(x => x * x * x * x * x * x * x * x).sum\n        val max8 = a.map(x => x * x * x * x * x * x * x * x).max\n        val sum9 = a.map(x => x * x * x * x * x * x * x * x * x).sum\n        val max9 = a.map(x => x * x * x * x * x * x * x * x * x).max\n        val sum10 = a.map(x => x * x * x * x * x * x * x * x * x * x).sum\n        val max10 = a.map(x => x * x * x * x * x * x * x * x * x * x).max\n        val sum11 = a.map(x => x * x * x * x * x * x * x * x * x * x * x).",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum < 0) maxSum\n        else {\n            val maxSumRepeated = sum * k\n            val maxSumCircular = maxSumRepeated - (a.map(x => if (x > 0) x else 0).sum)\n            max(maxSumRepeated, maxSumCircular)\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (maxSum < 0) maxSum\n        else if (k == 1) maxSubArraySum(a, n)\n        else {\n            val maxSumRepeated = maxSubArraySum(a, n)\n            if (maxSumRepeated > 0) max(maxSumRepeated, maxSumRepeated + (k - 2) * sum)\n            else maxSumRepeated\n        }",
    "        val sum = a.sum\n        val max = a.max\n        if (sum > 0) {\n            val maxSum = sum * k\n            val maxSumWithMax = maxSum - (max * (k - 1))\n            max(maxSum, maxSumWithMax)\n        } else max",
    "        val sums = new Array[Long](n.toInt)\n        var maxSum = Long.MinValue\n        var sum = 0L\n        for (i <- 0 until n.toInt) {\n            sum += a(i)\n            sums(i) = sum\n        }\n        for (i <- 0 until n.toInt) {\n            val sum = sums(i)\n            val sum2 = sums(i) - sums(0)\n            val sum3 = sums(n.toInt - 1) - sums(i)\n            val sum4 = sums(n.toInt - 1)\n            maxSum = max(maxSum, max(sum, max(sum2, max(sum3, sum4))))\n        }\n        maxSum * k",
    "        val dp = Array.fill(n.toInt)(0L)\n        var sum = 0L\n        for (i <- 0 until n.toInt) {\n            sum += a(i)\n            dp(i) = sum\n        }\n        var max = 0L\n        for (i <- 0 until n.toInt) {\n            val sum = dp(i)\n            if (sum > max) max = sum\n            for (j <- i + 1 until n.toInt) {\n                val sum = dp(j) - dp(i)\n                if (sum > max) max = sum\n            }\n        }\n        max * k",
    "        val sum = a.sum\n        val maxSum = a.max\n        val maxSumIndex = a.indexOf(maxSum)\n        val maxSumLeft = a.slice(0, maxSumIndex).sum\n        val maxSumRight = a.slice(maxSumIndex + 1, a.length).sum\n        val maxSumTotal = maxSumLeft + maxSumRight + maxSum * (k - 1)\n        if (maxSumTotal > sum * k) maxSumTotal else sum * k",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum < 0) maxSum\n        else {\n            val maxSumRepeated = sum * k\n            val maxSumCircular = maxSumRepeated - a.min\n            max(maxSumRepeated, maxSumCircular)\n        }",
    "        val b = a.map(x => x * k)\n        val c = b.map(x => if (x > 0) x else 0)\n        val d = b.map(x => if (x < 0) x else 0)\n        val csum = c.scanLeft(0L)(_ + _).tail\n        val dsum = d.scanLeft(0L)(_ + _).tail\n        val cmax = csum.max\n        val dmax = dsum.max\n        val dmaxIndex = dsum.indexOf(dmax)\n        val dmaxIndexNext = if (dmaxIndex == n - 1) 0 else dmaxIndex + 1\n        val dmaxIndexPrev = if (dmaxIndex == 0) n - 1 else dmaxIndex - 1\n        val dmaxIndexNextValue = dsum(dmaxIndexNext)\n        val dmaxIndexPrevValue = dsum(dmaxIndexPrev)\n        val dmaxIndexNextValue2 = if (dmaxIndexNextValue < 0) 0 else dmaxIndexNextValue\n        val dmaxIndexPrevValue2 = if (dmaxIndexPrevValue < 0) 0 else dmaxIndexPrevValue\n        val e = csum.drop(dmaxIndexNext) ++ csum.take(dmaxIndex)\n        val e2 = e.map(x => if (x < 0) 0 else x)\n        val e3 = e2.scanLeft(0L)(_ + _).tail\n        val e4 = e3.max\n        val e5 = e3.indexOf(e4)\n        val e6 = e5 + dmaxIndexNext\n        val e7 = if (e6 == n - 1) 0 else e6 + 1\n        val e8 = if (e6 == 0) n - 1 else e6 - 1\n        val e9 = csum(e7)\n        val e10 = csum(e8)\n        val e11 = if (e9 < 0) 0 else e9\n        val e12 = if (e10 < 0) 0 else e10\n        val e13 = e4 + e11 + e12\n        val e14 = if (e13 > cmax) e13 else cmax\n        val e15",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = sum * k\n            val maxSumRepeatedWithOverlap = sum * (k - 1) + maxSum\n            max(maxSumRepeated, maxSumRepeatedWithOverlap)\n        } else maxSum",
    "        val sum = a.sum\n        val max = a.max\n        if (sum > 0) {\n            val maxSum = sum * k\n            val maxSumRepeated = maxSum - (sum - max)\n            maxSumRepeated\n        } else {\n            max\n        }",
    "        val b = a.map(x => x * k)\n        val prefixSum = b.scanLeft(0L)(_ + _)\n        var max = 0L\n        for (i <- 0 until n.toInt) {\n            val sum = prefixSum(i + n.toInt) - prefixSum(i)\n            if (sum > max) max = sum\n        }\n        max",
    "        val sum = a.sum\n        val max = a.max\n        if (sum > 0) sum * k\n        else if (k == 1) max\n        else {\n            val maxSum = a.scanLeft(0L)(_ + _).drop(1).max\n            val maxSumRepeated = maxSum * (k - 1)\n            val maxSumRepeatedWithLast = maxSumRepeated + a.takeWhile(_ != max).sum + max\n            max(maxSumRepeated, maxSumRepeatedWithLast)\n        }",
    "        val b = a.map(x => x * k)\n        val c = b.map(x => x - n)\n        val d = c.map(x => x + n)\n        val e = d.map(x => x % n)\n        val f = e.map(x => if (x < 0) x + n else x)\n        val g = f.map(x => if (x == 0) n else x)\n        val h = g.map(x => if (x == n) 0 else x)\n        val i = h.map(x => if (x > n / 2) n - x else x)\n        val j = i.map(x => if (x == n / 2) -1 else x)\n        val l = j.map(x => if (x == -1) n / 2 else x)\n        val m = l.map(x => if (x == 0) n else x)\n        val o = m.map(x => if (x == n) 0 else x)\n        val p = o.map(x => if (x > n / 2) n - x else x)\n        val q = p.map(x => if (x == n / 2) -1 else x)\n        val r = q.map(x => if (x == -1) n / 2 else x)\n        val s = r.map(x => if (x == 0) n else x)\n        val t = s.map(x => if (x == n) 0 else x)\n        val u = t.map(x => if (x > n / 2) n - x else x)\n        val v = u.map(x => if (x == n / 2) -1 else x)\n        val w = v.map(x => if (x == -1) n / 2 else x)\n        val x = w.map(x => if (x == 0) n else x)\n        val y = x.map(x => if (x == n) 0 else x)\n        val z = y.map(x => if (x > n / 2) n - x else x)\n        val aa = z.map(x => if (x == n",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum <= 0) maxSum\n        else {\n            val maxSumRepeated = sum * k\n            val maxSumCircular = maxSumRepeated - a.min\n            max(maxSumRepeated, maxSumCircular)\n        }",
    "        val b = a.map(x => x * k)\n        val prefix = Array.fill(n.toInt)(0L)\n        prefix(0) = b(0)\n        for (i <- 1 until n.toInt) prefix(i) = prefix(i - 1) + b(i)\n        var max = Long.MinValue\n        for (i <- 0 until n.toInt) {\n            for (j <- i until n.toInt) {\n                val sum = prefix(j) - prefix(i) + b(i)\n                if (sum > max) max = sum\n            }\n        }\n        max",
    "        var max_so_far = Long.MinValue\n        var max_ending_here = 0L\n        for (i <- 0 until n) {\n            max_ending_here = max_ending_here + a(i)\n            if (max_so_far < max_ending_here) max_so_far = max_ending_here\n            if (max_ending_here < 0) max_ending_here = 0\n        }\n        var max_wrap = 0L\n        for (i <- 0 until n) {\n            max_wrap = max_wrap + a(i)\n            a(i) = -a(i)\n        }\n        for (i <- 0 until n) {\n            max_ending_here = max_ending_here + a(i)\n            if (max_so_far < max_ending_here) max_so_far = max_ending_here\n            if (max_ending_here < 0) max_ending_here = 0\n        }\n        max(max_so_far, max_wrap * (k - 2) + max_so_far)",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum < 0) maxSum\n        else {\n            val maxSumRepeated = sum * k\n            val maxSumCyclic = maxSumRepeated - (a.take(n.toInt - 1).sum * (k - 1))\n            max(maxSumRepeated, maxSumCyclic)\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (maxSum < 0) maxSum\n        else {\n            val maxSumRepeated = max(maxSum, sum * k)\n            val maxSumRepeatedWithOverlap = max(maxSumRepeated, maxSubArraySumRepeated(a, n, k - 1) + sum * (k - 1))\n            maxSumRepeatedWithOverlap\n        }",
    "        val m = a.map(x => x * k).toArray\n        var max_so_far = Long.MinValue\n        var max_ending_here = 0L\n        for (i <- 0 until n) {\n            max_ending_here = max_ending_here + m(i)\n            if (max_so_far < max_ending_here) max_so_far = max_ending_here\n            if (max_ending_here < 0) max_ending_here = 0\n        }\n        max_so_far",
    "        val b = a.map(x => x * k)\n        var max_so_far = Long.MinValue\n        var max_ending_here = 0L\n        for (i <- 0 until n) {\n            max_ending_here = max(b(i), max_ending_here + b(i))\n            max_so_far = max(max_so_far, max_ending_here)\n        }\n        max_so_far",
    "        val sum = a.sum\n        val max = a.max\n        if (sum <= 0) max\n        else {\n            val maxSubArraySum = a.scanLeft(0L)(_ + _).drop(1).max\n            val maxSubArraySumRepeated = maxSubArraySum + (k - 2) * sum\n            max(maxSubArraySumRepeated, maxSubArraySum + sum * (k - 1))\n        }",
    "        val b = a.map(x => x * k)\n        val c = b.map(x => if (x > 0) x else 0)\n        val d = b.map(x => if (x < 0) x else 0)\n        val csum = c.scanLeft(0L)(_ + _).tail\n        val dsum = d.scanLeft(0L)(_ + _).tail\n        val cmax = csum.max\n        val dmax = dsum.max\n        val dmin = dsum.min\n        val dmax2 = dsum.filter(x => x != dmin).max\n        val dmax3 = dsum.filter(x => x != dmin && x != dmax2).max\n        val dmax4 = dsum.filter(x => x != dmin && x != dmax2 && x != dmax3).max\n        val dmax5 = dsum.filter(x => x != dmin && x != dmax2 && x != dmax3 && x != dmax4).max\n        val dmax6 = dsum.filter(x => x != dmin && x != dmax2 && x != dmax3 && x != dmax4 && x != dmax5).max\n        val dmax7 = dsum.filter(x => x != dmin && x != dmax2 && x != dmax3 && x != dmax4 && x != dmax5 && x != dmax6).max\n        val dmax8 = dsum.filter(x => x != dmin && x != dmax2 && x != dmax3 && x != dmax4 && x != dmax5 && x != dmax6 && x != dmax7).max\n        val dmax9 = dsum.filter(x => x != dmin && x != dmax2 && x != dmax3 && x != dmax4 && x != dmax5 && x != dmax6 && x != dmax7 && x != dmax8).max\n        val dmax10 = dsum.filter(x => x != dmin && x != dmax2 && x != dmax3 && x != dmax4 && x != dmax5 && x != dmax6 && x != dmax7 && x != dmax",
    "        val mod = 1000000007\n        val sum = a.sum\n        val max = a.max\n        if (sum > 0) {\n            val result = (sum * k) % mod\n            return result\n        }\n        else {\n            val result = (max * k) % mod\n            return result\n        }",
    "        val sum = a.sum\n        val max = a.max\n        if (sum > 0) {\n            val maxSum = sum * k\n            val maxSumRepeated = maxSum - sum + max\n            maxSumRepeated\n        } else {\n            max\n        }",
    "        val s = a.map(x => x * k).sum\n        val m = a.map(x => x * (k - 1)).sum\n        val r = (s - m) / 2\n        val p = a.map(x => x * (k - 2)).sum\n        val q = (s - p) / 3\n        val t = (s - p) / 2\n        val u = (s - p) / 4\n        val v = (s - p) / 6\n        val w = (s - p) / 8\n        val x = (s - p) / 12\n        val y = (s - p) / 16\n        val z = (s - p) / 24\n        val b = List(r, q, t, u, v, w, x, y, z).max\n        val c = a.map(x => x * (k - 3)).sum\n        val d = (s - c) / 4\n        val e = (s - c) / 6\n        val f = (s - c) / 8\n        val g = (s - c) / 12\n        val h = (s - c) / 16\n        val i = (s - c) / 24\n        val j = (s - c) / 36\n        val k = (s - c) / 48\n        val l = (s - c) / 72\n        val o = List(d, e, f, g, h, i, j, k, l).max\n        val p = a.map(x => x * (k - 4)).sum\n        val q = (s - p) / 6\n        val r = (s - p) / 8\n        val t = (s - p) / 12\n        val u = (s - p) / 16\n        val v = (s - p) / 24\n        val w = (s - p) / 36\n        val x = (s - p) / 48\n        val y = (s - p) / 72\n        val z = (s - p) / 96\n        val aa = List(q, r, t, u, v, w, x, y, z).max\n        val ab = a.map(x => x * (k - 5",
    "        val b = a.map(x => x * k)\n        val prefix = b.scanLeft(0L)(_ + _).tail\n        val suffix = b.scanRight(0L)(_ + _).init\n        val max = (prefix zip suffix).map(x => x._1 + x._2).max\n        val maxPrefix = prefix.max\n        val maxSuffix = suffix.max\n        val maxPrefixSuffix = maxPrefix + maxSuffix - b.sum\n        max max maxPrefixSuffix",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum < 0) maxSum\n        else {\n            val maxSumRepeated = max(sum * k, maxSum + sum * (k - 2))\n            maxSumRepeated\n        }",
    "        val sum = a.sum\n        val max = a.max\n        if (sum > 0) {\n            val maxSum = sum * k\n            if (max > 0) maxSum\n            else maxSum - (max * (k - 1))\n        } else {\n            val maxSum = max * k\n            if (maxSum > sum) maxSum\n            else sum\n        }",
    "        val prefix = a.scanLeft(0L)(_ + _).tail\n        val suffix = a.scanRight(0L)(_ + _).init\n        val max = prefix.zip(suffix).map(x => x._1 + x._2).max\n        val sum = prefix.last\n        val maxSum = max + (k - 2) * sum\n        val maxPrefix = prefix.init.zip(prefix.tail).map(x => x._2 - x._1).max\n        val maxSuffix = suffix.init.zip(suffix.tail).map(x => x._2 - x._1).max\n        val maxSingle = max(maxPrefix, maxSuffix)\n        max(maxSum, maxSingle)",
    "        val sum = a.sum\n        val max = a.max\n        if (sum < 0) return max * k\n        val maxSum = a.scanLeft(0L)(_ + _).max\n        val minSum = a.scanLeft(0L)(_ + _).min\n        val maxSumRepeated = maxSum * k + (k - 1) * minSum\n        val maxSumCircular = maxSumRepeated - minSum\n        max(maxSumCircular, maxSumRepeated)",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum < 0) maxSum\n        else {\n            val maxSumRepeated = max(sum * k, sum * (k - 2) + maxSum)\n            maxSumRepeated\n        }",
    "        val sum = a.sum\n        val maxSubArraySum = maxSubArraySum(a, n)\n        if (k == 1) maxSubArraySum\n        else if (k == 2) max(maxSubArraySum, sum + maxSubArraySum(a, n))\n        else {\n            val maxSubArraySumRepeated = maxSubArraySumRepeated(a, n, k / 2)\n            val maxSubArraySumRepeated2 = maxSubArraySumRepeated(a, n, k - k / 2)\n            max(maxSubArraySumRepeated, maxSubArraySumRepeated2)\n        }",
    "        val sum = a.sum\n        val max = a.max\n        if (sum < 0) return max * k\n        val maxSum = maxSubArraySum(a, n)\n        val maxSumRepeated = maxSum * k\n        val maxSumLast = maxSubArraySum(a.take(n.toInt - 1), n - 1)\n        val maxSumFirst = maxSubArraySum(a.drop(1), n - 1)\n        val maxSumTotal = maxSumLast + sum * (k - 1) + a.last\n        val maxSumTotal2 = maxSumFirst + sum * (k - 1) + a.head\n        List(maxSumRepeated, maxSumTotal, maxSumTotal2).max",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = sum * k\n            val maxSumRepeatedWithOverlap = sum * (k - 1) + maxSum\n            max(maxSumRepeated, maxSumRepeatedWithOverlap)\n        }\n        else maxSum",
    "        val b = a.map(x => x * k)\n        var max_so_far = Long.MinValue\n        var max_ending_here = 0L\n        for (i <- 0 until n) {\n            max_ending_here = max_ending_here + b(i)\n            if (max_so_far < max_ending_here) max_so_far = max_ending_here\n            if (max_ending_here < 0) max_ending_here = 0\n        }\n        max_so_far",
    "        val a2 = a.map(x => x * k)\n        val sum = a2.sum\n        val max = a2.max\n        if (max > sum - max) max else sum - max",
    "        var sum = 0L\n        var max_so_far = Long.MinValue\n        var max_ending_here = 0L\n        for (i <- 0 until n) {\n            max_ending_here = max_ending_here + a(i)\n            if (max_so_far < max_ending_here) max_so_far = max_ending_here\n            if (max_ending_here < 0) max_ending_here = 0\n        }\n        var max_wrap = 0L\n        for (i <- 0 until n) {\n            max_wrap = max_wrap + a(i)\n            a(i) = -a(i)\n        }\n        for (i <- 0 until n) {\n            max_ending_here = max_ending_here + a(i)\n            if (max_so_far < max_ending_here) max_so_far = max_ending_here\n            if (max_ending_here < 0) max_ending_here = 0\n        }\n        max_wrap = max_wrap + max_wrap\n        if (max_wrap > max_so_far) max_so_far = max_wrap\n        max_so_far",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum < 0) maxSum\n        else {\n            val maxSumRepeated = sum * k\n            val maxSumRepeatedWithMod = maxSumRepeated - (sum * (k / n) * 2)\n            max(maxSumRepeatedWithMod, maxSum)\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = maxSum * k\n            val maxSumRepeatedWithOverlap = maxSumRepeated + (sum * (k - 1))\n            max(maxSumRepeated, maxSumRepeatedWithOverlap)\n        } else {\n            maxSum\n        }",
    "        val b = a.map(x => x * k)\n        val c = b.map(x => x % n)\n        val d = c.map(x => if (x < 0) x + n else x)\n        val e = d.map(x => x % n)\n        val f = e.map(x => if (x < 0) x + n else x)\n        val g = f.map(x => x % n)\n        val h = g.map(x => if (x < 0) x + n else x)\n        val i = h.map(x => x % n)\n        val j = i.map(x => if (x < 0) x + n else x)\n        val k = j.map(x => x % n)\n        val l = k.map(x => if (x < 0) x + n else x)\n        val m = l.map(x => x % n)\n        val o = m.map(x => if (x < 0) x + n else x)\n        val p = o.map(x => x % n)\n        val q = p.map(x => if (x < 0) x + n else x)\n        val r = q.map(x => x % n)\n        val s = r.map(x => if (x < 0) x + n else x)\n        val t = s.map(x => x % n)\n        val u = t.map(x => if (x < 0) x + n else x)\n        val v = u.map(x => x % n)\n        val w = v.map(x => if (x < 0) x + n else x)\n        val x = w.map(x => x % n)\n        val y = x.map(x => if (x < 0) x + n else x)\n        val z = y.map(x => x % n)\n        val aa = z.map(x => if (x < 0) x + n else x)\n        val ab = aa.map(x => x % n)\n        val ac = ab.map(x => if (x < 0) x + n else x)\n",
    "        val sum = a.sum\n        val max = a.max\n        if (sum < 0) max\n        else {\n            val maxSum = sum * k\n            val maxPrefixSum = (0 until n.toInt).map(i => a.slice(0, i).sum).max\n            val maxSuffixSum = (0 until n.toInt).map(i => a.slice(i, n.toInt).sum).max\n            val maxMiddleSum = maxPrefixSum + maxSuffixSum\n            max(maxSum, max(maxMiddleSum, max(maxPrefixSum, maxSuffixSum)))\n        }",
    "        val b = a.map(x => x * k)\n        var max_so_far = b(0)\n        var curr_max = b(0)\n        for (i <- 1 until n.toInt) {\n            curr_max = max(b(i), curr_max + b(i))\n            max_so_far = max(max_so_far, curr_max)\n        }\n        max_so_far",
    "        val s = a.sum\n        val m = a.map(x => x * k).max\n        val r = a.map(x => x * (k - 1)).sum\n        val p = a.map(x => x * (k - 2)).sum\n        val q = a.map(x => x * (k - 3)).sum\n        val t = a.map(x => x * (k - 4)).sum\n        val u = a.map(x => x * (k - 5)).sum\n        val v = a.map(x => x * (k - 6)).sum\n        val w = a.map(x => x * (k - 7)).sum\n        val x = a.map(x => x * (k - 8)).sum\n        val y = a.map(x => x * (k - 9)).sum\n        val z = a.map(x => x * (k - 10)).sum\n        val aa = a.map(x => x * (k - 11)).sum\n        val bb = a.map(x => x * (k - 12)).sum\n        val cc = a.map(x => x * (k - 13)).sum\n        val dd = a.map(x => x * (k - 14)).sum\n        val ee = a.map(x => x * (k - 15)).sum\n        val ff = a.map(x => x * (k - 16)).sum\n        val gg = a.map(x => x * (k - 17)).sum\n        val hh = a.map(x => x * (k - 18)).sum\n        val ii = a.map(x => x * (k - 19)).sum\n        val jj = a.map(x => x * (k - 20)).sum\n        val kk = a.map(x => x * (k - 21)).sum\n        val ll = a.map(x => x * (k - 22)).sum\n        val mm = a.map(x => x * (k - 23)).sum\n        val nn = a.map(x => x * (k - 24)).sum\n        val oo = a.map(x => x * (k - 25)).sum\n        val pp",
    "        val b = a.map(x => x * k)\n        val s = b.sum\n        val m = b.max\n        val l = b.min\n        val r = if (m > 0) s - l else s - m\n        r",
    "        val sum = a.sum\n        val max = a.max\n        if (sum > 0) {\n            val maxSum = max * k + sum * (k - 1)\n            val minSum = max * k + sum * (k - 2) + a.min\n            max(maxSum, minSum)\n        } else max",
    "        val sum = a.sum\n        val maxSum = a.max\n        val maxSumRepeated = max(sum * k, maxSum)\n        maxSumRepeated",
    "        val sum = a.sum\n        val max = a.max\n        if (sum < 0) max\n        else {\n            val maxSum = maxSubArraySum(a, n)\n            val maxSumRepeated = maxSubArraySumRepeated(a, n, k - 1)\n            max(maxSum, maxSumRepeated + sum * (k - 1))\n        }",
    "        val sum = a.sum\n        val max = a.max\n        if (sum < 0) max\n        else sum * k",
    "        val sum = a.sum\n        val max = a.max\n        if (sum > 0) sum * k\n        else if (k == 1) max\n        else {\n            val maxSum = a.scanLeft(0L)(_ + _).drop(1).max\n            max(maxSum, max + maxSubArraySumRepeated(a, n, k - 2))\n        }",
    "        var max_so_far = Long.MinValue\n        var max_ending_here = 0L\n        var start = 0L\n        var end = 0L\n        var s = 0L\n        for (i <- 0 until n) {\n            max_ending_here = max_ending_here + a(i.toInt)\n            if (max_so_far < max_ending_here) {\n                max_so_far = max_ending_here\n                start = s\n                end = i\n            }\n            if (max_ending_here < 0) {\n                max_ending_here = 0\n                s = i + 1\n            }\n        }\n        var max_wrap = 0L\n        for (i <- 0 until n) {\n            max_wrap += a(i.toInt)\n            a(i.toInt) = -a(i.toInt)\n        }\n        for (i <- 0 until n) {\n            max_ending_here = max_ending_here + a(i.toInt)\n            if (max_ending_here > max_wrap) {\n                max_wrap = max_ending_here\n            }\n            if (max_ending_here < 0) {\n                max_ending_here = 0\n            }\n        }\n        max(max_so_far, max_wrap * (k - 2) + max_so_far)",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum <= 0) maxSum\n        else {\n            val maxSumRepeated = sum * k\n            val maxSumSubArray = maxSubArraySum(a)\n            if (maxSumSubArray > 0) max(maxSumRepeated, maxSumSubArray)\n            else maxSumRepeated\n        }",
    "        val sum = a.foldLeft(0L)(_ + _)\n        val maxSum = a.foldLeft(0L)((x, y) => max(x, x + y))\n        val maxSumRepeated = max(maxSum, sum * (k - 2) + maxSum)\n        maxSumRepeated",
    "        val sum = a.sum\n        val max = a.max\n        if (sum > 0) sum * k\n        else if (k == 1) max\n        else {\n            val prefixSum = a.scanLeft(0L)(_ + _).tail\n            val suffixSum = a.scanRight(0L)(_ + _).init\n            val prefixMax = prefixSum.max\n            val suffixMax = suffixSum.max\n            val midMax = (for (i <- 0 until n.toInt) yield prefixSum(i) + suffixSum(i)).max\n            max(max(prefixMax, suffixMax), midMax)\n        }",
    "        var sum = 0L\n        var maxSum = 0L\n        for (i <- 0 until n) {\n            sum += a(i.toInt)\n            if (i == n - 1) {\n                maxSum = max(maxSum, sum)\n                for (j <- 1 until k) {\n                    sum += a(i.toInt)\n                    maxSum = max(maxSum, sum)\n                }\n            }\n        }\n        maxSum",
    "        val sum = a.foldLeft(0L)(_ + _)\n        val max = a.foldLeft(0L)((x, y) => max(x, y))\n        val maxSum = max * k\n        if (sum <= 0) maxSum\n        else {\n            val maxSumIncludingFirst = maxSubArraySum(a, n)\n            val maxSumIncludingLast = maxSubArraySum(a.reverse, n)\n            val maxSumIncludingFirstAndLast = maxSubArraySum(a.slice(1, a.length - 1), n - 2)\n            val maxSumIncludingFirstAndLastRepeated = maxSumIncludingFirstAndLast * (k - 2)\n            max(maxSumIncludingFirst, max(maxSumIncludingLast, maxSumIncludingFirstAndLastRepeated + maxSumIncludingFirst + maxSumIncludingLast))\n        }",
    "        val b = a.map(x => x * k)\n        var max_so_far = 0L\n        var max_ending_here = 0L\n        for (i <- 0 until b.length) {\n            max_ending_here = max(b(i), max_ending_here + b(i))\n            max_so_far = max(max_so_far, max_ending_here)\n        }\n        max_so_far",
    "        val s = a.sum\n        val m = a.map(x => x * k).sum\n        val p = a.map(x => x * (k - 1)).sum\n        val q = a.map(x => x * (k - 2)).sum\n        val r = a.map(x => x * (k - 3)).sum\n        val t = a.map(x => x * (k - 4)).sum\n        val u = a.map(x => x * (k - 5)).sum\n        val v = a.map(x => x * (k - 6)).sum\n        val w = a.map(x => x * (k - 7)).sum\n        val x = a.map(x => x * (k - 8)).sum\n        val y = a.map(x => x * (k - 9)).sum\n        val z = a.map(x => x * (k - 10)).sum\n        val aa = a.map(x => x * (k - 11)).sum\n        val ab = a.map(x => x * (k - 12)).sum\n        val ac = a.map(x => x * (k - 13)).sum\n        val ad = a.map(x => x * (k - 14)).sum\n        val ae = a.map(x => x * (k - 15)).sum\n        val af = a.map(x => x * (k - 16)).sum\n        val ag = a.map(x => x * (k - 17)).sum\n        val ah = a.map(x => x * (k - 18)).sum\n        val ai = a.map(x => x * (k - 19)).sum\n        val aj = a.map(x => x * (k - 20)).sum\n        val ak = a.map(x => x * (k - 21)).sum\n        val al = a.map(x => x * (k - 22)).sum\n        val am = a.map(x => x * (k - 23)).sum\n        val an = a.map(x => x * (k - 24)).sum\n        val ao = a.map(x => x * (k - 25)).sum\n        val ap = a.map",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum <= 0) return maxSum * k\n        val maxSubArraySum = maxSubArraySum(a)\n        val maxSubArraySumRepeated = max(maxSubArraySum, sum * (k - 2) + maxSubArraySum)\n        maxSubArraySumRepeated",
    "        val sum = a.map(x => x * k).sum\n        val max = a.max\n        if (max < 0) max * k\n        else {\n            val maxSum = a.foldLeft(0L)((acc, x) => max(acc + x, 0))\n            max(sum, sum - maxSum + max * k)\n        }",
    "        val b = a.map(x => x * k)\n        var max_so_far = Long.MinValue\n        var max_ending_here = 0L\n        for (i <- 0 until n) {\n            max_ending_here = max_ending_here + b(i)\n            if (max_so_far < max_ending_here) max_so_far = max_ending_here\n            if (max_ending_here < 0) max_ending_here = 0\n        }\n        max_so_far",
    "        val sum = a.sum\n        val maxSum = a.max\n        val maxSumRepeated = max(sum * k, maxSum)\n        val maxSumNonRepeated = maxSubArraySum(a, n)\n        max(maxSumRepeated, maxSumNonRepeated)",
    "        val m = a.map(x => x * k)\n        val s = m.scanLeft(0L)(_ + _).tail\n        var max = 0L\n        for (i <- 0 until n.toInt) {\n            val l = s(i)\n            val r = s(i + n.toInt)\n            val sum = r - l\n            if (sum > max) max = sum\n        }\n        max",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = max(maxSum, (sum * k) - (a.map(x => -x).min * k))\n            maxSumRepeated\n        } else {\n            maxSum\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        val maxSumRepeated = max(sum * k, maxSum)\n        val prefixSum = a.scanLeft(0L)(_ + _).tail\n        val suffixSum = a.scanRight(0L)(_ + _).init\n        val prefixSuffixSum = prefixSum.zip(suffixSum).map(x => x._1 + x._2)\n        val prefixSuffixSumRepeated = prefixSuffixSum.map(x => x * k)\n        val prefixSuffixSumRepeatedSorted = prefixSuffixSumRepeated.sorted\n        val prefixSuffixSumRepeatedSortedReversed = prefixSuffixSumRepeatedSorted.reverse\n        val prefixSuffixSumRepeatedSortedReversedMax = prefixSuffixSumRepeatedSortedReversed.max\n        val prefixSuffixSumRepeatedSortedReversedMax2 = prefixSuffixSumRepeatedSortedReversed.tail.max\n        val prefixSuffixSumRepeatedSortedReversedMax3 = prefixSuffixSumRepeatedSortedReversed.tail.tail.max\n        val prefixSuffixSumRepeatedSortedReversedMax4 = prefixSuffixSumRepeatedSortedReversed.tail.tail.tail.max\n        val prefixSuffixSumRepeatedSortedReversedMax5 = prefixSuffixSumRepeatedSortedReversed.tail.tail.tail.tail.max\n        val prefixSuffixSumRepeatedSortedReversedMax6 = prefixSuffixSumRepeatedSortedReversed.tail.tail.tail.tail.tail.max\n        val prefixSuffixSumRepeatedSortedReversedMax7 = prefixSuffixSumRepeatedSortedReversed.tail.tail.tail.tail.tail.tail.max\n        val prefixSuffixSumRepeatedSortedReversedMax8 = prefixSuffixSumRepeatedSortedReversed.tail.tail.tail.tail.tail.tail.tail.max\n        val prefixSuffixSumRepeatedSortedReversedMax9 = prefixSuffixSumRepe",
    "        val b = a.map(x => x * k)\n        val c = b.map(x => if (x > 0) x else 0)\n        val d = b.map(x => if (x < 0) x else 0)\n        val e = c.sum\n        val f = d.sum\n        val g = abs(f)\n        val h = e + g\n        h",
    "        val sum = a.sum\n        val max = a.max\n        if (sum < 0) max\n        else if (sum * k < 0) max\n        else {\n            val prefix = a.scanLeft(0L)(_ + _).tail\n            val suffix = a.scanRight(0L)(_ + _).init\n            val prefixSum = prefix.map(x => x * k)\n            val suffixSum = suffix.map(x => x * k)\n            val prefixMax = prefix.max\n            val suffixMax = suffix.max\n            val prefixMaxSum = prefixSum.max\n            val suffixMaxSum = suffixSum.max\n            val prefixMaxSumIndex = prefixSum.indexOf(prefixMaxSum)\n            val suffixMaxSumIndex = suffixSum.indexOf(suffixMaxSum)\n            val prefixMaxSumIndex2 = prefixSum.indexOf(prefixMaxSum, prefixMaxSumIndex + 1)\n            val suffixMaxSumIndex2 = suffixSum.indexOf(suffixMaxSum, suffixMaxSumIndex + 1)\n            val prefixMaxSumIndex3 = prefixSum.indexOf(prefixMaxSum, prefixMaxSumIndex2 + 1)\n            val suffixMaxSumIndex3 = suffixSum.indexOf(suffixMaxSum, suffixMaxSumIndex2 + 1)\n            val prefixMaxSumIndex4 = prefixSum.indexOf(prefixMaxSum, prefixMaxSumIndex3 + 1)\n            val suffixMaxSumIndex4 = suffixSum.indexOf(suffixMaxSum, suffixMaxSumIndex3 + 1)\n            val prefixMaxSumIndex5 = prefixSum.indexOf(prefixMaxSum, prefixMaxSumIndex4 + 1)\n            val suffixMaxSumIndex5 = suffixSum.indexOf(suffixMaxSum, suffixMaxSumIndex4 + 1)\n            val prefixMaxSumIndex6 = prefixSum.indexOf(prefixMaxSum, prefixMaxSumIndex5 + 1)\n            val suffixMaxSumIndex6 = suffixSum.indexOf(suffixMaxSum, suffixMaxSumIndex5 + 1)\n            val prefixMaxSumIndex7 = prefixSum.indexOf(prefixMaxSum, prefixMaxSumIndex6 + 1)\n            val suffixMaxSumIndex7 = suffixSum.indexOf(suffixMaxSum, suffixMaxSumIndex6 +",
    "        val b = a.map(x => x * k)\n        var max_so_far = Long.MinValue\n        var max_ending_here = 0L\n        for (i <- 0 until n) {\n            max_ending_here = max_ending_here + b(i)\n            if (max_so_far < max_ending_here) max_so_far = max_ending_here\n            if (max_ending_here < 0) max_ending_here = 0\n        }\n        max_so_far",
    "        val sum = a.sum\n        val maxSum = max(a.max, sum * k)\n        val minSum = min(a.min, sum * k)\n        val maxPrefixSum = a.scanLeft(0L)(_ + _).drop(1).max\n        val minPrefixSum = a.scanLeft(0L)(_ + _).drop(1).min\n        val maxSuffixSum = a.scanRight(0L)(_ + _).dropRight(1).max\n        val minSuffixSum = a.scanRight(0L)(_ + _).dropRight(1).min\n        val maxPrefixSumRepeated = max(maxPrefixSum, sum * (k - 1) + maxSuffixSum)\n        val minPrefixSumRepeated = min(minPrefixSum, sum * (k - 1) + minSuffixSum)\n        max(maxSum, maxPrefixSumRepeated - minPrefixSumRepeated)",
    "        val sum = a.sum\n        val max = a.max\n        if (sum > 0) {\n            val b = a.map(x => x * k)\n            val c = b.scanLeft(0L)(_ + _).tail\n            val d = c.map(x => x % sum)\n            val e = d.zip(c).map(x => (x._1, x._2 - x._1))\n            val f = e.map(x => x._2)\n            val g = f.max\n            val h = if (g > 0) g else 0\n            val i = if (h > max) h else max\n            i\n        } else max",
    "        val sum = a.sum\n        val max = a.max\n        if (max > 0) max * k\n        else if (sum > 0) sum * (k - 1) + maxSubArraySum(a)\n        else maxSubArraySum(a)",
    "        val sum = a.sum\n        val max = a.max\n        if (sum > 0) {\n            val maxSum = sum * k\n            if (max > 0) maxSum\n            else max(maxSum, max * (k - 2) + sum)\n        }\n        else max * k",
    "        val b = a.map(x => x * k)\n        val c = b.sliding(n.toInt).map(x => x.sum).max\n        c",
    "        var max_so_far = Long.MinValue\n        var max_ending_here = 0L\n        for (i <- 0 until n) {\n            max_ending_here = max_ending_here + a(i)\n            if (max_so_far < max_ending_here) max_so_far = max_ending_here\n            if (max_ending_here < 0) max_ending_here = 0\n        }\n        var max_wrap = 0L\n        for (i <- 0 until n) {\n            max_wrap = max_wrap + a(i)\n            a(i) = -a(i)\n        }\n        for (i <- 0 until n) {\n            max_ending_here = max_ending_here + a(i)\n            if (max_so_far < max_ending_here) max_so_far = max_ending_here\n            if (max_ending_here < 0) max_ending_here = 0\n        }\n        max_wrap = max_wrap + max_wrap\n        if (k == 1) max_so_far\n        else if (max_wrap > 0) max(max_so_far, max_wrap * (k - 2) + max_so_far)\n        else max_so_far",
    "        var max_so_far = Long.MinValue\n        var max_ending_here = 0L\n        for (i <- 0 until n) {\n            max_ending_here = max_ending_here + a(i)\n            if (max_so_far < max_ending_here) max_so_far = max_ending_here\n            if (max_ending_here < 0) max_ending_here = 0\n        }\n        var max_wrap = 0L\n        for (i <- 0 until n) {\n            max_wrap += a(i)\n            a(i) = -a(i)\n        }\n        for (i <- 0 until n) {\n            max_ending_here = max_ending_here + a(i)\n            if (max_so_far < max_ending_here) max_so_far = max_ending_here\n            if (max_ending_here < 0) max_ending_here = 0\n        }\n        max_wrap + max_so_far",
    "        val b = a.map(x => x * k)\n        val prefixSum = b.scanLeft(0L)(_ + _)\n        var maxSum = Long.MinValue\n        for (i <- 0 until n.toInt) {\n            val sum = prefixSum(i + n.toInt) - prefixSum(i)\n            maxSum = max(maxSum, sum)\n        }\n        maxSum",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = sum * k\n            val maxSumRepeatedWithOverlap = sum * (k - 1) + maxSum\n            max(maxSumRepeated, maxSumRepeatedWithOverlap)\n        } else maxSum",
    "        val b = a.map(x => x * k)\n        var max_so_far = b(0)\n        var curr_max = b(0)\n        for (i <- 1 until n.toInt) {\n            curr_max = max(b(i), curr_max + b(i))\n            max_so_far = max(max_so_far, curr_max)\n        }\n        max_so_far",
    "        val sum = a.sum\n        val max = a.max\n        if (sum < 0) max\n        else if (sum * k < 0) max * k\n        else {\n            val maxSum = maxSubArraySum(a)\n            if (maxSum > 0) maxSum * k + sum * (k - 1)\n            else maxSum\n        }",
    "        val sum = a.sum\n        val max = a.max\n        if (max <= 0) max\n        else if (sum <= 0) sum * k\n        else {\n            val prefix = new Array[Long](n.toInt)\n            val suffix = new Array[Long](n.toInt)\n            var maxPrefix = Long.MinValue\n            var maxSuffix = Long.MinValue\n            var maxPrefixIndex = -1\n            var maxSuffixIndex = -1\n            var sumPrefix = 0L\n            var sumSuffix = 0L\n            for (i <- 0 until n.toInt) {\n                sumPrefix += a(i)\n                if (sumPrefix > maxPrefix) {\n                    maxPrefix = sumPrefix\n                    maxPrefixIndex = i\n                }\n                prefix(i) = maxPrefix\n            }\n            for (i <- n.toInt - 1 to 0 by -1) {\n                sumSuffix += a(i)\n                if (sumSuffix > maxSuffix) {\n                    maxSuffix = sumSuffix\n                    maxSuffixIndex = i\n                }\n                suffix(i) = maxSuffix\n            }\n            var maxSum = Long.MinValue\n            for (i <- 0 until n.toInt) {\n                val sum = prefix(i) + (if (i + 1 < n.toInt) suffix(i + 1) else 0)\n                if (sum > maxSum) maxSum = sum\n            }\n            maxSum + (k - 2) * sum\n        }",
    "        val b = a.map(x => x * k)\n        var max_so_far = b(0)\n        var curr_max = b(0)\n        for (i <- 1 until n.toInt) {\n            curr_max = max(b(i), curr_max + b(i))\n            max_so_far = max(max_so_far, curr_max)\n        }\n        max_so_far",
    "        val sum = a.sum\n        val max = a.max\n        if (sum < 0) max\n        else sum * k",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = sum * k\n            val maxSumRepeatedWithOverlap = sum * (k - 1) + maxSum\n            max(maxSumRepeated, maxSumRepeatedWithOverlap)\n        } else maxSum",
    "        val s = a.map(x => x * k).sum\n        val m = a.map(x => x * (k - 1)).sum\n        val d = a.map(x => x * (k - 2)).sum\n        val b = a.map(x => x * (k - 3)).sum\n        val c = a.map(x => x * (k - 4)).sum\n        val e = a.map(x => x * (k - 5)).sum\n        val f = a.map(x => x * (k - 6)).sum\n        val g = a.map(x => x * (k - 7)).sum\n        val h = a.map(x => x * (k - 8)).sum\n        val i = a.map(x => x * (k - 9)).sum\n        val j = a.map(x => x * (k - 10)).sum\n        val l = a.map(x => x * (k - 11)).sum\n        val o = a.map(x => x * (k - 12)).sum\n        val p = a.map(x => x * (k - 13)).sum\n        val q = a.map(x => x * (k - 14)).sum\n        val r = a.map(x => x * (k - 15)).sum\n        val t = a.map(x => x * (k - 16)).sum\n        val u = a.map(x => x * (k - 17)).sum\n        val v = a.map(x => x * (k - 18)).sum\n        val w = a.map(x => x * (k - 19)).sum\n        val x = a.map(x => x * (k - 20)).sum\n        val y = a.map(x => x * (k - 21)).sum\n        val z = a.map(x => x * (k - 22)).sum\n        val aa = a.map(x => x * (k - 23)).sum\n        val ab = a.map(x => x * (k - 24)).sum\n        val ac = a.map(x => x * (k - 25)).sum\n        val ad = a.map(x => x * (k - 26)).sum\n",
    "        val b = a.map(x => x * k)\n        val s = b.sum\n        val m = b.max\n        val p = b.min\n        if (s > 0) {\n            val c = b.map(x => if (x > 0) x else 0)\n            val d = b.map(x => if (x < 0) x else 0)\n            val e = c.sum\n            val f = d.sum\n            val g = if (f > 0) 0 else f\n            val h = e + g\n            val i = m + h\n            if (i > s) i else s\n        } else {\n            m\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = sum * k\n            if (maxSumRepeated > maxSum) maxSumRepeated else maxSum\n        } else maxSum",
    "        val b = a.map(x => x * k)\n        var max_so_far = b(0)\n        var curr_max = b(0)\n        for (i <- 1 until n.toInt) {\n            curr_max = max(b(i), curr_max + b(i))\n            max_so_far = max(max_so_far, curr_max)\n        }\n        max_so_far",
    "        val b = a.map(x => x * k)\n        val c = b.map(x => if (x > 0) x else 0)\n        val d = b.map(x => if (x < 0) x else 0)\n        val e = c.sum\n        val f = d.sum\n        val g = max(e, f)\n        val h = if (g > 0) g else 0\n        val i = b.map(x => if (x > 0) x else 0)\n        val j = i.sum\n        val m = max(h, j)\n        m",
    "        val sum = a.sum\n        val max = a.max\n        if (sum < 0) max\n        else if (sum * k < 0) max\n        else {\n            val sumRepeated = sum * k\n            val maxRepeated = max * k\n            val maxSubArraySum = maxSubArraySum(a, n)\n            val maxSubArraySumRepeated = maxSubArraySum(a, n) * k\n            val maxSubArraySumRepeated2 = maxSubArraySum(a, n) * (k - 1) + max\n            val maxSubArraySumRepeated3 = maxSubArraySum(a, n) * (k - 2) + max + max\n            val maxSubArraySumRepeated4 = maxSubArraySum(a, n) * (k - 3) + max + max + max\n            val maxSubArraySumRepeated5 = maxSubArraySum(a, n) * (k - 4) + max + max + max + max\n            val maxSubArraySumRepeated6 = maxSubArraySum(a, n) * (k - 5) + max + max + max + max + max\n            val maxSubArraySumRepeated7 = maxSubArraySum(a, n) * (k - 6) + max + max + max + max + max + max\n            val maxSubArraySumRepeated8 = maxSubArraySum(a, n) * (k - 7) + max + max + max + max + max + max + max\n            val maxSubArraySumRepeated9 = maxSubArraySum(a, n) * (k - 8) + max + max + max + max + max + max + max + max\n            val maxSubArraySumRepeated10 = maxSubArraySum(a, n) * (k - 9) + max + max + max + max + max + max + max + max + max\n            val maxSubArraySumRepeated11 = maxSubArraySum(a, n) * (k - 10) + max + max + max + max + max + max + max + max + max + max\n            val maxSubArraySumRepeated12 = maxSubArraySum(a, n) * (k - 11) + max + max + max + max + max + max + max + max +",
    "        val m = a.length\n        val s = a.sum\n        val max = a.max\n        if (max <= 0) return max * k\n        val b = new Array[Long](m)\n        for (i <- 0 until m) b(i) = a(i)\n        for (i <- 0 until m) b(i) += b((i + 1) % m)\n        val c = new Array[Long](m)\n        for (i <- 0 until m) c(i) = b(i)\n        for (i <- 0 until m) c(i) += c((i + 1) % m)\n        val d = new Array[Long](m)\n        for (i <- 0 until m) d(i) = c(i)\n        for (i <- 0 until m) d(i) += d((i + 1) % m)\n        var result = 0L\n        for (i <- 0 until m) {\n            val x = b(i) * (k - 2) + c(i) + d(i) * (k - 3)\n            if (x > result) result = x\n        }\n        result",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum < 0) maxSum\n        else {\n            val maxSumRepeated = sum * k\n            val maxSumCircular = maxSumRepeated - a.min\n            max(maxSumRepeated, maxSumCircular)\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum < 0) maxSum\n        else {\n            val maxSumRepeated = max(sum * k, maxSum + sum * (k - 2))\n            maxSumRepeated\n        }",
    "        val b = a.map(x => x * k)\n        var max_so_far = 0L\n        var max_ending_here = 0L\n        for (i <- 0 until n) {\n            max_ending_here = max_ending_here + b(i.toInt)\n            if (max_ending_here < 0) max_ending_here = 0\n            if (max_so_far < max_ending_here) max_so_far = max_ending_here\n        }\n        max_so_far",
    "        val b = a.map(x => x * k)\n        val sum = b.sum\n        val max = b.max\n        val min = b.min\n        if (max < 0) max\n        else if (min > 0) sum\n        else {\n            var max_so_far = 0L\n            var max_ending_here = 0L\n            for (x <- b) {\n                max_ending_here = max_ending_here + x\n                if (max_ending_here < 0) max_ending_here = 0\n                if (max_so_far < max_ending_here) max_so_far = max_ending_here\n            }\n            max_so_far\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        val minSum = a.min\n        val maxSumRepeated = if (sum > 0) sum * k else max(maxSum, sum * (k - 1) + minSum)\n        maxSumRepeated",
    "        var max_so_far = Long.MinValue\n        var max_ending_here = 0L\n        for (i <- 0 until n) {\n            max_ending_here = max_ending_here + a(i).toLong\n            if (max_so_far < max_ending_here) max_so_far = max_ending_here\n            if (max_ending_here < 0) max_ending_here = 0\n        }\n        var max_without_wrap = max_so_far\n        var max_wrap = 0L\n        for (i <- 0 until n) {\n            max_wrap += a(i).toLong\n            max_ending_here += a(i).toLong\n            if (max_ending_here > max_so_far) max_so_far = max_ending_here\n            if (max_ending_here < 0) max_ending_here = 0\n        }\n        if (max_wrap > 0) max_so_far = max(max_so_far, max_without_wrap + (k - 2) * max_wrap)\n        max_so_far",
    "        val b = a.map(x => x * k)\n        var max_so_far = Long.MinValue\n        var max_ending_here = 0L\n        for (i <- 0 until n) {\n            max_ending_here = max_ending_here + b(i)\n            if (max_so_far < max_ending_here) max_so_far = max_ending_here\n            if (max_ending_here < 0) max_ending_here = 0\n        }\n        max_so_far",
    "        val b = a.map(x => x * k)\n        val s = b.sum\n        val m = b.max\n        val p = b.min\n        if (s > 0) {\n            val c = b.filter(x => x > 0).sum\n            val d = b.filter(x => x < 0).sum\n            if (c > abs(d)) c else abs(d)\n        } else if (s < 0) {\n            val c = b.filter(x => x > 0).sum\n            val d = b.filter(x => x < 0).sum\n            if (c > abs(d)) c else abs(d)\n        } else {\n            m\n        }",
    "        val b = a.map(x => x * k)\n        var max_so_far = Long.MinValue\n        var max_ending_here = 0L\n        for (i <- 0 until n) {\n            max_ending_here = max_ending_here + b(i)\n            if (max_so_far < max_ending_here) max_so_far = max_ending_here\n            if (max_ending_here < 0) max_ending_here = 0\n        }\n        max_so_far",
    "        val sum = a.sum\n        val max = a.max\n        if (sum < 0) return max * k\n        val maxSubArraySum = maxSubArraySum(a, n)\n        val maxSubArraySumRepeated = maxSubArraySum * k\n        val maxSubArraySumRepeatedWithOverlap = maxSubArraySumRepeated + sum * (k - 1)\n        return max(maxSubArraySumRepeatedWithOverlap, maxSubArraySumRepeated)",
    "        val aa = a.map(x => x * k)\n        val s = aa.sum\n        val m = aa.max\n        if (s > m) s else m",
    "        var max_so_far = 0L\n        var max_ending_here = 0L\n        for (i <- 0 until n) {\n            max_ending_here = max_ending_here + a(i).toLong\n            if (max_ending_here < 0) max_ending_here = 0\n            if (max_so_far < max_ending_here) max_so_far = max_ending_here\n        }\n        var max_wrap = 0L\n        for (i <- 0 until n) {\n            max_wrap = max_wrap + a(i).toLong\n            a(i) = -a(i).toLong\n        }\n        for (i <- 0 until n) {\n            max_ending_here = max_ending_here + a(i).toLong\n            if (max_ending_here < 0) max_ending_here = 0\n            if (max_so_far < max_ending_here) max_so_far = max_ending_here\n        }\n        max_wrap = max_wrap + max_wrap\n        if (k == 1) return max_so_far\n        if (max_wrap > 0) return max(max_so_far, max_wrap * (k - 2) + max_so_far)\n        return max_so_far",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (maxSum <= 0) return maxSum * k\n        val maxSubArraySum = maxSubArraySum(a, n)\n        val maxSubArraySumRepeated = max(maxSubArraySum, maxSubArraySum + (k - 2) * sum)\n        maxSubArraySumRepeated",
    "        val sum = a.sum\n        val max = a.max\n        if (sum > 0) {\n            val maxSum = max * k\n            val maxSumRepeated = maxSum + (sum * (k - 1))\n            maxSumRepeated\n        } else {\n            max\n        }",
    "        val b = ListBuffer[Long]()\n        for (i <- 0 until k.toInt) b ++= a\n        val c = b.toList\n        var max_so_far = Long.MinValue\n        var max_ending_here = 0L\n        for (i <- 0 until c.length) {\n            max_ending_here = max_ending_here + c(i)\n            if (max_so_far < max_ending_here) max_so_far = max_ending_here\n            if (max_ending_here < 0) max_ending_here = 0\n        }\n        max_so_far",
    "        val sum = a.sum\n        val max = a.max\n        if (sum > 0) {\n            val maxSum = (k - 1) * sum + a.take(n.toInt).sum\n            maxSum max max\n        } else max",
    "        val b = a.map(x => x * k)\n        var max_so_far = Long.MinValue\n        var max_ending_here = 0L\n        for (i <- 0 until b.length) {\n            max_ending_here = max_ending_here + b(i)\n            if (max_so_far < max_ending_here) max_so_far = max_ending_here\n            if (max_ending_here < 0) max_ending_here = 0\n        }\n        max_so_far",
    "        val sum = a.foldLeft(0L)(_ + _)\n        val max = a.foldLeft(0L)((x, y) => max(x, y))\n        if (max <= 0) return max * k\n        val maxSum = maxSubArraySum(a, n)\n        val maxPrefixSum = maxPrefixSumRepeated(a, n, k)\n        val maxSuffixSum = maxSuffixSumRepeated(a, n, k)\n        max(maxSum, maxPrefixSum + maxSuffixSum + sum * (k - 2))",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum < 0) maxSum\n        else {\n            val maxSumRepeated = sum * k\n            val maxSumNonRepeated = maxSum + maxSubArraySum(a, n)\n            max(maxSumRepeated, maxSumNonRepeated)\n        }",
    "        val sum = a.sum\n        val maxSum = a.map(x => x * k).max\n        if (sum > 0) max(maxSum, sum * (k - 1) + maxSubArraySum(a, n))\n        else maxSum",
    "        val sum = a.sum\n        val maxSum = a.map(x => x * k).max\n        val maxSumRepeated = a.map(x => x * (k - 1)).max\n        val maxSumRepeated2 = a.map(x => x * (k - 2)).max\n        val maxSumRepeated3 = a.map(x => x * (k - 3)).max\n        val maxSumRepeated4 = a.map(x => x * (k - 4)).max\n        val maxSumRepeated5 = a.map(x => x * (k - 5)).max\n        val maxSumRepeated6 = a.map(x => x * (k - 6)).max\n        val maxSumRepeated7 = a.map(x => x * (k - 7)).max\n        val maxSumRepeated8 = a.map(x => x * (k - 8)).max\n        val maxSumRepeated9 = a.map(x => x * (k - 9)).max\n        val maxSumRepeated10 = a.map(x => x * (k - 10)).max\n        val maxSumRepeated11 = a.map(x => x * (k - 11)).max\n        val maxSumRepeated12 = a.map(x => x * (k - 12)).max\n        val maxSumRepeated13 = a.map(x => x * (k - 13)).max\n        val maxSumRepeated14 = a.map(x => x * (k - 14)).max\n        val maxSumRepeated15 = a.map(x => x * (k - 15)).max\n        val maxSumRepeated16 = a.map(x => x * (k - 16)).max\n        val maxSumRepeated17 = a.map(x => x * (k - 17)).max\n        val maxSumRepeated18 = a.map(x => x * (k - 18)).max\n        val maxSumRepeated19 = a.map(x => x * (k - 19)).max\n        val maxSumRepeated20 = a.map(x => x * (k - 20)).max\n        val maxSumRepeated21 = a.map(x => x * (k - 21)).max\n        val maxSum",
    "        val sum = a.foldLeft(0L)(_ + _)\n        val max = a.foldLeft(0L)((x, y) => max(x, y))\n        if (max <= 0) max * k\n        else {\n            val maxSum = maxSubArraySum(a, n)\n            val maxPrefixSum = maxPrefixSumRepeated(a, n, k)\n            val maxSuffixSum = maxSuffixSumRepeated(a, n, k)\n            val ans = max(maxSum, maxPrefixSum + maxSuffixSum + sum * (k - 2))\n            ans\n        }",
    "        val b = a.map(x => x * k)\n        val s = b.sum\n        val m = b.max\n        val c = b.count(x => x == m)\n        if (c == 1) s - m\n        else s - m * (k - c)",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum <= 0) maxSum\n        else {\n            val maxSumRepeated = sum * k\n            val maxSumNonRepeated = maxSubArraySum(a)\n            max(maxSumRepeated, maxSumNonRepeated)\n        }",
    "        val sum = a.sum\n        val max = a.max\n        if (sum > 0) sum * k\n        else if (k == 1) max\n        else max(sum * (k - 1) + max, maxSubArraySum(a))",
    "        val b = a.map(x => x * k)\n        val s = b.sum\n        val m = b.max\n        val p = b.min\n        if (s > 0) s - p\n        else m",
    "        val m = a.length\n        val sum = new Array[Long](m)\n        sum(0) = a(0)\n        for (i <- 1 until m) {\n            sum(i) = sum(i - 1) + a(i)\n        }\n        var max = Long.MinValue\n        for (i <- 0 until m) {\n            for (j <- i until m) {\n                val s = if (i == 0) sum(j) else sum(j) - sum(i - 1)\n                max = max max s\n            }\n        }\n        max * k - (sum(m - 1) * (k - 1))",
    "        val sum = a.sum\n        val max = a.max\n        if (sum < 0) max\n        else {\n            val maxSubArraySum = maxSubArraySum(a, n)\n            if (maxSubArraySum > 0) maxSubArraySum * k + sum * (k - 1)\n            else max\n        }",
    "        var sum = 0L\n        var max_so_far = 0L\n        var max_ending_here = 0L\n        for (i <- 0 until n) {\n            max_ending_here = max_ending_here + a(i)\n            if (max_ending_here < 0) max_ending_here = 0\n            if (max_so_far < max_ending_here) max_so_far = max_ending_here\n            sum += a(i)\n        }\n        if (k == 1) return max_so_far\n        var max_sum = max_so_far\n        var min_sum = 0L\n        var curr_prefix = 0L\n        var curr_suffix = 0L\n        for (i <- 0 until n) {\n            curr_prefix += a(i)\n            curr_suffix += a(n - i - 1)\n            min_sum = min(min_sum, curr_prefix)\n            max_sum = max(max_sum, curr_suffix)\n        }\n        max(max_sum, sum * k - min_sum)",
    "        val b = a.map(x => x * k)\n        val prefix = b.scanLeft(0L)(_ + _).tail\n        var max = 0L\n        for (i <- 0 until n.toInt) {\n            val j = i + n.toInt\n            val sum = prefix(j) - prefix(i)\n            if (sum > max) max = sum\n        }\n        max",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = max(sum * k, maxSum + sum * (k - 1))\n            maxSumRepeated\n        } else maxSum",
    "        val b = a.map(x => x * k)\n        val sum = b.sum\n        val max = b.max\n        val min = b.min\n        val maxSum = max(sum - min, max)\n        maxSum",
    "        val sum = a.sum\n        val max = a.max\n        if (sum > 0) sum * k\n        else if (k == 1) max\n        else {\n            val maxSum = maxSubArraySum(a)\n            if (maxSum > 0) maxSum + (k - 2) * sum\n            else maxSum + (k - 1) * sum\n        }",
    "        val b = a.map(x => x * k)\n        var max_so_far = Long.MinValue\n        var max_ending_here = 0L\n        for (i <- 0 until n) {\n            max_ending_here = max_ending_here + b(i)\n            if (max_so_far < max_ending_here) max_so_far = max_ending_here\n            if (max_ending_here < 0) max_ending_here = 0\n        }\n        max_so_far",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (maxSum <= 0) maxSum\n        else if (k == 1) maxSubArraySum(a, n)\n        else if (k == 2) max(maxSubArraySum(a, n), maxSubArraySum(a, n) + sum)\n        else {\n            val maxSum = a.max\n            val maxSumIndex = a.indexOf(maxSum)\n            val left = a.slice(0, maxSumIndex)\n            val right = a.slice(maxSumIndex + 1, a.length)\n            val leftSum = maxSubArraySum(left, left.length)\n            val rightSum = maxSubArraySum(right, right.length)\n            val maxSum = max(leftSum, rightSum)\n            val maxSumRepeated = max(maxSum, maxSum + sum * (k - 2))\n            maxSumRepeated\n        }",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = sum * k\n            val maxSumRepeatedWithoutOverlap = sum * (k - 1) + maxSum\n            max(maxSumRepeated, maxSumRepeatedWithoutOverlap)\n        } else maxSum",
    "        // Find the maximum sum of the subarray in the original list.\n        val maxSum = maxSubArraySum(a, n)\n        // Find the maximum sum of the subarray in the original list which is formed by repeating the given list k times.\n        val maxSumRepeated = maxSubArraySumRepeated(a, n, k, maxSum)\n        // Return the maximum sum of the subarray in the original list which is formed by repeating the given list k times.\n        maxSumRepeated",
    "        var max_so_far = Long.MinValue\n        var max_ending_here = 0L\n        for (i <- 0 to n - 1) {\n            max_ending_here = max_ending_here + a(i)\n            if (max_so_far < max_ending_here) max_so_far = max_ending_here\n            if (max_ending_here < 0) max_ending_here = 0\n        }\n        var max_without_wrap = max_so_far\n        var max_wrap = 0L\n        for (i <- 0 to n - 1) {\n            max_wrap += a(i)\n            max_ending_here += a(i)\n            if (max_ending_here > max_so_far) max_so_far = max_ending_here\n            if (max_ending_here < 0) max_ending_here = 0\n        }\n        max(max_so_far, max_wrap * (k - 2) + max_without_wrap)",
    "        val sum = a.sum\n        val max = a.max\n        if (sum > 0) {\n            val maxSum = sum * k\n            val maxSumWithOverlap = sum * (k - 1) + max\n            max(maxSum, maxSumWithOverlap)\n        } else max",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = sum * k\n            val maxSumRepeatedWithOverlap = sum * (k - 1) + maxSum\n            max(maxSumRepeated, maxSumRepeatedWithOverlap)\n        } else {\n            maxSum\n        }",
    "        val sum = a.sum\n        val max = a.max\n        if (sum < 0) max\n        else sum * k - (a.map(x => if (x < 0) x else 0).sum)",
    "        val sum = a.sum\n        val max = a.max\n        if (sum <= 0) max\n        else {\n            val maxSubArraySum = maxSubArraySum(a, n)\n            val maxSubArraySumRepeated = maxSubArraySum + (k - 2) * sum\n            if (maxSubArraySumRepeated > maxSubArraySum) maxSubArraySumRepeated else maxSubArraySum\n        }",
    "        val sum = a.sum\n        val max = a.max\n        if (sum < 0) max\n        else if (sum * k < 0) max\n        else {\n            var maxSum = 0L\n            var sum = 0L\n            for (i <- 0 until n.toInt) {\n                sum += a(i)\n                if (sum < 0) sum = 0\n                else if (sum > maxSum) maxSum = sum\n            }\n            maxSum * k\n        }",
    "        val b = a.map(x => x * k)\n        var max_so_far = Long.MinValue\n        var max_ending_here = 0L\n        for (i <- 0 until n) {\n            max_ending_here = max(b(i).toLong, max_ending_here + b(i).toLong)\n            max_so_far = max(max_so_far, max_ending_here)\n        }\n        max_so_far",
    "        val sum = a.sum\n        val maxSum = a.max\n        val maxSumRepeated = max(sum * k, maxSum)\n        val maxSumRepeated2 = max(maxSumRepeated, maxSubArraySum(a, n))\n        maxSumRepeated2",
    "        val sum = a.sum\n        val max = a.max\n        if (max < 0) return max * k\n        if (sum < 0) return max(sum * k, maxSubArraySumRepeated(a, n, k - 1))\n        val prefix = Array.fill(n.toInt)(0L)\n        val suffix = Array.fill(n.toInt)(0L)\n        var maxPrefix = 0L\n        var maxSuffix = 0L\n        for (i <- 0 until n.toInt) {\n            maxPrefix = max(maxPrefix + a(i), 0L)\n            prefix(i) = maxPrefix\n        }\n        for (i <- n.toInt - 1 to 0 by -1) {\n            maxSuffix = max(maxSuffix + a(i), 0L)\n            suffix(i) = maxSuffix\n        }\n        var result = 0L\n        for (i <- 0 until n.toInt) {\n            result = max(result, prefix(i) + suffix(i))\n        }\n        result + (k - 2) * sum",
    "        val m = a.length\n        var sum = 0L\n        for (i <- 0 until m) sum += a(i)\n        val maxSum = sum * k\n        var maxSumSoFar = 0L\n        var maxSumEndingHere = 0L\n        for (i <- 0 until m) {\n            maxSumEndingHere = max(maxSumEndingHere + a(i), 0)\n            maxSumSoFar = max(maxSumSoFar, maxSumEndingHere)\n        }\n        max(maxSum - maxSumSoFar, maxSumSoFar)",
    "        val sum = a.sum\n        val maxSum = a.max\n        if (sum > 0) {\n            val maxSumRepeated = sum * k\n            val maxSumRepeatedWithOverlap = sum * (k - 1) + maxSum\n            max(maxSumRepeated, maxSumRepeatedWithOverlap)\n        } else maxSum",
    "        val b = a.map(x => x * k)\n        val c = b.scanLeft(0L)(_ + _).tail\n        val d = c.sliding(2).map(x => x(1) - x(0)).toList\n        val e = d.scanLeft(0L)(_ + _).tail\n        val f = e.sliding(2).map(x => x(1) - x(0)).toList\n        val g = f.scanLeft(0L)(_ + _).tail\n        val h = g.sliding(2).map(x => x(1) - x(0)).toList\n        val i = h.scanLeft(0L)(_ + _).tail\n        val j = i.sliding(2).map(x => x(1) - x(0)).toList\n        val k = j.scanLeft(0L)(_ + _).tail\n        val l = k.sliding(2).map(x => x(1) - x(0)).toList\n        val m = l.scanLeft(0L)(_ + _).tail\n        val n = m.sliding(2).map(x => x(1) - x(0)).toList\n        val o = n.scanLeft(0L)(_ + _).tail\n        val p = o.sliding(2).map(x => x(1) - x(0)).toList\n        val q = p.scanLeft(0L)(_ + _).tail\n        val r = q.sliding(2).map(x => x(1) - x(0)).toList\n        val s = r.scanLeft(0L)(_ + _).tail\n        val t = s.sliding(2).map(x => x(1) - x(0)).toList\n        val u = t.scanLeft(0L)(_ + _).tail\n        val v = u.sliding(2).map(x => x(1) - x(0)).toList\n        val w = v.scanLeft(0L)(_ + _).tail\n        val x = w.sliding(2).map(x => x(1) - x(0)).toList\n       ",
    "        val m = a.map(x => x * k).toArray\n        var max_so_far = Long.MinValue\n        var max_ending_here = 0L\n        for (i <- 0 until m.length) {\n            max_ending_here = max(m(i), max_ending_here + m(i))\n            max_so_far = max(max_so_far, max_ending_here)\n        }\n        max_so_far",
    "        val s = a.sum\n        val m = a.map(x => x * k - x).max\n        val p = a.map(x => x * k - x).min\n        val r = a.map(x => x * k - x).sum\n        val q = if (r > 0) r else 0\n        val t = if (r < 0) r else 0\n        val l = if (s * k > 0) s * k else 0\n        val u = if (s * k < 0) s * k else 0\n        val v = if (m > 0) m else 0\n        val w = if (p < 0) p else 0\n        val x = if (v > l) v else l\n        val y = if (w < u) w else u\n        val z = if (x > q) x else q\n        val b = if (y < t) y else t\n        if (z > b) z else b",
    "        val sum = a.sum\n        val max = a.max\n        if (sum > 0) {\n            val ans = (k - 2) * sum + max\n            if (k == 1) max else ans\n        } else {\n            max\n        }",
    "        val sum = a.foldLeft(0L)(_ + _)\n        val max = a.foldLeft(0L)((x, y) => max(x, y))\n        if (sum < 0) max\n        else max(sum * k, maxSubArraySum(a, n))",
    "        val b = a.map(x => x * k)\n        var max_so_far = 0L\n        var max_ending_here = 0L\n        for (i <- 0 until n) {\n            max_ending_here = max_ending_here + b(i)\n            if (max_ending_here < 0) max_ending_here = 0\n            if (max_so_far < max_ending_here) max_so_far = max_ending_here\n        }\n        max_so_far",
    "        val sum = a.sum\n        val max = a.max\n        if (max < 0) max\n        else if (sum < 0) maxSubArraySum(a, n)\n        else {\n            val maxSubArraySum = maxSubArraySum(a, n)\n            val maxSubArraySumRepeated = maxSubArraySum(a, n) * k\n            val maxSubArraySumRepeatedWithOverlap = maxSubArraySumRepeated - (sum * (k - 1))\n            max(maxSubArraySum, max(maxSubArraySumRepeated, maxSubArraySumRepeatedWithOverlap))\n        }",
    "        val sum = a.sum\n        val max = a.max\n        if (sum > 0) {\n            val maxSum = sum * k\n            val maxSumRepeated = maxSum - sum + max\n            maxSumRepeated\n        } else max",
    "        val sum = a.sum\n        val max = a.max\n        if (sum > 0) {\n            val maxSum = sum * k\n            val maxSumRepeated = maxSum - (sum - max)\n            maxSumRepeated\n        } else {\n            max\n        }",
    "        val sum = a.foldLeft(0L)(_ + _)\n        val maxSum = a.foldLeft(0L)((x, y) => max(x, x + y))\n        if (maxSum <= 0) maxSum\n        else max(maxSum, sum * k - maxSubArraySumRepeated(a.map(-_), n, k))"
  ]
}