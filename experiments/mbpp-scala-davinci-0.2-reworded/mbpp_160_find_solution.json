{
  "name": "mbpp_160_find_solution",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function that returns integers x and y that satisfy ax + by = n as a tuple, or return None if no solution exists.\n    def findSolution(a : Long, b : Long, n : Long) : Option[Long] = {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_160_find_solution.py",
  "prompt_terminology": "reworded",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(findSolution((2l), (3l), (7l)).equals((2l, 1l)));\n    assert(findSolution((4l), (2l), (7l)).equals(None));\n    assert(findSolution((1l), (13l), (17l)).equals((4l, 1l)));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclid(a, b)\n        val d = gcd(a, b)\n        Some(x * (n / d))",
    "        val d = gcd(a, b)\n        if (n % d != 0) return None\n        val x0 = findSolution(a / d, b / d, n / d)\n        if (x0 == None) return None\n        val x = x0.get\n        Some(x * d)",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclid(a, b)\n        Some(x * (n / gcd(a, b)))",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = solve(a, b, n)\n        Some(x)",
    "        if (n % gcd(a, b) != 0) None else {\n            val (x, y) = extendedEuclid(a, b)\n            Some(x * (n / gcd(a, b)))\n        }",
    "        if (n % gcd(a, b) == 0) {\n            val x = n / a\n            val y = n / b\n            val g = gcd(a, b)\n            val d = a / g\n            val e = b / g\n            val f = n / g\n            val m = (x + y) / 2\n            val k = (y - x) / 2\n            val result = m + k * d\n            Some(result)\n        } else None",
    "        val d = gcd(a, b)\n        if (n % d != 0) return None\n        val x0 = findSolution(a / d, b / d, n / d).get\n        val y0 = (n - a * x0) / b\n        Some(x0 * b + y0 * a)",
    "        val g = gcd(a, b)\n        if (n % g != 0) return None\n        val (x, y) = findSolution(a / g, b / g, n / g)\n        return Some(x * g, y * g)",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclidean(a, b)\n            val k = n / gcd(a, b)\n            Some(k * x)\n        }",
    "        if (n % gcd(a, b) != 0) return None\n        var x = 0L\n        var y = n / b\n        while (a * x <= n) {\n            if ((n - a * x) % b == 0) return Some(x)\n            x += 1\n        }\n        None",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclidean(a, b)\n            Some(x * (n / gcd(a, b)))\n        }",
    "        if (n % gcd(a, b) != 0) None else {\n            val (x, y) = extendedEuclid(a, b)\n            Some(x * (n / gcd(a, b)))\n        }",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclid(a, b)\n            val d = gcd(a, b)\n            Some(x * (n / d))\n        }",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x0, y0) = extendedEuclid(a, b)\n            val d = gcd(a, b)\n            val x = x0 * (n / d)\n            val y = y0 * (n / d)\n            Some(x)\n        }",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = solve(a, b)\n        Some(x * (n / gcd(a, b)))",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclid(a, b)\n            val d = gcd(a, b)\n            Some(x * (n / d))\n        }",
    "        val d = gcd(a, b)\n        if (n % d == 0) {\n            val x = n / d * inverse(a / d, b / d)\n            val y = (n - a * x) / b\n            Some(x)\n        } else None",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclid(a, b)\n            val d = gcd(a, b)\n            Some(x * (n / d))\n        }",
    "        def findSolutionRec(x : Long, y : Long) : Option[Long] = {\n            if (a * x + b * y == n) Some(x)\n            else if (x > n) None\n            else findSolutionRec(x + 1, y - 1)\n        }\n        findSolutionRec(0, n / b)",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = solve(a, b)\n        val k = n / gcd(a, b)\n        return Some(x * k, y * k)",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclid(a, b)\n        Some(x * (n / gcd(a, b)))",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclidean(a, b)\n        val d = gcd(a, b)\n        Some(x * (n / d))",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = solve(a, b)\n        Some(x * (n / gcd(a, b)))",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclidean(a, b)\n        val d = gcd(a, b)\n        Some(x * (n / d))",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = solve(a, b, n)\n        Some(x)",
    "        if (n % gcd(a, b) != 0) None else Some(n / a)",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclidean(a, b)\n        Some(x * (n / gcd(a, b)))",
    "        val gcd = a.gcd(b)\n        if (n % gcd != 0) return None\n        val a1 = a / gcd\n        val b1 = b / gcd\n        val n1 = n / gcd\n        val (x, y) = findSolution(a1, b1, n1)\n        return Some(x * gcd, y * gcd)",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclid(a, b)\n            val k = n / gcd(a, b)\n            Some(x * k)\n        }",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclid(a, b)\n            Some(x * (n / gcd(a, b)))\n        }",
    "        val x = n / a\n        val y = n / b\n        val m = min(x, y)\n        val M = max(x, y)\n        for (i <- m to M) {\n            if (a * i % b != 0) {\n                return Some(i)\n            }\n        }\n        return None",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclid(a, b)\n        val d = gcd(a, b)\n        Some(x * (n / d))",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclid(a, b)\n        val d = gcd(a, b)\n        Some(x * (n / d))",
    "        val x = n / a\n        val y = n / b\n        val max = max(x, y)\n        val min = min(x, y)\n        for (i <- min to max) {\n            if (a * i % b != 0) {\n                if (a * i + b * (i - 1) == n) return Some(i)\n            }\n        }\n        return None",
    "        val x = (n - b) / a\n        if (x * a + b == n) Some(x) else None",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclidean(a, b)\n            Some(x * (n / gcd(a, b)))\n        }",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclid(a, b)\n        val d = gcd(a, b)\n        Some(x * (n / d))",
    "        val x = (n - b) / a\n        if (x * a + b == n) Some(x) else None",
    "        val x = n / a\n        val y = n / b\n        val xs = (0 to x.toInt).map(i => (i, (n - a * i) / b)).filter(p => p._2 >= 0 && p._2 * b + p._1 * a == n)\n        if (xs.size == 0) None else Some(xs.map(p => p._1 + p._2).min)",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclid(a, b)\n            Some(x * (n / gcd(a, b)))\n        }",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclid(a, b)\n            val d = gcd(a, b)\n            Some(x * (n / d))\n        }",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclid(a, b)\n            val d = gcd(a, b)\n            Some(x * (n / d))\n        }",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = solve(a, b)\n        Some(x * (n / gcd(a, b)))",
    "        if (n % gcd(a, b) == 0) {\n            val (x, y) = extendedEuclid(a, b)\n            val k = n / gcd(a, b)\n            Some(k * x)\n        } else None",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclid(a, b)\n            val d = gcd(a, b)\n            Some(x * (n / d))\n        }",
    "        var x = 0\n        var y = 0\n        var found = false\n        while (!found) {\n            if (a * x + b * y == n) {\n                found = true\n            } else {\n                x += 1\n                y = (n - a * x) / b\n            }\n        }\n        Some(x)",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclidean(a, b)\n        val d = gcd(a, b)\n        Some(x * (n / d))",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclid(a, b)\n        val d = gcd(a, b)\n        Some(x * (n / d))",
    "        val g = gcd(a, b)\n        if (n % g != 0) return None\n        val x = n / g * inverse(a / g, b / g) % (b / g)\n        val y = (n - a * x) / b\n        Some(x)",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclid(a, b)\n        val d = gcd(a, b)\n        Some(x * (n / d))",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclid(a, b)\n            val d = gcd(a, b)\n            Some(x * (n / d))\n        }",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclid(a, b)\n        val d = gcd(a, b)\n        Some(x * (n / d) + b / d * (n / d) * y)",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val x = n / a\n            val y = n / b\n            val (x1, y1) = findSolution(a, b, x, y)\n            Some(x1 * a + y1 * b)\n        }",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclid(a, b)\n            Some(x * (n / gcd(a, b)))\n        }",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclid(a, b)\n        val d = gcd(a, b)\n        Some(x * (n / d))",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclidean(a, b)\n            val k = n / gcd(a, b)\n            Some(x * k)\n        }",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclidean(a, b)\n            Some(x * (n / gcd(a, b)))\n        }",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclid(a, b)\n        val d = gcd(a, b)\n        Some(x * (n / d))",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclidean(a, b)\n            Some(x * (n / gcd(a, b)))\n        }",
    "        val x = n / a\n        val y = n / b\n        val xy = x * y\n        val xy1 = (x + 1) * (y + 1)\n        val xy2 = (x + 2) * (y + 2)\n        val xy3 = (x + 3) * (y + 3)\n        val xy4 = (x + 4) * (y + 4)\n        val xy5 = (x + 5) * (y + 5)\n        val xy6 = (x + 6) * (y + 6)\n        val xy7 = (x + 7) * (y + 7)\n        val xy8 = (x + 8) * (y + 8)\n        val xy9 = (x + 9) * (y + 9)\n        val xy10 = (x + 10) * (y + 10)\n        val xy11 = (x + 11) * (y + 11)\n        val xy12 = (x + 12) * (y + 12)\n        val xy13 = (x + 13) * (y + 13)\n        val xy14 = (x + 14) * (y + 14)\n        val xy15 = (x + 15) * (y + 15)\n        val xy16 = (x + 16) * (y + 16)\n        val xy17 = (x + 17) * (y + 17)\n        val xy18 = (x + 18) * (y + 18)\n        val xy19 = (x + 19) * (y + 19)\n        val xy20 = (x + 20) * (y + 20)\n        val xy21 = (x + 21) * (y + 21)\n        val xy22 = (x + 22) * (y + 22)\n        val xy23 = (x + 23) * (y + 23)\n        val xy24 = (x + 24) * (y + 24)\n        val xy25 = (x + 25) * (y + 25)\n        val xy26 = (x + 26) * (y + 26)\n        val xy27 = (x + 27) * (y + 27)\n",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclid(a, b)\n        Some(x * (n / gcd(a, b)))",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclidean(a, b)\n        val d = gcd(a, b)\n        Some(x * (n / d) + b / d)",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclid(a, b)\n        val d = gcd(a, b)\n        Some(x * (n / d) + b / d)",
    "        if (n % gcd(a, b) == 0) {\n            val (x, y) = findSolution(a, b)\n            Some(x * (n / gcd(a, b)))\n        }\n        else None",
    "        val x = n / a\n        val y = n / b\n        val xy = x * y\n        val xy2 = xy * 2\n        val xy3 = xy * 3\n        val xy4 = xy * 4\n        val xy5 = xy * 5\n        val xy6 = xy * 6\n        val xy7 = xy * 7\n        val xy8 = xy * 8\n        val xy9 = xy * 9\n        val xy10 = xy * 10\n        val xy11 = xy * 11\n        val xy12 = xy * 12\n        val xy13 = xy * 13\n        val xy14 = xy * 14\n        val xy15 = xy * 15\n        val xy16 = xy * 16\n        val xy17 = xy * 17\n        val xy18 = xy * 18\n        val xy19 = xy * 19\n        val xy20 = xy * 20\n        val xy21 = xy * 21\n        val xy22 = xy * 22\n        val xy23 = xy * 23\n        val xy24 = xy * 24\n        val xy25 = xy * 25\n        val xy26 = xy * 26\n        val xy27 = xy * 27\n        val xy28 = xy * 28\n        val xy29 = xy * 29\n        val xy30 = xy * 30\n        val xy31 = xy * 31\n        val xy32 = xy * 32\n        val xy33 = xy * 33\n        val xy34 = xy * 34\n        val xy35 = xy * 35\n        val xy36 = xy * 36\n        val xy37 = xy * 37\n        val xy38 = xy * 38\n        val xy39 = xy * 39\n        val xy40 = xy * 40\n        val xy41 = xy * 41\n        val xy42 = xy * 42\n        val xy43 = xy * 43\n        val xy44 = xy * 44\n        val xy45 = xy * 45\n        val",
    "        if (n % gcd(a, b) != 0) None else {\n            val (x, y) = extendedEuclid(a, b)\n            val d = gcd(a, b)\n            Some(x * (n / d))\n        }",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclid(a, b)\n            val d = gcd(a, b)\n            Some(x * (n / d))\n        }",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclid(a, b)\n            Some(x * (n / gcd(a, b)))\n        }",
    "        val g = gcd(a, b)\n        if (n % g != 0) return None\n        val a1 = a / g\n        val b1 = b / g\n        val n1 = n / g\n        val (x, y) = extendedEuclid(a1, b1)\n        return Some(x * n1)",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclid(a, b)\n            val d = gcd(a, b)\n            Some(x * (n / d))\n        }",
    "        val gcd = a.gcd(b)\n        if (n % gcd != 0) return None\n        val (x, y) = extendedEuclid(a, b)\n        val k = n / gcd\n        Some(x * k)",
    "        if (n % gcd(a, b) == 0) {\n            val (x, y) = findSolutionHelper(a, b, n)\n            Some(x)\n        } else None",
    "        val d = gcd(a, b)\n        if (n % d != 0) return None\n        val x = n / d * inverse(a / d, b / d) % (b / d)\n        val y = (n - a * x) / b\n        Some(x)",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = solve(a, b)\n        Some(x * (n / gcd(a, b)))",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclid(a, b)\n            Some(x * (n / gcd(a, b)))\n        }",
    "        val g = gcd(a, b)\n        if (n % g != 0) return None\n        val x = n / g * inverse(a / g, b / g)\n        val y = (n - a * x) / b\n        Some(x)",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclidean(a, b)\n            Some(x * (n / gcd(a, b)))\n        }",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclidean(a, b)\n        val d = gcd(a, b)\n        Some(x * (n / d))",
    "        val x = n / a\n        val y = n % a\n        if (y == 0) Some(x)\n        else None",
    "        if (n % gcd(a, b) == 0) {\n            val (x, y) = findSolutionHelper(a, b, n)\n            Some(x)\n        } else None",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclideanAlgorithm(a, b)\n        val d = gcd(a, b)\n        Some(x * (n / d))",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclid(a, b)\n            Some(x * (n / gcd(a, b)))\n        }",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclid(a, b)\n            Some(x * (n / gcd(a, b)))\n        }",
    "        if (n % gcd(a, b) != 0) None else {\n            val (x, y) = extendedEuclid(a, b)\n            val d = gcd(a, b)\n            Some(x * (n / d))\n        }",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclid(a, b)\n        val d = gcd(a, b)\n        Some(x * (n / d))",
    "        def findSolutionHelper(a : Long, b : Long, n : Long) : Option[Long] = {\n            if (n == 0) Some(0)\n            else if (n < 0) None\n            else {\n                val x = findSolutionHelper(a, b, n - a)\n                if (x.isDefined) Some(x.get + 1)\n                else {\n                    val y = findSolutionHelper(a, b, n - b)\n                    if (y.isDefined) Some(y.get + 1)\n                    else None\n                }\n            }\n        }\n        findSolutionHelper(a, b, n)",
    "        val d = gcd(a, b)\n        if (n % d != 0) return None\n        val x = n / d * modInverse(a / d, b / d)\n        val y = (n - a * x) / b\n        Some(x)",
    "        val d = gcd(a, b)\n        if (n % d != 0) return None\n        val x = n / d * modInverse(a / d, b / d)\n        val y = (n - a * x) / b\n        Some(x)",
    "        val m = n % a\n        if (m == 0) Some(n / a)\n        else if (m % b == 0) Some(m / b)\n        else None",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedGcd(a, b)\n            Some(x * (n / gcd(a, b)))\n        }",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclid(a, b)\n            val d = gcd(a, b)\n            Some(x * (n / d))\n        }",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = solve(a, b)\n        Some(x * (n / gcd(a, b)) + y * (n / gcd(a, b)))",
    "        def findSolutionHelper(a : Long, b : Long, n : Long, x : Long, y : Long) : Option[Long] = {\n            if (a == 0 && b == 0) {\n                if (n == 0) Some(x) else None\n            } else if (a == 0) {\n                if (n % b == 0) Some(x) else None\n            } else if (b == 0) {\n                if (n % a == 0) Some(y) else None\n            } else {\n                val g = gcd(a, b)\n                if (n % g == 0) {\n                    val x1 = x + (b / g)\n                    val y1 = y - (a / g)\n                    findSolutionHelper(a, b, n, x1, y1)\n                } else None\n            }\n        }\n        findSolutionHelper(a, b, n, 0, n / a)",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclid(a, b)\n            Some(x * (n / gcd(a, b)))\n        }",
    "        val d = gcd(a, b)\n        if (n % d == 0) {\n            val x0 = findSolution(a / d, b / d, n / d).get\n            val y0 = (n - a * x0) / b\n            Some(x0 * b + y0 * a)\n        } else None",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclid(a, b)\n            Some(x * (n / gcd(a, b)))\n        }",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclid(a, b)\n            val d = gcd(a, b)\n            Some(x * (n / d))\n        }",
    "        val gcd = gcdExtended(a, b)\n        if (n % gcd._1 == 0) {\n            val x = gcd._2 * (n / gcd._1)\n            val y = gcd._3 * (n / gcd._1)\n            Some(x)\n        } else None",
    "        def find(x : Long, y : Long) : Option[Long] = {\n            if (x < 0 || y < 0) None\n            else if (a * x + b * y == n) Some(x)\n            else if (a * x + b * y < n) find(x + 1, y)\n            else find(x, y - 1)\n        }\n        find(0, n / b)",
    "        val g = gcd(a, b)\n        if (n % g != 0) return None\n        val a1 = a / g\n        val b1 = b / g\n        val n1 = n / g\n        val (x, y) = extendedEuclid(a1, b1)\n        val x1 = x * n1\n        val y1 = y * n1\n        val x2 = x1 % b1\n        val y2 = y1 % a1\n        val x3 = if (x2 < 0) x2 + b1 else x2\n        val y3 = if (y2 < 0) y2 + a1 else y2\n        Some(x3)",
    "        def findSolutionRec(a : Long, b : Long, n : Long, x : Long, y : Long) : Option[Long] = {\n            if (n == 0) Some(x)\n            else if (n < 0) None\n            else {\n                val x1 = findSolutionRec(a, b, n - a, x + 1, y)\n                if (x1.isDefined) x1\n                else findSolutionRec(a, b, n - b, x, y + 1)\n            }\n        }\n        findSolutionRec(a, b, n, 0, 0)",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclidean(a, b)\n        val d = gcd(a, b)\n        Some(x * (n / d))",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclidean(a, b)\n            val k = n / gcd(a, b)\n            Some(x * k)\n        }",
    "        var x = 0L\n        while (a * x <= n) {\n            if ((n - a * x) % b == 0) return Some(x)\n            x += 1\n        }\n        return None",
    "        val x = n / a\n        val y = n / b\n        val xy = x * y\n        val xy1 = xy + 1\n        val xy2 = xy - 1\n        if (xy1 % b == 0) Some(xy1 / b) else if (xy2 % b == 0) Some(xy2 / b) else None",
    "        val gcd = gcdExtended(a, b)\n        if (n % gcd != 0) return None\n        val x = gcdExtended(a, b)._1 * (n / gcd)\n        val y = gcdExtended(a, b)._2 * (n / gcd)\n        return Some(x)",
    "        if (n % gcd(a, b) == 0) {\n            val (x, y) = extendedEuclidean(a, b)\n            val k = n / gcd(a, b)\n            Some(x * k)\n        } else None",
    "        var x = 0L\n        var y = 0L\n        var found = false\n        while (x <= n) {\n            y = (n - a * x) / b\n            if (a * x + b * y == n) {\n                found = true\n                return Some(x)\n            }\n            x += 1\n        }\n        if (!found) None",
    "        // Euclidean algorithm\n        def gcd(a : Long, b : Long) : Long = if (b == 0) a else gcd(b, a % b)\n        // Extended Euclidean algorithm\n        def egcd(a : Long, b : Long) : (Long, Long, Long) = {\n            if (b == 0) (a, 1, 0)\n            else {\n                val (g, x, y) = egcd(b, a % b)\n                (g, y, x - (a / b) * y)\n            }\n        }\n        val g = gcd(a, b)\n        if (n % g != 0) None\n        else {\n            val (g, x, y) = egcd(a, b)\n            Some(x * (n / g))\n        }",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclidean(a, b)\n        val d = gcd(a, b)\n        Some(x * (n / d))",
    "        val d = gcd(a, b)\n        if (n % d != 0) return None\n        val x = n / d * inverse(a / d, b / d) % (b / d)\n        Some(x)",
    "        if (n % gcd(a, b) == 0) {\n            val (x, y) = extendedEuclid(a, b)\n            val k = n / gcd(a, b)\n            Some(k * x)\n        } else None",
    "        if (n % gcd(a, b) == 0) {\n            val (x, y) = findSolutionHelper(a, b, n)\n            Some(x)\n        } else None",
    "        val gcd = a.gcd(b)\n        if (n % gcd != 0) return None\n        val x0 = (1 to gcd.toInt).find(x => (n - a * x) % b == 0)\n        if (x0.isEmpty) return None\n        val x = x0.get\n        val y = (n - a * x) / b\n        Some(x)",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclidean(a, b)\n        val d = gcd(a, b)\n        Some(x * (n / d))",
    "        def findSolution(x : Long, y : Long) : Option[Long] = {\n            if (x < 0 || y < 0) None\n            else if (a * x + b * y == n) Some(x)\n            else if (a * x + b * y < n) findSolution(x + 1, y)\n            else findSolution(x, y - 1)\n        }\n        findSolution(0, n / b)",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = solve(a, b)\n        return Some(x * (n / gcd(a, b)))",
    "        val gcd = a.gcd(b)\n        if (n % gcd == 0) {\n            val x = n / gcd * a\n            val y = n / gcd * b\n            Some(x + y)\n        } else None",
    "        if (n % gcd(a, b) != 0) None else Some(n / a)",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclidean(a, b)\n            Some(x * (n / gcd(a, b)))\n        }",
    "        val d = gcd(a, b)\n        if (n % d != 0) return None\n        val x0 = solve(a / d, b / d, n / d)\n        Some(x0)",
    "        val x = (n - b) / a\n        if (x * a + b == n) Some(x) else None",
    "        if (n % gcd(a, b) == 0) {\n            val x = n / a\n            val y = n / b\n            val g = gcd(a, b)\n            val m = a / g\n            val n = b / g\n            val k = x / m\n            val l = y / n\n            val z = max(k, l)\n            val x0 = x - z * m\n            val y0 = y - z * n\n            Some(x0)\n        } else None",
    "        val d = gcd(a, b)\n        if (n % d != 0) return None\n        val x = n / d * modInverse(a / d, b / d)\n        val y = (n - a * x) / b\n        Some(x)",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclidean(a, b)\n            val d = gcd(a, b)\n            Some(x * (n / d))\n        }",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclid(a, b)\n        val d = gcd(a, b)\n        Some(x * (n / d) + b / d)",
    "        val g = gcd(a, b)\n        if (n % g != 0) return None\n        val x = n / g * inverse(a / g, b / g)\n        val y = (n - a * x) / b\n        Some(x)",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclid(a, b)\n        Some(x * (n / gcd(a, b)))",
    "        val x = (n - b) / a\n        if (x * a + b == n) Some(x) else None",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclid(a, b)\n            val d = gcd(a, b)\n            Some(x * (n / d))\n        }",
    "        val x = (n - b) / a\n        if (x * a + b == n) Some(x) else None",
    "        if (n % gcd(a, b) == 0) {\n            val (x, y) = extendedEuclid(a, b)\n            Some(x * (n / gcd(a, b)))\n        } else None",
    "        val d = gcd(a, b)\n        if (n % d != 0) return None\n        val x = n / d * modInverse(a / d, b / d)\n        val y = (n - a * x) / b\n        if (a * x + b * y != n) return None\n        Some(x)",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclidean(a, b)\n            Some(x * (n / gcd(a, b)))\n        }",
    "        if (n % gcd(a, b) == 0) Some(n / gcd(a, b)) else None",
    "        var x = 0L\n        var y = 0L\n        while (a * x <= n) {\n            if ((n - a * x) % b == 0) {\n                y = (n - a * x) / b\n                return Some(x)\n            }\n            x += 1\n        }\n        return None",
    "        var x = 0L\n        var y = 0L\n        var found = false\n        while (x <= n && !found) {\n            y = (n - a * x) / b\n            if (a * x + b * y == n) found = true\n            else x += 1\n        }\n        if (found) Some(x) else None",
    "        val x = n / a\n        val y = n / b\n        val xy = x * y\n        if (xy == n) Some(x)\n        else if (xy < n) findSolution(a, b, n - xy)\n        else None",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclidean(a, b)\n        val d = gcd(a, b)\n        Some(x * (n / d))",
    "        val x = n / a\n        val y = n / b\n        val min = min(x, y)\n        val max = max(x, y)\n        for (i <- min to max) {\n            if (a * i + b * (n - i) == n) return Some(i)\n        }\n        return None",
    "        val x = (n - b) / a\n        if (x * a + b == n) Some(x) else None",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = solve(a, b)\n        val k = n / gcd(a, b)\n        return Some(k * x)",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = solve(a, b)\n        val k = n / gcd(a, b)\n        Some(x * k)",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclid(a, b)\n            Some(x * (n / gcd(a, b)))\n        }",
    "        val x = n / a\n        val y = n / b\n        val min = min(x, y)\n        val max = max(x, y)\n        for (i <- min to max) {\n            if (a * i % b != 0 && b * i % a != 0) return Some(i)\n        }\n        return None",
    "        val x = n / a\n        val y = n / b\n        val xy = x * y\n        val xy2 = xy * 2\n        val xy3 = xy * 3\n        val xy4 = xy * 4\n        val xy5 = xy * 5\n        val xy6 = xy * 6\n        val xy7 = xy * 7\n        val xy8 = xy * 8\n        val xy9 = xy * 9\n        val xy10 = xy * 10\n        val xy11 = xy * 11\n        val xy12 = xy * 12\n        val xy13 = xy * 13\n        val xy14 = xy * 14\n        val xy15 = xy * 15\n        val xy16 = xy * 16\n        val xy17 = xy * 17\n        val xy18 = xy * 18\n        val xy19 = xy * 19\n        val xy20 = xy * 20\n        val xy21 = xy * 21\n        val xy22 = xy * 22\n        val xy23 = xy * 23\n        val xy24 = xy * 24\n        val xy25 = xy * 25\n        val xy26 = xy * 26\n        val xy27 = xy * 27\n        val xy28 = xy * 28\n        val xy29 = xy * 29\n        val xy30 = xy * 30\n        val xy31 = xy * 31\n        val xy32 = xy * 32\n        val xy33 = xy * 33\n        val xy34 = xy * 34\n        val xy35 = xy * 35\n        val xy36 = xy * 36\n        val xy37 = xy * 37\n        val xy38 = xy * 38\n        val xy39 = xy * 39\n        val xy40 = xy * 40\n        val xy41 = xy * 41\n        val xy42 = xy * 42\n        val xy43 = xy * 43\n        val xy44 = xy * 44\n        val xy45 = xy * 45\n        val",
    "        val m = n % gcd(a, b)\n        if (m == 0) {\n            val x = n / a\n            val y = n / b\n            if (x >= 0 && y >= 0) Some(min(x, y))\n            else None\n        }\n        else None",
    "        val d = gcd(a, b)\n        if (n % d != 0) return None\n        val x = n / d * modInverse(a / d, b / d)\n        val y = (n - a * x) / b\n        Some(x)",
    "        if (n % gcd(a, b) == 0) {\n            val (x, y) = findSolutionHelper(a, b, n)\n            Some(x * n / gcd(a, b))\n        } else None",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclidean(a, b)\n        Some(x * (n / gcd(a, b)))",
    "        val d = gcd(a, b)\n        if (n % d != 0) return None\n        val x0 = solve(a / d, b / d, n / d)\n        if (x0 == None) return None\n        val x = x0.get._1\n        val y = x0.get._2\n        val k = n / (a * x + b * y)\n        return Some(x * k)",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = solve(a, b)\n        Some(x * (n / gcd(a, b)) % b)",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclidean(a, b)\n            val k = n / gcd(a, b)\n            Some(k * x)\n        }",
    "        val x = (n - b) / a\n        if (x * a + b == n) Some(x) else None",
    "        if (n % gcd(a, b) == 0) {\n            val (x, y) = findSolutionHelper(a, b, n)\n            Some(x)\n        } else None",
    "        def find(x : Long, y : Long) : Option[Long] = {\n            if (x < 0 || y < 0) None\n            else if (a * x + b * y == n) Some(x)\n            else if (a * x + b * y < n) find(x + 1, y)\n            else find(x, y - 1)\n        }\n        find(0, n / b)",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclid(a, b)\n        val d = gcd(a, b)\n        Some(x * (n / d))",
    "        if (n % gcd(a, b) == 0) {\n            val (x, y) = solve(a, b, n)\n            Some(x)\n        } else None",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclid(a, b)\n        val d = gcd(a, b)\n        Some(x * (n / d) + b / d * (n / d) * y)",
    "        val d = gcd(a, b)\n        if (n % d != 0) None\n        else {\n            val x = n / d * inverse(a / d, b / d) % b\n            Some(x)\n        }",
    "        def findSolutionHelper(a : Long, b : Long, n : Long, x : Long, y : Long) : Option[Long] = {\n            if (a * x + b * y == n) Some(x)\n            else if (x > n) None\n            else findSolutionHelper(a, b, n, x + 1, y)\n        }\n        findSolutionHelper(a, b, n, 0, 0)",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclid(a, b)\n        val d = gcd(a, b)\n        Some(x * (n / d) + b / d * (y * (n / d)))",
    "        def findSolutionHelper(a : Long, b : Long, n : Long, x : Long, y : Long) : Option[Long] = {\n            if (a == 0) {\n                if (n == 0) Some(x) else None\n            } else {\n                val g = gcd(a, b)\n                if (n % g == 0) {\n                    val x1 = x + b / g\n                    val y1 = y - a / g\n                    findSolutionHelper(b % a, a, n / g, x1, y1)\n                } else None\n            }\n        }\n        findSolutionHelper(a, b, n, 0, 1)",
    "        if (n % gcd(a, b) == 0) {\n            val x = n / a\n            val y = n / b\n            val m = max(x, y)\n            val M = min(x, y)\n            val d = gcd(a, b)\n            val c = a / d\n            val k = b / d\n            val x0 = (M - m * c) / (k - c)\n            val y0 = (n - a * x0) / b\n            Some(x0)\n        } else None",
    "        if (n % gcd(a, b) == 0) {\n            val (x, y) = extendedEuclid(a, b)\n            val k = n / gcd(a, b)\n            Some(k * x)\n        } else None",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclidean(a, b)\n        Some(x * (n / gcd(a, b)))",
    "        val x = n / a\n        val y = n / b\n        val xy = x * y\n        val xy1 = (x + 1) * (y + 1)\n        if (xy <= n && n <= xy1) {\n            val x1 = n - xy\n            val y1 = xy1 - n\n            if (x1 < y1) Some(x) else Some(y)\n        } else None",
    "        val d = gcd(a, b)\n        if (n % d != 0) return None\n        val x0 = (n / d) * modInverse(a / d, b / d)\n        val y0 = (n - a * x0) / b\n        Some(x0)",
    "        val x = (n - b) / a\n        if (a * x + b == n) Some(x) else None",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclidean(a, b)\n        val d = gcd(a, b)\n        Some(x * (n / d))",
    "        if (n % gcd(a, b) != 0) None else {\n            val (x, y) = extendedEuclid(a, b)\n            val d = gcd(a, b)\n            Some(x * (n / d))\n        }",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclidean(a, b)\n        Some(x * (n / gcd(a, b)))",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = solve(a, b)\n        Some(x * (n / gcd(a, b)) % b)",
    "        if (n % gcd(a, b) == 0) {\n            val (x, y) = extendedEuclidean(a, b)\n            val k = n / gcd(a, b)\n            Some(x * k)\n        } else None",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclid(a, b)\n            val d = gcd(a, b)\n            Some(x * (n / d))\n        }",
    "        if (n % gcd(a, b) == 0) Some(n / a)\n        else None",
    "        def findSolution(x : Long, y : Long) : Option[Long] = {\n            if (x < 0 || y < 0) None\n            else if (a * x + b * y == n) Some(x)\n            else if (a * x + b * y < n) findSolution(x + 1, y)\n            else findSolution(x, y - 1)\n        }\n        findSolution(0, n / b)",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclidean(a, b)\n            Some(x * (n / gcd(a, b)))\n        }",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclid(a, b)\n        val d = gcd(a, b)\n        Some(x * (n / d))",
    "        if (n % gcd(a, b) == 0) {\n            val (x, y) = findSolutionHelper(a, b, n)\n            Some(x)\n        } else None",
    "        if (n % gcd(a, b) == 0) {\n            val x = n / a\n            val y = n / b\n            val g = gcd(a, b)\n            val l = lcm(a, b)\n            val m = max(x, y)\n            val M = min(x, y)\n            val d = g / a\n            val D = l / a\n            val k = (m - M) / d\n            val K = (m - M) / D\n            val r = (m - M) % d\n            val R = (m - M) % D\n            if (r == 0) {\n                val x = M + k * a\n                val y = m - k * b\n                Some(x)\n            } else if (R == 0) {\n                val x = M + K * a\n                val y = m - K * b\n                Some(x)\n            } else None\n        } else None",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclid(a, b)\n        Some(x * (n / gcd(a, b)))",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclid(a, b)\n            Some(x * (n / gcd(a, b)))\n        }",
    "        if (n % gcd(a, b) != 0) None else Some(n / a)",
    "        if (n % gcd(a, b) == 0) {\n            val (x, y) = findSolutionHelper(a, b, n)\n            Some(x)\n        } else None",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclid(a, b)\n            Some(x * (n / gcd(a, b)))\n        }",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclid(a, b)\n        Some(x * (n / gcd(a, b)))",
    "        val x = (n - b) / a\n        if (x * a + b == n) Some(x) else None",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclid(a, b)\n            val d = gcd(a, b)\n            Some(x * (n / d))\n        }",
    "        def findSolution(x : Long, y : Long) : Option[Long] = {\n            if (x < 0 || y < 0) None\n            else if (a * x + b * y == n) Some(x)\n            else if (a * x + b * y < n) findSolution(x + 1, y)\n            else findSolution(x, y - 1)\n        }\n        findSolution(0, n / b)",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclidean(a, b)\n            val k = n / gcd(a, b)\n            Some(x * k)\n        }",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclid(a, b)\n        val d = gcd(a, b)\n        Some(x * (n / d) + b / d * (y * (n / d)))",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = findSolutionHelper(a, b, n)\n            Some(x)\n        }",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclid(a, b)\n        val d = gcd(a, b)\n        Some(x * (n / d))",
    "        val d = gcd(a, b)\n        if (n % d != 0) return None\n        val x = n / d * inverse(a / d, b / d)\n        val y = (n - a * x) / b\n        Some(x)",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclidean(a, b)\n        val d = gcd(a, b)\n        Some(x * (n / d))",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclid(a, b)\n            val d = gcd(a, b)\n            Some(x * (n / d))\n        }",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclid(a, b)\n        val d = gcd(a, b)\n        Some(x * (n / d))",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclid(a, b)\n            val d = gcd(a, b)\n            Some(x * (n / d))\n        }",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = solve(a, b, n)\n        Some(x)"
  ]
}