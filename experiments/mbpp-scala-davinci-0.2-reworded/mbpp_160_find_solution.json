{
  "name": "mbpp_160_find_solution",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function that returns integers x and y that satisfy ax + by = n as a tuple, or return None if no solution exists.\n    def findSolution(a : Long, b : Long, n : Long) : Option[Long] = {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_160_find_solution.py",
  "prompt_terminology": "reworded",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(findSolution((2l), (3l), (7l)).equals((2l, 1l)));\n    assert(findSolution((4l), (2l), (7l)).equals(None));\n    assert(findSolution((1l), (13l), (17l)).equals((4l, 1l)));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclid(a, b)\n        val d = gcd(a, b)\n        Some(x * (n / d))",
    "        val d = gcd(a, b)\n        if (n % d != 0) return None\n        val x0 = findSolution(a / d, b / d, n / d)\n        if (x0 == None) return None\n        val x = x0.get\n        Some(x * d)",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = extendedEuclid(a, b)\n        Some(x * (n / gcd(a, b)))",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = solve(a, b, n)\n        Some(x)",
    "        if (n % gcd(a, b) != 0) None else {\n            val (x, y) = extendedEuclid(a, b)\n            Some(x * (n / gcd(a, b)))\n        }",
    "        if (n % gcd(a, b) == 0) {\n            val x = n / a\n            val y = n / b\n            val g = gcd(a, b)\n            val d = a / g\n            val e = b / g\n            val f = n / g\n            val m = (x + y) / 2\n            val k = (y - x) / 2\n            val result = m + k * d\n            Some(result)\n        } else None",
    "        val d = gcd(a, b)\n        if (n % d != 0) return None\n        val x0 = findSolution(a / d, b / d, n / d).get\n        val y0 = (n - a * x0) / b\n        Some(x0 * b + y0 * a)",
    "        val g = gcd(a, b)\n        if (n % g != 0) return None\n        val (x, y) = findSolution(a / g, b / g, n / g)\n        return Some(x * g, y * g)",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclidean(a, b)\n            val k = n / gcd(a, b)\n            Some(k * x)\n        }",
    "        if (n % gcd(a, b) != 0) return None\n        var x = 0L\n        var y = n / b\n        while (a * x <= n) {\n            if ((n - a * x) % b == 0) return Some(x)\n            x += 1\n        }\n        None",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclidean(a, b)\n            Some(x * (n / gcd(a, b)))\n        }",
    "        if (n % gcd(a, b) != 0) None else {\n            val (x, y) = extendedEuclid(a, b)\n            Some(x * (n / gcd(a, b)))\n        }",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclid(a, b)\n            val d = gcd(a, b)\n            Some(x * (n / d))\n        }",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x0, y0) = extendedEuclid(a, b)\n            val d = gcd(a, b)\n            val x = x0 * (n / d)\n            val y = y0 * (n / d)\n            Some(x)\n        }",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = solve(a, b)\n        Some(x * (n / gcd(a, b)))",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclid(a, b)\n            val d = gcd(a, b)\n            Some(x * (n / d))\n        }",
    "        val d = gcd(a, b)\n        if (n % d == 0) {\n            val x = n / d * inverse(a / d, b / d)\n            val y = (n - a * x) / b\n            Some(x)\n        } else None",
    "        if (n % gcd(a, b) != 0) None\n        else {\n            val (x, y) = extendedEuclid(a, b)\n            val d = gcd(a, b)\n            Some(x * (n / d))\n        }",
    "        def findSolutionRec(x : Long, y : Long) : Option[Long] = {\n            if (a * x + b * y == n) Some(x)\n            else if (x > n) None\n            else findSolutionRec(x + 1, y - 1)\n        }\n        findSolutionRec(0, n / b)",
    "        if (n % gcd(a, b) != 0) return None\n        val (x, y) = solve(a, b)\n        val k = n / gcd(a, b)\n        return Some(x * k, y * k)"
  ]
}