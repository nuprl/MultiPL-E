{
  "name": "mbpp_265_list_split",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function that takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.\n    def listSplit(S : Any, step : Long) : Any = {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_265_list_split.py",
  "prompt_terminology": "reworded",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(listSplit((Any(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\")), (3l)).equals((Any(List[String](\"a\", \"d\", \"g\", \"j\", \"m\"), List[String](\"b\", \"e\", \"h\", \"k\", \"n\"), List[String](\"c\", \"f\", \"i\", \"l\")))));\n    assert(listSplit((Any(1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 11l.toLong, 12l.toLong, 13l.toLong, 14l.toLong)), (3l)).equals((Any(List[Long](1l.toLong, 4l.toLong, 7l.toLong, 10l.toLong, 13l.toLong), List[Long](2l.toLong, 5l.toLong, 8l.toLong, 11l.toLong, 14l.toLong), List[Long](3l.toLong, 6l.toLong, 9l.toLong, 12l.toLong)))));\n    assert(listSplit((Any(\"python\", \"java\", \"C\", \"C++\", \"DBMS\", \"SQL\")), (2l)).equals((Any(List[String](\"python\", \"C\", \"DBMS\"), List[String](\"java\", \"C++\", \"SQL\")))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        var result = List[Any]()\n        var i = 0\n        var j = 0\n        while (i < S.asInstanceOf[List[Any]].length) {\n            var temp = List[Any]()\n            while (j < step && i < S.asInstanceOf[List[Any]].length) {\n                temp = temp :+ S.asInstanceOf[List[Any]](i)\n                i += 1\n                j += 1\n            }\n            result = result :+ temp\n            j = 0\n        }\n        result",
    "        var L = List[Any]()\n        var i = 0\n        var j = 0\n        var k = 0\n        var M = List[Any]()\n        var N = List[Any]()\n        var O = List[Any]()\n        var P = List[Any]()\n        var Q = List[Any]()\n        var R = List[Any]()\n        var S = List[Any]()\n        var T = List[Any]()\n        var U = List[Any]()\n        var V = List[Any]()\n        var W = List[Any]()\n        var X = List[Any]()\n        var Y = List[Any]()\n        var Z = List[Any]()\n        var a = List[Any]()\n        var b = List[Any]()\n        var c = List[Any]()\n        var d = List[Any]()\n        var e = List[Any]()\n        var f = List[Any]()\n        var g = List[Any]()\n        var h = List[Any]()\n        var i = List[Any]()\n        var j = List[Any]()\n        var k = List[Any]()\n        var l = List[Any]()\n        var m = List[Any]()\n        var n = List[Any]()\n        var o = List[Any]()\n        var p = List[Any]()\n        var q = List[Any]()\n        var r = List[Any]()\n        var s = List[Any]()\n        var t = List[Any]()\n        var u = List[Any]()\n        var v = List[Any]()\n        var w = List[Any]()\n        var x = List[Any]()\n        var y = List[Any]()\n        var z = List[Any]()\n        var A = List[Any]()\n        var B = List[Any]()\n        var C = List[Any]()\n        var D = List[Any]()\n        var E = List[Any]()\n        var F = List[Any]()\n        var G = List[Any]()\n        var H = List[Any]()\n        var I",
    "        val list = S.asInstanceOf[List[Any]]\n        val result = new ListBuffer[Any]\n        var i = 0\n        while (i < list.length) {\n            val sublist = new ListBuffer[Any]\n            var j = 0\n            while (j < step && i < list.length) {\n                sublist += list(i)\n                i += 1\n                j += 1\n            }\n            result += sublist.toList\n        }\n        result.toList",
    "        var result = List[Any]()\n        var temp = List[Any]()\n        var count = 0\n        for (i <- S.asInstanceOf[List[Any]]) {\n            if (count == step) {\n                result = result :+ temp\n                temp = List[Any]()\n                count = 0\n            }\n            temp = temp :+ i\n            count += 1\n        }\n        if (temp.length > 0) result = result :+ temp\n        return result",
    "        var list = List[Any]()\n        var sublist = List[Any]()\n        var i = 0\n        for (x <- S.asInstanceOf[List[Any]]) {\n            if (i % step == 0 && i != 0) {\n                list = list :+ sublist\n                sublist = List[Any]()\n            }\n            sublist = sublist :+ x\n            i += 1\n        }\n        list = list :+ sublist\n        return list",
    "        if (step == 0) throw new Exception(\"Step cannot be zero\")\n        else if (step < 0) throw new Exception(\"Step cannot be negative\")\n        else if (S.isInstanceOf[List[Any]]) {\n            val L = S.asInstanceOf[List[Any]]\n            val result = new ListBuffer[Any]\n            var i = 0\n            while (i < L.length) {\n                val sublist = new ListBuffer[Any]\n                var j = 0\n                while (j < step && i < L.length) {\n                    sublist += L(i)\n                    i += 1\n                    j += 1\n                }\n                result += sublist.toList\n            }\n            result.toList\n        }\n        else if (S.isInstanceOf[Array[Any]]) {\n            val L = S.asInstanceOf[Array[Any]]\n            val result = new ListBuffer[Any]\n            var i = 0\n            while (i < L.length) {\n                val sublist = new ListBuffer[Any]\n                var j = 0\n                while (j < step && i < L.length) {\n                    sublist += L(i)\n                    i += 1\n                    j += 1\n                }\n                result += sublist.toList\n            }\n            result.toList\n        }\n        else throw new Exception(\"Invalid argument\")",
    "        var result = List[Any]()\n        var temp = List[Any]()\n        var count = 0\n        for (i <- S.asInstanceOf[List[Any]]) {\n            temp = temp :+ i\n            count += 1\n            if (count == step) {\n                result = result :+ temp\n                temp = List[Any]()\n                count = 0\n            }\n        }\n        if (temp != List[Any]()) result = result :+ temp\n        return result",
    "        val list = S.asInstanceOf[List[Any]]\n        val n = list.length\n        val result = new ListBuffer[Any]\n        for (i <- 0 to n - 1 by step.toInt) {\n            val sublist = new ListBuffer[Any]\n            for (j <- i to min(i + step - 1, n - 1)) {\n                sublist += list(j)\n            }\n            result += sublist.toList\n        }\n        result.toList",
    "        var result = new ArrayBuffer[Any]()\n        var temp = new ArrayBuffer[Any]()\n        var i = 0\n        for (x <- S.asInstanceOf[List[Any]]) {\n            if (i == step) {\n                result += temp\n                temp = new ArrayBuffer[Any]()\n                i = 0\n            }\n            temp += x\n            i += 1\n        }\n        if (temp.length != 0) result += temp\n        result",
    "        var result = List[Any]()\n        var temp = List[Any]()\n        var i = 0\n        for (x <- S.asInstanceOf[List[Any]]) {\n            if (i < step) {\n                temp = temp :+ x\n                i += 1\n            } else {\n                result = result :+ temp\n                temp = List[Any]()\n                temp = temp :+ x\n                i = 1\n            }\n        }\n        if (temp.length > 0) result = result :+ temp\n        return result",
    "        val list = S.asInstanceOf[List[Any]]\n        val result = new ListBuffer[Any]\n        var i = 0\n        while (i < list.length) {\n            val temp = new ListBuffer[Any]\n            var j = 0\n            while (j < step && i < list.length) {\n                temp += list(i)\n                i += 1\n                j += 1\n            }\n            result += temp.toList\n        }\n        result.toList",
    "        var result : List[Any] = Nil\n        var i = 0\n        var temp : List[Any] = Nil\n        for (x <- S.asInstanceOf[List[Any]]) {\n            if (i == step) {\n                result = result :+ temp\n                temp = Nil\n                i = 0\n            }\n            temp = temp :+ x\n            i += 1\n        }\n        if (temp != Nil) result = result :+ temp\n        return result",
    "        val list = S.asInstanceOf[List[Any]]\n        val result = new ListBuffer[Any]\n        var i = 0\n        while (i < list.length) {\n            result += list.slice(i, i + step)\n            i += step\n        }\n        result.toList",
    "        val list = S.asInstanceOf[List[Any]]\n        val result = new ListBuffer[Any]\n        for (i <- 0 until list.length by step.toInt) {\n            val sublist = new ListBuffer[Any]\n            for (j <- i until min(i + step, list.length)) {\n                sublist += list(j)\n            }\n            result += sublist.toList\n        }\n        result.toList",
    "        var result : List[Any] = List()\n        var i = 0\n        var j = 0\n        var temp : List[Any] = List()\n        while (i < S.asInstanceOf[List[Any]].length) {\n            if (j == step) {\n                result = result :+ temp\n                temp = List()\n                j = 0\n            }\n            temp = temp :+ S.asInstanceOf[List[Any]].apply(i)\n            i += 1\n            j += 1\n        }\n        if (temp.length != 0) result = result :+ temp\n        return result",
    "        var result = List[Any]()\n        var i = 0\n        var j = 0\n        var temp = List[Any]()\n        while (i < S.asInstanceOf[List[Any]].length) {\n            if (j == step) {\n                result = result :+ temp\n                temp = List[Any]()\n                j = 0\n            }\n            temp = temp :+ S.asInstanceOf[List[Any]].apply(i)\n            i += 1\n            j += 1\n        }\n        result = result :+ temp\n        result",
    "        val list = S.asInstanceOf[List[Any]]\n        val result = new ListBuffer[Any]\n        var i = 0\n        while (i < list.length) {\n            val sublist = new ListBuffer[Any]\n            var j = 0\n            while (j < step && i < list.length) {\n                sublist += list(i)\n                i += 1\n                j += 1\n            }\n            result += sublist.toList\n        }\n        result.toList",
    "        S match {\n            case Nil => Nil\n            case x :: xs => {\n                if (step == 1) {\n                    List(List(x))\n                } else {\n                    val (first, second) = S.asInstanceOf[List[Any]].splitAt(step.toInt)\n                    List(first) ::: listSplit(second, step)\n                }\n            }\n        }",
    "        val list = S.asInstanceOf[List[Any]]\n        val length = list.length\n        val result = new ListBuffer[List[Any]]\n        for (i <- 0 to length - 1 by step.toInt) {\n            result += list.slice(i, min(i + step, length))\n        }\n        result.toList",
    "        val list = S.asInstanceOf[List[Any]]\n        val result = new ListBuffer[Any]\n        for (i <- 0 until list.length by step.toInt) {\n            val sublist = new ListBuffer[Any]\n            for (j <- i until min(i + step, list.length)) {\n                sublist += list(j)\n            }\n            result += sublist.toList\n        }\n        result.toList"
  ]
}