{
  "name": "mbpp_89_closest_num",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the closest smaller number than n.\n    def closestNum(N : Long) : Long = {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_89_closest_num.py",
  "prompt_terminology": "reworded",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(closestNum((11l)) == (10l));\n    assert(closestNum((7l)) == (6l));\n    assert(closestNum((12l)) == (11l));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        val n = N.toString.toList\n        val n1 = n.map(x => if (x == '0') '9' else (x - 1).toChar)\n        val n2 = n.map(x => if (x == '9') '0' else (x + 1).toChar)\n        val d1 = (n1.mkString.toLong - N).abs\n        val d2 = (n2.mkString.toLong - N).abs\n        if (d1 < d2) n1.mkString.toLong else n2.mkString.toLong",
    "        val s = N.toString\n        val n = s.length\n        val sb = new StringBuilder\n        var i = 0\n        while (i < n - 1) {\n            if (s(i) > s(i + 1)) {\n                sb.append(s.substring(0, i) + s(i + 1))\n                var j = i + 1\n                while (j < n) {\n                    sb.append(s(i))\n                    j += 1\n                }\n                return sb.toString.toLong\n            }\n            i += 1\n        }\n        return N",
    "        val digits = N.toString.toList.map(_.asDigit)\n        val n = digits.length\n        val (i, j) = (0 until n).find(i => digits(i) > digits((i + 1) % n)).getOrElse(-1, -1)\n        if (i == -1) return -1\n        val temp = digits(i)\n        digits(i) = digits(j)\n        digits(j) = temp\n        digits.mkString.toLong",
    "        var n = N\n        var count = 0\n        while (n > 0) {\n            if ((n & 1) == 0) count += 1\n            n >>= 1\n        }\n        N - (1 << count)",
    "        var n = N\n        var i = 0\n        while (n > 0) {\n            if ((n & 1) == 0) i += 1\n            n >>= 1\n        }\n        N - (1 << i)",
    "        var n = N\n        var i = 0\n        var j = 0\n        while (n > 0) {\n            if ((n & 1) == 0) i += 1\n            else j += 1\n            n >>= 1\n        }\n        if (i == 0) return -1\n        else return N - (1 << (i + j - 1))",
    "        var n = N\n        var i = 0\n        while (n > 0) {\n            if ((n & 1) == 0) {\n                n = n >> 1\n                i += 1\n            } else {\n                n = n >> 1\n                i += 1\n                break\n            }\n        }\n        return N - (1 << i)",
    "        var n = N\n        var i = 0\n        var j = 0\n        while (n > 0) {\n            if ((n & 1) == 0) i += 1\n            else j += 1\n            n >>= 1\n        }\n        if (i == 0) return -1\n        return N - (1 << (i + j - 1))",
    "        var n = N\n        var i = 0\n        var j = 0\n        while (n > 0) {\n            if (n % 2 == 0) i += 1\n            else j += 1\n            n /= 2\n        }\n        val k = i + j\n        var result = 0L\n        for (i <- 0 until k) {\n            if (i < j) result = result * 2 + 1\n            else result = result * 2\n        }\n        result",
    "        val n = N.toString\n        val len = n.length\n        val sb = new StringBuilder\n        var i = 0\n        while (i < len - 1) {\n            if (n(i) > n(i + 1)) {\n                sb.append(n.substring(0, i))\n                sb.append(n(i + 1))\n                sb.append(n(i))\n                sb.append(n.substring(i + 2))\n                return sb.toString.toLong\n            }\n            i += 1\n        }\n        return -1",
    "        var n = N\n        var i = 0\n        var j = 0\n        while (n > 0) {\n            if ((n & 1) == 0) {\n                i += 1\n            } else {\n                j += 1\n            }\n            n >>= 1\n        }\n        if (i == 0) return -1\n        var res = N\n        res &= ~(1 << (i + j))\n        res |= (1 << (i + j - 1))\n        res |= ((1 << (i - 1)) - 1)\n        return res",
    "        var n = N\n        var i = 0\n        var j = 0\n        while (n > 0) {\n            if ((n & 1) == 0) {\n                i += 1\n            } else {\n                j += 1\n            }\n            n >>= 1\n        }\n        (1L << (i + j)) - 1",
    "        val s = N.toString\n        val l = s.length\n        val m = s.substring(0, l - 1)\n        val n = s.substring(l - 1, l)\n        val d = n.toInt\n        if (d == 0) {\n            val x = m.toLong\n            return x - 1\n        }\n        val x = m + (d - 1).toString\n        return x.toLong",
    "        var n = N\n        var i = 0\n        var j = 0\n        while (n > 0) {\n            if (n % 2 == 0) i += 1\n            else j += 1\n            n /= 2\n        }\n        return pow(2, i + j - 1).toLong",
    "        var n = N\n        var i = 0\n        var j = 0\n        while (n > 0) {\n            if ((n & 1) == 0) i += 1\n            else j += 1\n            n >>= 1\n        }\n        if (i == 0) return -1\n        val res = N - (1 << (i + j - 1))\n        res",
    "        val n = N.toString\n        val n_len = n.length\n        val n_arr = n.toCharArray\n        var i = n_len - 1\n        while (i > 0) {\n            if (n_arr(i) < n_arr(i - 1)) {\n                val temp = n_arr(i)\n                n_arr(i) = n_arr(i - 1)\n                n_arr(i - 1) = temp\n                return n_arr.mkString.toLong\n            }\n            i -= 1\n        }\n        return -1",
    "        var n = N\n        var count = 0\n        while (n % 2 == 0) {\n            count += 1\n            n /= 2\n        }\n        if (count == 0) return N - 1\n        var result = N\n        for (i <- 1 to count) {\n            result /= 2\n            result *= 2\n            result += 1\n        }\n        return result",
    "        var n = N\n        var result = 0L\n        var count = 0\n        while (n > 0) {\n            if ((n & 1) == 0) {\n                result |= (1 << count)\n            }\n            n >>= 1\n            count += 1\n        }\n        result",
    "        val s = N.toString\n        val n = s.length\n        val l = s.last\n        val ld = l.toString.toInt\n        if (ld == 0) return -1\n        val p = s.substring(0, n - 1)\n        val pd = p.toInt\n        val pd1 = pd - 1\n        val pd1s = pd1.toString\n        val pd1sl = pd1s.length\n        val pd1sld = pd1s.last\n        val pd1sldd = pd1sld.toString.toInt\n        val pd1sldd1 = pd1sldd - 1\n        val pd1sldd1s = pd1sldd1.toString\n        val pd1sldd1sl = pd1sldd1s.length\n        val pd1sldd1sl1 = pd1sldd1sl + 1\n        val pd1sldd1sl1s = \"9\" * pd1sldd1sl1\n        val pd1sldd1sl1sl = pd1sldd1sl1s.length\n        val pd1sldd1sl1sll = pd1sldd1sl1s.last\n        val pd1sldd1sl1slld = pd1sldd1sl1sll.toString.toInt\n        val pd1sldd1sl1slld1 = pd1sldd1sl1slld + 1\n        val pd1sldd1sl1slld1s = pd1sldd1sl1slld1.toString\n        val pd1sldd1sl1slld1sl = pd1sldd1sl1slld1s.length\n        val pd1sldd1sl1slld1sll = pd1sldd1sl1slld1s.last\n        val pd1sldd1sl1slld1slld = pd1sldd1sl1",
    "        var n = N\n        var i = 0\n        var j = 0\n        while (n > 0) {\n            if ((n & 1) == 0) i += 1\n            else j += 1\n            n >>= 1\n        }\n        if (i == 0) return -1\n        var result = N\n        result &= ~(1 << (i + j))\n        result |= (1 << (i + j - 1))\n        result -= 1\n        result |= ((1 << (j - 1)) - 1)\n        return result"
  ]
}