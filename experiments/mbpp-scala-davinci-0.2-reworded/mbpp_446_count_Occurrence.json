{
  "name": "mbpp_446_count_Occurrence",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a scalathon function to count the occurence of all elements of list in a tuple.\n    def countOccurrence(tup : Any, lst : Any) : Long = {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_446_count_Occurrence.py",
  "prompt_terminology": "reworded",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(countOccurrence((Any((\"a\", \"a\", \"c\", \"b\", \"d\"))), (Any(\"a\", \"b\"))) == (3l));\n    assert(countOccurrence((Any((1l, 2l, 3l, 1l, 4l, 6l, 7l, 1l, 4l))), (Any(1l.toLong, 4l.toLong, 7l.toLong))) == (6l));\n    assert(countOccurrence((Any((1l, 2l, 3l, 4l, 5l, 6l))), (Any(1l.toLong, 2l.toLong))) == (2l));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        var count = 0\n        lst match {\n            case lst : List[Any] => {\n                for (i <- 0 until lst.length) {\n                    if (tup == lst(i)) {\n                        count += 1\n                    }\n                }\n            }\n            case _ => {\n                println(\"Invalid input\")\n                return -1\n            }\n        }\n        return count",
    "        var count = 0\n        lst match {\n            case l : List[Any] => {\n                for (i <- l) {\n                    if (i == tup) {\n                        count += 1\n                    }\n                }\n            }\n            case _ => {\n                println(\"List is not of type List[Any]\")\n            }\n        }\n        count",
    "        var count = 0\n        lst match {\n            case Nil => count\n            case x :: xs => if (x == tup) countOccurrence(tup, xs) + 1 else countOccurrence(tup, xs)\n        }",
    "        val lst1 = lst.asInstanceOf[List[Any]]\n        val tup1 = tup.asInstanceOf[Tuple2[Any, Any]]\n        var count = 0\n        for (i <- 0 until lst1.length) {\n            if (lst1(i) == tup1._1) count += 1\n        }\n        count",
    "        lst match {\n            case Nil => 0\n            case x :: xs => {\n                tup match {\n                    case (a, b) => {\n                        if (a == x) 1 + countOccurrence((a, b), xs)\n                        else countOccurrence((a, b), xs)\n                    }\n                    case _ => 0\n                }\n            }\n        }",
    "        var count = 0\n        lst match {\n            case Nil => 0\n            case x :: xs => if (x == tup) countOccurrence(tup, xs) + 1 else countOccurrence(tup, xs)\n        }",
    "        lst match {\n            case Nil => 0\n            case x :: xs => {\n                tup match {\n                    case (a, b) => {\n                        if (a == x) 1 + countOccurrence(tup, xs)\n                        else countOccurrence(tup, xs)\n                    }\n                }\n            }\n        }",
    "        val tupList = tup.asInstanceOf[List[Any]]\n        val lstList = lst.asInstanceOf[List[Any]]\n        val tupSet = tupList.toSet\n        var count = 0\n        for (i <- lstList) {\n            if (tupSet.contains(i)) count += 1\n        }\n        count",
    "        val lst1 = lst.asInstanceOf[List[Any]]\n        val tup1 = tup.asInstanceOf[Tuple2[Any, Any]]\n        val lst2 = lst1.filter(x => x == tup1._1)\n        lst2.length",
    "        var count = 0\n        for (i <- 0 until lst.asInstanceOf[List[Any]].length) {\n            if (tup.asInstanceOf[Tuple2[Any, Any]]._1 == lst.asInstanceOf[List[Any]].apply(i)) {\n                count += 1\n            }\n        }\n        return count",
    "        val lst2 = lst.asInstanceOf[List[Any]]\n        val tup2 = tup.asInstanceOf[Tuple2[Any, Any]]\n        val lst3 = lst2.map(x => x.asInstanceOf[Tuple2[Any, Any]])\n        lst3.filter(x => x._1 == tup2._1).map(x => x._2).sum",
    "        lst match {\n            case Nil => 0\n            case x :: xs => if (x == tup) 1 + countOccurrence(tup, xs) else countOccurrence(tup, xs)\n        }",
    "        var count = 0\n        lst match {\n            case lst : List[Any] => {\n                for (x <- lst) {\n                    if (x == tup) count += 1\n                }\n            }\n            case _ => count = 0\n        }\n        count",
    "        val lst1 = lst.asInstanceOf[List[Any]]\n        val tup1 = tup.asInstanceOf[Tuple2[Any, Any]]\n        val lst2 = lst1.filter(x => x == tup1._1)\n        lst2.length",
    "        var count = 0\n        lst match {\n            case lst : List[Any] => {\n                for (i <- lst) {\n                    if (i == tup) {\n                        count += 1\n                    }\n                }\n            }\n            case _ => {\n                println(\"Not a list\")\n            }\n        }\n        count",
    "        val lst1 = lst.asInstanceOf[List[Any]]\n        val tup1 = tup.asInstanceOf[Tuple2[Any, Any]]\n        val lst2 = lst1.filter(x => x == tup1._1)\n        lst2.length",
    "        if (lst.isInstanceOf[List[Any]]) {\n            val lst1 = lst.asInstanceOf[List[Any]]\n            lst1.count(x => x == tup)\n        } else {\n            0\n        }",
    "        lst match {\n            case Nil => 0\n            case x :: xs => {\n                tup match {\n                    case (a, b) => {\n                        if (a == x) 1 + countOccurrence(tup, xs)\n                        else countOccurrence(tup, xs)\n                    }\n                    case _ => 0\n                }\n            }\n        }",
    "        val tupList = tup.asInstanceOf[Tuple2[Any, Any]]\n        val lstList = lst.asInstanceOf[List[Any]]\n        val tupList1 = tupList._1.asInstanceOf[List[Any]]\n        val tupList2 = tupList._2.asInstanceOf[List[Any]]\n        val tupList3 = tupList1 ++ tupList2\n        val tupList4 = tupList3.toSet\n        val tupList5 = tupList4.toList\n        val tupList6 = tupList5.sorted\n        val tupList7 = tupList6.map(x => (x, 0))\n        val tupList8 = tupList7.toMap\n        val tupList9 = lstList.map(x => (x, 1))\n        val tupList10 = tupList9.toMap\n        val tupList11 = tupList10.foldLeft(tupList8)((x, y) => x + y)\n        val tupList12 = tupList11.values.toList\n        val tupList13 = tupList12.foldLeft(0)((x, y) => x + y)\n        tupList13",
    "        var count = 0\n        lst match {\n            case lst : List[Any] => {\n                for (i <- lst) {\n                    if (i == tup) {\n                        count += 1\n                    }\n                }\n            }\n            case _ => {\n                println(\"Invalid input\")\n            }\n        }\n        return count"
  ]
}