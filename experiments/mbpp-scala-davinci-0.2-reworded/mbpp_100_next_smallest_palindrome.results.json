{
  "name": "mbpp_100_next_smallest_palindrome",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_100_next_smallest_palindrome.py",
  "prompt_terminology": "reworded",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "results": [
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var length = n.toString.length\n        var half = length / 2\n        var left = n / pow(10, half).toLong\n        var right = n % pow(10, half).toLong\n        var left_reverse = 0L\n        var right_reverse = 0L\n        for (i <- 0 until half) {\n            left_reverse = left_reverse * 10 + left % 10\n            left /= 10\n            right_reverse = right_reverse * 10 + right % 10\n            right /= 10\n        }\n        if (left == right && left_reverse == right_reverse) {\n            var left_next = left + 1\n            var right_next = 0L\n            for (i <- 0 until half) {\n                right_next = right_next * 10 + left_next % 10\n                left_next /= 10\n            }\n            left_next * pow(10, half).toLong + right_next\n        } else if (left_reverse > right) {\n            left * pow(10, half).toLong + left_reverse\n        } else {\n            var left_next = left + 1\n            var right_next = 0L\n            for (i <- 0 until half) {\n                right_next = right_next * 10 + left_next % 10\n                left_next /= 10\n            }\n            left_next * pow(10, half).toLong + right_next\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1665517292,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp9wl3yoel.scala:40)\n\tat Problem.main(tmp9wl3yoel.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val str = num.toString\n        val len = str.length\n        val half = len / 2\n        val left = str.substring(0, half)\n        val right = str.substring(len - half, len)\n        val leftRev = left.reverse\n        if (leftRev > right) {\n            val leftInt = left.toInt\n            return (leftInt + 1).toString + leftRev.substring(1, half).reverse\n        }\n        else {\n            val leftInt = left.toInt\n            return leftInt.toString + leftRev.substring(1, half).reverse\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1665517291,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcdcae8z2.scala:14:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mreturn\u001b[0m (leftInt + \u001b[31m1\u001b[0m).toString + leftRev.substring(\u001b[31m1\u001b[0m, half).reverse\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    String\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcdcae8z2.scala:18:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            \u001b[33mreturn\u001b[0m leftInt.toString + leftRev.substring(\u001b[31m1\u001b[0m, half).reverse\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    String\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        def isPalindrome(num : Long) : Boolean = {\n            val str = num.toString\n            str.reverse == str\n        }\n        def nextPalindrome(num : Long) : Long = {\n            if (isPalindrome(num)) num\n            else nextPalindrome(num + 1)\n        }\n        nextPalindrome(num + 1)\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1665517292,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        def isPalindrome(num : Long) : Boolean = {\n            val str = num.toString\n            str == str.reverse\n        }\n        def nextPalindrome(num : Long) : Long = {\n            val str = num.toString\n            val len = str.length\n            val half = len / 2\n            val left = str.substring(0, half)\n            val right = str.substring(half + len % 2, len)\n            val leftRev = left.reverse\n            val leftNum = left.toLong\n            val leftRevNum = leftRev.toLong\n            val rightNum = right.toLong\n            if (leftNum == leftRevNum) {\n                val nextLeft = (leftNum + 1).toString\n                val nextLeftLen = nextLeft.length\n                val nextLeftRev = nextLeft.reverse\n                val nextLeftRevLen = nextLeftRev.length\n                val nextLeftRevStr = if (nextLeftLen > nextLeftRevLen) \"0\" + nextLeftRev else nextLeftRev\n                val nextLeftStr = if (nextLeftLen > nextLeftRevLen) nextLeft + \"0\" else nextLeft\n                val nextLeftNum = nextLeftStr.toLong\n                val nextLeftRevNum = nextLeftRevStr.toLong\n                if (nextLeftNum == nextLeftRevNum) nextLeftNum\n                else nextPalindrome(nextLeftNum)\n            } else {\n                val nextLeft = leftNum.toString\n                val nextLeftRev = leftRevNum.toString\n                val nextLeftLen = nextLeft.length\n                val nextLeftRevLen = nextLeftRev.length\n                val nextLeftRevStr = if (nextLeftLen > nextLeftRevLen) \"0\" + nextLeftRev else nextLeftRev\n                val nextLeftStr = if (nextLeftLen > nextLeftRevLen) nextLeft + \"0\" else nextLeft\n                val nextLeftNum = nextLeftStr.toLong\n                val nextLeftRevNum = nextLeftRevStr.toLong\n                if (nextLeftNum == nextLeftRevNum) nextLeftNum\n                else nextPalindrome(nextLeftNum)\n            }\n        }\n        if (isPalindrome(num)) num\n        else nextPal\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1665517289,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8x76z08c.scala:45:13 ------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m        \u001b[33melse\u001b[0m nextPal\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m             Not found: nextPal\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val numString = num.toString\n        val numLength = numString.length\n        val halfLength = numLength / 2\n        val leftHalf = numString.substring(0, halfLength)\n        val rightHalf = numString.substring(numLength - halfLength, numLength)\n        val leftHalfReversed = leftHalf.reverse\n        val leftHalfInt = leftHalf.toInt\n        val leftHalfReversedInt = leftHalfReversed.toInt\n        if (leftHalfInt == leftHalfReversedInt) {\n            val nextLeftHalf = (leftHalfInt + 1).toString\n            val nextLeftHalfLength = nextLeftHalf.length\n            val nextLeftHalfHalfLength = nextLeftHalfLength / 2\n            val nextLeftHalfLeftHalf = nextLeftHalf.substring(0, nextLeftHalfHalfLength)\n            val nextLeftHalfRightHalf = nextLeftHalf.substring(nextLeftHalfLength - nextLeftHalfHalfLength, nextLeftHalfLength)\n            val nextLeftHalfRightHalfReversed = nextLeftHalfRightHalf.reverse\n            val nextLeftHalfLeftHalfInt = nextLeftHalfLeftHalf.toInt\n            val nextLeftHalfRightHalfReversedInt = nextLeftHalfRightHalfReversed.toInt\n            if (nextLeftHalfLeftHalfInt == nextLeftHalfRightHalfReversedInt) {\n                val nextLeftHalfRightHalfReversedIntString = nextLeftHalfRightHalfReversedInt.toString\n                val nextLeftHalfRightHalfReversedIntStringLength = nextLeftHalfRightHalfReversedIntString.length\n                val nextLeftHalfRightHalfReversedIntStringHalfLength = nextLeftHalfRightHalfReversedIntStringLength / 2\n                val nextLeftHalfRightHalfReversedIntStringLeftHalf = nextLeftHalfRightHalfReversedIntString.substring(0, nextLeftHalfRightHalfReversedIntStringHalfLength)\n                val nextLeftHalfRightHalfReversedIntStringRightHalf = nextLeftHalfRightHalfReversedIntString.substring(nextLeftHalfRightHalfReversedIntStringLength - nextLeftHalfRightHalfReversedIntStringHalfLength, nextLeftHalfRightHalfReversedIntStringLength)\n                val nextLeftHalfRightHalf\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1665517290,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmptr5itwod.scala:30:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmptr5itwod.scala:38:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[33m\u001b[33m-- Warning: /tmp/tmptr5itwod.scala:31:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m31 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val n = s.length\n        val half = n / 2\n        val left = s.substring(0, half)\n        val right = s.substring(half + n % 2, n)\n        val leftRev = left.reverse\n        val leftInt = left.toInt\n        val leftRevInt = leftRev.toInt\n        if (leftInt < leftRevInt) {\n            val leftInc = (leftInt + 1).toString\n            val leftIncRev = leftInc.reverse\n            val leftIncRevLen = leftIncRev.length\n            val leftIncRevPad = leftIncRev + \"0\" * (half - leftIncRevLen)\n            val leftIncRevInt = leftIncRevPad.toInt\n            val rightInt = right.toInt\n            if (leftIncRevInt > rightInt) {\n                val leftIncRevPadInt = leftIncRevPad.toInt\n                val leftIncRevPadStr = leftIncRevPadInt.toString\n                val leftIncRevPadStrRev = leftIncRevPadStr.reverse\n                val leftIncRevPadStrRevInt = leftIncRevPadStrRev.toInt\n                val leftIncRevPadStrRevIntStr = leftIncRevPadStrRevInt.toString\n                val leftIncRevPadStrRevIntStrPad = leftIncRevPadStrRevIntStr + \"0\" * (n - leftIncRevPadStrRevIntStr.length)\n                leftIncRevPadStrRevIntStrPad.toLong\n            } else {\n                val leftIncRevPadInt = leftIncRevPad.toInt\n                val leftIncRevPadStr = leftIncRevPadInt.toString\n                val leftIncRevPadStrRev = leftIncRevPadStr.reverse\n                val leftIncRevPadStrRevInt = leftIncRevPadStrRev.toInt\n                val leftIncRevPadStrRevIntStr = leftIncRevPadStrRevInt.toString\n                val leftIncRevPadStrRevIntStrPad = leftIncRevPadStrRevIntStr + \"0\" * (n - leftIncRevPadStrRevIntStr.length)\n                leftIncRevPadStrRevIntStrPad.toLong\n            }\n        } else {\n            val leftRevIntStr\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1665517292,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpnrdd2dvr.scala:40:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpnrdd2dvr.scala:48:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnrdd2dvr.scala:47:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpnrdd2dvr.scala:41:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m41 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val numStr = num.toString\n        val len = numStr.length\n        val halfLen = len / 2\n        val leftHalf = numStr.substring(0, halfLen)\n        val rightHalf = numStr.substring(halfLen + (len % 2), len)\n        val leftHalfReversed = leftHalf.reverse\n        val leftHalfInt = leftHalf.toInt\n        val leftHalfReversedInt = leftHalfReversed.toInt\n        if (leftHalfInt < leftHalfReversedInt) {\n            val leftHalfPlusOne = (leftHalfInt + 1).toString\n            val leftHalfPlusOneReversed = leftHalfPlusOne.reverse\n            val leftHalfPlusOneLen = leftHalfPlusOne.length\n            val leftHalfPlusOneReversedLen = leftHalfPlusOneReversed.length\n            val leftHalfPlusOneReversedPadded = leftHalfPlusOneReversed + \"0\" * (leftHalfPlusOneLen - leftHalfPlusOneReversedLen)\n            val leftHalfPlusOnePadded = leftHalfPlusOne + \"0\" * (leftHalfPlusOneLen - leftHalfPlusOneReversedLen)\n            val leftHalfPlusOneInt = leftHalfPlusOnePadded.toInt\n            val leftHalfPlusOneReversedInt = leftHalfPlusOneReversedPadded.toInt\n            if (leftHalfPlusOneInt < leftHalfPlusOneReversedInt) leftHalfPlusOnePadded + leftHalfPlusOneReversedPadded\n            else leftHalfPlusOnePadded + leftHalfPlusOnePadded\n        } else leftHalf + leftHalfReversed\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1665517292,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6g7ta82h.scala:23:65 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mif\u001b[0m (leftHalfPlusOneInt < leftHalfPlusOneReversedInt) leftHalfPlusOnePadded + leftHalfPlusOneReversedPadded\n\u001b[31m\u001b[31m   |\u001b[0m                                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                        Found:    String\n\u001b[31m   |\u001b[0m                                                        Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6g7ta82h.scala:24:17 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33melse\u001b[0m leftHalfPlusOnePadded + leftHalfPlusOnePadded\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 Found:    String\n\u001b[31m   |\u001b[0m                 Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6g7ta82h.scala:25:15 --------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        } \u001b[33melse\u001b[0m leftHalf + leftHalfReversed\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               Found:    String\n\u001b[31m   |\u001b[0m               Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var i = 0\n        while (i < n.toString.length / 2) {\n            if (n.toString.charAt(i) != n.toString.charAt(n.toString.length - 1 - i)) {\n                n = n + pow(10, i).toLong\n                i = 0\n            } else i += 1\n        }\n        n\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1665517292,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpyemss7w3.scala:17)\n\tat Problem.main(tmpyemss7w3.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        def isPalindrome(num : Long) : Boolean = {\n            val str = num.toString\n            str == str.reverse\n        }\n        def nextPalindrome(num : Long) : Long = {\n            if (isPalindrome(num)) num\n            else nextPalindrome(num + 1)\n        }\n        nextPalindrome(num + 1)\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1665517291,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        def isPalindrome(num : Long) : Boolean = {\n            val str = num.toString\n            str == str.reverse\n        }\n        def nextPalindrome(num : Long) : Long = {\n            if (isPalindrome(num)) num\n            else nextPalindrome(num + 1)\n        }\n        nextPalindrome(num + 1)\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1665517291,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var digits = new ArrayBuffer[Int]\n        while (n > 0) {\n            digits += (n % 10).toInt\n            n /= 10\n        }\n        var i = 0\n        var j = digits.length - 1\n        while (i < j) {\n            if (digits(i) < digits(j)) {\n                digits(j) = digits(i)\n            } else if (digits(i) > digits(j)) {\n                digits(j) = digits(i)\n                var k = j - 1\n                while (k >= 0 && digits(k) == 9) {\n                    digits(k) = 0\n                    k -= 1\n                }\n                if (k < 0) {\n                    digits.insert(0, 1)\n                } else {\n                    digits(k) += 1\n                }\n            }\n            i += 1\n            j -= 1\n        }\n        var result = 0L\n        for (i <- 0 until digits.length) result = result * 10 + digits(i)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1665517292,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp3lure1e9.scala:38)\n\tat Problem.main(tmp3lure1e9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val n = s.length\n        val half = n / 2\n        val isOdd = n % 2 == 1\n        val left = s.substring(0, half)\n        val right = s.substring(half + (if (isOdd) 1 else 0))\n        val leftReverse = left.reverse\n        val leftReverseInt = leftReverse.toInt\n        val leftInt = left.toInt\n        val rightInt = right.toInt\n        if (leftInt < leftReverseInt) {\n            val newLeft = (leftInt + 1).toString\n            val newRight = newLeft.reverse\n            val newRightInt = newRight.toInt\n            val newLeftInt = newLeft.toInt\n            if (newLeftInt < newRightInt) {\n                val newLeft = (leftInt + 1).toString\n                val newRight = newLeft.reverse\n                val newRightInt = newRight.toInt\n                val newLeftInt = newLeft.toInt\n                val newLeftPadded = newLeft.padTo(half, '0')\n                val newRightPadded = newRight.padTo(half, '0')\n                val newLeftPaddedInt = newLeftPadded.toInt\n                val newRightPaddedInt = newRightPadded.toInt\n                if (newLeftPaddedInt < newRightPaddedInt) {\n                    val newLeftPadded = newLeft.padTo(half, '0')\n                    val newRightPadded = newRight.padTo(half, '0')\n                    val newLeftPaddedInt = newLeftPadded.toInt\n                    val newRightPaddedInt = newRightPadded.toInt\n                    val newLeftPaddedReverse = newLeftPadded.reverse\n                    val newLeftPaddedReverseInt = newLeftPaddedReverse.toInt\n                    val newLeftPaddedInt = newLeftPadded.toInt\n                    if (newLeftPaddedInt < newLeftPaddedReverseInt) {\n                        val newLeftPadded = newLeft.padTo(half, '0')\n                        val newRightPadded = newRight.padTo(half, '\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1665517290,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpn5hcwgcl.scala:40:66 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m                        \u001b[33mval\u001b[0m \u001b[36mnewRightPadded\u001b[0m = newRight.padTo(half, '\n\u001b[31m\u001b[31m   |\u001b[0m                                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                              unclosed character literal\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpn5hcwgcl.scala:49:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpn5hcwgcl.scala:37:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                    \u001b[33mval\u001b[0m \u001b[36mnewLeftPaddedInt\u001b[0m = newLeftPadded.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnewLeftPaddedInt is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnewLeftPaddedInt\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpn5hcwgcl.scala:42:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m42 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        def isPalindrome(num : Long) : Boolean = {\n            val str = num.toString\n            str == str.reverse\n        }\n        def nextPalindrome(num : Long) : Long = {\n            if (isPalindrome(num)) num\n            else nextPalindrome(num + 1)\n        }\n        nextPalindrome(num + 1)\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1665517291,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val digits = num.toString.map(_.asDigit)\n        val half = digits.length / 2\n        val left = digits.take(half)\n        val right = digits.drop(half + digits.length % 2).reverse\n        if (left.mkString.toLong < right.mkString.toLong) {\n            val newRight = left.reverse\n            val newDigits = left ++ (if (digits.length % 2 == 1) digits(half) :: newRight else newRight)\n            newDigits.mkString.toLong\n        } else {\n            val newLeft = (left.mkString.toLong + 1).toString.map(_.asDigit)\n            val newRight = newLeft.reverse\n            val newDigits = newLeft ++ (if (digits.length % 2 == 1) digits(half) :: newRight else newRight)\n            newDigits.mkString.toLong\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1665517291,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8c58zv4n.scala:12:78 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnewDigits\u001b[0m = left ++ (\u001b[33mif\u001b[0m (digits.length % \u001b[31m2\u001b[0m == \u001b[31m1\u001b[0m) digits(half) :: newRight \u001b[33melse\u001b[0m newRight)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                              ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m value :: is not a member of IndexedSeq[Int] - did you mean newRight.+:?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8c58zv4n.scala:17:81 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnewDigits\u001b[0m = newLeft ++ (\u001b[33mif\u001b[0m (digits.length % \u001b[31m2\u001b[0m == \u001b[31m1\u001b[0m) digits(half) :: newRight \u001b[33melse\u001b[0m newRight)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                 ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m value :: is not a member of IndexedSeq[Int] - did you mean newRight.+:?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        def isPalindrome(num : Long) : Boolean = {\n            val str = num.toString\n            str == str.reverse\n        }\n        def nextPalindrome(num : Long) : Long = {\n            if (isPalindrome(num)) num\n            else nextPalindrome(num + 1)\n        }\n        nextPalindrome(num + 1)\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1665517291,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val str = num.toString\n        val len = str.length\n        val half = len / 2\n        val left = str.substring(0, half)\n        val right = str.substring(half + len % 2, len)\n        val leftRev = left.reverse\n        if (leftRev > right) {\n            val newLeft = (left.toLong + 1).toString\n            val newRight = newLeft.reverse\n            val newStr = newLeft + newRight.substring(newRight.length - len % 2, newRight.length)\n            newStr.toLong\n        } else {\n            val newLeft = left + leftRev.substring(leftRev.length - len % 2, leftRev.length)\n            newLeft.toLong\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1665517292,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpo1il4o_e.scala:23)\n\tat Problem.main(tmpo1il4o_e.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val str = num.toString\n        val len = str.length\n        val half = len / 2\n        val left = str.substring(0, half)\n        val right = str.substring(half + len % 2)\n        val leftRev = left.reverse\n        val leftRevInt = leftRev.toInt\n        val leftInt = left.toInt\n        if (leftRevInt > right.toInt) {\n            val leftRevStr = leftRevInt.toString\n            val leftRevStrLen = leftRevStr.length\n            val leftRevStrHalf = leftRevStrLen / 2\n            val leftRevStrLeft = leftRevStr.substring(0, leftRevStrHalf)\n            val leftRevStrRight = leftRevStr.substring(leftRevStrHalf + leftRevStrLen % 2)\n            val leftRevStrLeftInt = leftRevStrLeft.toInt\n            val leftRevStrRightInt = leftRevStrRight.toInt\n            if (leftRevStrLeftInt == leftRevStrRightInt) {\n                val leftStr = leftRevStrLeftInt.toString\n                val leftStrLen = leftStr.length\n                val leftStrHalf = leftStrLen / 2\n                val leftStrLeft = leftStr.substring(0, leftStrHalf)\n                val leftStrRight = leftStr.substring(leftStrHalf + leftStrLen % 2)\n                val leftStrLeftInt = leftStrLeft.toInt\n                val leftStrRightInt = leftStrRight.toInt\n                if (leftStrLeftInt == leftStrRightInt) {\n                    val leftStrLeftIntNext = leftStrLeftInt + 1\n                    val leftStrLeftIntNextStr = leftStrLeftIntNext.toString\n                    val leftStrLeftIntNextStrLen = leftStrLeftIntNextStr.length\n                    val leftStrLeftIntNextStrHalf = leftStrLeftIntNextStrLen / 2\n                    val leftStrLeftIntNextStrLeft = leftStrLeftIntNextStr.substring(0, leftStrLeftIntNextStrHalf)\n                    val leftStrLeftIntNextStrRight = leftStrLeftIntNextStr.substring(leftStrLeftIntNextStrHalf + leftStrLeftIntNextStrLen % 2)\n                    val leftStrLeftIntNextStrLeft\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1665517290,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpgre7sg6n.scala:38:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpgre7sg6n.scala:46:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpgre7sg6n.scala:39:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m39 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val n = s.length\n        val mid = n / 2\n        val left = s.substring(0, mid)\n        val right = s.substring(mid + (n % 2), n).reverse\n        val leftNum = left.toLong\n        val rightNum = right.toLong\n        if (leftNum == rightNum) {\n            val nextLeft = (leftNum + 1).toString\n            val nextRight = nextLeft.reverse\n            if (nextLeft.length > left.length) nextRight.toLong * pow(10, n / 2 + 1).toLong + nextLeft.toLong * pow(10, n / 2).toLong\n            else nextRight.toLong * pow(10, n / 2).toLong + nextLeft.toLong * pow(10, n / 2).toLong\n        }\n        else if (leftNum > rightNum) {\n            val nextLeft = left\n            val nextRight = nextLeft.reverse\n            if (nextLeft.length > left.length) nextRight.toLong * pow(10, n / 2 + 1).toLong + nextLeft.toLong * pow(10, n / 2).toLong\n            else nextRight.toLong * pow(10, n / 2).toLong + nextLeft.toLong * pow(10, n / 2).toLong\n        }\n        else {\n            val nextLeft = (leftNum + 1).toString\n            val nextRight = nextLeft.reverse\n            if (nextLeft.length > left.length) nextRight.toLong * pow(10, n / 2 + 1).toLong + nextLeft.toLong * pow(10, n / 2).toLong\n            else nextRight.toLong * pow(10, n / 2).toLong + nextLeft.toLong * pow(10, n / 2).toLong\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1665517292,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp8pp1l3p8.scala:33)\n\tat Problem.main(tmp8pp1l3p8.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val str = num.toString\n        val len = str.length\n        val half = len / 2\n        val (left, right) = str.splitAt(half)\n        val leftRev = left.reverse\n        val leftRevInt = leftRev.toInt\n        val leftInt = left.toInt\n        if (leftRevInt < leftInt) {\n            val newLeft = (leftInt + 1).toString\n            val newLeftRev = newLeft.reverse\n            val newLeftRevLen = newLeftRev.length\n            val newLeftLen = newLeft.length\n            val newLeftRevDiff = half - newLeftRevLen\n            val newLeftDiff = half - newLeftLen\n            val newLeftRevPadded = \"0\" * newLeftRevDiff + newLeftRev\n            val newLeftPadded = \"0\" * newLeftDiff + newLeft\n            val newStr = newLeftPadded + newLeftRevPadded\n            newStr.toLong\n        } else {\n            val newStr = left + leftRev\n            newStr.toLong\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1665517292,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpb228v6i7.scala:30)\n\tat Problem.main(tmpb228v6i7.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        while(true) {\n            n += 1\n            if(isPalindrome(n)) return n\n        }\n        return -1\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1665517289,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8ynnkoj1.scala:9:15 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m            \u001b[33mif\u001b[0m(isPalindrome(n)) \u001b[33mreturn\u001b[0m n\n\u001b[31m\u001b[31m  |\u001b[0m               ^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m               Not found: isPalindrome\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var digits = new ArrayBuffer[Int]()\n        while (n > 0) {\n            digits += (n % 10).toInt\n            n /= 10\n        }\n        var i = 0\n        var j = digits.length - 1\n        while (i < j) {\n            if (digits(i) < digits(j)) {\n                digits(j) = digits(i)\n                return digits.reverse.foldLeft(0L)((a, b) => a * 10 + b)\n            }\n            else if (digits(i) > digits(j)) {\n                digits(j) = digits(i)\n                var carry = 1\n                var k = j - 1\n                while (k >= 0) {\n                    if (digits(k) + carry > 9) {\n                        digits(k) = 0\n                        carry = 1\n                    }\n                    else {\n                        digits(k) += carry\n                        carry = 0\n                    }\n                    k -= 1\n                }\n                if (carry == 1) {\n                    digits.insert(0, 1)\n                }\n                return digits.reverse.foldLeft(0L)((a, b) => a * 10 + b)\n            }\n            i += 1\n            j -= 1\n        }\n        digits.reverse.foldLeft(0L)((a, b) => a * 10 + b)\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123060,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpspypzjqd.scala:45)\n\tat Problem.main(tmpspypzjqd.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val str = num.toString\n        val len = str.length\n        val half = len / 2\n        val left = str.substring(0, half)\n        val right = str.substring(half + len % 2)\n        val leftRev = left.reverse\n        val leftNum = left.toLong\n        val rightNum = right.toLong\n        if (leftNum == rightNum) {\n            val nextLeft = (leftNum + 1).toString\n            val nextLeftRev = nextLeft.reverse\n            val nextLeftLen = nextLeft.length\n            val nextLeftRevLen = nextLeftRev.length\n            val nextLeftRevPad = if (nextLeftLen > nextLeftRevLen) \"0\" * (nextLeftLen - nextLeftRevLen) else \"\"\n            val nextLeftPad = if (nextLeftLen > nextLeftRevLen) \"0\" * (nextLeftLen - nextLeftRevLen) else \"\"\n            (nextLeftPad + nextLeft + nextLeftRevPad + nextLeftRev).toLong\n        } else {\n            val nextLeft = (leftNum + 1).toString\n            val nextLeftRev = nextLeft.reverse\n            val nextLeftLen = nextLeft.length\n            val nextLeftRevLen = nextLeftRev.length\n            val nextLeftRevPad = if (nextLeftLen > nextLeftRevLen) \"0\" * (nextLeftLen - nextLeftRevLen) else \"\"\n            val nextLeftPad = if (nextLeftLen > nextLeftRevLen) \"0\" * (nextLeftLen - nextLeftRevLen) else \"\"\n            (nextLeftPad + nextLeft + nextLeftRevPad + nextLeftRev).toLong\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123059,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpw_3iyt0_.scala:33)\n\tat Problem.main(tmpw_3iyt0_.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var digits = new ArrayBuffer[Int]()\n        while (n > 0) {\n            digits += (n % 10).toInt\n            n /= 10\n        }\n        var i = 0\n        while (i < digits.length / 2) {\n            if (digits(i) < digits(digits.length - 1 - i)) {\n                var j = digits.length - 1 - i\n                while (j > i && digits(j) == 0) {\n                    digits(j) = 9\n                    j -= 1\n                }\n                digits(j) -= 1\n                i += 1\n            } else if (digits(i) > digits(digits.length - 1 - i)) {\n                digits(digits.length - 1 - i) = digits(i)\n                i += 1\n            } else i += 1\n        }\n        var result = 0L\n        for (i <- 0 until digits.length) result = result * 10 + digits(i)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123060,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpexzommpj.scala:32)\n\tat Problem.main(tmpexzommpj.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var digits = new ArrayBuffer[Int]\n        while (n > 0) {\n            digits += (n % 10).toInt\n            n /= 10\n        }\n        var i = 0\n        while (i < digits.length / 2) {\n            if (digits(i) < digits(digits.length - 1 - i)) {\n                var j = digits.length - 1 - i\n                while (digits(j) == 0) {\n                    digits(j) = 9\n                    j -= 1\n                }\n                digits(j) -= 1\n            }\n            digits(digits.length - 1 - i) = digits(i)\n            i += 1\n        }\n        var result = 0L\n        for (i <- 0 until digits.length) {\n            result = result * 10 + digits(i)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123060,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp8zl0btyb.scala:32)\n\tat Problem.main(tmp8zl0btyb.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        def isPalindrome(num : Long) : Boolean = {\n            val str = num.toString\n            str == str.reverse\n        }\n        def nextSmallestPalindrome(num : Long, i : Int) : Long = {\n            if (i == 0) num\n            else {\n                val str = num.toString\n                val str2 = str.substring(0, i) + str.substring(i)\n                val num2 = str2.toLong\n                if (isPalindrome(num2)) num2\n                else nextSmallestPalindrome(num2, i - 1)\n            }\n        }\n        nextSmallestPalindrome(num, num.toString.length)\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123060,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmphryg1gks.scala:23)\n\tat Problem.main(tmphryg1gks.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        def isPalindrome(num : Long) : Boolean = {\n            val str = num.toString\n            str == str.reverse\n        }\n        def nextPalindrome(num : Long) : Long = {\n            if (isPalindrome(num)) num\n            else nextPalindrome(num - 1)\n        }\n        nextPalindrome(num - 1)\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123059,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpdhktl6ou.scala:17)\n\tat Problem.main(tmpdhktl6ou.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        def isPalindrome(num : Long) : Boolean = {\n            val str = num.toString\n            str == str.reverse\n        }\n        def nextSmallestPalindrome(num : Long, i : Int) : Long = {\n            if (i == 0) return num\n            val next = num - pow(10, i).toLong\n            if (isPalindrome(next)) return next\n            nextSmallestPalindrome(next, i - 1)\n        }\n        val str = num.toString\n        val len = str.length\n        val half = len / 2\n        val left = str.substring(0, half)\n        val right = str.substring(half + len % 2, len)\n        val leftNum = left.toLong\n        val rightNum = right.toLong\n        if (leftNum == rightNum) {\n            val next = nextSmallestPalindrome(leftNum * pow(10, len).toLong + rightNum, half - 1)\n            if (next == num) nextSmallestPalindrome(num - 1, half)\n            else next\n        } else {\n            val next = leftNum * pow(10, len).toLong + rightNum\n            if (next < num) next\n            else nextSmallestPalindrome(next - 1, half)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123060,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpgy_v9az9.scala:34)\n\tat Problem.main(tmpgy_v9az9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        def isPalindrome(num : Long) : Boolean = {\n            val str = num.toString\n            str == str.reverse\n        }\n        def nextSmallestPalindromeHelper(num : Long) : Long = {\n            if (isPalindrome(num)) num\n            else nextSmallestPalindromeHelper(num - 1)\n        }\n        nextSmallestPalindromeHelper(num - 1)\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123059,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp7sdoi41l.scala:17)\n\tat Problem.main(tmp7sdoi41l.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val str = num.toString\n        val len = str.length\n        val half = len / 2\n        val left = str.substring(0, half)\n        val right = str.substring(half + len % 2)\n        val leftRev = left.reverse\n        val leftInt = left.toLong\n        val leftRevInt = leftRev.toLong\n        val rightInt = right.toLong\n        val leftRevIntPlusOne = leftRevInt + 1\n        val leftRevPlusOne = leftRevIntPlusOne.toString\n        val leftRevPlusOneLen = leftRevPlusOne.length\n        val leftRevPlusOneRev = leftRevPlusOne.reverse\n        val leftRevPlusOneRevInt = leftRevPlusOneRev.toLong\n        if (leftRevIntPlusOne == rightInt) {\n            val leftPlusOne = (leftInt + 1).toString\n            val leftPlusOneLen = leftPlusOne.length\n            val leftPlusOneRev = leftPlusOne.reverse\n            val leftPlusOneRevInt = leftPlusOneRev.toLong\n            val leftPlusOneRevIntPlusOne = leftPlusOneRevInt + 1\n            val leftPlusOneRevPlusOne = leftPlusOneRevIntPlusOne.toString\n            val leftPlusOneRevPlusOneLen = leftPlusOneRevPlusOne.length\n            val leftPlusOneRevPlusOneRev = leftPlusOneRevPlusOne.reverse\n            val leftPlusOneRevPlusOneRevInt = leftPlusOneRevPlusOneRev.toLong\n            if (leftPlusOneLen == leftRevPlusOneLen) {\n                val leftPlusOneRevPlusOneRevIntStr = leftPlusOneRevPlusOneRevInt.toString\n                val leftPlusOneRevPlusOneRevIntStrLen = leftPlusOneRevPlusOneRevIntStr.length\n                val leftPlusOneRevPlusOneRevIntStrHalf = leftPlusOneRevPlusOneRevIntStrLen / 2\n                val leftPlusOneRevPlusOneRevIntStrLeft = leftPlusOneRevPlusOneRevIntStr.substring(0, leftPlusOneRevPlusOneRevIntStrHalf)\n                val leftPlusOneRevPlusOneRevIntStrRight = leftPlusOneRevPlusOneRevIntStr.substring(leftPlusOneRevPlusOneRevIntStrHalf +\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123057,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpm2diimaj.scala:35:135 --------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mleftPlusOneRevPlusOneRevIntStrRight\u001b[0m = leftPlusOneRevPlusOneRevIntStr.substring(leftPlusOneRevPlusOneRevIntStrHalf +\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm2diimaj.scala:44:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpm2diimaj.scala:37:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m37 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val digits = num.toString.toList.map(_.toString.toInt)\n        val n = digits.length\n        val half = digits.slice(0, n / 2)\n        val halfRev = half.reverse\n        val halfRevStr = halfRev.mkString\n        val halfStr = half.mkString\n        val halfRevInt = halfRevStr.toInt\n        val halfInt = halfStr.toInt\n        val halfRevIntPlusOne = halfRevInt + 1\n        val halfRevIntPlusOneStr = halfRevIntPlusOne.toString\n        val halfRevIntPlusOneStrRev = halfRevIntPlusOneStr.reverse\n        val halfRevIntPlusOneStrRevInt = halfRevIntPlusOneStrRev.toInt\n        val halfRevIntPlusOneStrInt = halfRevIntPlusOneStr.toInt\n        val halfRevIntPlusOneStrRevIntPlusOne = halfRevIntPlusOneStrRevInt + 1\n        val halfRevIntPlusOneStrRevIntPlusOneStr = halfRevIntPlusOneStrRevIntPlusOne.toString\n        val halfRevIntPlusOneStrRevIntPlusOneStrRev = halfRevIntPlusOneStrRevIntPlusOneStr.reverse\n        val halfRevIntPlusOneStrRevIntPlusOneStrRevInt = halfRevIntPlusOneStrRevIntPlusOneStrRev.toInt\n        val halfRevIntPlusOneStrRevIntPlusOneStrInt = halfRevIntPlusOneStrRevIntPlusOneStr.toInt\n        val halfRevIntPlusOneStrRevIntPlusOneStrRevIntPlusOne = halfRevIntPlusOneStrRevIntPlusOneStrRevInt + 1\n        val halfRevIntPlusOneStrRevIntPlusOneStrRevIntPlusOneStr = halfRevIntPlusOneStrRevIntPlusOneStrRevIntPlusOne.toString\n        val halfRevIntPlusOneStrRevIntPlusOneStrRevIntPlusOneStrRev = halfRevIntPlusOneStrRevIntPlusOneStrRevIntPlusOneStr.reverse\n        val halfRevIntPlusOneStrRevIntPlusOneStrRevIntPlusOneStrRevInt = halfRevIntPlusOneStrRevIntPlusOneStrRevIntPlusOneStrRev.toInt\n        val halfRevIntPlusOneStrRevIntPlusOneStrRevIntPlusOneStrInt = halfRev\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123059,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpz5f3mfwm.scala:29:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var i = 0\n        while (n > 0) {\n            n /= 10\n            i += 1\n        }\n        var j = 0\n        var k = i - 1\n        var flag = true\n        while (j < k) {\n            val d1 = (num / pow(10, j).toLong) % 10\n            val d2 = (num / pow(10, k).toLong) % 10\n            if (d1 != d2) {\n                flag = false\n                break\n            }\n            j += 1\n            k -= 1\n        }\n        if (flag) {\n            val d = (num / pow(10, j).toLong) % 10\n            if (d == 9) {\n                var m = num\n                var l = 0\n                while (l < j) {\n                    m += pow(10, l).toLong\n                    l += 1\n                }\n                return m\n            }\n            else return num + 2 * pow(10, j).toLong\n        }\n        else {\n            var m = num\n            var l = 0\n            while (l < j) {\n                m += pow(10, l).toLong\n                l += 1\n            }\n            return m\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123057,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpcmbe7xgm.scala:20:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val str = num.toString\n        val len = str.length\n        val half = len / 2\n        val left = str.substring(0, half)\n        val right = str.substring(half + len % 2, len)\n        val leftRev = left.reverse\n        if (leftRev > right) {\n            val leftNum = left.toLong\n            val leftNumNext = leftNum + 1\n            val leftNumNextStr = leftNumNext.toString\n            val leftNumNextStrRev = leftNumNextStr.reverse\n            val leftNumNextStrRevLen = leftNumNextStrRev.length\n            val leftNumNextStrRevLenDiff = leftNumNextStr.length - leftNumNextStrRevLen\n            val leftNumNextStrRevPadded = leftNumNextStrRev + \"0\" * leftNumNextStrRevLenDiff\n            val leftNumNextStrRevPaddedLen = leftNumNextStrRevPadded.length\n            val leftNumNextStrRevPaddedHalf = leftNumNextStrRevPaddedLen / 2\n            val leftNumNextStrRevPaddedLeft = leftNumNextStrRevPadded.substring(0, leftNumNextStrRevPaddedHalf)\n            val leftNumNextStrRevPaddedRight = leftNumNextStrRevPadded.substring(leftNumNextStrRevPaddedHalf + leftNumNextStrRevPaddedLen % 2, leftNumNextStrRevPaddedLen)\n            val leftNumNextStrRevPaddedLeftNum = leftNumNextStrRevPaddedLeft.toLong\n            val leftNumNextStrRevPaddedRightNum = leftNumNextStrRevPaddedRight.toLong\n            val leftNumNextStrRevPaddedLeftNumNext = leftNumNextStrRevPaddedLeftNum + 1\n            val leftNumNextStrRevPaddedLeftNumNextStr = leftNumNextStrRevPaddedLeftNumNext.toString\n            val leftNumNextStrRevPaddedLeftNumNextStrRev = leftNumNextStrRevPaddedLeftNumNextStr.reverse\n            val leftNumNextStrRevPaddedLeftNumNextStrRevLen = leftNumNextStrRevPaddedLeftNumNextStrRev.length\n            val leftNumNextStrRevPaddedLeftNumNextStrRevLenDiff = leftNumNextStrRevPaddedLeftNum\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123060,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpr4m9q9kg.scala:39:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpr4m9q9kg.scala:38:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpr4m9q9kg.scala:32:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m32 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        def isPalindrome(num : Long) : Boolean = {\n            val str = num.toString\n            str == str.reverse\n        }\n        def nextPalindrome(num : Long) : Long = {\n            if (isPalindrome(num)) num\n            else nextPalindrome(num + 1)\n        }\n        nextPalindrome(num + 1)\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1665517291,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var digits = new ArrayBuffer[Int]()\n        while (n > 0) {\n            digits += (n % 10).toInt\n            n /= 10\n        }\n        var i = 0\n        while (i < digits.length / 2) {\n            if (digits(i) > digits(digits.length - i - 1)) {\n                digits(digits.length - i - 1) = digits(i)\n            } else if (digits(i) < digits(digits.length - i - 1)) {\n                digits(digits.length - i - 1) = digits(i)\n                var j = digits.length - i - 2\n                while (j >= 0 && digits(j) == 9) {\n                    digits(j) = 0\n                    j -= 1\n                }\n                if (j == -1) {\n                    digits += 0\n                    digits(0) = 1\n                } else {\n                    digits(j) += 1\n                }\n            }\n            i += 1\n        }\n        var result = 0L\n        for (i <- 0 until digits.length) {\n            result = result * 10 + digits(i)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123060,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpc_g0g0yo.scala:39)\n\tat Problem.main(tmpc_g0g0yo.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val digits = num.toString.toList.map(_.asDigit)\n        val len = digits.length\n        val half = len / 2\n        val left = digits.take(half)\n        val right = digits.takeRight(half).reverse\n        val leftInc = left.reverse.scanLeft(0)((a, b) => if (a == 9) 0 else b + 1).reverse\n        val leftDec = left.reverse.scanLeft(0)((a, b) => if (a == 0) 9 else b - 1).reverse\n        val rightInc = right.scanLeft(0)((a, b) => if (a == 9) 0 else b + 1).tail\n        val rightDec = right.scanLeft(0)((a, b) => if (a == 0) 9 else b - 1).tail\n        val inc = leftInc.zip(rightInc).map(x => x._1 + x._2)\n        val dec = leftDec.zip(rightDec).map(x => x._1 + x._2)\n        val incPalindrome = (leftInc ++ inc ++ rightInc.reverse).mkString.toLong\n        val decPalindrome = (leftDec ++ dec ++ rightDec.reverse).mkString.toLong\n        val incDiff = abs(incPalindrome - num)\n        val decDiff = abs(decPalindrome - num)\n        if (incDiff < decDiff) incPalindrome else decPalindrome\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123060,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp8ymdweu9.scala:24)\n\tat Problem.main(tmp8ymdweu9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        def isPalindrome(num : Long) : Boolean = {\n            val s = num.toString\n            s == s.reverse\n        }\n        def nextPalindrome(num : Long) : Long = {\n            if (isPalindrome(num)) num\n            else nextPalindrome(num + 1)\n        }\n        nextPalindrome(num)\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123060,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpce544jk1.scala:17)\n\tat Problem.main(tmpce544jk1.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val n = s.length\n        val half = n / 2\n        val left = s.substring(0, half)\n        val right = s.substring(half + n % 2, n)\n        val leftRev = left.reverse\n        val leftRevNum = leftRev.toLong\n        val leftNum = left.toLong\n        val rightNum = right.toLong\n        if (leftRevNum < rightNum) {\n            val leftInc = (leftNum + 1).toString\n            val leftIncRev = leftInc.reverse\n            val leftIncRevNum = leftIncRev.toLong\n            val leftIncNum = leftInc.toLong\n            if (leftIncRevNum < rightNum) {\n                val leftIncRevStr = leftIncRevNum.toString\n                val leftIncStr = leftIncNum.toString\n                val leftIncStrLen = leftIncStr.length\n                val leftIncRevStrLen = leftIncRevStr.length\n                val leftIncStrPad = \"0\" * (leftIncRevStrLen - leftIncStrLen)\n                val leftIncStrPadRev = \"0\" * (leftIncStrLen - leftIncRevStrLen)\n                val leftIncStrPadRevNum = leftIncStrPadRev.toLong\n                val leftIncStrPadNum = leftIncStrPad.toLong\n                val leftIncStrPadRevNumStr = leftIncStrPadRevNum.toString\n                val leftIncStrPadNumStr = leftIncStrPadNum.toString\n                val leftIncStrPadRevNumStrLen = leftIncStrPadRevNumStr.length\n                val leftIncStrPadNumStrLen = leftIncStrPadNumStr.length\n                val leftIncStrPadRevNumStrPad = \"0\" * (leftIncStrPadNumStrLen - leftIncStrPadRevNumStrLen)\n                val leftIncStrPadNumStrPad = \"0\" * (leftIncStrPadRevNumStrLen - leftIncStrPadNumStrLen)\n                val leftIncStrPadRevNumStrPadNum = leftIncStrPadRevNumStrPad.toLong\n                val leftIncStrPadNumStrPadNum = leftIncStrPadNumStrPad.toLong\n                val leftIncStrPadRev\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123056,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp66cdeksa.scala:38:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp66cdeksa.scala:46:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[33m\u001b[33m-- Warning: /tmp/tmp66cdeksa.scala:39:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m39 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val n = s.length\n        val half = n / 2\n        val (left, right) = s.splitAt(half)\n        val leftRev = left.reverse\n        val leftRevInt = leftRev.toInt\n        val leftInt = left.toInt\n        val rightInt = right.toInt\n        if (leftRevInt > rightInt) {\n            val leftRevStr = leftRevInt.toString\n            val leftRevStrRev = leftRevStr.reverse\n            val leftRevStrRevInt = leftRevStrRev.toInt\n            val leftRevStrRevIntStr = leftRevStrRevInt.toString\n            val leftRevStrRevIntStrRev = leftRevStrRevIntStr.reverse\n            val leftRevStrRevIntStrRevInt = leftRevStrRevIntStrRev.toInt\n            val leftRevStrRevIntStrRevIntStr = leftRevStrRevIntStrRevInt.toString\n            val leftRevStrRevIntStrRevIntStrRev = leftRevStrRevIntStrRevIntStr.reverse\n            val leftRevStrRevIntStrRevIntStrRevInt = leftRevStrRevIntStrRevIntStrRev.toInt\n            val leftRevStrRevIntStrRevIntStrRevIntStr = leftRevStrRevIntStrRevIntStrRevInt.toString\n            val leftRevStrRevIntStrRevIntStrRevIntStrRev = leftRevStrRevIntStrRevIntStrRevIntStr.reverse\n            val leftRevStrRevIntStrRevIntStrRevIntStrRevInt = leftRevStrRevIntStrRevIntStrRevIntStrRev.toInt\n            val leftRevStrRevIntStrRevIntStrRevIntStrRevIntStr = leftRevStrRevIntStrRevIntStrRevIntStrRevInt.toString\n            val leftRevStrRevIntStrRevIntStrRevIntStrRevIntStrRev = leftRevStrRevIntStrRevIntStrRevIntStrRevIntStr.reverse\n            val leftRevStrRevIntStrRevIntStrRevIntStrRevIntStrRevInt = leftRevStrRevIntStrRevIntStrRevIntStrRevIntStrRev.toInt\n            val leftRevStrRevIntStrRevIntStrRevIntStrRevIntStrRevIntStr = leftRevStrRevIntStrRevIntStrRev\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123060,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpft53n_et.scala:39:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpft53n_et.scala:38:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpft53n_et.scala:32:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m32 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val n = s.length\n        val half = n / 2\n        val left = s.substring(0, half)\n        val right = s.substring(half + (n % 2), n)\n        val leftRev = left.reverse\n        val leftNum = left.toLong\n        val leftRevNum = leftRev.toLong\n        val rightNum = right.toLong\n        if (leftRevNum < rightNum) {\n            val newLeft = (leftNum + 1).toString\n            val newLeftRev = newLeft.reverse\n            val newLeftRevNum = newLeftRev.toLong\n            val newRight = newLeftRevNum.toString\n            val newRightNum = newRight.toLong\n            if (newRightNum < rightNum) {\n                val newRightNum = newRight.toLong\n                val newLeftNum = newLeft.toLong\n                val newLeftRevNum = newLeftRev.toLong\n                val newRight = newLeftRevNum.toString\n                val newLeft = newLeftNum.toString\n                val newLeftRev = newLeft.reverse\n                val newLeftRevNum = newLeftRev.toLong\n                val newRightNum = newRight.toLong\n                val newRight = newRightNum.toString\n                val newLeft = newLeftNum.toString\n                val newLeftRev = newLeft.reverse\n                val newLeftRevNum = newLeftRev.toLong\n                val newRightNum = newRight.toLong\n                val newRight = newRightNum.toString\n                val newLeft = newLeftNum.toString\n                val newLeftRev = newLeft.reverse\n                val newLeftRevNum = newLeftRev.toLong\n                val newRightNum = newRight.toLong\n                val newRight = newRightNum.toString\n                val newLeft = newLeftNum.toString\n                val newLeftRev = newLeft.reverse\n                val newLeftRevNum = newLeftRev.toLong\n                val newRightNum = newRight.toLong\n                val newRight = newRightNum.toString\n                val newLeft = newLeftNum.toString\n                val newLeftRev = newLeft.reverse\n                val newLeftRevNum\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123056,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp6mvypwk6.scala:49:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp6mvypwk6.scala:57:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp6mvypwk6.scala:28:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mnewLeftRevNum\u001b[0m = newLeftRev.toLong\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnewLeftRevNum is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnewLeftRevNum\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp6mvypwk6.scala:29:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mnewRightNum\u001b[0m = newRight.toLong\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnewRightNum is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnewRightNum\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp6mvypwk6.scala:30:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mnewRight\u001b[0m = newRightNum.toString\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnewRight is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnewRight\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp6mvypwk6.scala:31:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mnewLeft\u001b[0m = newLeftNum.toString\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnewLeft is already defined as \u001b[33mvalue\u001b[0m ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        def isPalindrome(num : Long) : Boolean = {\n            val str = num.toString\n            str == str.reverse\n        }\n        var i = num\n        while (true) {\n            i += 1\n            if (isPalindrome(i)) return i\n        }\n        return -1\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123059,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val digits = num.toString.toList.map(_.toString.toInt)\n        val n = digits.length\n        val half = n / 2\n        val left = digits.take(half)\n        val right = digits.takeRight(half)\n        val leftReverse = left.reverse\n        val rightReverse = right.reverse\n        if (left.mkString.toLong < rightReverse.mkString.toLong) {\n            val result = (left.mkString + leftReverse.mkString).toLong\n            if (result >= num) result else nextSmallestPalindrome(result)\n        } else {\n            val leftReversePlusOne = (leftReverse.mkString.toLong + 1).toString.toList.map(_.toString.toInt)\n            val result = (leftReversePlusOne.mkString + leftReversePlusOne.reverse.mkString).toLong\n            if (result >= num) result else nextSmallestPalindrome(result)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123060,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpzf5a81nq.scala:23)\n\tat Problem.main(tmpzf5a81nq.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        if (num < 0) throw new IllegalArgumentException\n        if (num < 10) return num + 1\n        val s = num.toString\n        val n = s.length\n        val half = n / 2\n        val left = s.substring(0, half)\n        val right = s.substring(half + n % 2)\n        val leftNum = left.toLong\n        val rightNum = right.toLong\n        val leftRev = left.reverse\n        val rightRev = right.reverse\n        if (leftNum == rightRev && leftRev == rightNum) {\n            val nextLeft = (leftNum + 1).toString\n            val nextRight = nextLeft.reverse\n            val nextLeftLen = nextLeft.length\n            val nextRightLen = nextRight.length\n            val nextLeftPad = \"0\" * (half - nextLeftLen)\n            val nextRightPad = \"0\" * (half - nextRightLen)\n            (nextLeftPad + nextLeft + nextRightPad + nextRight).toLong\n        } else if (leftNum < rightRev) {\n            val nextLeft = left\n            val nextRight = nextLeft.reverse\n            val nextLeftLen = nextLeft.length\n            val nextRightLen = nextRight.length\n            val nextLeftPad = \"0\" * (half - nextLeftLen)\n            val nextRightPad = \"0\" * (half - nextRightLen)\n            (nextLeftPad + nextLeft + nextRightPad + nextRight).toLong\n        } else {\n            val nextLeft = (leftNum + 1).toString\n            val nextRight = nextLeft.reverse\n            val nextLeftLen = nextLeft.length\n            val nextRightLen = nextRight.length\n            val nextLeftPad = \"0\" * (half - nextLeftLen)\n            val nextRightPad = \"0\" * (half - nextRightLen)\n            (nextLeftPad + nextLeft + nextRightPad + nextRight).toLong\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123060,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpr1ikh30t.scala:17:12 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mif\u001b[0m (leftNum == rightRev && leftRev == rightNum) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types Long and String cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmpr1ikh30t.scala:17:35 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mif\u001b[0m (leftNum == rightRev && leftRev == rightNum) {\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Long cannot be compared with == or !=\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpr1ikh30t.scala:25:27 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (leftNum < rightRev) {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m<\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mLong\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Boolean\n\u001b[31m   |\u001b[0m (x: Float): Boolean\n\u001b[31m   |\u001b[0m (x: Long): Boolean\n\u001b[31m   |\u001b[0m (x: Int): Boolean\n\u001b[31m   |\u001b[0m (x: Char): Boolean\n\u001b[31m   |\u001b[0m (x: Short): Boolean\n\u001b[31m   |\u001b[0m (x: Byte): Boolean\n\u001b[31m   |\u001b[0mmatch arguments ((rightRev : String))\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        def isPalindrome(num : Long) : Boolean = {\n            val str = num.toString\n            str == str.reverse\n        }\n        def nextPalindrome(num : Long) : Long = {\n            val str = num.toString\n            val len = str.length\n            val half = len / 2\n            val left = str.substring(0, half)\n            val right = str.substring(half + len % 2)\n            val leftNum = left.toLong\n            val rightNum = right.toLong\n            if (leftNum == rightNum) {\n                val nextLeft = (leftNum + 1).toString\n                val nextRight = nextLeft.reverse\n                val nextLeftLen = nextLeft.length\n                val nextRightLen = nextRight.length\n                val nextLeftPad = if (nextLeftLen < half) \"0\" * (half - nextLeftLen) else \"\"\n                val nextRightPad = if (nextRightLen < half) \"0\" * (half - nextRightLen) else \"\"\n                (nextLeftPad + nextLeft + nextRightPad + nextRight).toLong\n            } else if (leftNum > rightNum) {\n                val nextRight = left.reverse\n                val nextRightLen = nextRight.length\n                val nextRightPad = if (nextRightLen < half) \"0\" * (half - nextRightLen) else \"\"\n                (left + nextRightPad + nextRight).toLong\n            } else {\n                val nextLeft = (leftNum + 1).toString\n                val nextRight = nextLeft.reverse\n                val nextLeftLen = nextLeft.length\n                val nextRightLen = nextRight.length\n                val nextLeftPad = if (nextLeftLen < half) \"0\" * (half - nextLeftLen) else \"\"\n                val nextRightPad = if (nextRightLen < half) \"0\" * (half - nextRightLen) else \"\"\n                (nextLeftPad + nextLeft + nextRightPad + nextRight).toLong\n            }\n        }\n        if (isPalindrome(num)) num else nextPalindrome(num)\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123060,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpfae3g6kc.scala:44)\n\tat Problem.main(tmpfae3g6kc.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var i = 0\n        while (i < 100) {\n            n += 1\n            if (isPalindrome(n)) return n\n            i += 1\n        }\n        return -1\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123057,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpil8ny6sr.scala:10:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m            \u001b[33mif\u001b[0m (isPalindrome(n)) \u001b[33mreturn\u001b[0m n\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPalindrome\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val n = s.length\n        val mid = n / 2\n        var i = mid - 1\n        var j = if (n % 2 == 0) mid else mid + 1\n        var leftSmaller = false\n        while (i >= 0 && s(i) == s(j)) {\n            i -= 1\n            j += 1\n        }\n        if (i < 0 || s(i) < s(j)) leftSmaller = true\n        while (i >= 0) {\n            s(j) = s(i)\n            i -= 1\n            j += 1\n        }\n        var carry = 0\n        if (leftSmaller) {\n            carry = 1\n            i = mid - 1\n            if (n % 2 == 1) {\n                s(mid) += 1\n                carry = s(mid) / 10\n                s(mid) %= 10\n            }\n            j = if (n % 2 == 0) mid else mid + 1\n            while (i >= 0) {\n                s(i) += carry\n                carry = s(i) / 10\n                s(i) %= 10\n                s(j) = s(i)\n                i -= 1\n                j += 1\n            }\n        }\n        s.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123068,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpq0z26zub.scala:18:12 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            s(j) = s(i)\n\u001b[31m\u001b[31m   |\u001b[0m            ^\u001b[0m\n\u001b[31m   |\u001b[0m            value update is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpq0z26zub.scala:27:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                s(mid) += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Char - did you mean Char.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpq0z26zub.scala:29:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                s(mid) %= \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value %= is not a member of Char - did you mean Char.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpq0z26zub.scala:33:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                s(i) += carry\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Char - did you mean Char.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpq0z26zub.scala:35:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                s(i) %= \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value %= is not a member of Char - did you mean Char.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpq0z26zub.scala:36:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                s(j) = s(i)\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                value update is not a member of String\n6 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val n = s.length\n        val half = n / 2\n        val left = s.substring(0, half)\n        val right = s.substring(half + n % 2)\n        val leftRev = left.reverse\n        val leftNum = left.toLong\n        val leftRevNum = leftRev.toLong\n        if (leftNum < leftRevNum) {\n            val leftNumPlusOne = leftNum + 1\n            val leftNumPlusOneStr = leftNumPlusOne.toString\n            val leftNumPlusOneStrRev = leftNumPlusOneStr.reverse\n            val leftNumPlusOneStrRevStr = leftNumPlusOneStr + leftNumPlusOneStrRev\n            if (n % 2 == 1) leftNumPlusOneStrRevStr + leftNumPlusOneStr else leftNumPlusOneStrRevStr\n        } else {\n            val leftNumStr = leftNum.toString\n            val leftNumStrRev = leftNumStr.reverse\n            val leftNumStrRevStr = leftNumStr + leftNumStrRev\n            if (n % 2 == 1) leftNumStrRevStr + leftNumStr else leftNumStrRevStr\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123067,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpitslkfk1.scala:19:28 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mif\u001b[0m (n % \u001b[31m2\u001b[0m == \u001b[31m1\u001b[0m) leftNumPlusOneStrRevStr + leftNumPlusOneStr \u001b[33melse\u001b[0m leftNumPlusOneStrRevStr\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    String\n\u001b[31m   |\u001b[0m                            Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpitslkfk1.scala:19:77 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mif\u001b[0m (n % \u001b[31m2\u001b[0m == \u001b[31m1\u001b[0m) leftNumPlusOneStrRevStr + leftNumPlusOneStr \u001b[33melse\u001b[0m leftNumPlusOneStrRevStr\n\u001b[31m\u001b[31m   |\u001b[0m                                                                             ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (leftNumPlusOneStrRevStr : String)\n\u001b[31m   |\u001b[0m                            Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpitslkfk1.scala:24:28 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mif\u001b[0m (n % \u001b[31m2\u001b[0m == \u001b[31m1\u001b[0m) leftNumStrRevStr + leftNumStr \u001b[33melse\u001b[0m leftNumStrRevStr\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    String\n\u001b[31m   |\u001b[0m                            Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpitslkfk1.scala:24:63 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mif\u001b[0m (n % \u001b[31m2\u001b[0m == \u001b[31m1\u001b[0m) leftNumStrRevStr + leftNumStr \u001b[33melse\u001b[0m leftNumStrRevStr\n\u001b[31m\u001b[31m   |\u001b[0m                                                               ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Found:    (le",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        def isPalindrome(num : Long) : Boolean = {\n            val str = num.toString\n            str == str.reverse\n        }\n        def nextPalindrome(num : Long) : Long = {\n            var n = num\n            while (!isPalindrome(n)) n += 1\n            n\n        }\n        nextPalindrome(num + 1)\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123067,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var i = 0\n        while (true) {\n            if (isPalindrome(n)) return n\n            n = num - i\n            i += 1\n        }\n        return -1\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123062,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6bb_b7ra.scala:9:16 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m            \u001b[33mif\u001b[0m (isPalindrome(n)) \u001b[33mreturn\u001b[0m n\n\u001b[31m\u001b[31m  |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                Not found: isPalindrome\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val n = s.length\n        val half = n / 2\n        val left = s.substring(0, half)\n        val right = s.substring(half + (if (n % 2 == 0) 0 else 1), n)\n        val leftRev = left.reverse\n        val leftRevInt = leftRev.toInt\n        val leftInt = left.toInt\n        val rightInt = right.toInt\n        if (leftRevInt > rightInt) {\n            val leftRevStr = leftRevInt.toString\n            val leftRevStrRev = leftRevStr.reverse\n            val leftRevStrRevInt = leftRevStrRev.toInt\n            val leftRevStrInt = leftRevStr.toInt\n            if (leftRevStrInt > leftRevStrRevInt) {\n                val leftRevStrRevStr = leftRevStrRevInt.toString\n                val leftRevStrRevStrRev = leftRevStrRevStr.reverse\n                val leftRevStrRevStrRevInt = leftRevStrRevStrRev.toInt\n                val leftRevStrRevStrInt = leftRevStrRevStr.toInt\n                if (leftRevStrRevStrInt > leftRevStrRevStrRevInt) {\n                    val leftRevStrRevStrRevStr = leftRevStrRevStrRevInt.toString\n                    val leftRevStrRevStrRevStrRev = leftRevStrRevStrRevStr.reverse\n                    val leftRevStrRevStrRevStrRevInt = leftRevStrRevStrRevStrRev.toInt\n                    val leftRevStrRevStrRevStrInt = leftRevStrRevStrRevStr.toInt\n                    if (leftRevStrRevStrRevStrInt > leftRevStrRevStrRevStrRevInt) {\n                        val leftRevStrRevStrRevStrRevStr = leftRevStrRevStrRevStrRevInt.toString\n                        val leftRevStrRevStrRevStrRevStrRev = leftRevStrRevStrRevStrRevStr.reverse\n                        val leftRevStrRevStrRevStrRevStrRevInt = leftRevStrRevStrRevStrRevStrRev.toInt\n                        val leftRevStrRevStrRevStrRevStrInt = leftRevStrRevStrRevStrRevStr.toInt\n                        if (leftRevStrRevStrRevStrRevStr\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123066,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpyzigqbu0.scala:36:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpyzigqbu0.scala:44:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpyzigqbu0.scala:35:28 --------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                        \u001b[33mif\u001b[0m (leftRevStrRevStrRevStrRevStr\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (leftRevStrRevStrRevStrRevStr : String)\n\u001b[31m   |\u001b[0m                       Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpyzigqbu0.scala:37:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m37 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val digits = num.toString.toList.map(_.asDigit)\n        val n = digits.length\n        val half = n / 2\n        val left = digits.slice(0, half)\n        val right = digits.slice(half + (n % 2), n)\n        val nextLeft = if (left.mkString.toLong < right.reverse.mkString.toLong) left else left.reverse.map(_ + 1).map(_ % 10)\n        val nextRight = nextLeft.reverse\n        (nextLeft ++ (if (n % 2 == 1) digits(half) else Nil) ++ nextRight).mkString.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123069,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp00l1vl5l.scala:13:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        (nextLeft ++ (\u001b[33mif\u001b[0m (n % \u001b[31m2\u001b[0m == \u001b[31m1\u001b[0m) digits(half) \u001b[33melse\u001b[0m Nil) ++ nextRight).mkString.toLong\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Found:    Int\n\u001b[31m   |\u001b[0m                                      Required: IterableOnce[Int]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val str = num.toString\n        val len = str.length\n        val half = len / 2\n        val left = str.substring(0, half)\n        val right = str.substring(half + len % 2, len)\n        val leftNum = left.toLong\n        val rightNum = right.toLong\n        val leftNumRev = left.reverse.toLong\n        val rightNumRev = right.reverse.toLong\n        if (leftNum == rightNumRev) {\n            val nextLeft = (leftNum + 1).toString\n            val nextLeftRev = nextLeft.reverse\n            val nextLeftRevLen = nextLeftRev.length\n            val nextRight = if (nextLeftRevLen > half) nextLeftRev.substring(0, half) else nextLeftRev\n            val nextRightRev = nextRight.reverse\n            val nextRightRevLen = nextRightRev.length\n            val nextLeftRevLenDiff = nextLeftRevLen - nextRightRevLen\n            val nextLeftRevLenDiffHalf = nextLeftRevLenDiff / 2\n            val nextLeftRevLenDiffHalfRem = nextLeftRevLenDiff % 2\n            val nextLeftRevLenDiffHalfRemHalf = nextLeftRevLenDiffHalfRem / 2\n            val nextLeftRevLenDiffHalfRemHalfRem = nextLeftRevLenDiffHalfRem % 2\n            val nextLeftRevLenDiffHalfRemHalfRemHalf = nextLeftRevLenDiffHalfRemHalfRem / 2\n            val nextLeftRevLenDiffHalfRemHalfRemHalfRem = nextLeftRevLenDiffHalfRemHalfRem % 2\n            val nextLeftRevLenDiffHalfRemHalfRemHalfRemHalf = nextLeftRevLenDiffHalfRemHalfRemHalfRem / 2\n            val nextLeftRevLenDiffHalfRemHalfRemHalfRemHalfRem = nextLeftRevLenDiffHalfRemHalfRemHalfRem % 2\n            val nextLeftRevLenDiffHalfRemHalfRemHalfRemHalfRemHalf = nextLeftRevLenDiffHalfRemHalfRemHalfRemHalfRem / 2\n            val nextLeftRevLenDiffHalfRemHalfRemHalfRemHalfRemHalfRem = nextLeftRevLenDiffHalfRemHalfRemHalfRemHalfRem % 2\n            val nextLeftRevLenDiffHalfRemHalfRemHalfRemHalfRemHalfRemHalf = nextLeftRevLenDiffHalfRemHalfRemHalfRemHalf\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123070,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpaznnxwo8.scala:42:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpaznnxwo8.scala:41:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpaznnxwo8.scala:35:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m35 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val len = s.length\n        val half = len / 2\n        val left = s.substring(0, half)\n        val right = s.substring(half + len % 2)\n        val leftRev = left.reverse\n        val leftNum = left.toLong\n        val leftRevNum = leftRev.toLong\n        val rightNum = right.toLong\n        if (leftNum == leftRevNum) {\n            if (leftNum == 0) return num + 2\n            else return num + 2 * pow(10, half).toLong\n        }\n        else if (leftNum < leftRevNum) {\n            val newLeft = (leftNum + 1).toString\n            val newLeftRev = newLeft.reverse\n            val newLeftNum = newLeft.toLong\n            val newLeftRevNum = newLeftRev.toLong\n            if (newLeftNum == newLeftRevNum) return newLeftNum * pow(10, len - half).toLong + newLeftRevNum\n            else return newLeftNum * pow(10, len - half).toLong + newLeftRevNum / 10\n        }\n        else {\n            val newLeft = left\n            val newLeftRev = newLeft.reverse\n            val newLeftNum = newLeft.toLong\n            val newLeftRevNum = newLeftRev.toLong\n            if (newLeftNum == newLeftRevNum) return newLeftNum * pow(10, len - half).toLong + newLeftRevNum\n            else return newLeftNum * pow(10, len - half).toLong + newLeftRevNum / 10\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123070,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmprkoorokh.scala:37)\n\tat Problem.main(tmprkoorokh.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        def isPalindrome(num : Long) : Boolean = {\n            val str = num.toString\n            str == str.reverse\n        }\n        def nextPalindrome(num : Long) : Long = {\n            if (isPalindrome(num)) num\n            else nextPalindrome(num + 1)\n        }\n        nextPalindrome(num + 1)\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1665517291,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var i = 0\n        while (n > 0) {\n            n /= 10\n            i += 1\n        }\n        var j = 0\n        while (j < i / 2) {\n            if (num / pow(10, j).toLong % 10 != num / pow(10, i - j - 1).toLong % 10) return -1\n            j += 1\n        }\n        var k = 0\n        while (k < i / 2) {\n            if (num / pow(10, k).toLong % 10 != num / pow(10, i - k - 1).toLong % 10) {\n                if (num / pow(10, k).toLong % 10 > num / pow(10, i - k - 1).toLong % 10) {\n                    var l = k\n                    while (l < i / 2) {\n                        num += (num / pow(10, k).toLong % 10 - num / pow(10, i - k - 1).toLong % 10) * pow(10, i - l - 1).toLong\n                        l += 1\n                    }\n                } else {\n                    var l = k\n                    while (l < i / 2) {\n                        num -= (num / pow(10, i - k - 1).toLong % 10 - num / pow(10, k).toLong % 10) * pow(10, i - l - 1).toLong\n                        l += 1\n                    }\n                }\n                return num\n            }\n            k += 1\n        }\n        return -1\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123070,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp29m1mq_d.scala:23:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                        num += (num / pow(\u001b[31m10\u001b[0m, k).toLong % \u001b[31m10\u001b[0m - num / pow(\u001b[31m10\u001b[0m, i - k - \u001b[31m1\u001b[0m).toLong % \u001b[31m10\u001b[0m) * pow(\u001b[31m10\u001b[0m, i - l - \u001b[31m1\u001b[0m).toLong\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 value += is not a member of Long - did you mean num.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp29m1mq_d.scala:29:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                        num -= (num / pow(\u001b[31m10\u001b[0m, i - k - \u001b[31m1\u001b[0m).toLong % \u001b[31m10\u001b[0m - num / pow(\u001b[31m10\u001b[0m, k).toLong % \u001b[31m10\u001b[0m) * pow(\u001b[31m10\u001b[0m, i - l - \u001b[31m1\u001b[0m).toLong\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 value -= is not a member of Long - did you mean num.!=?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        while (true) {\n            n += 1\n            if (isPalindrome(n)) return n\n        }\n        return -1\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123066,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3skv3vcx.scala:9:16 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m            \u001b[33mif\u001b[0m (isPalindrome(n)) \u001b[33mreturn\u001b[0m n\n\u001b[31m\u001b[31m  |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                Not found: isPalindrome\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val len = s.length\n        val half = len / 2\n        val left = s.substring(0, half)\n        val right = s.substring(half + (len % 2), len)\n        val leftNum = left.toLong\n        val rightNum = right.toLong\n        val leftNumRev = left.reverse.toLong\n        val rightNumRev = right.reverse.toLong\n        if (leftNumRev < rightNum) {\n            val leftNumInc = leftNum + 1\n            val leftNumIncStr = leftNumInc.toString\n            val leftNumIncStrRev = leftNumIncStr.reverse\n            val leftNumIncStrRevLen = leftNumIncStrRev.length\n            val leftNumIncStrLen = leftNumIncStr.length\n            val leftNumIncStrRevLenDiff = leftNumIncStrLen - leftNumIncStrRevLen\n            val leftNumIncStrRevLenDiffStr = \"0\" * leftNumIncStrRevLenDiff\n            val leftNumIncStrRevLenDiffStrRev = leftNumIncStrRevLenDiffStr.reverse\n            val leftNumIncStrRevLenDiffStrRevLen = leftNumIncStrRevLenDiffStrRev.length\n            val leftNumIncStrRevLenDiffStrRevLenDiff = leftNumIncStrLen - leftNumIncStrRevLenDiffStrRevLen\n            val leftNumIncStrRevLenDiffStrRevLenDiffStr = \"0\" * leftNumIncStrRevLenDiffStrRevLenDiff\n            val leftNumIncStrRevLenDiffStrRevLenDiffStrRev = leftNumIncStrRevLenDiffStrRevLenDiffStr.reverse\n            val leftNumIncStrRevLenDiffStrRevLenDiffStrRevLen = leftNumIncStrRevLenDiffStrRevLenDiffStrRev.length\n            val leftNumIncStrRevLenDiffStrRevLenDiffStrRevLenDiff = leftNumIncStrLen - leftNumIncStrRevLenDiffStrRevLenDiffStrRevLen\n            val leftNumIncStrRevLenDiffStrRevLenDiffStrRevLenDiffStr = \"0\" * leftNumIncStrRevLenDiffStrRevLenDiffStrRevLenDiff\n            val leftNumIncStrRevLenDiffStrRevLenDiffStrRevLenDiffStrRev = leftNumIncStrRev\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123071,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp0yqkbmqg.scala:40:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0yqkbmqg.scala:39:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmp0yqkbmqg.scala:33:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m33 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val digits = num.toString.toList.map(_.asDigit)\n        val n = digits.length\n        val half = n / 2\n        val left = digits.take(half)\n        val right = digits.drop(half + n % 2)\n        val leftMirror = left.reverse\n        val leftMirrorNum = leftMirror.foldLeft(0)((acc, x) => acc * 10 + x)\n        val leftNum = left.foldLeft(0)((acc, x) => acc * 10 + x)\n        val rightNum = right.foldLeft(0)((acc, x) => acc * 10 + x)\n        if (leftMirrorNum >= rightNum) {\n            val newLeft = (leftNum + 1).toString.toList.map(_.asDigit)\n            val newLeftMirror = newLeft.reverse\n            val newLeftMirrorNum = newLeftMirror.foldLeft(0)((acc, x) => acc * 10 + x)\n            val newLeftNum = newLeft.foldLeft(0)((acc, x) => acc * 10 + x)\n            val newRightNum = newLeftMirrorNum - newLeftNum\n            val newRight = newRightNum.toString.toList.map(_.asDigit)\n            val newDigits = newLeft ++ newRight\n            newDigits.foldLeft(0)((acc, x) => acc * 10 + x)\n        } else {\n            val newRight = (rightNum + 1).toString.toList.map(_.asDigit)\n            val newRightNum = newRight.foldLeft(0)((acc, x) => acc * 10 + x)\n            val newLeftNum = leftMirrorNum - newRightNum\n            val newLeft = newLeftNum.toString.toList.map(_.asDigit)\n            val newDigits = newLeft ++ newRight\n            newDigits.foldLeft(0)((acc, x) => acc * 10 + x)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123071,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpf_q65bav.scala:34)\n\tat Problem.main(tmpf_q65bav.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val str = num.toString\n        val len = str.length\n        val half = len / 2\n        val left = str.substring(0, half)\n        val right = str.substring(half + len % 2)\n        val next = (left.toLong + 1).toString\n        val nextPalindrome = next + next.reverse.substring(0, half)\n        if (nextPalindrome.length > len) nextPalindrome.substring(1).toLong\n        else nextPalindrome.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123071,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp_uts47m2.scala:17)\n\tat Problem.main(tmp_uts47m2.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val str = num.toString\n        val len = str.length\n        val half = len / 2\n        val left = str.substring(0, half)\n        val right = str.substring(half + len % 2)\n        val leftRev = left.reverse\n        val leftInt = left.toInt\n        val leftRevInt = leftRev.toInt\n        val rightInt = right.toInt\n        if (leftInt == leftRevInt) {\n            if (leftInt == 0) return num + 2\n            else {\n                val nextLeft = (leftInt + 1).toString\n                val nextLeftRev = nextLeft.reverse\n                val nextLeftRevInt = nextLeftRev.toInt\n                if (nextLeftRevInt < rightInt) return (nextLeft + right).toLong\n                else return (nextLeft + nextLeftRev).toLong\n            }\n        }\n        else {\n            if (leftInt < leftRevInt) return (left + leftRev).toLong\n            else {\n                val nextLeft = (leftInt + 1).toString\n                val nextLeftRev = nextLeft.reverse\n                return (nextLeft + nextLeftRev).toLong\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123071,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpup0mtw5k.scala:35)\n\tat Problem.main(tmpup0mtw5k.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var digits = List[Int]()\n        while (n > 0) {\n            digits = (n % 10).toInt :: digits\n            n /= 10\n        }\n        var i = 0\n        while (i < digits.length / 2) {\n            if (digits(i) < digits(digits.length - 1 - i)) {\n                digits(digits.length - 1 - i) = digits(i)\n            }\n            else if (digits(i) > digits(digits.length - 1 - i)) {\n                digits(digits.length - 1 - i) = digits(i)\n                var j = digits.length - 2 - i\n                while (j >= 0 && digits(j) == 9) {\n                    digits(j) = 0\n                    j -= 1\n                }\n                if (j >= 0) digits(j) += 1\n                else digits = 1 :: digits\n            }\n            i += 1\n        }\n        var result = 0L\n        for (i <- 0 until digits.length) result = result * 10 + digits(i)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123071,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkv41b82y.scala:15:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m                digits(digits.length - \u001b[31m1\u001b[0m - i) = digits(i)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue update is not a member of List[Int] - did you mean List[Int].updated?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkv41b82y.scala:18:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                digits(digits.length - \u001b[31m1\u001b[0m - i) = digits(i)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue update is not a member of List[Int] - did you mean List[Int].updated?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkv41b82y.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                    digits(j) = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue update is not a member of List[Int] - did you mean List[Int].updated?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkv41b82y.scala:24:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                \u001b[33mif\u001b[0m (j >= \u001b[31m0\u001b[0m) digits(j) += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value += is not a member of Int - did you mean Int.!=?\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val numStr = num.toString\n        val len = numStr.length\n        val halfLen = len / 2\n        val leftHalf = numStr.substring(0, halfLen)\n        val rightHalf = numStr.substring(halfLen + len % 2, len)\n        val leftHalfRev = leftHalf.reverse\n        if (leftHalfRev > rightHalf) {\n            val leftHalfInt = leftHalf.toInt\n            val leftHalfIntInc = leftHalfInt + 1\n            val leftHalfInc = leftHalfIntInc.toString\n            val leftHalfIncLen = leftHalfInc.length\n            val leftHalfIncRev = leftHalfInc.reverse\n            val leftHalfIncRevLen = leftHalfIncRev.length\n            val leftHalfIncRevPadded = leftHalfIncRev.padTo(leftHalfIncLen, '0')\n            val leftHalfIncRevPaddedLen = leftHalfIncRevPadded.length\n            val leftHalfIncRevPaddedSub = leftHalfIncRevPadded.substring(0, halfLen)\n            val leftHalfIncRevPaddedSubLen = leftHalfIncRevPaddedSub.length\n            val leftHalfIncRevPaddedSubRev = leftHalfIncRevPaddedSub.reverse\n            val leftHalfIncRevPaddedSubRevLen = leftHalfIncRevPaddedSubRev.length\n            val leftHalfIncRevPaddedSubRevPadded = leftHalfIncRevPaddedSubRev.padTo(leftHalfIncRevPaddedSubLen, '0')\n            val leftHalfIncRevPaddedSubRevPaddedLen = leftHalfIncRevPaddedSubRevPadded.length\n            val leftHalfIncRevPaddedSubRevPaddedSub = leftHalfIncRevPaddedSubRevPadded.substring(0, halfLen)\n            val leftHalfIncRevPaddedSubRevPaddedSubLen = leftHalfIncRevPaddedSubRevPaddedSub.length\n            val leftHalfIncRevPaddedSubRevPaddedSubRev = leftHalfIncRevPaddedSubRevPaddedSub.reverse\n            val leftHalfIncRevPaddedSubRevPaddedSubRevLen = leftHalfIncRevPaddedSubRevPaddedSubRev.length\n            val leftHalfIncRevPaddedSubRevPaddedSubRevPadded = left\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123070,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpfvc6krxq.scala:40:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfvc6krxq.scala:31:63 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mleftHalfIncRevPaddedSubRevPaddedSubRevPadded\u001b[0m = left\n\u001b[31m\u001b[31m   |\u001b[0m                                                               ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                         Not found: left\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfvc6krxq.scala:39:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpfvc6krxq.scala:33:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m33 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        if (num < 0) return -1\n        if (num < 10) return num + 1\n        val digits = num.toString.toCharArray\n        var i = 0\n        while (i < digits.length / 2) {\n            if (digits(i) != digits(digits.length - 1 - i)) {\n                digits(digits.length - 1 - i) = digits(i)\n                return digits.mkString.toLong\n            }\n            i += 1\n        }\n        var j = digits.length / 2 - 1\n        while (j >= 0) {\n            if (digits(j) != '9') {\n                digits(j) = (digits(j) + 1).toChar\n                digits(digits.length - 1 - j) = digits(j)\n                return digits.mkString.toLong\n            }\n            digits(j) = '0'\n            digits(digits.length - 1 - j) = '0'\n            j -= 1\n        }\n        1 + (num + 1) * 10\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123072,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp8sgtjw95.scala:31)\n\tat Problem.main(tmp8sgtjw95.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var numStr = num.toString\n        var len = numStr.length\n        var left = numStr.substring(0, len / 2)\n        var right = numStr.substring(len / 2 + len % 2, len)\n        var leftRev = left.reverse\n        if (left + leftRev < right) {\n            var leftInt = left.toInt\n            left = (leftInt + 1).toString\n            leftRev = left.reverse\n        }\n        return (left + leftRev).toLong\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123071,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp6tjcim07.scala:19)\n\tat Problem.main(tmp6tjcim07.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var i = 0\n        while (n > 0) {\n            n /= 10\n            i += 1\n        }\n        var j = 0\n        var k = i - 1\n        var l = 0\n        var m = i - 1\n        var isPalindrome = true\n        while (j < k) {\n            l = (num / pow(10, j).toLong) % 10\n            m = (num / pow(10, k).toLong) % 10\n            if (l != m) {\n                isPalindrome = false\n                break\n            }\n            j += 1\n            k -= 1\n        }\n        if (isPalindrome) return num\n        n = num\n        var d = 0\n        var e = 0\n        var f = 0\n        var g = 0\n        var h = 0\n        var isAllNine = true\n        while (n > 0) {\n            d = n % 10\n            if (d != 9) isAllNine = false\n            e = e * 10 + d\n            f = f * 10 + d\n            g = g * 10 + d\n            h = h * 10 + d\n            n /= 10\n        }\n        if (isAllNine) return (f + 1) * pow(10, i - 1).toLong\n        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var aa = 0\n        var bb = 0\n        var cc = 0\n        var dd = 0\n        var ee = 0\n        var ff = 0\n        var gg = 0\n        var hh = 0\n        var ii = 0\n        var jj = 0\n        var kk = 0\n        var ll = 0\n        var mm = 0\n        var nn = 0\n        var oo = 0\n        var pp = 0\n        var qq = 0\n        var rr = 0\n        var ss = 0\n        var tt = 0\n        var uu = 0\n\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123072,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1wqlxygi.scala:18:16 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            l = (num / pow(\u001b[31m10\u001b[0m, j).toLong) % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Found:    Long\n\u001b[31m   |\u001b[0m                Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1wqlxygi.scala:19:16 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            m = (num / pow(\u001b[31m10\u001b[0m, k).toLong) % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Found:    Long\n\u001b[31m   |\u001b[0m                Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1wqlxygi.scala:22:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1wqlxygi.scala:36:16 --------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m            d = n % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Found:    Long\n\u001b[31m   |\u001b[0m                Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1wqlxygi.scala:78:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val n = s.length\n        val half = n / 2\n        val left = s.substring(0, half)\n        val right = s.substring(half + n % 2, n)\n        val leftRev = left.reverse\n        if (leftRev > right) {\n            val leftInc = (left.toLong + 1).toString\n            val leftIncRev = leftInc.reverse\n            val leftIncRevPadded = leftIncRev.padTo(half, '0')\n            val leftIncPadded = leftInc.padTo(half, '0')\n            val leftIncPaddedRev = leftIncPadded.reverse\n            if (leftIncPaddedRev > right) leftIncPadded.toLong * pow(10, half).toLong + leftIncRevPadded.toLong * pow(10, half + n % 2).toLong\n            else leftIncPadded.toLong * pow(10, half).toLong + leftIncPaddedRev.toLong * pow(10, half + n % 2).toLong\n        }\n        else {\n            val leftRevPadded = leftRev.padTo(half, '0')\n            val leftPadded = left.padTo(half, '0')\n            val leftPaddedRev = leftPadded.reverse\n            if (leftPaddedRev > right) leftPadded.toLong * pow(10, half).toLong + leftRevPadded.toLong * pow(10, half + n % 2).toLong\n            else leftPadded.toLong * pow(10, half).toLong + leftPaddedRev.toLong * pow(10, half + n % 2).toLong\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123071,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp1wwxt16u.scala:30)\n\tat Problem.main(tmp1wwxt16u.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val n = s.length\n        val mid = n / 2\n        val left = s.substring(0, mid)\n        val right = s.substring(mid + n % 2, n)\n        val leftRev = left.reverse\n        if (leftRev > right) {\n            val leftInc = (left.toLong + 1).toString\n            val leftIncRev = leftInc.reverse\n            if (leftInc.length > left.length) leftInc + leftIncRev.substring(1, leftIncRev.length) else leftInc + leftIncRev\n        } else {\n            val leftRev = left.reverse\n            val leftRevInc = (leftRev.toLong + 1).toString\n            val leftRevIncRev = leftRevInc.reverse\n            if (leftRevInc.length > left.length) leftRevInc + leftRevIncRev.substring(1, leftRevIncRev.length) else leftRevInc + leftRevIncRev\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123071,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_v8xgks7.scala:15:46 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m (leftInc.length > left.length) leftInc + leftIncRev.substring(\u001b[31m1\u001b[0m, leftIncRev.length) \u001b[33melse\u001b[0m leftInc + leftIncRev\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                              Found:    String\n\u001b[31m   |\u001b[0m                                              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_v8xgks7.scala:15:104 -------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m (leftInc.length > left.length) leftInc + leftIncRev.substring(\u001b[31m1\u001b[0m, leftIncRev.length) \u001b[33melse\u001b[0m leftInc + leftIncRev\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                        ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                        Found:    String\n\u001b[31m   |\u001b[0m                                                        Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_v8xgks7.scala:20:49 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            \u001b[33mif\u001b[0m (leftRevInc.length > left.length) leftRevInc + leftRevIncRev.substring(\u001b[31m1\u001b[0m, leftRevIncRev.length) \u001b[33melse\u001b[0m leftRevInc + leftRevIncRev\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                 Found:    String\n\u001b[31m   |\u001b[0m                                                 Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_v8xgks7.scala:20:116 -------------------\u001b[0m\u001b[0",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        def isPalindrome(num : Long) : Boolean = {\n            val s = num.toString\n            s == s.reverse\n        }\n        var n = num\n        while (!isPalindrome(n)) n -= 1\n        n\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123072,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpmh15emji.scala:15)\n\tat Problem.main(tmpmh15emji.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val str = num.toString\n        val len = str.length\n        val half = len / 2\n        val left = str.substring(0, half)\n        val right = str.substring(half + len % 2, len)\n        val leftRev = left.reverse\n        if (leftRev < right) {\n            val nextLeft = (left.toLong + 1).toString\n            val nextLeftRev = nextLeft.reverse\n            val nextRight = if (nextLeftRev.length > right.length) nextLeftRev.substring(0, right.length) else nextLeftRev\n            (nextLeft + nextRight).toLong\n        } else {\n            val nextLeft = left\n            val nextLeftRev = nextLeft.reverse\n            val nextRight = if (nextLeftRev.length > right.length) nextLeftRev.substring(0, right.length) else nextLeftRev\n            (nextLeft + nextRight).toLong\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123071,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpknn6_45j.scala:25)\n\tat Problem.main(tmpknn6_45j.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        def isPalindrome(num : Long) : Boolean = {\n            val str = num.toString\n            str == str.reverse\n        }\n        def nextPalindrome(num : Long) : Long = {\n            if (isPalindrome(num)) num\n            else nextPalindrome(num + 1)\n        }\n        nextPalindrome(num + 1)\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1665517291,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var digits = new ArrayBuffer[Int]()\n        while (n > 0) {\n            digits += (n % 10).toInt\n            n /= 10\n        }\n        var i = 0\n        while (i < digits.length / 2) {\n            if (digits(i) < digits(digits.length - 1 - i)) {\n                var j = digits.length - 1 - i\n                while (j >= 0 && digits(j) == 9) {\n                    digits(j) = 0\n                    j -= 1\n                }\n                if (j >= 0) digits(j) += 1\n                else digits.insert(0, 1)\n                i += 1\n            } else if (digits(i) > digits(digits.length - 1 - i)) {\n                digits(digits.length - 1 - i) = digits(i)\n                i += 1\n            } else i += 1\n        }\n        var result = 0L\n        for (i <- 0 until digits.length) result = result * 10 + digits(i)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123075,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpclrndfa8.scala:33)\n\tat Problem.main(tmpclrndfa8.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        while (!isPalindrome(n)) n -= 1\n        n\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123073,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqgzr8xaq.scala:7:16 -------------------------\u001b[0m\u001b[0m\n\u001b[31m7 |\u001b[0m        \u001b[33mwhile\u001b[0m (!isPalindrome(n)) n -= \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m  |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                Not found: isPalindrome\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val digits = num.toString.map(_.asDigit)\n        val n = digits.length\n        val half = n / 2\n        val left = digits.slice(0, half)\n        val right = digits.slice(half + n % 2, n)\n        val leftReversed = left.reverse\n        if (left == right) {\n            val leftIncremented = left.map(_ + 1)\n            val leftIncrementedReversed = leftIncremented.reverse\n            val leftIncrementedReversedPadded = if (leftIncrementedReversed.length < half) leftIncrementedReversed :+ 0 else leftIncrementedReversed\n            val leftIncrementedReversedPaddedString = leftIncrementedReversedPadded.mkString\n            val leftIncrementedReversedPaddedStringInt = leftIncrementedReversedPaddedString.toInt\n            val leftIncrementedReversedPaddedStringIntString = leftIncrementedReversedPaddedStringInt.toString\n            val leftIncrementedReversedPaddedStringIntStringPadded = if (leftIncrementedReversedPaddedStringIntString.length < half) \"0\" + leftIncrementedReversedPaddedStringIntString else leftIncrementedReversedPaddedStringIntString\n            val leftIncrementedReversedPaddedStringIntStringPaddedReversed = leftIncrementedReversedPaddedStringIntStringPadded.reverse\n            val leftIncrementedReversedPaddedStringIntStringPaddedReversedInt = leftIncrementedReversedPaddedStringIntStringPaddedReversed.toInt\n            val leftIncrementedReversedPaddedStringIntStringPaddedReversedIntString = leftIncrementedReversedPaddedStringIntStringPaddedReversedInt.toString\n            val leftIncrementedReversedPaddedStringIntStringPaddedReversedIntStringPadded = if (leftIncrementedReversedPaddedStringIntStringPaddedReversedIntString.length < half) \"0\" + leftIncrementedReversedPaddedStringIntStringPaddedReversedIntString else leftIncrementedReversedPaddedStringIntStringPaddedReversedIntString\n            val leftIncrementedReversedPaddedString\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123077,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpcjnnujc9.scala:25:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpcjnnujc9.scala:33:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcjnnujc9.scala:32:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpcjnnujc9.scala:26:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m26 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val digits = num.toString.toList.map(_.asDigit)\n        val mid = digits.length / 2\n        val left = digits.slice(0, mid)\n        val right = digits.slice(mid + (if (digits.length % 2 == 0) 0 else 1), digits.length).reverse\n        if (left == right) {\n            val leftInc = left.reverse.scanLeft(0)((a, b) => if (a == 0) b + 1 else b).reverse\n            val rightInc = leftInc.reverse\n            val newDigits = leftInc ++ (if (digits.length % 2 == 0) rightInc else rightInc.tail)\n            newDigits.foldLeft(0L)((a, b) => a * 10 + b)\n        } else {\n            val leftInc = left.reverse.scanLeft(0)((a, b) => if (a == 0) b + 1 else b).reverse\n            val rightInc = leftInc.reverse\n            val newDigits = leftInc ++ (if (digits.length % 2 == 0) rightInc else rightInc.tail)\n            newDigits.foldLeft(0L)((a, b) => a * 10 + b)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123079,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpwgdhocag.scala:23)\n\tat Problem.main(tmpwgdhocag.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        while (true) {\n            n += 1\n            if (isPalindrome(n)) return n\n        }\n        return -1\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123066,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3skv3vcx.scala:9:16 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m            \u001b[33mif\u001b[0m (isPalindrome(n)) \u001b[33mreturn\u001b[0m n\n\u001b[31m\u001b[31m  |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                Not found: isPalindrome\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        def isPalindrome(num : Long) = num.toString == num.toString.reverse\n        def nextPalindrome(num : Long) : Long = {\n            if (isPalindrome(num)) num\n            else nextPalindrome(num - 1)\n        }\n        nextPalindrome(num - 1)\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123078,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpt8p2nplu.scala:14)\n\tat Problem.main(tmpt8p2nplu.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val digits = num.toString.toList.map(_.asDigit)\n        val len = digits.length\n        val half = len / 2\n        val left = digits.take(half)\n        val right = digits.drop(len - half)\n        val leftRev = left.reverse\n        val leftRevNum = leftRev.foldLeft(0)((a, b) => a * 10 + b)\n        val rightNum = right.foldLeft(0)((a, b) => a * 10 + b)\n        if (leftRevNum < rightNum) {\n            val leftNum = left.foldLeft(0)((a, b) => a * 10 + b)\n            val nextLeft = leftNum + 1\n            val nextLeftDigits = nextLeft.toString.toList.map(_.asDigit)\n            val nextLeftRev = nextLeftDigits.reverse\n            val nextLeftRevNum = nextLeftRev.foldLeft(0)((a, b) => a * 10 + b)\n            nextLeftRevNum * pow(10, half).toLong + nextLeftNum\n        } else {\n            val leftRevNum = leftRev.foldLeft(0)((a, b) => a * 10 + b)\n            leftRevNum * pow(10, half).toLong + leftRevNum\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123075,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpimmbq7mo.scala:20:52 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            nextLeftRevNum * pow(\u001b[31m10\u001b[0m, half).toLong + nextLeftNum\n\u001b[31m\u001b[31m   |\u001b[0m                                                    ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                  Not found: nextLeftNum\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        def isPalindrome(num : Long) : Boolean = {\n            val str = num.toString\n            str == str.reverse\n        }\n        var n = num\n        while (!isPalindrome(n)) n -= 1\n        n\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123079,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmplf31x817.scala:15)\n\tat Problem.main(tmplf31x817.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var digits = List[Int]()\n        while (n > 0) {\n            digits = (n % 10).toInt :: digits\n            n /= 10\n        }\n        var i = 0\n        while (i < digits.length / 2) {\n            if (digits(i) < digits(digits.length - 1 - i)) {\n                digits(digits.length - 1 - i) = digits(i)\n            } else if (digits(i) > digits(digits.length - 1 - i)) {\n                digits(digits.length - 1 - i) = digits(i)\n                var j = digits.length - 2 - i\n                while (j >= 0 && digits(j) == 9) {\n                    digits(j) = 0\n                    j -= 1\n                }\n                if (j < 0) {\n                    digits = 1 :: digits\n                } else {\n                    digits(j) += 1\n                }\n            }\n            i += 1\n        }\n        var result = 0L\n        for (i <- 0 until digits.length) {\n            result = result * 10 + digits(i)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123081,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmny8awv_.scala:15:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m                digits(digits.length - \u001b[31m1\u001b[0m - i) = digits(i)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue update is not a member of List[Int] - did you mean List[Int].updated?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmny8awv_.scala:17:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                digits(digits.length - \u001b[31m1\u001b[0m - i) = digits(i)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue update is not a member of List[Int] - did you mean List[Int].updated?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmny8awv_.scala:20:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                    digits(j) = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue update is not a member of List[Int] - did you mean List[Int].updated?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmny8awv_.scala:26:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                    digits(j) += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value += is not a member of Int - did you mean Int.!=?\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var i = 0\n        while (n > 0) {\n            i += 1\n            n /= 10\n        }\n        var j = i / 2\n        var k = i - j\n        var l = pow(10, j).toLong\n        var m = pow(10, k).toLong\n        var n1 = num / l\n        var n2 = num % l\n        var n3 = n2 / m\n        var n4 = n2 % m\n        var n5 = n1 / m\n        var n6 = n1 % m\n        var n7 = n3 * m + n4\n        var n8 = n5 * m + n6\n        var n9 = n7 * l + n8\n        if (n9 > num) return n9\n        if (n7 < m - 1) return n7 * l + n8\n        if (n8 < m - 1) return n8 * l + n7\n        return nextSmallestPalindrome(num + 2)\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123081,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp1zc4spwv.scala:31)\n\tat Problem.main(tmp1zc4spwv.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val n = s.length\n        val half = n / 2\n        val left = s.substring(0, half)\n        val right = s.substring(half + (if (n % 2 == 0) 0 else 1), n)\n        val leftRev = left.reverse\n        val leftRevInt = leftRev.toInt\n        val leftInt = left.toInt\n        val rightInt = right.toInt\n        if (leftRevInt < rightInt) {\n            val leftInc = (leftInt + 1).toString\n            val leftIncRev = leftInc.reverse\n            val leftIncRevInt = leftIncRev.toInt\n            if (leftIncRevInt < rightInt) {\n                val leftIncRevStr = leftIncRevInt.toString\n                val leftIncStr = leftInc.toString\n                val leftStr = left.toString\n                val rightStr = right.toString\n                val leftPad = \"0\" * (half - leftIncStr.length)\n                val rightPad = \"0\" * (half - rightStr.length)\n                val leftPadRev = \"0\" * (half - leftIncRevStr.length)\n                val rightPadRev = \"0\" * (half - rightStr.length)\n                val leftPadStr = leftPad + leftIncStr\n                val rightPadStr = rightPad + rightStr\n                val leftPadRevStr = leftPadRev + leftIncRevStr\n                val rightPadRevStr = rightPadRev + rightStr\n                val leftPadStrInt = leftPadStr.toInt\n                val rightPadStrInt = rightPadStr.toInt\n                val leftPadRevStrInt = leftPadRevStr.toInt\n                val rightPadRevStrInt = rightPadRevStr.toInt\n                if (leftPadStrInt < rightPadStrInt) {\n                    val leftPadStrIntStr = leftPadStrInt.toString\n                    val rightPadStrIntStr = rightPadStrInt.toString\n                    val leftPadRevStrIntStr = leftPadRevStrInt.toString\n                    val rightPadRevStrIntStr = rightPadRevStrInt.toString\n                    val leftPadStrIntStrPad = \"0\" * (n - leftPad\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123078,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpenpwtcdz.scala:42:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpenpwtcdz.scala:50:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpenpwtcdz.scala:41:55 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m                    \u001b[33mval\u001b[0m \u001b[36mleftPadStrIntStrPad\u001b[0m = \u001b[31m\"0\"\u001b[0m * (n - leftPad\n\u001b[31m\u001b[31m   |\u001b[0m                                                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0m None of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m-\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mInt\u001b[0m with types\n\u001b[31m   |\u001b[0m  (x: Double): Double\n\u001b[31m   |\u001b[0m  (x: Float): Float\n\u001b[31m   |\u001b[0m  (x: Long): Long\n\u001b[31m   |\u001b[0m  (x: Int): Int\n\u001b[31m   |\u001b[0m  (x: Char): Int\n\u001b[31m   |\u001b[0m  (x: Short): Int\n\u001b[31m   |\u001b[0m  (x: Byte): Int\n\u001b[31m   |\u001b[0m match arguments ((leftPad : String))\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpenpwtcdz.scala:43:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m43 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val n = s.length\n        val half = n / 2\n        val left = s.substring(0, half)\n        val right = s.substring(half + (if (n % 2 == 0) 0 else 1), n)\n        val leftReversed = left.reverse\n        val leftInt = left.toInt\n        val leftReversedInt = leftReversed.toInt\n        val rightInt = right.toInt\n        if (leftReversedInt > rightInt) {\n            val leftIntPlusOne = (leftInt + 1).toString\n            val leftIntPlusOneReversed = leftIntPlusOne.reverse\n            val leftIntPlusOneReversedInt = leftIntPlusOneReversed.toInt\n            if (leftIntPlusOneReversedInt < rightInt) {\n                val leftIntPlusOneReversedIntString = leftIntPlusOneReversedInt.toString\n                val leftIntPlusOneReversedIntStringLength = leftIntPlusOneReversedIntString.length\n                val leftIntPlusOneReversedIntStringLengthDiff = right.length - leftIntPlusOneReversedIntStringLength\n                val leftIntPlusOneReversedIntStringPadded = leftIntPlusOneReversedIntString + \"0\" * leftIntPlusOneReversedIntStringLengthDiff\n                val leftIntPlusOneReversedIntStringPaddedInt = leftIntPlusOneReversedIntStringPadded.toInt\n                val leftIntPlusOneInt = leftIntPlusOne.toInt\n                val leftIntPlusOneIntString = leftIntPlusOneInt.toString\n                val leftIntPlusOneIntStringLength = leftIntPlusOneIntString.length\n                val leftIntPlusOneIntStringLengthDiff = right.length - leftIntPlusOneIntStringLength\n                val leftIntPlusOneIntStringPadded = leftIntPlusOneIntString + \"0\" * leftIntPlusOneIntStringLengthDiff\n                val leftIntPlusOneIntStringPaddedInt = leftIntPlusOneIntStringPadded.toInt\n                val result = leftIntPlusOneIntStringPaddedInt + leftIntPlusOneReversedIntStringPaddedInt\n                result.toLong\n\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123078,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpzcghk6gj.scala:42:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpzcghk6gj.scala:15:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mif\u001b[0m (leftReversedInt > rightInt) {\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    Unit\n\u001b[31m   |\u001b[0m        Required: Long\n\u001b[31m   |\u001b[0m        Maybe you are missing an else part for the conditional?\n\u001b[31m16 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mleftIntPlusOne\u001b[0m = (leftInt + \u001b[31m1\u001b[0m).toString\n\u001b[31m17 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mleftIntPlusOneReversed\u001b[0m = leftIntPlusOne.reverse\n\u001b[31m18 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mleftIntPlusOneReversedInt\u001b[0m = leftIntPlusOneReversed.toInt\n\u001b[31m19 |\u001b[0m            \u001b[33mif\u001b[0m (leftIntPlusOneReversedInt < rightInt) {\n\u001b[31m20 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mleftIntPlusOneReversedIntString\u001b[0m = leftIntPlusOneReversedInt.toString\n\u001b[31m21 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mleftIntPlusOneReversedIntStringLength\u001b[0m = leftIntPlusOneReversedIntString.length\n\u001b[31m22 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mleftIntPlusOneReversedIntStringLengthDiff\u001b[0m = right.length - leftIntPlusOneReversedIntStringLength\n\u001b[31m23 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mleftIntPlusOneReversedIntStringPadded\u001b[0m = leftIntPlusOneReversedIntString + \u001b[31m\"0\"\u001b[0m * leftIntPlusOneReversedIntStringLengthDiff\n\u001b[31m24 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mleftIntPlusOneReversedIntStringPaddedInt\u001b[0m = leftIntPlusOneReversedIntStringPadded.toInt\n\u001b[31m25 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mleftIntPlusOneInt\u001b[0m = leftIntPlusOne.toInt\n\u001b[31m26 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mleftIntPlusOneIntString\u001b[0m = leftIntPlusOneInt.toString\n\u001b[31m27 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mleftIntPlusOneIntStringLength\u001b[0m = leftIntPlusOneIntString.length\n\u001b[31m28 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mleftIntPlusOneIntStringLengthDiff\u001b[0m = right.length - leftIntPlusOneIntString",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val n = s.length\n        if (n == 1) return num + 1\n        val mid = n / 2\n        val left = s.substring(0, mid)\n        val right = s.substring(mid + (n % 2), n)\n        val leftRev = left.reverse\n        val rightRev = right.reverse\n        if (leftRev < right) {\n            val newLeft = (left.toLong + 1).toString\n            val newRight = newLeft.reverse\n            return (newLeft + newRight.substring(n % 2)).toLong\n        }\n        else {\n            val newLeft = left\n            val newRight = newLeft.reverse\n            return (newLeft + newRight.substring(n % 2)).toLong\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123081,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpcpvu03az.scala:26)\n\tat Problem.main(tmpcpvu03az.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        def isPalindrome(num : Long) : Boolean = {\n            val str = num.toString\n            str == str.reverse\n        }\n        def nextSmallestPalindrome(num : Long, i : Int) : Long = {\n            if (i > 100) throw new Exception(\"Failed to find next smallest palindrome\")\n            val next = num - i\n            if (isPalindrome(next)) next\n            else nextSmallestPalindrome(num, i + 1)\n        }\n        nextSmallestPalindrome(num, 1)\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123081,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpidiuj145.scala:19)\n\tat Problem.main(tmpidiuj145.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val n = s.length\n        val half = n / 2\n        val left = s.substring(0, half)\n        val right = s.substring(half + n % 2, n)\n        val leftRev = left.reverse\n        val leftRevNum = leftRev.toLong\n        val leftNum = left.toLong\n        val rightNum = right.toLong\n        if (leftRevNum < rightNum) {\n            val leftNumPlusOne = leftNum + 1\n            val leftPlusOne = leftNumPlusOne.toString\n            val leftPlusOneRev = leftPlusOne.reverse\n            val leftPlusOneRevNum = leftPlusOneRev.toLong\n            val leftPlusOneNum = leftPlusOne.toLong\n            if (leftPlusOneRevNum < rightNum) {\n                val leftPlusOneNumStr = leftPlusOneNum.toString\n                val leftPlusOneRevNumStr = leftPlusOneRevNum.toString\n                val leftPlusOneNumStrLen = leftPlusOneNumStr.length\n                val leftPlusOneRevNumStrLen = leftPlusOneRevNumStr.length\n                val leftPlusOneNumStrLenDiff = leftPlusOneNumStrLen - leftPlusOneRevNumStrLen\n                val leftPlusOneRevNumStrPadded = \"0\" * leftPlusOneNumStrLenDiff + leftPlusOneRevNumStr\n                val leftPlusOneNumStrPadded = leftPlusOneNumStr + \"0\" * leftPlusOneNumStrLenDiff\n                val leftPlusOneNumStrPaddedLen = leftPlusOneNumStrPadded.length\n                val leftPlusOneRevNumStrPaddedLen = leftPlusOneRevNumStrPadded.length\n                val leftPlusOneNumStrPaddedLenDiff = leftPlusOneNumStrPaddedLen - leftPlusOneRevNumStrPaddedLen\n                val leftPlusOneRevNumStrPaddedPadded = \"0\" * leftPlusOneNumStrPaddedLenDiff + leftPlusOneRevNumStrPadded\n                val leftPlusOneNumStrPaddedPadded = leftPlusOneNumStrPadded + \"0\" * leftPlusOneNumStrPaddedLenDiff\n                leftPlusOneNumStrPaddedPadded.toLong\n            } else {\n               \n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123078,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp8dx23jmn.scala:45:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8dx23jmn.scala:15:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mif\u001b[0m (leftRevNum < rightNum) {\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    Unit\n\u001b[31m   |\u001b[0m        Required: Long\n\u001b[31m   |\u001b[0m        Maybe you are missing an else part for the conditional?\n\u001b[31m16 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mleftNumPlusOne\u001b[0m = leftNum + \u001b[31m1\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mleftPlusOne\u001b[0m = leftNumPlusOne.toString\n\u001b[31m18 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mleftPlusOneRev\u001b[0m = leftPlusOne.reverse\n\u001b[31m19 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mleftPlusOneRevNum\u001b[0m = leftPlusOneRev.toLong\n\u001b[31m20 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mleftPlusOneNum\u001b[0m = leftPlusOne.toLong\n\u001b[31m21 |\u001b[0m            \u001b[33mif\u001b[0m (leftPlusOneRevNum < rightNum) {\n\u001b[31m22 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mleftPlusOneNumStr\u001b[0m = leftPlusOneNum.toString\n\u001b[31m23 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mleftPlusOneRevNumStr\u001b[0m = leftPlusOneRevNum.toString\n\u001b[31m24 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mleftPlusOneNumStrLen\u001b[0m = leftPlusOneNumStr.length\n\u001b[31m25 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mleftPlusOneRevNumStrLen\u001b[0m = leftPlusOneRevNumStr.length\n\u001b[31m26 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mleftPlusOneNumStrLenDiff\u001b[0m = leftPlusOneNumStrLen - leftPlusOneRevNumStrLen\n\u001b[31m27 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mleftPlusOneRevNumStrPadded\u001b[0m = \u001b[31m\"0\"\u001b[0m * leftPlusOneNumStrLenDiff + leftPlusOneRevNumStr\n\u001b[31m28 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mleftPlusOneNumStrPadded\u001b[0m = leftPlusOneNumStr + \u001b[31m\"0\"\u001b[0m * leftPlusOneNumStrLenDiff\n\u001b[31m29 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mleftPlusOneNumStrPaddedLen\u001b[0m = leftPlusOneNumStrPadded.length\n\u001b[31m30 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mleftPlusOneRevNumStrPaddedLen\u001b[0m = leftPlusOneRevNumStrPadded.length\n\u001b[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val str = num.toString\n        val len = str.length\n        val half = len / 2\n        val left = str.substring(0, half)\n        val right = str.substring(half + len % 2, len)\n        val leftRev = left.reverse\n        if (leftRev > right) {\n            val leftNum = left.toLong\n            val leftNumRev = leftRev.toLong\n            val leftNumRevInc = leftNumRev + 1\n            val leftNumRevIncStr = leftNumRevInc.toString\n            val leftNumRevIncStrRev = leftNumRevIncStr.reverse\n            val leftNumRevIncStrRevNum = leftNumRevIncStrRev.toLong\n            val leftNumRevIncStrRevNumStr = leftNumRevIncStrRevNum.toString\n            val leftNumRevIncStrRevNumStrRev = leftNumRevIncStrRevNumStr.reverse\n            val leftNumRevIncStrRevNumStrRevNum = leftNumRevIncStrRevNumStrRev.toLong\n            val leftNumRevIncStrRevNumStrRevNumStr = leftNumRevIncStrRevNumStrRevNum.toString\n            val leftNumRevIncStrRevNumStrRevNumStrRev = leftNumRevIncStrRevNumStrRevNumStr.reverse\n            val leftNumRevIncStrRevNumStrRevNumStrRevNum = leftNumRevIncStrRevNumStrRevNumStrRev.toLong\n            val leftNumRevIncStrRevNumStrRevNumStrRevNumStr = leftNumRevIncStrRevNumStrRevNumStrRevNum.toString\n            val leftNumRevIncStrRevNumStrRevNumStrRevNumStrRev = leftNumRevIncStrRevNumStrRevNumStrRevNumStr.reverse\n            val leftNumRevIncStrRevNumStrRevNumStrRevNumStrRevNum = leftNumRevIncStrRevNumStrRevNumStrRevNumStrRev.toLong\n            val leftNumRevIncStrRevNumStrRevNumStrRevNumStrRevNumStr = leftNumRevIncStrRevNumStrRevNumStrRevNumStrRevNum.toString\n            val leftNumRevIncStrRevNumStrRevNumStrRevNumStrRevNumStrRev = leftNumRevIncStrRevNumStrRevNumStrRevNumStrRevNumStr.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123080,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpvbhblwfp.scala:38:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpvbhblwfp.scala:37:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpvbhblwfp.scala:31:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m31 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        def isPalindrome(num : Long) : Boolean = {\n            val str = num.toString\n            str == str.reverse\n        }\n        var result = num\n        while (!isPalindrome(result)) result -= 1\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123081,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmprka5xejk.scala:15)\n\tat Problem.main(tmprka5xejk.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val n = s.length\n        val half = n / 2\n        val left = s.substring(0, half)\n        val right = s.substring(half + (if (n % 2 == 0) 0 else 1), n)\n        val leftRev = left.reverse\n        val rightRev = right.reverse\n        val leftInt = left.toInt\n        val rightInt = right.toInt\n        val leftRevInt = leftRev.toInt\n        val rightRevInt = rightRev.toInt\n        if (leftInt < rightInt) {\n            val leftRevInt = leftRev.toInt\n            val leftRevIntPlusOne = leftRevInt + 1\n            val leftRevPlusOne = leftRevIntPlusOne.toString\n            val leftRevPlusOneRev = leftRevPlusOne.reverse\n            val leftRevPlusOneRevInt = leftRevPlusOneRev.toInt\n            if (leftRevPlusOneRevInt < rightInt) {\n                val leftRevPlusOneRevInt = leftRevPlusOneRev.toInt\n                val leftRevPlusOneRevIntPlusOne = leftRevPlusOneRevInt + 1\n                val leftRevPlusOneRevPlusOne = leftRevPlusOneRevIntPlusOne.toString\n                val leftRevPlusOneRevPlusOneRev = leftRevPlusOneRevPlusOne.reverse\n                val leftRevPlusOneRevPlusOneRevInt = leftRevPlusOneRevPlusOneRev.toInt\n                val leftRevPlusOneRevPlusOneRevInt = leftRevPlusOneRevPlusOneRev.toInt\n                val leftRevPlusOneRevPlusOneRevIntPlusOne = leftRevPlusOneRevPlusOneRevInt + 1\n                val leftRevPlusOneRevPlusOneRevPlusOne = leftRevPlusOneRevPlusOneRevIntPlusOne.toString\n                val leftRevPlusOneRevPlusOneRevPlusOneRev = leftRevPlusOneRevPlusOneRevPlusOne.reverse\n                val leftRevPlusOneRevPlusOneRevPlusOneRevInt = leftRevPlusOneRevPlusOneRevPlusOneRev.toInt\n                val leftRevPlusOneRevPlusOneRevPlusOneRevInt = leftRevPlusOneRevPlusOneRevPlusOneRev.toInt\n                val leftRevPlusOneRevPlusOneRevPlusOne\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123078,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpl825lv67.scala:36:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpl825lv67.scala:44:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpl825lv67.scala:29:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mleftRevPlusOneRevPlusOneRevInt\u001b[0m = leftRevPlusOneRevPlusOneRev.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleftRevPlusOneRevPlusOneRevInt is already defined as \u001b[33mvalue\u001b[0m \u001b[35mleftRevPlusOneRevPlusOneRevInt\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpl825lv67.scala:34:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mleftRevPlusOneRevPlusOneRevPlusOneRevInt\u001b[0m = leftRevPlusOneRevPlusOneRevPlusOneRev.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleftRevPlusOneRevPlusOneRevPlusOneRevInt is already defined as \u001b[33mvalue\u001b[0m \u001b[35mleftRevPlusOneRevPlusOneRevPlusOneRevInt\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpl825lv67.scala:37:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m37 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val str = num.toString\n        val len = str.length\n        val half = len / 2\n        val left = str.substring(0, half)\n        val right = str.substring(half + len % 2)\n        val leftNum = left.toLong\n        val rightNum = right.toLong\n        val leftNumRev = left.reverse.toLong\n        val rightNumRev = right.reverse.toLong\n        if (leftNumRev < rightNum) {\n            val newLeft = (leftNum + 1).toString\n            val newRight = newLeft.reverse\n            (newLeft + newRight.substring(len % 2)).toLong\n        }\n        else if (leftNumRev > rightNum) {\n            val newLeft = leftNum.toString\n            val newRight = newLeft.reverse\n            (newLeft + newRight.substring(len % 2)).toLong\n        }\n        else {\n            val newLeft = (leftNum + 1).toString\n            val newRight = newLeft.reverse\n            (newLeft + newRight.substring(len % 2)).toLong\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123081,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpdhdq1dk9.scala:32)\n\tat Problem.main(tmpdhdq1dk9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val l = s.length\n        if (l == 1) return num\n        val mid = l / 2\n        val left = s.substring(0, mid)\n        val right = s.substring(mid + (if (l % 2 == 0) 0 else 1), l)\n        val leftInt = left.toInt\n        val rightInt = right.toInt\n        if (leftInt == rightInt) {\n            val nextLeft = (leftInt + 1).toString\n            val nextRight = nextLeft.reverse\n            val next = nextLeft + nextRight\n            if (l % 2 == 1) next + nextLeft.substring(0, 1)\n            else next\n        } else {\n            val nextLeft = leftInt.toString\n            val nextRight = nextLeft.reverse\n            val next = nextLeft + nextRight\n            if (l % 2 == 1) next + nextLeft.substring(0, 1)\n            else next\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123082,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphx6yar3d.scala:18:28 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            \u001b[33mif\u001b[0m (l % \u001b[31m2\u001b[0m == \u001b[31m1\u001b[0m) next + nextLeft.substring(\u001b[31m0\u001b[0m, \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    String\n\u001b[31m   |\u001b[0m                            Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphx6yar3d.scala:19:17 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33melse\u001b[0m next\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 Found:    (next : String)\n\u001b[31m   |\u001b[0m                 Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphx6yar3d.scala:24:28 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mif\u001b[0m (l % \u001b[31m2\u001b[0m == \u001b[31m1\u001b[0m) next + nextLeft.substring(\u001b[31m0\u001b[0m, \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    String\n\u001b[31m   |\u001b[0m                            Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphx6yar3d.scala:25:17 --------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33melse\u001b[0m next\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 Found:    (next : String)\n\u001b[31m   |\u001b[0m                 Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        while (true) {\n            n += 1\n            if (isPalindrome(n)) return n\n        }\n        return -1\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123066,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3skv3vcx.scala:9:16 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m            \u001b[33mif\u001b[0m (isPalindrome(n)) \u001b[33mreturn\u001b[0m n\n\u001b[31m\u001b[31m  |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                Not found: isPalindrome\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        def isPalindrome(num : Long) : Boolean = {\n            val s = num.toString\n            s == s.reverse\n        }\n        var i = num - 1\n        while (i > 0) {\n            if (isPalindrome(i)) return i\n            i -= 1\n        }\n        return -1\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123082,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpetgvml0y.scala:18)\n\tat Problem.main(tmpetgvml0y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        while (true) {\n            n += 1\n            if (isPalindrome(n)) return n\n        }\n        return -1\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123066,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3skv3vcx.scala:9:16 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m            \u001b[33mif\u001b[0m (isPalindrome(n)) \u001b[33mreturn\u001b[0m n\n\u001b[31m\u001b[31m  |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                Not found: isPalindrome\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var i = 0\n        while (i < 100) {\n            n += 1\n            if (isPalindrome(n)) return n\n            i += 1\n        }\n        -1\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123079,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpg9o86le0.scala:10:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m            \u001b[33mif\u001b[0m (isPalindrome(n)) \u001b[33mreturn\u001b[0m n\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPalindrome\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var digits = new ArrayBuffer[Int]\n        while (n > 0) {\n            digits += (n % 10).toInt\n            n /= 10\n        }\n        var i = 0\n        var j = digits.length - 1\n        while (i < j) {\n            if (digits(i) < digits(j)) {\n                var k = j\n                while (k > i && digits(k) == 0) k -= 1\n                if (k == i) {\n                    digits(k) -= 1\n                    k -= 1\n                    while (k >= 0) {\n                        digits(k) = 9\n                        k -= 1\n                    }\n                } else {\n                    digits(k) -= 1\n                }\n                j = digits.length - 1\n                while (j > i) {\n                    digits(j) = digits(i)\n                    j -= 1\n                }\n            } else if (digits(i) > digits(j)) {\n                j = digits.length - 1\n                while (j > i) {\n                    digits(j) = digits(i)\n                    j -= 1\n                }\n            }\n            i += 1\n            j -= 1\n        }\n        var result = 0L\n        for (i <- 0 until digits.length) result = result * 10 + digits(i)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpmsmiz5cm.scala:48)\n\tat Problem.main(tmpmsmiz5cm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        while (true) {\n            n += 1\n            if (isPalindrome(n)) return n\n        }\n        return -1\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123066,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3skv3vcx.scala:9:16 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m            \u001b[33mif\u001b[0m (isPalindrome(n)) \u001b[33mreturn\u001b[0m n\n\u001b[31m\u001b[31m  |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                Not found: isPalindrome\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val str = num.toString\n        val len = str.length\n        val half = len / 2\n        val left = str.substring(0, half)\n        val right = str.substring(half + len % 2, len)\n        val leftRev = left.reverse\n        if (leftRev <= right) {\n            val leftInc = (left.toLong + 1).toString\n            val leftIncRev = leftInc.reverse\n            val leftIncRevLen = leftIncRev.length\n            val leftIncRevPad = leftIncRev + \"0\" * (half - leftIncRevLen)\n            val leftIncRevPadLen = leftIncRevPad.length\n            val leftIncRevPadHalf = leftIncRevPadLen / 2\n            val leftIncRevPadLeft = leftIncRevPad.substring(0, leftIncRevPadHalf)\n            val leftIncRevPadRight = leftIncRevPad.substring(leftIncRevPadHalf, leftIncRevPadLen)\n            if (leftIncRevPadLeft == leftIncRevPadRight) leftIncRevPad.toLong\n            else leftIncRevPadLeft.toLong * pow(10, leftIncRevPadHalf).toLong\n        } else {\n            val leftRevLen = leftRev.length\n            val leftRevPad = leftRev + \"0\" * (half - leftRevLen)\n            val leftRevPadLen = leftRevPad.length\n            val leftRevPadHalf = leftRevPadLen / 2\n            val leftRevPadLeft = leftRevPad.substring(0, leftRevPadHalf)\n            val leftRevPadRight = leftRevPad.substring(leftRevPadHalf, leftRevPadLen)\n            if (leftRevPadLeft == leftRevPadRight) leftRevPad.toLong\n            else leftRevPadLeft.toLong * pow(10, leftRevPadHalf).toLong\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpbtu34frq.scala:35)\n\tat Problem.main(tmpbtu34frq.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var digits = new ArrayBuffer[Int]()\n        while (n > 0) {\n            digits += (n % 10).toInt\n            n /= 10\n        }\n        var i = 0\n        while (i < digits.length / 2) {\n            if (digits(i) != digits(digits.length - 1 - i)) {\n                if (digits(i) > digits(digits.length - 1 - i)) {\n                    digits(digits.length - 1 - i) = digits(i)\n                } else {\n                    digits(i) = digits(digits.length - 1 - i)\n                }\n            }\n            i += 1\n        }\n        var palindrome = 0L\n        for (i <- 0 until digits.length) {\n            palindrome = palindrome * 10 + digits(i)\n        }\n        palindrome\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123085,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp01db9o65.scala:30)\n\tat Problem.main(tmp01db9o65.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        while (true) {\n            n += 1\n            if (isPalindrome(n)) return n\n        }\n        return -1\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123066,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3skv3vcx.scala:9:16 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m            \u001b[33mif\u001b[0m (isPalindrome(n)) \u001b[33mreturn\u001b[0m n\n\u001b[31m\u001b[31m  |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                Not found: isPalindrome\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var digits = new ArrayBuffer[Int]()\n        while (n > 0) {\n            digits += (n % 10).toInt\n            n /= 10\n        }\n        var i = 0\n        while (i < digits.length / 2) {\n            if (digits(i) < digits(digits.length - 1 - i)) {\n                digits(digits.length - 1 - i) = digits(i)\n            } else if (digits(i) > digits(digits.length - 1 - i)) {\n                digits(digits.length - 1 - i) = digits(i)\n                var j = digits.length - 2 - i\n                while (j >= 0 && digits(j) == 9) {\n                    digits(j) = 0\n                    j -= 1\n                }\n                if (j < 0) {\n                    digits.insert(0, 1)\n                } else {\n                    digits(j) += 1\n                }\n            }\n            i += 1\n        }\n        var result = 0L\n        for (i <- 0 until digits.length) {\n            result = result * 10 + digits(i)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123085,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpa8y6fmnd.scala:38)\n\tat Problem.main(tmpa8y6fmnd.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val digits = num.toString.toList.map(_.asDigit)\n        val n = digits.length\n        val half = n / 2\n        val (left, right) = digits.splitAt(half)\n        val (left1, right1) = (left.reverse, right)\n        val (left2, right2) = (left1.reverse, right1)\n        val (left3, right3) = (left2.reverse, right2)\n        val (left4, right4) = (left3.reverse, right3)\n        val (left5, right5) = (left4.reverse, right4)\n        val (left6, right6) = (left5.reverse, right5)\n        val (left7, right7) = (left6.reverse, right6)\n        val (left8, right8) = (left7.reverse, right7)\n        val (left9, right9) = (left8.reverse, right8)\n        val (left10, right10) = (left9.reverse, right9)\n        val (left11, right11) = (left10.reverse, right10)\n        val (left12, right12) = (left11.reverse, right11)\n        val (left13, right13) = (left12.reverse, right12)\n        val (left14, right14) = (left13.reverse, right13)\n        val (left15, right15) = (left14.reverse, right14)\n        val (left16, right16) = (left15.reverse, right15)\n        val (left17, right17) = (left16.reverse, right16)\n        val (left18, right18) = (left17.reverse, right17)\n        val (left19, right19) = (left18.reverse, right18)\n        val (left20, right20) = (left19.reverse, right19)\n        val (left21, right21) = (left20.reverse, right20)\n        val (left22, right22) = (left21.reverse, right21)\n        val (left23, right23) = (left22.reverse, right22)\n       \n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123085,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpp5_3f18s.scala:34:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val digits = num.toString.map(_.asDigit).toList\n        val len = digits.length\n        val half = len / 2\n        val left = digits.take(half)\n        val right = digits.takeRight(half)\n        val (newLeft, newRight) = if (left == right.reverse) {\n            val (newLeft, carry) = left.foldRight((List[Int](), 1))((d, acc) => {\n                val (newLeft, carry) = acc\n                val (newD, newCarry) = (d + carry) / 10 match {\n                    case 0 => (d + carry, 0)\n                    case 1 => (0, 1)\n                }\n                (newD :: newLeft, newCarry)\n            })\n            if (carry == 1) {\n                val newLeft = (1 :: newLeft).reverse\n                (newLeft, newLeft.takeRight(half))\n            } else {\n                (newLeft, newLeft.takeRight(half))\n            }\n        } else {\n            val newLeft = left.zip(right.reverse).map(p => max(p._1, p._2)).reverse\n            (newLeft, newLeft.takeRight(half))\n        }\n        (newLeft ++ newRight.reverse).foldLeft(0L)((acc, d) => acc * 10 + d)\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123084,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmps1jnkngt.scala:21:36 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mnewLeft\u001b[0m = (\u001b[31m1\u001b[0m :: newLeft).reverse\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Recursive \u001b[33mvalue\u001b[0m \u001b[35mnewLeft\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val n = s.length\n        val half = n / 2\n        val left = s.substring(0, half)\n        val right = s.substring(half + n % 2, n)\n        val leftRev = left.reverse\n        val leftInt = left.toInt\n        val rightInt = right.toInt\n        if (leftInt == rightInt) {\n            val nextLeft = (leftInt + 1).toString\n            val nextLeftRev = nextLeft.reverse\n            val nextLeftRevLen = nextLeftRev.length\n            val nextLeftLen = nextLeft.length\n            val nextLeftRevDiff = nextLeftRevLen - nextLeftLen\n            val nextLeftRevDiffStr = \"0\" * nextLeftRevDiff\n            val nextLeftStr = nextLeftRevDiffStr + nextLeft\n            val nextRightStr = nextLeftRev\n            val nextStr = nextLeftStr + nextRightStr\n            nextStr.toLong\n        } else {\n            val leftRevInt = leftRev.toInt\n            val rightInt = right.toInt\n            val nextLeft = if (leftRevInt > rightInt) left else (leftInt + 1).toString\n            val nextLeftRev = nextLeft.reverse\n            val nextLeftRevLen = nextLeftRev.length\n            val nextLeftLen = nextLeft.length\n            val nextLeftRevDiff = nextLeftRevLen - nextLeftLen\n            val nextLeftRevDiffStr = \"0\" * nextLeftRevDiff\n            val nextLeftStr = nextLeftRevDiffStr + nextLeft\n            val nextRightStr = nextLeftRev\n            val nextStr = nextLeftStr + nextRightStr\n            nextStr.toLong\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123088,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpp_3i3nmo.scala:41)\n\tat Problem.main(tmpp_3i3nmo.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val str = num.toString\n        val len = str.length\n        val half = len / 2\n        val left = str.substring(0, half)\n        val right = str.substring(half + len % 2)\n        val leftRev = left.reverse\n        val leftRevNum = leftRev.toLong\n        val rightNum = right.toLong\n        if (leftRevNum >= rightNum) {\n            val nextLeft = (left.toLong + 1).toString\n            val nextLeftRev = nextLeft.reverse\n            val nextLeftRevNum = nextLeftRev.toLong\n            val nextRightNum = nextLeftRevNum\n            val nextRight = nextRightNum.toString\n            val nextStr = nextLeft + nextRight\n            nextStr.toLong\n        } else {\n            val nextLeft = left\n            val nextLeftRev = nextLeft.reverse\n            val nextLeftRevNum = nextLeftRev.toLong\n            val nextRightNum = nextLeftRevNum\n            val nextRight = nextRightNum.toString\n            val nextStr = nextLeft + nextRight\n            nextStr.toLong\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123088,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpbgq9srtv.scala:35)\n\tat Problem.main(tmpbgq9srtv.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val n = s.length\n        val mid = n / 2\n        val left = s.substring(0, mid)\n        val right = s.substring(n - mid, n)\n        val leftRev = left.reverse\n        if (left == leftRev && right == leftRev) {\n            val leftInc = (left.toLong + 1).toString\n            val leftIncRev = leftInc.reverse\n            val leftIncRevLen = leftIncRev.length\n            val leftIncRevPad = if (leftIncRevLen < mid) leftIncRev + \"0\" * (mid - leftIncRevLen) else leftIncRev\n            leftInc + leftIncRevPad\n        } else if (left == leftRev && right < leftRev) {\n            left + leftRev\n        } else if (left < leftRev) {\n            val leftInc = (left.toLong + 1).toString\n            val leftIncRev = leftInc.reverse\n            val leftIncRevLen = leftIncRev.length\n            val leftIncRevPad = if (leftIncRevLen < mid) leftIncRev + \"0\" * (mid - leftIncRevLen) else leftIncRev\n            leftInc + leftIncRevPad\n        } else {\n            val leftRevLen = leftRev.length\n            val leftRevPad = if (leftRevLen < mid) leftRev + \"0\" * (mid - leftRevLen) else leftRev\n            leftRev + leftRevPad\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123088,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpsb83azl5.scala:17:12 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            leftInc + leftIncRevPad\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Found:    String\n\u001b[31m   |\u001b[0m            Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpsb83azl5.scala:19:12 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            left + leftRev\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Found:    String\n\u001b[31m   |\u001b[0m            Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpsb83azl5.scala:25:12 --------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            leftInc + leftIncRevPad\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Found:    String\n\u001b[31m   |\u001b[0m            Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpsb83azl5.scala:29:12 --------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            leftRev + leftRevPad\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Found:    String\n\u001b[31m   |\u001b[0m            Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var digits = new ArrayBuffer[Int]\n        while (n > 0) {\n            digits += (n % 10).toInt\n            n /= 10\n        }\n        var i = 0\n        while (i < digits.length / 2) {\n            if (digits(i) < digits(digits.length - 1 - i)) {\n                digits(digits.length - 1 - i) = digits(i)\n            } else if (digits(i) > digits(digits.length - 1 - i)) {\n                digits(digits.length - 1 - i) = digits(i)\n                var j = digits.length - 2 - i\n                while (j >= 0 && digits(j) == 9) {\n                    digits(j) = 0\n                    j -= 1\n                }\n                if (j < 0) {\n                    digits += 0\n                    digits(0) = 1\n                } else {\n                    digits(j) += 1\n                }\n            }\n            i += 1\n        }\n        var result = 0L\n        for (i <- 0 until digits.length) {\n            result = result * 10 + digits(i)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123089,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpu3vm5of9.scala:39)\n\tat Problem.main(tmpu3vm5of9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var digits = new ArrayBuffer[Int]()\n        while (n > 0) {\n            digits += (n % 10).toInt\n            n /= 10\n        }\n        var i = 0\n        var j = digits.length - 1\n        while (i < j) {\n            if (digits(i) < digits(j)) {\n                digits(j) = digits(i)\n                i += 1\n                j -= 1\n            } else if (digits(i) > digits(j)) {\n                digits(j) = digits(i)\n                i += 1\n                j -= 1\n                var carry = 1\n                var k = j + 1\n                while (carry > 0) {\n                    if (k == digits.length) {\n                        digits += 1\n                        carry = 0\n                    } else {\n                        digits(k) += 1\n                        if (digits(k) == 10) digits(k) = 0\n                        else carry = 0\n                        k += 1\n                    }\n                }\n            } else {\n                i += 1\n                j -= 1\n            }\n        }\n        var result = 0L\n        for (i <- 0 until digits.length) result = result * 10 + digits(i)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123089,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp8uewfkal.scala:46)\n\tat Problem.main(tmp8uewfkal.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var digits = new ArrayBuffer[Int]()\n        while (n > 0) {\n            digits += (n % 10).toInt\n            n /= 10\n        }\n        var i = 0\n        while (i < digits.length / 2) {\n            if (digits(i) != digits(digits.length - 1 - i)) {\n                if (digits(i) > digits(digits.length - 1 - i)) {\n                    digits(digits.length - 1 - i) = digits(i)\n                } else {\n                    digits(digits.length - 1 - i) = digits(i)\n                    var j = digits.length - 1 - i - 1\n                    while (j >= 0) {\n                        if (digits(j) < 9) {\n                            digits(j) += 1\n                            break\n                        } else {\n                            digits(j) = 0\n                            j -= 1\n                        }\n                    }\n                    if (j < 0) {\n                        digits.insert(0, 1)\n                    }\n                }\n            }\n            i += 1\n        }\n        var result = 0L\n        for (i <- 0 until digits.length) {\n            result = result * 10 + digits(i)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123085,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp04leb_nv.scala:23:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                            break\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var digits = new ArrayBuffer[Int]\n        while (n > 0) {\n            digits += (n % 10).toInt\n            n /= 10\n        }\n        var i = 0\n        var j = digits.length - 1\n        while (i < j) {\n            if (digits(i) < digits(j)) {\n                digits(j) = digits(i)\n            } else if (digits(i) > digits(j)) {\n                digits(j) = digits(i)\n                var k = j - 1\n                while (k >= 0 && digits(k) == 9) {\n                    digits(k) = 0\n                    k -= 1\n                }\n                if (k < 0) {\n                    digits.insert(0, 1)\n                } else {\n                    digits(k) += 1\n                }\n            }\n            i += 1\n            j -= 1\n        }\n        var result = 0L\n        for (i <- 0 until digits.length) {\n            result = result * 10 + digits(i)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123089,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmplwt3r2c7.scala:40)\n\tat Problem.main(tmplwt3r2c7.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val str = num.toString\n        val len = str.length\n        val half = len / 2\n        val left = str.substring(0, half)\n        val right = str.substring(half + len % 2, len)\n        val leftInt = left.toInt\n        val rightInt = right.toInt\n        if (leftInt == rightInt) {\n            val next = leftInt + 1\n            val nextStr = next.toString\n            val nextLen = nextStr.length\n            val nextHalf = nextLen / 2\n            val nextLeft = nextStr.substring(0, nextHalf)\n            val nextRight = nextStr.substring(nextHalf + nextLen % 2, nextLen)\n            val nextLeftInt = nextLeft.toInt\n            val nextRightInt = nextRight.toInt\n            if (nextLeftInt == nextRightInt) {\n                val nextNext = nextLeftInt + 1\n                val nextNextStr = nextNext.toString\n                val nextNextLen = nextNextStr.length\n                val nextNextHalf = nextNextLen / 2\n                val nextNextLeft = nextNextStr.substring(0, nextNextHalf)\n                val nextNextRight = nextNextStr.substring(nextNextHalf + nextNextLen % 2, nextNextLen)\n                val nextNextLeftInt = nextNextLeft.toInt\n                val nextNextRightInt = nextNextRight.toInt\n                if (nextNextLeftInt == nextNextRightInt) {\n                    val nextNextNext = nextNextLeftInt + 1\n                    val nextNextNextStr = nextNextNext.toString\n                    val nextNextNextLen = nextNextNextStr.length\n                    val nextNextNextHalf = nextNextNextLen / 2\n                    val nextNextNextLeft = nextNextNextStr.substring(0, nextNextNextHalf)\n                    val nextNextNextRight = nextNextNextStr.substring(nextNextNextHalf + nextNextNextLen % 2, nextNextNextLen)\n                    val nextNextNextLeftInt = nextNextNextLeft.toInt\n                    val nextNextNextRightInt = nextNextNextRight.toInt\n                    if (nextNextNextLeftInt == nextNextNextRightInt) {\n                        val nextNextNextNext = nextNext\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123085,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpllenz1av.scala:50:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpllenz1av.scala:13:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mif\u001b[0m (leftInt == rightInt) {\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    Unit\n\u001b[31m   |\u001b[0m        Required: Long\n\u001b[31m   |\u001b[0m        Maybe you are missing an else part for the conditional?\n\u001b[31m14 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnext\u001b[0m = leftInt + \u001b[31m1\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnextStr\u001b[0m = next.toString\n\u001b[31m16 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnextLen\u001b[0m = nextStr.length\n\u001b[31m17 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnextHalf\u001b[0m = nextLen / \u001b[31m2\u001b[0m\n\u001b[31m18 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnextLeft\u001b[0m = nextStr.substring(\u001b[31m0\u001b[0m, nextHalf)\n\u001b[31m19 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnextRight\u001b[0m = nextStr.substring(nextHalf + nextLen % \u001b[31m2\u001b[0m, nextLen)\n\u001b[31m20 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnextLeftInt\u001b[0m = nextLeft.toInt\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnextRightInt\u001b[0m = nextRight.toInt\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m (nextLeftInt == nextRightInt) {\n\u001b[31m23 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mnextNext\u001b[0m = nextLeftInt + \u001b[31m1\u001b[0m\n\u001b[31m24 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mnextNextStr\u001b[0m = nextNext.toString\n\u001b[31m25 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mnextNextLen\u001b[0m = nextNextStr.length\n\u001b[31m26 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mnextNextHalf\u001b[0m = nextNextLen / \u001b[31m2\u001b[0m\n\u001b[31m27 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mnextNextLeft\u001b[0m = nextNextStr.substring(\u001b[31m0\u001b[0m, nextNextHalf)\n\u001b[31m28 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mnextNextRight\u001b[0m = nextNextStr.substring(nextNextHalf + nextNextLen % \u001b[31m2\u001b[0m, nextNextLen)\n\u001b[31m29 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mnextNextLeftInt\u001b[0m = nextNextLeft.toInt\n\u001b[31m30 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mnextNextRightInt\u001b[0m = nextNextRight.toInt\n\u001b[31m31 |\u001b[0m   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val digits = num.toString.toList.map(_.asDigit)\n        val n = digits.length\n        val half = n / 2\n        val left = digits.take(half)\n        val right = digits.takeRight(half).reverse\n        val leftPalindrome = left ++ left.reverse\n        val rightPalindrome = right ++ right.reverse\n        val leftPalindromeNum = leftPalindrome.foldLeft(0)((acc, x) => acc * 10 + x)\n        val rightPalindromeNum = rightPalindrome.foldLeft(0)((acc, x) => acc * 10 + x)\n        if (leftPalindromeNum < rightPalindromeNum) {\n            if (n % 2 == 0) leftPalindromeNum * pow(10, half).toLong\n            else leftPalindromeNum * pow(10, half + 1).toLong\n        }\n        else {\n            val leftPlusOne = left.map(_ + 1)\n            val leftPlusOnePalindrome = leftPlusOne ++ leftPlusOne.reverse\n            val leftPlusOnePalindromeNum = leftPlusOnePalindrome.foldLeft(0)((acc, x) => acc * 10 + x)\n            if (n % 2 == 0) leftPlusOnePalindromeNum * pow(10, half).toLong\n            else leftPlusOnePalindromeNum * pow(10, half + 1).toLong\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123091,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpohtfq2ya.scala:28)\n\tat Problem.main(tmpohtfq2ya.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val str = num.toString\n        val len = str.length\n        val half = len / 2\n        val (left, right) = str.splitAt(half)\n        val (leftNum, rightNum) = (left.toLong, right.reverse.toLong)\n        if (leftNum == rightNum) {\n            val nextLeft = (leftNum + 1).toString\n            val nextRight = nextLeft.reverse\n            val nextLen = nextLeft.length\n            if (nextLen > half) {\n                nextLeft.toLong * pow(10, len).toLong + nextRight.toLong\n            } else {\n                nextLeft.toLong * pow(10, half).toLong + nextRight.toLong\n            }\n        } else if (leftNum < rightNum) {\n            val nextLeft = left\n            val nextRight = nextLeft.reverse\n            nextLeft.toLong * pow(10, half).toLong + nextRight.toLong\n        } else {\n            val nextLeft = (leftNum + 1).toString\n            val nextRight = nextLeft.reverse\n            nextLeft.toLong * pow(10, half).toLong + nextRight.toLong\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123091,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmphpl1ch0e.scala:31)\n\tat Problem.main(tmphpl1ch0e.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        while (true) {\n            n += 1\n            if (isPalindrome(n)) return n\n        }\n        return -1\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123066,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3skv3vcx.scala:9:16 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m            \u001b[33mif\u001b[0m (isPalindrome(n)) \u001b[33mreturn\u001b[0m n\n\u001b[31m\u001b[31m  |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                Not found: isPalindrome\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        def isPalindrome(num : Long) : Boolean = {\n            val str = num.toString\n            str == str.reverse\n        }\n        def nextSmallestPalindrome(num : Long, i : Int) : Long = {\n            if (i == 0) num\n            else {\n                val str = num.toString\n                val len = str.length\n                val half = len / 2\n                val left = str.substring(0, half)\n                val right = str.substring(half + (len % 2), len)\n                val leftInt = left.toInt\n                val rightInt = right.toInt\n                if (leftInt == rightInt) nextSmallestPalindrome(num, i - 1)\n                else {\n                    val nextLeft = (leftInt + 1).toString\n                    val nextRight = nextLeft.reverse\n                    val nextStr = nextLeft + nextRight.substring(0, right.length)\n                    nextSmallestPalindrome(nextStr.toLong, i - 1)\n                }\n            }\n        }\n        nextSmallestPalindrome(num, num.toString.length)\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123091,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpm5w1q_vn.scala:32)\n\tat Problem.main(tmpm5w1q_vn.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var digits = new ArrayBuffer[Int]\n        while (n > 0) {\n            digits += (n % 10).toInt\n            n /= 10\n        }\n        var i = 0\n        while (i < digits.length / 2) {\n            if (digits(i) != digits(digits.length - 1 - i)) {\n                digits(digits.length - 1 - i) = digits(i)\n                var j = digits.length - 1 - i - 1\n                while (j >= 0 && digits(j) == 9) {\n                    digits(j) = 0\n                    j -= 1\n                }\n                if (j >= 0) digits(j) += 1\n                else digits.insert(0, 1)\n            }\n            i += 1\n        }\n        var result = 0L\n        for (i <- 0 until digits.length) result = result * 10 + digits(i)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123092,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp1swuqa7u.scala:31)\n\tat Problem.main(tmp1swuqa7u.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var isPalindrome = false\n        while (!isPalindrome) {\n            n += 1\n            isPalindrome = true\n            val s = n.toString\n            for (i <- 0 until s.length / 2) {\n                if (s(i) != s(s.length - 1 - i)) {\n                    isPalindrome = false\n                    break\n                }\n            }\n        }\n        n\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123087,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7cuucvye.scala:15:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m                    break\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var i = 0\n        while (true) {\n            if (isPalindrome(n)) return n\n            n = num - i\n            i += 1\n        }\n        return -1\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123062,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6bb_b7ra.scala:9:16 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m            \u001b[33mif\u001b[0m (isPalindrome(n)) \u001b[33mreturn\u001b[0m n\n\u001b[31m\u001b[31m  |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                Not found: isPalindrome\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val digits = num.toString.toList.map(_.toString.toInt)\n        val n = digits.length\n        val half = n / 2\n        val left = digits.take(half)\n        val right = digits.drop(n - half).reverse\n        if (left.reverse == right) {\n            val nextLeft = (left.reverse.mkString.toLong + 1).toString.toList.map(_.toString.toInt)\n            val nextRight = nextLeft.reverse\n            val nextDigits = nextLeft ++ nextRight.drop(n % 2)\n            nextDigits.mkString.toLong\n        } else {\n            val nextLeft = left.reverse\n            val nextRight = nextLeft.reverse\n            val nextDigits = nextLeft ++ nextRight.drop(n % 2)\n            nextDigits.mkString.toLong\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123093,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpqqkezbq1.scala:24)\n\tat Problem.main(tmpqqkezbq1.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        def isPalindrome(num : Long) : Boolean = {\n            val str = num.toString\n            str == str.reverse\n        }\n        var n = num\n        while (!isPalindrome(n)) n -= 1\n        n\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123079,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmplf31x817.scala:15)\n\tat Problem.main(tmplf31x817.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val str = num.toString\n        val len = str.length\n        val half = len / 2\n        val left = str.substring(0, half)\n        val right = str.substring(half + len % 2)\n        val leftRev = left.reverse\n        val leftRevInt = leftRev.toInt\n        val rightInt = right.toInt\n        if (leftRevInt < rightInt) {\n            val newLeft = (leftRevInt + 1).toString\n            val newLeftRev = newLeft.reverse\n            val newLeftRevLen = newLeftRev.length\n            val newLeftLen = newLeft.length\n            val newLeftRevPadding = \"0\" * (half - newLeftRevLen)\n            val newLeftPadding = \"0\" * (half - newLeftLen)\n            val newLeftRevStr = newLeftRevPadding + newLeftRev\n            val newLeftStr = newLeftPadding + newLeft\n            val newStr = newLeftRevStr + newLeftStr\n            if (len % 2 == 1) newStr + newLeftStr(0) else newStr\n        } else {\n            val newLeftRev = leftRev\n            val newLeftRevLen = newLeftRev.length\n            val newLeftRevPadding = \"0\" * (half - newLeftRevLen)\n            val newLeftRevStr = newLeftRevPadding + newLeftRev\n            val newStr = newLeftRevStr + newLeftRevStr\n            if (len % 2 == 1) newStr + newLeftRevStr(0) else newStr\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123092,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp79q8zhta.scala:24:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mif\u001b[0m (len % \u001b[31m2\u001b[0m == \u001b[31m1\u001b[0m) newStr + newLeftStr(\u001b[31m0\u001b[0m) \u001b[33melse\u001b[0m newStr\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    String\n\u001b[31m   |\u001b[0m                              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp79q8zhta.scala:24:58 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mif\u001b[0m (len % \u001b[31m2\u001b[0m == \u001b[31m1\u001b[0m) newStr + newLeftStr(\u001b[31m0\u001b[0m) \u001b[33melse\u001b[0m newStr\n\u001b[31m\u001b[31m   |\u001b[0m                                                          ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                             Found:    (newStr : String)\n\u001b[31m   |\u001b[0m                                             Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp79q8zhta.scala:31:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            \u001b[33mif\u001b[0m (len % \u001b[31m2\u001b[0m == \u001b[31m1\u001b[0m) newStr + newLeftRevStr(\u001b[31m0\u001b[0m) \u001b[33melse\u001b[0m newStr\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    String\n\u001b[31m   |\u001b[0m                              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp79q8zhta.scala:31:61 --------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            \u001b[33mif\u001b[0m (len % \u001b[31m2\u001b[0m == \u001b[31m1\u001b[0m) newStr + newLeftRevStr(\u001b[31m0\u001b[0m) \u001b[33melse\u001b[0m newStr\n\u001b[31m\u001b[31m   |\u001b[0m                                                             ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                             Found:    (newStr : String)\n\u001b[31m   |\u001b[0m                                             Required: Long\n\u001b[31m ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var i = 0\n        while (n > 0) {\n            n /= 10\n            i += 1\n        }\n        var j = i / 2\n        var k = i - j\n        var m = num\n        var l = 0\n        while (j > 0) {\n            l = l * 10 + m % 10\n            m /= 10\n            j -= 1\n        }\n        if (i % 2 == 1) m /= 10\n        while (m > 0) {\n            l = l * 10 + m % 10\n            m /= 10\n        }\n        l\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123091,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn6ku7v9_.scala:17:16 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            l = l * \u001b[31m10\u001b[0m + m % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Found:    Long\n\u001b[31m   |\u001b[0m                Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn6ku7v9_.scala:23:16 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            l = l * \u001b[31m10\u001b[0m + m % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Found:    Long\n\u001b[31m   |\u001b[0m                Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var digits = new ArrayBuffer[Int]()\n        while (n > 0) {\n            digits += (n % 10).toInt\n            n /= 10\n        }\n        var i = 0\n        var j = digits.length - 1\n        while (i < j) {\n            if (digits(i) > digits(j)) {\n                digits(j) = digits(i)\n            } else if (digits(i) < digits(j)) {\n                digits(j) = digits(i)\n                var k = j - 1\n                while (k >= 0 && digits(k) == 9) {\n                    digits(k) = 0\n                    k -= 1\n                }\n                if (k >= 0) {\n                    digits(k) += 1\n                } else {\n                    digits += 1\n                }\n            }\n            i += 1\n            j -= 1\n        }\n        var result = 0L\n        for (digit <- digits) {\n            result = result * 10 + digit\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123092,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpvv68tu44.scala:40)\n\tat Problem.main(tmpvv68tu44.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        def isPalindrome(num : Long) : Boolean = {\n            val str = num.toString\n            str == str.reverse\n        }\n        def nextSmallestPalindrome(num : Long, digits : Int) : Long = {\n            if (digits == 1) {\n                if (num == 9) return 11\n                else return num + 2\n            }\n            val half = digits / 2\n            val firstHalf = num / pow(10, half).toLong\n            val firstHalfStr = firstHalf.toString\n            val secondHalf = num % pow(10, half).toLong\n            val secondHalfStr = secondHalf.toString\n            val secondHalfReversed = secondHalfStr.reverse\n            val secondHalfReversedInt = secondHalfReversed.toLong\n            val secondHalfReversedIntPadded = secondHalfReversedInt * pow(10, half).toLong\n            val secondHalfReversedIntPaddedPlusOne = secondHalfReversedIntPadded + pow(10, half).toLong\n            val secondHalfReversedIntPaddedPlusOneStr = secondHalfReversedIntPaddedPlusOne.toString\n            val secondHalfReversedIntPaddedPlusOneStrReversed = secondHalfReversedIntPaddedPlusOneStr.reverse\n            val secondHalfReversedIntPaddedPlusOneStrReversedInt = secondHalfReversedIntPaddedPlusOneStrReversed.toLong\n            val secondHalfReversedIntPaddedPlusOneStrReversedIntPadded = secondHalfReversedIntPaddedPlusOneStrReversedInt * pow(10, half).toLong\n            val secondHalfReversedIntPaddedPlusOneStrReversedIntPaddedPlusOne = secondHalfReversedIntPaddedPlusOneStrReversedIntPadded + pow(10, half).toLong\n            val secondHalfReversedIntPaddedPlusOneStrReversedIntPaddedPlusOneStr = secondHalfReversedIntPaddedPlusOneStrReversedIntPaddedPlusOne.toString\n            val secondHalfReversedIntPaddedPlusOneStrReversedIntPaddedPlusOneStrReversed = secondHalfReversedIntPaddedPlus\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123093,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpna2q991m.scala:39:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpna2q991m.scala:30:91 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36msecondHalfReversedIntPaddedPlusOneStrReversedIntPaddedPlusOneStrReversed\u001b[0m = secondHalfReversedIntPaddedPlus\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: secondHalfReversedIntPaddedPlus\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpna2q991m.scala:31:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpna2q991m.scala:33:33 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m    assert(nextSmallestPalindrome((\u001b[31m99l\u001b[0m)) == (\u001b[31m101l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter digits of \u001b[33mmethod\u001b[0m \u001b[35mnextSmallestPalindrome\u001b[0m: (num: Long, digits: Int): Long\n\u001b[31m\u001b[31m-- Error: /tmp/tmpna2q991m.scala:34:33 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m    assert(nextSmallestPalindrome((\u001b[31m1221l\u001b[0m)) == (\u001b[31m1331l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter digits of \u001b[33mmethod\u001b[0m \u001b[35mnextSmallestPalindrome\u001b[0m: (num: Long, digits: Int): Long\n\u001b[31m\u001b[31m-- Error: /tmp/tmpna2q991m.scala:35:33 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m    assert(nextSmallestPalindrome((\u001b[31m120l\u001b[0m)) == (\u001b[31m121l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^^^^^^^^^^^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val n = s.length\n        val half = n / 2\n        val left = s.substring(0, half)\n        val right = s.substring(half + n % 2)\n        val leftReverse = left.reverse\n        val leftReverseLong = leftReverse.toLong\n        val leftLong = left.toLong\n        val rightLong = right.toLong\n        if (leftReverseLong > rightLong) {\n            val newLeft = (leftLong - 1).toString\n            val newLeftReverse = newLeft.reverse\n            val newLeftReverseLong = newLeftReverse.toLong\n            val newLeftLong = newLeft.toLong\n            if (newLeftReverseLong > rightLong) {\n                val newRight = (newLeftLong - 1).toString\n                val newRightReverse = newRight.reverse\n                val newRightReverseLong = newRightReverse.toLong\n                val newRightLong = newRight.toLong\n                if (newRightReverseLong > newLeftLong) {\n                    val newNewRight = (newRightLong - 1).toString\n                    val newNewRightReverse = newNewRight.reverse\n                    val newNewRightReverseLong = newNewRightReverse.toLong\n                    val newNewRightLong = newNewRight.toLong\n                    if (newNewRightReverseLong > newLeftLong) {\n                        val newNewLeft = (newLeftLong - 1).toString\n                        val newNewLeftReverse = newNewLeft.reverse\n                        val newNewLeftReverseLong = newNewLeftReverse.toLong\n                        val newNewLeftLong = newNewLeft.toLong\n                        if (newNewLeftReverseLong > newNewRightLong) {\n                            val newNewNewRight = (newNewRightLong - 1).toString\n                            val newNewNewRightReverse = newNewNewRight.reverse\n                            val newNewNewRightReverseLong = newNewNewRightReverse.toLong\n                            val newNewNewRightLong = newNewNewRight.toLong\n                            if (newNewNew\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123090,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmptluywlz0.scala:41:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmptluywlz0.scala:49:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptluywlz0.scala:40:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m                            \u001b[33mif\u001b[0m (newNewNew\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: newNewNew\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmptluywlz0.scala:42:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m42 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val digits = num.toString.toList.map(_.toString.toInt)\n        val n = digits.length\n        val half = n / 2\n        val left = digits.slice(0, half)\n        val right = digits.slice(half + n % 2, n)\n        val leftRev = left.reverse\n        val rightRev = right.reverse\n        val leftRevStr = leftRev.mkString\n        val rightRevStr = rightRev.mkString\n        val leftRevNum = leftRevStr.toLong\n        val rightRevNum = rightRevStr.toLong\n        val leftNum = left.mkString.toLong\n        val rightNum = right.mkString.toLong\n        if (leftRevNum < rightRevNum) {\n            val leftStr = left.mkString\n            val rightStr = leftRevStr\n            val leftStrNum = leftStr.toLong\n            val rightStrNum = rightStr.toLong\n            if (leftStrNum < rightStrNum) {\n                val leftStrNumPlusOne = leftStrNum + 1\n                val leftStrNumPlusOneStr = leftStrNumPlusOne.toString\n                val leftStrNumPlusOneStrRev = leftStrNumPlusOneStr.reverse\n                val leftStrNumPlusOneStrRevNum = leftStrNumPlusOneStrRev.toLong\n                val leftStrNumPlusOneStrNum = leftStrNumPlusOneStr.toLong\n                if (leftStrNumPlusOneStrNum < leftStrNumPlusOneStrRevNum) {\n                    val leftStrNumPlusOneStrRevNumStr = leftStrNumPlusOneStrRevNum.toString\n                    val leftStrNumPlusOneStrRevNumStrRev = leftStrNumPlusOneStrRevNumStr.reverse\n                    val leftStrNumPlusOneStrRevNumStrRevNum = leftStrNumPlusOneStrRevNumStrRev.toLong\n                    val leftStrNumPlusOneStrRevNumStrNum = leftStrNumPlusOneStrRevNumStr.toLong\n                    if (leftStrNumPlusOneStrRevNumStrNum < leftStrNumPlusOneStrRevNumStrRevNum) {\n                        val leftStrNumPlusOneStrRevNumStrRevNumStr = leftStrNumPlusOneStrRevNumStrRevNum.toString\n                        val leftStr\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123092,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp1fml40ar.scala:38:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp1fml40ar.scala:46:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[33m\u001b[33m-- Warning: /tmp/tmp1fml40ar.scala:39:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m39 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var digits = new ArrayBuffer[Int]()\n        while (n > 0) {\n            digits += (n % 10).toInt\n            n /= 10\n        }\n        var i = 0\n        while (i < digits.length / 2) {\n            if (digits(i) != digits(digits.length - 1 - i)) {\n                if (digits(i) > digits(digits.length - 1 - i)) {\n                    digits(digits.length - 1 - i) = digits(i)\n                } else {\n                    digits(i) = digits(digits.length - 1 - i)\n                }\n            }\n            i += 1\n        }\n        var result = 0L\n        for (i <- 0 until digits.length) {\n            result = result * 10 + digits(i)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123096,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpzgzv_uty.scala:30)\n\tat Problem.main(tmpzgzv_uty.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        while(true) {\n            n += 1\n            if(isPalindrome(n)) return n\n        }\n        return -1\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1665517289,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8ynnkoj1.scala:9:15 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m            \u001b[33mif\u001b[0m(isPalindrome(n)) \u001b[33mreturn\u001b[0m n\n\u001b[31m\u001b[31m  |\u001b[0m               ^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m               Not found: isPalindrome\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val n = s.length\n        val half = n / 2\n        val left = s.substring(0, half)\n        val right = s.substring(half + (if (n % 2 == 0) 0 else 1), n)\n        val leftRev = left.reverse\n        val rightRev = right.reverse\n        if (leftRev > right) {\n            val leftInc = (left.toLong + 1).toString\n            val leftIncRev = leftInc.reverse\n            val leftIncRevPadded = leftIncRev.padTo(half, '0')\n            val leftIncPadded = leftInc.padTo(half, '0')\n            val mid = if (n % 2 == 0) \"\" else leftInc.last.toString\n            (leftIncPadded + mid + leftIncRevPadded).toLong\n        } else {\n            val leftRevPadded = leftRev.padTo(half, '0')\n            val leftPadded = left.padTo(half, '0')\n            val mid = if (n % 2 == 0) \"\" else left.last.toString\n            (leftPadded + mid + leftRevPadded).toLong\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123095,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpf3i9y1mw.scala:28)\n\tat Problem.main(tmpf3i9y1mw.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        def isPalindrome(num : Long) : Boolean = {\n            val str = num.toString\n            str == str.reverse\n        }\n        def nextPalindrome(num : Long) : Long = {\n            var n = num\n            while (!isPalindrome(n)) n += 1\n            n\n        }\n        nextPalindrome(num + 1)\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123067,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val n = s.length\n        if (n == 1) return num + 1\n        val mid = n / 2\n        val left = s.substring(0, mid)\n        val right = s.substring(mid + n % 2)\n        val leftNum = left.toLong\n        val rightNum = right.toLong\n        if (leftNum == rightNum) {\n            val nextLeft = (leftNum + 1).toString\n            val nextRight = nextLeft.substring(0, mid)\n            val nextLeftNum = nextLeft.toLong\n            val nextRightNum = nextRight.toLong\n            if (nextLeftNum == nextRightNum) {\n                val nextLeftNumStr = nextLeftNum.toString\n                val nextRightNumStr = nextRightNum.toString\n                val nextLeftNumStrLen = nextLeftNumStr.length\n                val nextRightNumStrLen = nextRightNumStr.length\n                val nextLeftNumStrLenDiff = mid - nextLeftNumStrLen\n                val nextRightNumStrLenDiff = mid - nextRightNumStrLen\n                val nextLeftNumStrPadded = \"1\" * nextLeftNumStrLenDiff + nextLeftNumStr\n                val nextRightNumStrPadded = \"1\" * nextRightNumStrLenDiff + nextRightNumStr\n                val nextLeftNumStrPaddedLen = nextLeftNumStrPadded.length\n                val nextRightNumStrPaddedLen = nextRightNumStrPadded.length\n                val nextLeftNumStrPaddedLenDiff = mid - nextLeftNumStrPaddedLen\n                val nextRightNumStrPaddedLenDiff = mid - nextRightNumStrPaddedLen\n                val nextLeftNumStrPaddedPadded = \"0\" * nextLeftNumStrPaddedLenDiff + nextLeftNumStrPadded\n                val nextRightNumStrPaddedPadded = \"0\" * nextRightNumStrPaddedLenDiff + nextRightNumStrPadded\n                val nextLeftNumStrPaddedPaddedLen = nextLeftNumStrPaddedPadded.length\n                val nextRightNumStrPaddedPaddedLen = nextRightNumStrPaddedPadded.length\n                val nextLeftNumStrPaddedPaddedLenDiff = mid - next\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123092,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpcewt9s1w.scala:45:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpcewt9s1w.scala:36:62 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mnextLeftNumStrPaddedPaddedLenDiff\u001b[0m = mid - next\n\u001b[31m\u001b[31m   |\u001b[0m                                                              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                         Not found: next\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpcewt9s1w.scala:38:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m38 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        def isPalindrome(num : Long) : Boolean = {\n            val str = num.toString\n            str == str.reverse\n        }\n        def nextSmallestPalindrome(num : Long, i : Int) : Long = {\n            if (i == 0) num\n            else {\n                val str = num.toString\n                val len = str.length\n                val (left, right) = str.splitAt(len / 2)\n                val leftInt = left.toInt\n                val rightInt = right.toInt\n                val nextLeftInt = leftInt + pow(10, i).toInt\n                val nextRightInt = nextLeftInt.toString.reverse.toInt\n                val nextNum = nextLeftInt * pow(10, len - i).toInt + nextRightInt\n                if (nextNum > num) nextNum\n                else nextSmallestPalindrome(num, i - 1)\n            }\n        }\n        nextSmallestPalindrome(num, num.toString.length / 2)\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123096,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp4jv4m8mq.scala:28)\n\tat Problem.main(tmp4jv4m8mq.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val n = s.length\n        val half = n / 2\n        val isEven = n % 2 == 0\n        val left = s.substring(0, half)\n        val right = s.substring(half + (if (isEven) 0 else 1), n)\n        val leftRev = left.reverse\n        if (leftRev > right) {\n            val leftInc = (BigInt(left) + 1).toString\n            val leftIncRev = leftInc.reverse\n            val leftIncRevPadded = leftIncRev.padTo(half, '0')\n            val leftIncPadded = leftInc.padTo(half, '0')\n            val rightPadded = right.padTo(half, '0')\n            if (leftIncRevPadded > rightPadded) leftInc + leftIncRevPadded\n            else leftIncPadded + leftIncRevPadded\n        }\n        else left + leftRev\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123095,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnqglbvd4.scala:19:48 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mif\u001b[0m (leftIncRevPadded > rightPadded) leftInc + leftIncRevPadded\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                Found:    String\n\u001b[31m   |\u001b[0m                                                Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnqglbvd4.scala:20:17 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            \u001b[33melse\u001b[0m leftIncPadded + leftIncRevPadded\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 Found:    String\n\u001b[31m   |\u001b[0m                 Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnqglbvd4.scala:22:13 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33melse\u001b[0m left + leftRev\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m             Found:    String\n\u001b[31m   |\u001b[0m             Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var digits = new ArrayBuffer[Int]()\n        while (n > 0) {\n            digits += (n % 10).toInt\n            n /= 10\n        }\n        var i = 0\n        while (i < digits.length / 2) {\n            if (digits(i) < digits(digits.length - 1 - i)) {\n                digits(digits.length - 1 - i) = digits(i)\n            }\n            else if (digits(i) > digits(digits.length - 1 - i)) {\n                digits(digits.length - 1 - i) = digits(i)\n                var j = digits.length - 2 - i\n                while (j >= 0 && digits(j) == 9) {\n                    digits(j) = 0\n                    j -= 1\n                }\n                if (j >= 0) digits(j) += 1\n                else digits += 1\n            }\n            i += 1\n        }\n        var result = 0L\n        for (i <- 0 until digits.length) result = result * 10 + digits(i)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123099,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp57f_3rgn.scala:34)\n\tat Problem.main(tmp57f_3rgn.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var digits = 0\n        while (n > 0) {\n            digits += 1\n            n /= 10\n        }\n        var left = digits / 2\n        var right = digits - left\n        var leftNum = num / pow(10, right).toLong\n        var rightNum = num % pow(10, right).toLong\n        if (leftNum == pow(10, left) - 1) {\n            var newLeft = pow(10, left - 1).toLong\n            var newRight = pow(10, right).toLong - 1\n            return newLeft * newRight\n        }\n        var newLeft = leftNum + 1\n        var newRight = newLeft\n        if (digits % 2 == 1) newRight /= 10\n        newRight = reverse(newRight)\n        return newLeft * pow(10, right).toLong + newRight\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123095,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpn7zgopy5.scala:24:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        newRight = reverse(newRight)\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: reverse\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val digits = num.toString.toList.map(_.toString.toInt)\n        val n = digits.length\n        val half = n / 2\n        val left = digits.take(half)\n        val right = digits.takeRight(half).reverse\n        val leftPalindrome = left.reverse\n        val rightPalindrome = right.reverse\n        val leftPalindromeNum = leftPalindrome.foldLeft(0)((a, b) => a * 10 + b)\n        val rightPalindromeNum = rightPalindrome.foldLeft(0)((a, b) => a * 10 + b)\n        if (leftPalindromeNum < rightPalindromeNum) {\n            val palindrome = leftPalindrome ++ rightPalindrome\n            palindrome.foldLeft(0L)((a, b) => a * 10 + b)\n        } else {\n            val leftPalindromeNum = leftPalindrome.foldLeft(0)((a, b) => a * 10 + b)\n            val nextLeftPalindromeNum = leftPalindromeNum + 1\n            val nextLeftPalindrome = nextLeftPalindromeNum.toString.toList.map(_.toString.toInt)\n            val nextPalindrome = nextLeftPalindrome ++ nextLeftPalindrome.reverse.drop(n % 2)\n            nextPalindrome.foldLeft(0L)((a, b) => a * 10 + b)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123100,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpl70wzy4y.scala:27)\n\tat Problem.main(tmpl70wzy4y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        def isPalindrome(num : Long) : Boolean = {\n            val str = num.toString\n            str == str.reverse\n        }\n        def nextSmallestPalindrome(num : Long, i : Int) : Long = {\n            if (i == 0) return num\n            if (isPalindrome(num)) return num\n            val str = num.toString\n            val half = str.length / 2\n            val left = str.substring(0, half)\n            val right = str.substring(half + str.length % 2)\n            val next = left + right.reverse\n            if (next.toLong < num) nextSmallestPalindrome(next.toLong + pow(10, half).toLong, i - 1)\n            else nextSmallestPalindrome(next.toLong, i - 1)\n        }\n        nextSmallestPalindrome(num, 10)\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123099,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp5g1c8ah2.scala:24)\n\tat Problem.main(tmp5g1c8ah2.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val str = num.toString\n        val len = str.length\n        val half = len / 2\n        val left = str.substring(0, half)\n        val right = str.substring(half + len % 2)\n        val leftRev = left.reverse\n        val leftInt = left.toInt\n        val leftRevInt = leftRev.toInt\n        if (leftRevInt > right.toInt) {\n            val leftIntInc = leftInt + 1\n            val leftRevInc = leftIntInc.toString.reverse\n            return (leftIntInc + leftRevInc.substring(0, half)).toLong\n        }\n        else {\n            val leftRevInc = leftRevInt + 1\n            val leftRevIncStr = leftRevInc.toString\n            val leftRevIncStrRev = leftRevIncStr.reverse\n            val leftRevIncStrRevLen = leftRevIncStrRev.length\n            return (leftRevIncStr + leftRevIncStrRev.substring(leftRevIncStrRevLen - half)).toLong\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123099,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpkhf_gw6c.scala:29)\n\tat Problem.main(tmpkhf_gw6c.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var digits = new ArrayBuffer[Int]()\n        while (n > 0) {\n            digits += (n % 10).toInt\n            n /= 10\n        }\n        var i = 0\n        var j = digits.length - 1\n        while (i < j) {\n            if (digits(i) < digits(j)) {\n                digits(j) = digits(i)\n                i += 1\n                j -= 1\n            } else if (digits(i) > digits(j)) {\n                digits(j) = digits(i)\n                i += 1\n                j -= 1\n                var k = j\n                while (k >= 0 && digits(k) == 9) {\n                    digits(k) = 0\n                    k -= 1\n                }\n                if (k >= 0) digits(k) += 1\n                else digits += 1\n            } else {\n                i += 1\n                j -= 1\n            }\n        }\n        digits.foldLeft(0L)((a, b) => a * 10 + b)\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123101,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp1wynjtmv.scala:38)\n\tat Problem.main(tmp1wynjtmv.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val n = s.length\n        val half = n / 2\n        val firstHalf = s.substring(0, half)\n        val secondHalf = s.substring(half + (n % 2), n)\n        val firstHalfReversed = firstHalf.reverse\n        val secondHalfReversed = secondHalf.reverse\n        if (firstHalfReversed < secondHalf) {\n            val newFirstHalf = (firstHalf.toLong + 1).toString\n            val newFirstHalfReversed = newFirstHalf.reverse\n            val newSecondHalf = newFirstHalfReversed.substring(0, secondHalf.length)\n            val newSecondHalfReversed = newSecondHalf.reverse\n            (newFirstHalf + newSecondHalfReversed).toLong\n        } else {\n            val newSecondHalf = firstHalfReversed.substring(0, secondHalf.length)\n            val newSecondHalfReversed = newSecondHalf.reverse\n            (firstHalf + newSecondHalfReversed).toLong\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123101,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpm1hbfj6s.scala:26)\n\tat Problem.main(tmpm1hbfj6s.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        def isPalindrome(num : Long) : Boolean = {\n            val str = num.toString\n            str == str.reverse\n        }\n        def nextPalindrome(num : Long) : Long = {\n            if (isPalindrome(num)) num\n            else nextPalindrome(num + 1)\n        }\n        nextPalindrome(num + 1)\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1665517291,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val n = s.length\n        val half = n / 2\n        val left = s.substring(0, half)\n        val right = s.substring(half + n % 2, n)\n        val leftRev = left.reverse\n        if (leftRev > right) {\n            val leftInc = (left.toLong + 1).toString\n            val leftIncRev = leftInc.reverse\n            val leftIncRevLen = leftIncRev.length\n            val leftIncRevPadded = leftIncRev.padTo(half, '0')\n            val leftIncRevPaddedLen = leftIncRevPadded.length\n            val leftIncRevPaddedSub = leftIncRevPadded.substring(leftIncRevLen - half, leftIncRevPaddedLen)\n            val leftIncRevPaddedSubLen = leftIncRevPaddedSub.length\n            val leftIncRevPaddedSubRev = leftIncRevPaddedSub.reverse\n            val leftIncRevPaddedSubRevLen = leftIncRevPaddedSubRev.length\n            val leftIncRevPaddedSubRevPadded = leftIncRevPaddedSubRev.padTo(half, '0')\n            val leftIncRevPaddedSubRevPaddedLen = leftIncRevPaddedSubRevPadded.length\n            val leftIncRevPaddedSubRevPaddedSub = leftIncRevPaddedSubRevPadded.substring(leftIncRevPaddedSubRevLen - half, leftIncRevPaddedSubRevPaddedLen)\n            val leftIncRevPaddedSubRevPaddedSubLen = leftIncRevPaddedSubRevPaddedSub.length\n            val leftIncRevPaddedSubRevPaddedSubRev = leftIncRevPaddedSubRevPaddedSub.reverse\n            val leftIncRevPaddedSubRevPaddedSubRevLen = leftIncRevPaddedSubRevPaddedSubRev.length\n            val leftIncRevPaddedSubRevPaddedSubRevPadded = leftIncRevPaddedSubRevPaddedSubRev.padTo(half, '0')\n            val leftIncRevPaddedSubRevPaddedSubRevPaddedLen = leftIncRevPaddedSubRevPaddedSubRevPadded.length\n            val leftIncRevPaddedSubRev\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123101,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpgx4r9phj.scala:31:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpgx4r9phj.scala:39:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpgx4r9phj.scala:38:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpgx4r9phj.scala:32:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m32 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val digits = num.toString.map(_.asDigit)\n        val n = digits.length\n        val half = n / 2\n        val left = digits.slice(0, half)\n        val right = digits.slice(half + n % 2, n)\n        val left2 = left.reverse\n        if (left2.mkString.toLong > right.mkString.toLong) {\n            val left3 = left.reverse.mkString.toLong\n            val right3 = right.mkString.toLong\n            val left4 = left3.toString.map(_.asDigit)\n            val right4 = right3.toString.map(_.asDigit)\n            val left5 = left4.slice(0, half)\n            val right5 = right4.slice(half + n % 2, n)\n            val left6 = left5.reverse\n            val right6 = right5.reverse\n            val left7 = left6.mkString.toLong\n            val right7 = right6.mkString.toLong\n            val left8 = left7.toString.map(_.asDigit)\n            val right8 = right7.toString.map(_.asDigit)\n            val left9 = left8.slice(0, half)\n            val right9 = right8.slice(half + n % 2, n)\n            val left10 = left9.reverse\n            val right10 = right9.reverse\n            val left11 = left10.mkString.toLong\n            val right11 = right10.mkString.toLong\n            val left12 = left11.toString.map(_.asDigit)\n            val right12 = right11.toString.map(_.asDigit)\n            val left13 = left12.slice(0, half)\n            val right13 = right12.slice(half + n % 2, n)\n            val left14 = left13.reverse\n            val right14 = right13.reverse\n            val left15 = left14.mkString.toLong\n            val right15 = right14.mkString.toLong\n            val left16 = left15.toString.map(_.asDigit)\n            val right16 = right15.toString\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123101,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmprc9bzr_z.scala:49:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprc9bzr_z.scala:48:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmprc9bzr_z.scala:42:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m42 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val digits = num.toString.toList.map(_.asDigit)\n        val len = digits.length\n        val half = len / 2\n        val left = digits.slice(0, half)\n        val right = digits.slice(half + len % 2, len)\n        val leftRev = left.reverse\n        if (left == right) {\n            val leftInc = left.map(x => (x + 1) % 10)\n            val leftRevInc = leftInc.reverse\n            if (leftInc.length == leftRevInc.length && leftInc.zip(leftRevInc).forall(x => x._1 == x._2)) {\n                val leftIncStr = leftInc.mkString\n                val leftRevIncStr = leftRevInc.mkString\n                val mid = if (len % 2 == 1) digits(half).toString else \"\"\n                (leftIncStr + mid + leftRevIncStr).toLong\n            } else {\n                val leftStr = left.mkString\n                val leftRevStr = leftRev.mkString\n                val mid = if (len % 2 == 1) digits(half).toString else \"\"\n                (leftStr + mid + leftRevStr).toLong\n            }\n        } else {\n            val leftStr = left.mkString\n            val leftRevStr = leftRev.mkString\n            val mid = if (len % 2 == 1) digits(half).toString else \"\"\n            (leftStr + mid + leftRevStr).toLong\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123102,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpiztga4b8.scala:34)\n\tat Problem.main(tmpiztga4b8.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val digits = num.toString.toList.map(_.asDigit)\n        val len = digits.length\n        val half = len / 2\n        val left = digits.take(half)\n        val right = digits.takeRight(half)\n        val leftRev = left.reverse\n        val rightRev = right.reverse\n        if (leftRev == right) {\n            val leftRevInc = leftRev.map(_ + 1)\n            val leftRevIncStr = leftRevInc.mkString\n            val leftRevIncStrRev = leftRevIncStr.reverse\n            val leftRevIncStrRevStr = leftRevIncStr + leftRevIncStrRev\n            leftRevIncStrRevStr.toLong\n        } else {\n            val leftStr = left.mkString\n            val rightStr = right.mkString\n            val leftStrRev = leftStr.reverse\n            val rightStrRev = rightStr.reverse\n            if (leftStrRev < rightStr) {\n                val leftStrRevStr = leftStr + leftStrRev\n                leftStrRevStr.toLong\n            } else if (leftStrRev > rightStr) {\n                val rightStrRevStr = rightStr + rightStrRev\n                rightStrRevStr.toLong\n            } else {\n                val leftStrRevStr = leftStr + leftStrRev\n                leftStrRevStr.toLong\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123103,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpnm5mje53.scala:37)\n\tat Problem.main(tmpnm5mje53.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val n = s.length\n        val half = n / 2\n        val left = s.substring(0, half)\n        val right = s.substring(half + n % 2, n)\n        val leftRev = left.reverse\n        val leftRevNum = leftRev.toLong\n        val leftNum = left.toLong\n        val rightNum = right.toLong\n        if (leftRevNum < rightNum) {\n            val leftRevNum = (left.toLong + 1).toString.reverse\n            (leftRevNum + leftRevNum.reverse).toLong\n        } else {\n            val leftRevNum = left.reverse\n            (leftRevNum + leftRevNum.reverse).toLong\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123102,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpbasnivla.scala:24)\n\tat Problem.main(tmpbasnivla.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val n = s.length\n        val half = n / 2\n        val left = s.substring(0, half)\n        val right = s.substring(half + n % 2, n)\n        val leftRev = left.reverse\n        if (leftRev > right) {\n            val leftInc = (left.toLong + 1).toString\n            val leftIncRev = leftInc.reverse\n            val leftIncRevPadded = leftIncRev.padTo(half, '0')\n            val leftIncPadded = leftInc.padTo(half, '0')\n            val leftIncPaddedRev = leftIncPadded.reverse\n            if (leftIncPaddedRev > right) {\n                val leftIncPaddedRevPadded = leftIncPaddedRev.padTo(half + n % 2, '0')\n                leftIncPaddedRevPadded + leftIncPaddedRevPadded.reverse\n            } else {\n                leftIncPaddedRevPadded + leftIncRevPadded\n            }\n        } else {\n            val leftRevPadded = leftRev.padTo(half, '0')\n            val leftPadded = left.padTo(half, '0')\n            val leftPaddedRev = leftPadded.reverse\n            if (leftPaddedRev > right) {\n                val leftPaddedRevPadded = leftPaddedRev.padTo(half + n % 2, '0')\n                leftPaddedRevPadded + leftPaddedRevPadded.reverse\n            } else {\n                leftRevPadded + leftRevPadded.reverse\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123102,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpeo22183z.scala:20:16 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                leftIncPaddedRevPadded + leftIncPaddedRevPadded.reverse\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Found:    String\n\u001b[31m   |\u001b[0m                Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpeo22183z.scala:22:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                leftIncPaddedRevPadded + leftIncRevPadded\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: leftIncPaddedRevPadded\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpeo22183z.scala:30:16 --------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                leftPaddedRevPadded + leftPaddedRevPadded.reverse\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Found:    String\n\u001b[31m   |\u001b[0m                Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpeo22183z.scala:32:16 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                leftRevPadded + leftRevPadded.reverse\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Found:    String\n\u001b[31m   |\u001b[0m                Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val n = s.length\n        val half = n / 2\n        val left = s.substring(0, half)\n        val right = s.substring(half + (if (n % 2 == 0) 0 else 1), n)\n        val leftNum = left.toLong\n        val rightNum = right.toLong\n        val leftNumRev = left.reverse.toLong\n        val rightNumRev = right.reverse.toLong\n        if (leftNum == rightNumRev && leftNumRev == rightNum) {\n            val nextLeftNum = leftNum + 1\n            val nextLeftNumRev = nextLeftNum.toString.reverse.toLong\n            if (nextLeftNumRev < nextLeftNum) {\n                val nextLeft = nextLeftNum.toString\n                val nextRight = nextLeftNumRev.toString\n                val nextLeftPadded = nextLeft + \"0\" * (n - nextLeft.length - nextRight.length)\n                val nextRightPadded = nextRight + \"0\" * (n - nextLeft.length - nextRight.length)\n                (nextLeftPadded + nextRightPadded).toLong\n            } else {\n                val nextLeft = nextLeftNum.toString\n                val nextRight = nextLeftNumRev.toString\n                (nextLeft + nextRight).toLong\n            }\n        } else if (leftNum < rightNumRev) {\n            val nextLeftNum = leftNum + 1\n            val nextLeftNumRev = nextLeftNum.toString.reverse.toLong\n            if (nextLeftNumRev < nextLeftNum) {\n                val nextLeft = nextLeftNum.toString\n                val nextRight = nextLeftNumRev.toString\n                val nextLeftPadded = nextLeft + \"0\" * (n - nextLeft.length - nextRight.length)\n                val nextRightPadded = nextRight + \"0\" * (n - nextLeft.length - nextRight.length)\n                (nextLeftPadded + nextRightPadded).toLong\n            } else {\n                val nextLeft = nextLeftNum.toString\n                val nextRight = nextLeftNumRev.toString\n                (nextLeft + nextRight).toLong\n           \n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123100,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpncgxsltt.scala:51:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpncgxsltt.scala:29:15 --------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (leftNum < rightNumRev) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m               Found:    Unit\n\u001b[31m   |\u001b[0m               Required: Long\n\u001b[31m   |\u001b[0m               Maybe you are missing an else part for the conditional?\n\u001b[31m30 |\u001b[0m            \u001b[33mval\u001b[0m nextLeftNum = leftNum + \u001b[31m1\u001b[0m\n\u001b[31m31 |\u001b[0m            \u001b[33mval\u001b[0m nextLeftNumRev = nextLeftNum.toString.reverse.toLong\n\u001b[31m32 |\u001b[0m            \u001b[33mif\u001b[0m (nextLeftNumRev < nextLeftNum) {\n\u001b[31m33 |\u001b[0m                \u001b[33mval\u001b[0m nextLeft = nextLeftNum.toString\n\u001b[31m34 |\u001b[0m                \u001b[33mval\u001b[0m nextRight = nextLeftNumRev.toString\n\u001b[31m35 |\u001b[0m                \u001b[33mval\u001b[0m nextLeftPadded = nextLeft + \u001b[31m\"0\"\u001b[0m * (n - nextLeft.length - nextRight.length)\n\u001b[31m36 |\u001b[0m                \u001b[33mval\u001b[0m nextRightPadded = nextRight + \u001b[31m\"0\"\u001b[0m * (n - nextLeft.length - nextRight.length)\n\u001b[31m37 |\u001b[0m                (nextLeftPadded + nextRightPadded).toLong\n\u001b[31m38 |\u001b[0m            } \u001b[33melse\u001b[0m {\n\u001b[31m39 |\u001b[0m                \u001b[33mval\u001b[0m nextLeft = nextLeftNum.toString\n\u001b[31m40 |\u001b[0m                \u001b[33mval\u001b[0m nextRight = nextLeftNumRev.toString\n\u001b[31m41 |\u001b[0m                (nextLeft + nextRight).toLong\n\u001b[31m42 |\u001b[0m           \n\u001b[31m43 |\u001b[0m    }\n\u001b[31m44 |\u001b[0m    \u001b[33mdef\u001b[0m main(args: Array[String]) = {\n\u001b[31m45 |\u001b[0m    assert(nextSmallestPalindrome((\u001b[31m99l\u001b[0m)) == (\u001b[31m101l\u001b[0m));\n\u001b[31m46 |\u001b[0m    assert(nextSmallestPalindrome((\u001b[31m1221l\u001b[0m)) == (\u001b[31m1331l\u001b[0m));\n\u001b[31m47 |\u001b[0m    assert(nextSmallestPalindrome((\u001b[31m120l\u001b[0m)) == (\u001b[31m121l\u001b[0m));\n\u001b[31m48 |\u001b[0m    }\n\u001b[31m49 |\u001b[0m}\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val n = s.length\n        if (n == 1) return num\n        val (left, right) = s.splitAt(n / 2)\n        val leftInt = left.toInt\n        val rightInt = right.toInt\n        val leftRev = left.reverse\n        val rightRev = right.reverse\n        val leftRevInt = leftRev.toInt\n        val rightRevInt = rightRev.toInt\n        if (leftRevInt > rightInt) {\n            val mid = if (n % 2 == 0) \"\" else left.charAt(0).toString\n            (left + mid + leftRev).toLong\n        } else {\n            val mid = if (n % 2 == 0) \"\" else left.charAt(0).toString\n            val leftPlusOne = (leftInt + 1).toString\n            val leftPlusOneRev = leftPlusOne.reverse\n            val leftPlusOneRevInt = leftPlusOneRev.toInt\n            if (leftPlusOneRevInt > rightInt) {\n                (leftPlusOne + mid + leftPlusOneRev).toLong\n            } else {\n                val leftPlusOneRevPlusOne = (leftPlusOneRevInt + 1).toString\n                (leftPlusOne + mid + leftPlusOneRevPlusOne).toLong\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123103,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpmj9uhx95.scala:33)\n\tat Problem.main(tmpmj9uhx95.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val digits = num.toString.toList.map(_.toString.toInt)\n        val len = digits.length\n        val (left, right) = digits.splitAt(len / 2)\n        val leftRev = left.reverse\n        val rightRev = right.reverse\n        val (leftRev2, rightRev2) = if (len % 2 == 0) (leftRev, rightRev) else (leftRev.tail, rightRev)\n        val (left2, right2) = (leftRev2.reverse, rightRev2.reverse)\n        val (left3, right3) = if (left2.length == right2.length) (left2, right2) else (left2.tail, right2)\n        val (left4, right4) = if (left3.length == right3.length) (left3, right3) else (left3.tail, right3)\n        val (left5, right5) = if (left4.length == right4.length) (left4, right4) else (left4.tail, right4)\n        val (left6, right6) = if (left5.length == right5.length) (left5, right5) else (left5.tail, right5)\n        val (left7, right7) = if (left6.length == right6.length) (left6, right6) else (left6.tail, right6)\n        val (left8, right8) = if (left7.length == right7.length) (left7, right7) else (left7.tail, right7)\n        val (left9, right9) = if (left8.length == right8.length) (left8, right8) else (left8.tail, right8)\n        val (left10, right10) = if (left9.length == right9.length) (left9, right9) else (left9.tail, right9)\n        val (left11, right11) = if (left10.length == right10.length) (left10, right10) else (left10.tail, right10)\n        val (left12, right12) = if (left11.length == right11.length) (\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123102,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp2dds3t3m.scala:22:70 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m (left12, right12) = \u001b[33mif\u001b[0m (left11.length == right11.length) (\n\u001b[31m\u001b[31m   |\u001b[0m                                                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2dds3t3m.scala:23:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val n = s.length\n        val half = n / 2\n        val left = s.substring(0, half)\n        val right = s.substring(half + n % 2, n)\n        val leftRev = left.reverse\n        if (leftRev > right) {\n            val leftInc = (left.toLong + 1).toString\n            val leftIncRev = leftInc.reverse\n            val leftIncRevPadded = leftIncRev.padTo(half, '0')\n            val result = leftInc + leftIncRevPadded\n            result.toLong\n        } else {\n            val leftRevPadded = leftRev.padTo(half, '0')\n            val result = left + leftRevPadded\n            result.toLong\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123103,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpwcliejxm.scala:25)\n\tat Problem.main(tmpwcliejxm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        while(!isPalindrome(n)) n -= 1\n        n\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123100,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwelbmlse.scala:7:15 -------------------------\u001b[0m\u001b[0m\n\u001b[31m7 |\u001b[0m        \u001b[33mwhile\u001b[0m(!isPalindrome(n)) n -= \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m  |\u001b[0m               ^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m               Not found: isPalindrome\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        def isPalindrome(num : Long) : Boolean = {\n            val str = num.toString\n            str == str.reverse\n        }\n        var n = num\n        while (!isPalindrome(n)) n -= 1\n        n\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123079,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmplf31x817.scala:15)\n\tat Problem.main(tmplf31x817.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val n = s.length\n        val half = n / 2\n        val left = s.substring(0, half)\n        val right = s.substring(n - half, n)\n        val leftNum = left.toLong\n        val rightNum = right.toLong\n        if (leftNum == rightNum) {\n            val nextLeft = (leftNum + 1).toString\n            val nextRight = nextLeft.substring(0, half)\n            val nextLeftNum = nextLeft.toLong\n            val nextRightNum = nextRight.toLong\n            if (nextLeftNum == nextRightNum) nextLeftNum * pow(10, half).toLong\n            else nextLeftNum * pow(10, half).toLong + nextRightNum\n        } else {\n            val nextLeft = (leftNum + 1).toString\n            val nextRight = nextLeft.substring(0, half)\n            val nextLeftNum = nextLeft.toLong\n            val nextRightNum = nextRight.toLong\n            if (nextLeftNum == nextRightNum) nextLeftNum * pow(10, half).toLong\n            else nextLeftNum * pow(10, half).toLong + nextRightNum\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123103,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpiafuyyb0.scala:31)\n\tat Problem.main(tmpiafuyyb0.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val str = num.toString\n        val len = str.length\n        val half = len / 2\n        val left = str.substring(0, half)\n        val right = str.substring(half + len % 2)\n        val leftRev = left.reverse\n        val leftNum = left.toLong\n        val rightNum = right.toLong\n        val leftRevNum = leftRev.toLong\n        if (leftNum == rightNum) {\n            if (leftNum == 0) return 1\n            else return (leftNum + 1) * pow(10, half).toLong + (leftNum + 1) * pow(10, half - len % 2).toLong\n        }\n        else if (leftNum < rightNum) {\n            if (leftNum == 0) return 1\n            else return (leftNum + 1) * pow(10, half).toLong + (leftNum + 1) * pow(10, half - len % 2).toLong\n        }\n        else {\n            if (leftRevNum < rightNum) return leftNum * pow(10, half).toLong + leftRevNum * pow(10, half - len % 2).toLong\n            else {\n                val newLeft = (leftNum + 1).toString\n                val newLeftRev = newLeft.reverse\n                return newLeft.toLong * pow(10, half).toLong + newLeftRev.toLong * pow(10, half - len % 2).toLong\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123106,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpqh5yqf0y.scala:33)\n\tat Problem.main(tmpqh5yqf0y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var isPalindrome = false\n        while (!isPalindrome) {\n            n += 1\n            isPalindrome = isPalindrome(n)\n        }\n        n\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123102,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp7r068lt3.scala:10:27 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m            isPalindrome = isPalindrome(n)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          \u001b[33mvariable\u001b[0m \u001b[35misPalindrome\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val digits = num.toString.toCharArray\n        val n = digits.length\n        var i = 0\n        while (i < n / 2 && digits(i) == digits(n - 1 - i)) i += 1\n        if (i == n / 2) {\n            if (n % 2 == 1) {\n                if (digits(n / 2) < '9') {\n                    digits(n / 2) = (digits(n / 2) + 1).toChar\n                    return digits.mkString.toLong\n                }\n                else {\n                    digits(n / 2) = '0'\n                    i = n / 2 - 1\n                }\n            }\n            else i = n / 2 - 1\n        }\n        else i = n / 2\n        var carry = 1\n        while (i >= 0) {\n            val sum = digits(i) + carry\n            if (sum > '9') {\n                digits(i) = '0'\n                carry = 1\n            }\n            else {\n                digits(i) = sum.toChar\n                carry = 0\n            }\n            digits(n - 1 - i) = digits(i)\n            i -= 1\n        }\n        if (carry == 1) {\n            val newDigits = new Array[Char](n + 1)\n            newDigits(0) = '1'\n            newDigits(n) = '1'\n            for (i <- 1 to n - 1) newDigits(i) = '0'\n            return newDigits.mkString.toLong\n        }\n        digits.mkString.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123107,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpqvhv_fgn.scala:50)\n\tat Problem.main(tmpqvhv_fgn.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var digits = new ArrayBuffer[Int]\n        while (n > 0) {\n            digits += (n % 10).toInt\n            n /= 10\n        }\n        var i = 0\n        while (i < digits.length / 2) {\n            if (digits(i) != digits(digits.length - 1 - i)) {\n                if (digits(i) > digits(digits.length - 1 - i)) {\n                    digits(digits.length - 1 - i) = digits(i)\n                }\n                else {\n                    digits(digits.length - 1 - i) = digits(i)\n                    var j = digits.length - 2 - i\n                    while (j >= 0 && digits(j) == 9) {\n                        digits(j) = 0\n                        j -= 1\n                    }\n                    if (j < 0) {\n                        digits.insert(0, 1)\n                    }\n                    else {\n                        digits(j) += 1\n                    }\n                }\n            }\n            i += 1\n        }\n        var result = 0L\n        for (i <- 0 until digits.length) {\n            result = result * 10 + digits(i)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123107,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpfmv5icx2.scala:42)\n\tat Problem.main(tmpfmv5icx2.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        while(!isPalindrome(n)) n -= 1\n        n\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123100,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwelbmlse.scala:7:15 -------------------------\u001b[0m\u001b[0m\n\u001b[31m7 |\u001b[0m        \u001b[33mwhile\u001b[0m(!isPalindrome(n)) n -= \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m  |\u001b[0m               ^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m               Not found: isPalindrome\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val numStr = num.toString\n        val len = numStr.length\n        val halfLen = len / 2\n        val leftHalf = numStr.substring(0, halfLen)\n        val rightHalf = numStr.substring(halfLen + len % 2, len)\n        val leftHalfRev = leftHalf.reverse\n        val leftHalfRevInt = leftHalfRev.toInt\n        val leftHalfInt = leftHalf.toInt\n        if (leftHalfRevInt < leftHalfInt) {\n            val leftHalfInc = (leftHalfInt + 1).toString\n            val leftHalfIncRev = leftHalfInc.reverse\n            val leftHalfIncRevLen = leftHalfIncRev.length\n            val leftHalfIncLen = leftHalfInc.length\n            val leftHalfIncRevPadded = leftHalfIncRev + \"0\" * (halfLen - leftHalfIncRevLen)\n            val leftHalfIncPadded = leftHalfInc + \"0\" * (halfLen - leftHalfIncLen)\n            val leftHalfPadded = if (leftHalfIncRevPadded.toInt < leftHalfIncPadded.toInt) leftHalfIncRevPadded else leftHalfIncPadded\n            val rightHalfPadded = leftHalfPadded.reverse\n            val numStrPadded = leftHalfPadded + rightHalfPadded\n            numStrPadded.toLong\n        } else {\n            val leftHalfRevPadded = leftHalfRev + \"0\" * (halfLen - leftHalfRev.length)\n            val rightHalfPadded = leftHalfRevPadded.reverse\n            val numStrPadded = leftHalfRevPadded + rightHalfPadded\n            numStrPadded.toLong\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123106,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp9valfh7_.scala:33)\n\tat Problem.main(tmp9valfh7_.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val digits = num.toString.toList.map(_.asDigit)\n        val n = digits.length\n        val half = n / 2\n        val isOdd = n % 2 == 1\n        val left = digits.slice(0, half)\n        val right = digits.slice(half + (if (isOdd) 1 else 0), n)\n        val leftRev = left.reverse\n        if (left == right) {\n            val leftInc = left.map(_ + 1).reverse\n            val leftIncRev = leftInc.reverse\n            val leftIncRevLen = leftIncRev.length\n            val leftIncRevPad = if (leftIncRevLen < half) leftIncRev ::: List.fill(half - leftIncRevLen)(0) else leftIncRev\n            val leftIncRevPadRev = leftIncRevPad.reverse\n            val leftIncRevPadRevLen = leftIncRevPadRev.length\n            val leftIncRevPadRevPad = if (leftIncRevPadRevLen < half) leftIncRevPadRev ::: List.fill(half - leftIncRevPadRevLen)(0) else leftIncRevPadRev\n            val leftIncRevPadRevPadRev = leftIncRevPadRevPad.reverse\n            val leftIncRevPadRevPadRevLen = leftIncRevPadRevPadRev.length\n            val leftIncRevPadRevPadRevPad = if (leftIncRevPadRevPadRevLen < half) leftIncRevPadRevPadRev ::: List.fill(half - leftIncRevPadRevPadRevLen)(0) else leftIncRevPadRevPadRev\n            val leftIncRevPadRevPadRevPadRev = leftIncRevPadRevPadRevPad.reverse\n            val leftIncRevPadRevPadRevPadRevLen = leftIncRevPadRevPadRevPadRev.length\n            val leftIncRevPadRevPadRevPadRevPad = if (leftIncRevPadRevPadRevPadRevLen < half) leftIncRevPadRevPadRevPadRev ::: List.fill(half - leftIncRevPadRevPadRevPadRevLen)(0) else leftIncRevPadRevPadRevPadRev\n            val leftIncRevPadRevPadRevPadRevPadRev = leftIncRevPadRevPadRevPadRevPad.reverse\n            val leftIncRevPadRev\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123110,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7b1ia66l.scala:29:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7b1ia66l.scala:37:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7b1ia66l.scala:36:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmp7b1ia66l.scala:30:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m30 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val n = s.length\n        val half = n / 2\n        val left = s.substring(0, half)\n        val right = s.substring(half + (if (n % 2 == 1) 1 else 0))\n        val leftInt = left.toInt\n        val rightInt = right.toInt\n        val leftRev = left.reverse\n        val rightRev = right.reverse\n        if (leftRev > right) {\n            val leftRevInt = leftRev.toInt\n            val leftRevStr = leftRevInt.toString\n            val leftRevStrRev = leftRevStr.reverse\n            val leftRevStrRevInt = leftRevStrRev.toInt\n            val leftRevStrRevStr = leftRevStrRevInt.toString\n            val leftRevStrRevStrRev = leftRevStrRevStr.reverse\n            val leftRevStrRevStrRevInt = leftRevStrRevStrRev.toInt\n            val leftRevStrRevStrRevStr = leftRevStrRevStrRevInt.toString\n            val leftRevStrRevStrRevStrRev = leftRevStrRevStrRevStr.reverse\n            val leftRevStrRevStrRevStrRevInt = leftRevStrRevStrRevStrRev.toInt\n            val leftRevStrRevStrRevStrRevStr = leftRevStrRevStrRevStrRevInt.toString\n            val leftRevStrRevStrRevStrRevStrRev = leftRevStrRevStrRevStrRevStr.reverse\n            val leftRevStrRevStrRevStrRevStrRevInt = leftRevStrRevStrRevStrRevStrRev.toInt\n            val leftRevStrRevStrRevStrRevStrRevStr = leftRevStrRevStrRevStrRevStrRevInt.toString\n            val leftRevStrRevStrRevStrRevStrRevStrRev = leftRevStrRevStrRevStrRevStrRevStr.reverse\n            val leftRevStrRevStrRevStrRevStrRevStrRevInt = leftRevStrRevStrRevStrRevStrRevStrRev.toInt\n            val leftRevStrRevStrRevStrRevStrRevStrRevStr = leftRevStrRevStrRevStrRevStrRevStrRevInt.toString\n            val leftRevStrRevStrRevStrRevStrRevStrRevStrRev = leftRevStrRevStrRevStr\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123109,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpv_0sq4o0.scala:42:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv_0sq4o0.scala:41:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpv_0sq4o0.scala:35:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m35 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var digits = new ArrayBuffer[Int]\n        while (n > 0) {\n            digits += (n % 10).toInt\n            n /= 10\n        }\n        var i = 0\n        while (i < digits.length / 2) {\n            if (digits(i) != digits(digits.length - 1 - i)) {\n                if (digits(i) > digits(digits.length - 1 - i)) {\n                    digits(digits.length - 1 - i) = digits(i)\n                } else {\n                    digits(i) = digits(digits.length - 1 - i)\n                }\n            }\n            i += 1\n        }\n        var result = 0L\n        for (i <- 0 until digits.length) {\n            result = result * 10 + digits(i)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123111,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpv1r9yeeo.scala:30)\n\tat Problem.main(tmpv1r9yeeo.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        while (true) {\n            n += 1\n            if (isPalindrome(n)) return n\n        }\n        return -1\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123066,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3skv3vcx.scala:9:16 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m            \u001b[33mif\u001b[0m (isPalindrome(n)) \u001b[33mreturn\u001b[0m n\n\u001b[31m\u001b[31m  |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                Not found: isPalindrome\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val str = num.toString\n        val len = str.length\n        val half = len / 2\n        val left = str.substring(0, half)\n        val right = str.substring(half + len % 2)\n        val leftRev = left.reverse\n        val leftNum = left.toLong\n        val leftRevNum = leftRev.toLong\n        val rightNum = right.toLong\n        if (leftRevNum > rightNum) {\n            val leftNum = left.toLong\n            val leftRevNum = leftRev.toLong\n            val rightNum = right.toLong\n            val leftRevNumPlusOne = leftRevNum + 1\n            val leftRevNumPlusOneStr = leftRevNumPlusOne.toString\n            val leftRevNumPlusOneStrRev = leftRevNumPlusOneStr.reverse\n            val leftRevNumPlusOneStrRevNum = leftRevNumPlusOneStrRev.toLong\n            val result = leftRevNumPlusOneStr + leftRevNumPlusOneStrRev\n            result.toLong\n        } else {\n            val leftNum = left.toLong\n            val leftRevNum = leftRev.toLong\n            val rightNum = right.toLong\n            val leftNumPlusOne = leftNum + 1\n            val leftNumPlusOneStr = leftNumPlusOne.toString\n            val leftNumPlusOneStrRev = leftNumPlusOneStr.reverse\n            val leftNumPlusOneStrRevNum = leftNumPlusOneStrRev.toLong\n            val result = leftNumPlusOneStr + leftNumPlusOneStrRev\n            result.toLong\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123110,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp0yhseatq.scala:38)\n\tat Problem.main(tmp0yhseatq.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        def isPalindrome(num : Long) : Boolean = {\n            val str = num.toString\n            str == str.reverse\n        }\n        def nextPalindrome(num : Long) : Long = {\n            if (isPalindrome(num)) num\n            else nextPalindrome(num + 1)\n        }\n        nextPalindrome(num + 1)\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1665517291,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var nn = 0\n        var nn2 = 0\n        var nn3 = 0\n        var nn4 = 0\n        var nn5 = 0\n        var nn6 = 0\n        var nn7 = 0\n        var nn8 = 0\n        var nn9 = 0\n        var nn10 = 0\n        var nn11 = 0\n        var nn12 = 0\n        var nn13 = 0\n        var nn14 = 0\n        var nn15 = 0\n        var nn16 = 0\n        var nn17 = 0\n        var nn18 = 0\n        var nn19 = 0\n        var nn20 = 0\n        var nn21 = 0\n        var nn22 = 0\n        var nn23 = 0\n        var nn24 = 0\n        var nn25 = 0\n        var nn26 = 0\n        var nn27 = 0\n        var nn28 = 0\n        var nn29 = 0\n        var nn30 = 0\n        var nn31 = 0\n        var nn32 = 0\n        var nn33 = 0\n        var nn34 = 0\n        var nn35 = 0\n        var nn36 = 0\n        var nn37 = 0\n        var nn38 = 0\n        var nn39 = 0\n        var nn40 = 0\n        var nn41 = 0\n        var nn42 = 0\n        var nn43 = 0\n        var nn44 = 0\n        var nn45 = 0\n        var nn46 = 0\n        var nn47 = 0\n        var nn48 = 0\n        var nn49 = 0\n        var nn50 = 0\n        var nn51 = 0\n        var nn52 = 0\n        var nn53 = 0\n        var nn54 = 0\n        var nn55 = 0\n        var nn56 = 0\n        var nn57 = 0\n        var nn58 = 0\n        var nn59 = 0\n        var nn\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123110,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpda65v6_c.scala:72:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m72 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpda65v6_c.scala:72:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m72 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        def isPalindrome(num : Long) : Boolean = {\n            val str = num.toString\n            str == str.reverse\n        }\n        def nextPalindrome(num : Long) : Long = {\n            var n = num\n            while (!isPalindrome(n)) n += 1\n            n\n        }\n        nextPalindrome(num + 1)\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123067,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var i = 0\n        while(n > 0) {\n            n /= 10\n            i += 1\n        }\n        var j = i\n        var k = i\n        var l = i\n        var m = i\n        var p = i\n        var q = i\n        var r = i\n        var s = i\n        var t = i\n        var u = i\n        var v = i\n        var w = i\n        var x = i\n        var y = i\n        var z = i\n        var a = i\n        var b = i\n        var c = i\n        var d = i\n        var e = i\n        var f = i\n        var g = i\n        var h = i\n        var ii = i\n        var jj = i\n        var kk = i\n        var ll = i\n        var mm = i\n        var nn = i\n        var oo = i\n        var pp = i\n        var qq = i\n        var rr = i\n        var ss = i\n        var tt = i\n        var uu = i\n        var vv = i\n        var ww = i\n        var xx = i\n        var yy = i\n        var zz = i\n        var aa = i\n        var bb = i\n        var cc = i\n        var dd = i\n        var ee = i\n        var ff = i\n        var gg = i\n        var hh = i\n        var iii = i\n        var jjj = i\n        var kkk = i\n        var lll = i\n        var mmm = i\n        var nnn = i\n        var ooo = i\n        var ppp = i\n        var qqq = i\n        var rrr = i\n        var sss = i\n        var ttt = i\n        var uuu = i\n        var vvv = i\n        var www = i\n        var xxx = i\n        var yyy = i\n        var zzz = i\n        var aaaa = i\n        var bbbb = i\n        var cccc = i\n        var dddd = i\n        var eeee = i\n        var\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123109,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpqx0qxr94.scala:84:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m84 |\u001b[0m        \u001b[33mvar\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqx0qxr94.scala:85:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m85 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        def isPalindrome(n : Long) : Boolean = {\n            val s = n.toString\n            s == s.reverse\n        }\n        def nextPalindrome(n : Long) : Long = {\n            if (isPalindrome(n)) n\n            else nextPalindrome(n + 1)\n        }\n        nextPalindrome(num + 1)\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123111,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val n = s.length\n        val half = n / 2\n        val left = s.substring(0, half)\n        val right = s.substring(half + n % 2, n)\n        val leftRev = left.reverse\n        val rightRev = right.reverse\n        if (leftRev <= right) {\n            val leftInc = (BigInt(left) + 1).toString\n            val leftIncRev = leftInc.reverse\n            val leftIncRevPadded = leftIncRev.padTo(half, '0')\n            val leftIncPadded = leftInc.padTo(half, '0')\n            val leftIncRevPaddedStr = leftIncRevPadded.mkString\n            val leftIncPaddedStr = leftIncPadded.mkString\n            if (leftIncRevPaddedStr > right) {\n                val leftIncRevPaddedStrStr = leftIncRevPaddedStr.mkString\n                val leftIncPaddedStrStr = leftIncPaddedStr.mkString\n                if (n % 2 == 0) leftIncRevPaddedStrStr + leftIncPaddedStrStr else leftIncRevPaddedStrStr + s(half) + leftIncPaddedStrStr\n            }\n            else {\n                val leftIncRevPaddedStrStr = leftIncRevPaddedStr.mkString\n                val leftIncPaddedStrStr = leftIncPaddedStr.mkString\n                if (n % 2 == 0) leftIncRevPaddedStrStr + leftIncPaddedStrStr else leftIncRevPaddedStrStr + s(half) + leftIncPaddedStrStr\n            }\n        }\n        else {\n            val leftRevStr = leftRev.mkString\n            val rightRevStr = rightRev.mkString\n            if (n % 2 == 0) leftRevStr + rightRevStr else leftRevStr + s(half) + rightRevStr\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123112,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp329gv7ph.scala:23:32 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                \u001b[33mif\u001b[0m (n % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) leftIncRevPaddedStrStr + leftIncPaddedStrStr \u001b[33melse\u001b[0m leftIncRevPaddedStrStr + s(half) + leftIncPaddedStrStr\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Found:    String\n\u001b[31m   |\u001b[0m                                Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp329gv7ph.scala:23:82 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                \u001b[33mif\u001b[0m (n % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) leftIncRevPaddedStrStr + leftIncPaddedStrStr \u001b[33melse\u001b[0m leftIncRevPaddedStrStr + s(half) + leftIncPaddedStrStr\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                        Found:    String\n\u001b[31m   |\u001b[0m                                                        Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp329gv7ph.scala:28:32 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                \u001b[33mif\u001b[0m (n % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) leftIncRevPaddedStrStr + leftIncPaddedStrStr \u001b[33melse\u001b[0m leftIncRevPaddedStrStr + s(half) + leftIncPaddedStrStr\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Found:    String\n\u001b[31m   |\u001b[0m                                Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp329gv7ph.scala:28:82 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                \u001b[33mif\u001b[0m (n % \u001b[31m2\u001b[0m ==",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var digits = new ArrayBuffer[Int]()\n        while (n > 0) {\n            digits += (n % 10).toInt\n            n /= 10\n        }\n        var i = 0\n        while (i < digits.length / 2 && digits(i) == digits(digits.length - 1 - i)) i += 1\n        if (i == digits.length / 2) {\n            if (digits.length % 2 == 1) {\n                if (digits(i) == 9) {\n                    var j = i - 1\n                    while (j >= 0 && digits(j) == 9) {\n                        digits(j) = 0\n                        j -= 1\n                    }\n                    if (j < 0) {\n                        digits += 0\n                        digits(0) = 1\n                    } else digits(j) += 1\n                } else digits(i) += 1\n            } else {\n                if (digits(i) == 9) {\n                    var j = i - 1\n                    while (j >= 0 && digits(j) == 9) {\n                        digits(j) = 0\n                        j -= 1\n                    }\n                    if (j < 0) {\n                        digits += 0\n                        digits(0) = 1\n                    } else digits(j) += 1\n                } else digits(i) += 1\n            }\n        } else {\n            var j = i - 1\n            while (j >= 0 && digits(j) == digits(digits.length - 1 - j)) j -= 1\n            if (j < 0) {\n                var k = i\n                while (k < digits.length / 2) {\n                    digits(k) = digits(digits.length - 1 - k)\n                    k += 1\n                }\n            } else {\n                if (digits(j) < digits(digits.length - 1 - j)) {\n                    var k = i\n                    while (k < digits.length / 2) {\n                        digits(k) = digits(digits.length - 1 - k)\n                        k += 1\n                    }\n                } else {\n                    var k = j\n                    while (k >= 0 && digits(k) == 9) {\n                        digits(k) = 0\n                       \n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123113,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpl6b9jby2.scala:69:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m69 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpl6b9jby2.scala:24:24 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                        digits(\u001b[31m0\u001b[0m) = \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Found:    Unit\n\u001b[31m   |\u001b[0m                        Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpl6b9jby2.scala:25:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                    } \u001b[33melse\u001b[0m digits(j) += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    Unit\n\u001b[31m   |\u001b[0m                           Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpl6b9jby2.scala:26:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                } \u001b[33melse\u001b[0m digits(i) += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    Unit\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpl6b9jby2.scala:36:24 --------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                        digits(\u001b[31m0\u001b[0m) = \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Found:    Unit\n\u001b[31m   |\u001b[0m                        Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpl6b9jby2.scala:37:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                    } \u001b[33melse\u001b[0m digits(j) += \u001b[31m1\u001b[0m\n\u001b[31m\u001b",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val str = num.toString\n        val len = str.length\n        val half = len / 2\n        val left = str.substring(0, half)\n        val right = str.substring(half + len % 2)\n        val leftRev = left.reverse\n        val leftRevNum = leftRev.toLong\n        val rightNum = right.toLong\n        if (leftRevNum > rightNum) {\n            val leftNum = left.toLong\n            val nextLeft = (leftNum + 1).toString\n            val nextLeftRev = nextLeft.reverse\n            val nextLeftRevNum = nextLeftRev.toLong\n            val nextRightNum = nextLeftRevNum\n            val nextRight = nextRightNum.toString\n            val nextStr = nextLeft + nextRight\n            nextStr.toLong\n        } else {\n            val leftNum = left.toLong\n            val nextLeft = leftNum.toString\n            val nextLeftRev = nextLeft.reverse\n            val nextLeftRevNum = nextLeftRev.toLong\n            val nextRightNum = nextLeftRevNum\n            val nextRight = nextRightNum.toString\n            val nextStr = nextLeft + nextRight\n            nextStr.toLong\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123111,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmph89onc5q.scala:35)\n\tat Problem.main(tmph89onc5q.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val n = s.length\n        val half = n / 2\n        val left = s.substring(0, half)\n        val right = s.substring(half + n % 2, n)\n        val leftRev = left.reverse\n        if (leftRev > right) {\n            val leftInc = (left.toLong + 1).toString\n            val leftIncRev = leftInc.reverse\n            val leftIncRevPadded = leftIncRev.padTo(half, '0')\n            val leftIncPadded = leftInc.padTo(half, '0')\n            val leftIncPaddedRev = leftIncPadded.reverse\n            if (leftIncPaddedRev > right) {\n                val leftIncPaddedRevPadded = leftIncPaddedRev.padTo(n, '0')\n                leftIncPaddedRevPadded.toLong\n            } else {\n                val leftIncRevPaddedRevPadded = leftIncRevPadded.padTo(n, '0')\n                leftIncRevPaddedRevPadded.toLong\n            }\n        } else {\n            val leftRevPadded = leftRev.padTo(n, '0')\n            leftRevPadded.toLong\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123113,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpjq5euprh.scala:31)\n\tat Problem.main(tmpjq5euprh.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num.toString\n        var i = 0\n        var j = n.length - 1\n        while (i < j) {\n            if (n(i) < n(j)) {\n                n = n.substring(0, j) + n(i) + n.substring(j + 1)\n            }\n            i += 1\n            j -= 1\n        }\n        n.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123113,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpz2xkzql_.scala:19)\n\tat Problem.main(tmpz2xkzql_.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        while (true) {\n            n += 1\n            if (isPalindrome(n)) return n\n        }\n        return -1\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123066,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3skv3vcx.scala:9:16 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m            \u001b[33mif\u001b[0m (isPalindrome(n)) \u001b[33mreturn\u001b[0m n\n\u001b[31m\u001b[31m  |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                Not found: isPalindrome\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val n = s.length\n        val half = n / 2\n        val (left, right) = s.splitAt(half)\n        val leftRev = left.reverse\n        val leftNum = left.toLong\n        val leftRevNum = leftRev.toLong\n        val rightNum = right.toLong\n        val leftRevNumPlusOne = leftRevNum + 1\n        val leftRevNumPlusOneStr = leftRevNumPlusOne.toString\n        val leftRevNumPlusOneStrRev = leftRevNumPlusOneStr.reverse\n        val leftRevNumPlusOneStrRevNum = leftRevNumPlusOneStrRev.toLong\n        val leftRevNumPlusOneStrNum = leftRevNumPlusOneStr.toLong\n        val leftRevNumPlusOneStrRevNumPlusOne = leftRevNumPlusOneStrRevNum + 1\n        val leftRevNumPlusOneStrRevNumPlusOneStr = leftRevNumPlusOneStrRevNumPlusOne.toString\n        val leftRevNumPlusOneStrRevNumPlusOneStrRev = leftRevNumPlusOneStrRevNumPlusOneStr.reverse\n        val leftRevNumPlusOneStrRevNumPlusOneStrRevNum = leftRevNumPlusOneStrRevNumPlusOneStrRev.toLong\n        val leftRevNumPlusOneStrRevNumPlusOneStrNum = leftRevNumPlusOneStrRevNumPlusOneStr.toLong\n        val leftRevNumPlusOneStrNumPlusOne = leftRevNumPlusOneStrNum + 1\n        val leftRevNumPlusOneStrNumPlusOneStr = leftRevNumPlusOneStrNumPlusOne.toString\n        val leftRevNumPlusOneStrNumPlusOneStrRev = leftRevNumPlusOneStrNumPlusOneStr.reverse\n        val leftRevNumPlusOneStrNumPlusOneStrRevNum = leftRevNumPlusOneStrNumPlusOneStrRev.toLong\n        val leftRevNumPlusOneStrNumPlusOneStrNum = leftRevNumPlusOneStrNumPlusOneStr.toLong\n        val leftRevNumPlusOneStrRevNumPlusOneStrRevNumPlusOne = leftRevNumPlusOneStrRevNumPlusOneStrRevNum + 1\n        val leftRevNumPlusOneStrRevNumPlusOneStrRevNumPlusOneStr = leftRevNumPlusOneStrRev\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123112,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6k52q0qs.scala:31:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var isPalindrome = false\n        while (!isPalindrome) {\n            n += 1\n            isPalindrome = isPalindrome(n)\n        }\n        n\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123102,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp7r068lt3.scala:10:27 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m            isPalindrome = isPalindrome(n)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          \u001b[33mvariable\u001b[0m \u001b[35misPalindrome\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val n = s.length\n        val half = n / 2\n        val left = s.substring(0, half)\n        val right = s.substring(half + (n % 2), n)\n        val leftRev = left.reverse\n        if (leftRev > right) {\n            val leftInc = (BigInt(left) + 1).toString\n            val leftIncRev = leftInc.reverse\n            val leftIncRevPadded = leftIncRev.padTo(right.length, '0')\n            val leftIncPadded = leftInc.padTo(half, '0')\n            val result = leftIncPadded + leftIncRevPadded\n            result.toLong\n        } else {\n            val leftRevPadded = leftRev.padTo(right.length, '0')\n            val leftPadded = left.padTo(half, '0')\n            val result = leftPadded + leftRevPadded\n            result.toLong\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123113,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpngyw1vr6.scala:27)\n\tat Problem.main(tmpngyw1vr6.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        def isPalindrome(num : Long) : Boolean = {\n            val str = num.toString\n            str == str.reverse\n        }\n        def nextPalindrome(num : Long) : Long = {\n            if (isPalindrome(num)) num\n            else nextPalindrome(num + 1)\n        }\n        nextPalindrome(num)\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123113,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpqy48z4b0.scala:17)\n\tat Problem.main(tmpqy48z4b0.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val str = num.toString\n        val len = str.length\n        val half = len / 2\n        val left = str.substring(0, half)\n        val right = str.substring(half + len % 2, len)\n        val leftRev = left.reverse\n        if (leftRev > right) {\n            val leftInc = (BigInt(left) + 1).toString\n            val leftIncRev = leftInc.reverse\n            val leftIncRevLen = leftIncRev.length\n            val leftIncRevPad = leftIncRev + \"0\" * (half - leftIncRevLen)\n            val leftIncRevPadLen = leftIncRevPad.length\n            val leftIncRevPadSub = leftIncRevPad.substring(0, half)\n            val leftIncRevPadSubLen = leftIncRevPadSub.length\n            val leftIncRevPadSubPad = leftIncRevPadSub + \"0\" * (half - leftIncRevPadSubLen)\n            val leftIncRevPadSubPadLen = leftIncRevPadSubPad.length\n            val leftIncRevPadSubPadSub = leftIncRevPadSubPad.substring(0, half)\n            val leftIncRevPadSubPadSubLen = leftIncRevPadSubPadSub.length\n            val leftIncRevPadSubPadSubPad = leftIncRevPadSubPadSub + \"0\" * (half - leftIncRevPadSubPadSubLen)\n            val leftIncRevPadSubPadSubPadLen = leftIncRevPadSubPadSubPad.length\n            val leftIncRevPadSubPadSubPadSub = leftIncRevPadSubPadSubPad.substring(0, half)\n            val leftIncRevPadSubPadSubPadSubLen = leftIncRevPadSubPadSubPadSub.length\n            val leftIncRevPadSubPadSubPadSubPad = leftIncRevPadSubPadSubPadSub + \"0\" * (half - leftIncRevPadSubPadSubPadSubLen)\n            val leftIncRevPadSubPadSubPadSubPadLen = leftIncRevPadSubPadSubPadSubPad.length\n            val leftIncRevPadSubPadSubPadSubPadSub = leftIncRevPadSubPadSubPadSubPad.substring(0, half)\n            val leftIncRevPadSub\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123113,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp8abecotn.scala:32:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp8abecotn.scala:40:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8abecotn.scala:39:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmp8abecotn.scala:33:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m33 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        while (true) {\n            n += 1\n            if (isPalindrome(n)) return n\n        }\n        return -1\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123066,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3skv3vcx.scala:9:16 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m            \u001b[33mif\u001b[0m (isPalindrome(n)) \u001b[33mreturn\u001b[0m n\n\u001b[31m\u001b[31m  |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                Not found: isPalindrome\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        while (true) {\n            n += 1\n            if (isPalindrome(n)) return n\n        }\n        return -1\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123066,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3skv3vcx.scala:9:16 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m            \u001b[33mif\u001b[0m (isPalindrome(n)) \u001b[33mreturn\u001b[0m n\n\u001b[31m\u001b[31m  |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                Not found: isPalindrome\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        def isPalindrome(num : Long) : Boolean = {\n            val str = num.toString\n            str == str.reverse\n        }\n        def nextSmallestPalindrome(num : Long, i : Long) : Long = {\n            if (isPalindrome(num + i)) num + i\n            else nextSmallestPalindrome(num, i + 1)\n        }\n        nextSmallestPalindrome(num, 1)\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123113,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        def isPalindrome(num : Long) : Boolean = {\n            val str = num.toString\n            str == str.reverse\n        }\n        def nextPalindrome(num : Long) : Long = {\n            if (isPalindrome(num)) num\n            else nextPalindrome(num + 1)\n        }\n        nextPalindrome(num + 1)\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1665517291,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val str = num.toString\n        val len = str.length\n        val half = len / 2\n        val left = str.substring(0, half)\n        val right = str.substring(half + len % 2)\n        val leftRev = left.reverse\n        val leftInt = left.toInt\n        val leftRevInt = leftRev.toInt\n        val rightInt = right.toInt\n        if (leftInt < rightInt) {\n            val leftRevStr = (leftInt + 1).toString\n            val leftRevStrRev = leftRevStr.reverse\n            val leftRevStrRevInt = leftRevStrRev.toInt\n            if (leftRevStrRevInt > rightInt) {\n                val leftRevStrInt = leftRevStr.toInt\n                val leftRevStrIntStr = leftRevStrInt.toString\n                val leftRevStrIntStrRev = leftRevStrIntStr.reverse\n                val leftRevStrIntStrRevInt = leftRevStrIntStrRev.toInt\n                val leftRevStrIntStrRevIntStr = leftRevStrIntStrRevInt.toString\n                val leftRevStrIntStrRevIntStrLen = leftRevStrIntStrRevIntStr.length\n                val leftRevStrIntStrRevIntStrLenHalf = leftRevStrIntStrRevIntStrLen / 2\n                val leftRevStrIntStrRevIntStrLenHalfStr = leftRevStrIntStrRevIntStr.substring(0, leftRevStrIntStrRevIntStrLenHalf)\n                val leftRevStrIntStrRevIntStrLenHalfStrInt = leftRevStrIntStrRevIntStrLenHalfStr.toInt\n                val leftRevStrIntStrRevIntStrLenHalfStrIntStr = leftRevStrIntStrRevIntStrLenHalfStrInt.toString\n                val leftRevStrIntStrRevIntStrLenHalfStrIntStrRev = leftRevStrIntStrRevIntStrLenHalfStrIntStr.reverse\n                val leftRevStrIntStrRevIntStrLenHalfStrIntStrRevInt = leftRevStrIntStrRevIntStrLenHalfStrIntStrRev.toInt\n                val leftRevStrIntStrRevIntStrLenHalfStrIntStrRevIntStr = leftRevStrIntStrRevIntStrLenHalfStrIntStrRevInt.toString\n\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123111,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmppokxbjcz.scala:42:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppokxbjcz.scala:15:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mif\u001b[0m (leftInt < rightInt) {\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    Unit\n\u001b[31m   |\u001b[0m        Required: Long\n\u001b[31m   |\u001b[0m        Maybe you are missing an else part for the conditional?\n\u001b[31m16 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mleftRevStr\u001b[0m = (leftInt + \u001b[31m1\u001b[0m).toString\n\u001b[31m17 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mleftRevStrRev\u001b[0m = leftRevStr.reverse\n\u001b[31m18 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mleftRevStrRevInt\u001b[0m = leftRevStrRev.toInt\n\u001b[31m19 |\u001b[0m            \u001b[33mif\u001b[0m (leftRevStrRevInt > rightInt) {\n\u001b[31m20 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mleftRevStrInt\u001b[0m = leftRevStr.toInt\n\u001b[31m21 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mleftRevStrIntStr\u001b[0m = leftRevStrInt.toString\n\u001b[31m22 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mleftRevStrIntStrRev\u001b[0m = leftRevStrIntStr.reverse\n\u001b[31m23 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mleftRevStrIntStrRevInt\u001b[0m = leftRevStrIntStrRev.toInt\n\u001b[31m24 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mleftRevStrIntStrRevIntStr\u001b[0m = leftRevStrIntStrRevInt.toString\n\u001b[31m25 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mleftRevStrIntStrRevIntStrLen\u001b[0m = leftRevStrIntStrRevIntStr.length\n\u001b[31m26 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mleftRevStrIntStrRevIntStrLenHalf\u001b[0m = leftRevStrIntStrRevIntStrLen / \u001b[31m2\u001b[0m\n\u001b[31m27 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mleftRevStrIntStrRevIntStrLenHalfStr\u001b[0m = leftRevStrIntStrRevIntStr.substring(\u001b[31m0\u001b[0m, leftRevStrIntStrRevIntStrLenHalf)\n\u001b[31m28 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mleftRevStrIntStrRevIntStrLenHalfStrInt\u001b[0m = leftRevStrIntStrRevIntStrLenHalfStr.toInt\n\u001b[31m29 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mleftRevStrIntStrRevIntStrLenHalfStrIntStr\u001b[0m = leftRevStrIntStrRevIntStrLenHalfStrInt.toString\n\u001b[31m30 |\u001b[0m             ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val n = s.length\n        val mid = n / 2\n        val left = s.substring(0, mid)\n        val right = s.substring(mid + (n % 2), n)\n        val leftRev = left.reverse\n        val leftInt = left.toInt\n        val leftRevInt = leftRev.toInt\n        val rightInt = right.toInt\n        if (leftInt == rightInt) {\n            val nextLeft = (leftInt + 1).toString\n            val nextLeftRev = nextLeft.reverse\n            val nextLeftRevInt = nextLeftRev.toInt\n            if (nextLeftRevInt < rightInt) {\n                val nextLeftRevStr = nextLeftRevInt.toString\n                val nextLeftRevStrPadded = nextLeftRevStr.padTo(mid, '0')\n                val nextLeftStr = nextLeft.padTo(mid, '0')\n                (nextLeftStr + nextLeftRevStrPadded).toLong\n            } else {\n                val nextLeftStr = nextLeft.padTo(mid, '0')\n                (nextLeftStr + nextLeft).toLong\n            }\n        } else if (leftInt < rightInt) {\n            val leftRevStr = leftRevInt.toString\n            val leftRevStrPadded = leftRevStr.padTo(mid, '0')\n            val leftStr = left.padTo(mid, '0')\n            (leftStr + leftRevStrPadded).toLong\n        } else {\n            val nextLeft = (leftInt + 1).toString\n            val nextLeftRev = nextLeft.reverse\n            val nextLeftRevInt = nextLeftRev.toInt\n            val nextLeftRevStr = nextLeftRevInt.toString\n            val nextLeftRevStrPadded = nextLeftRevStr.padTo(mid, '0')\n            val nextLeftStr = nextLeft.padTo(mid, '0')\n            (nextLeftStr + nextLeftRevStrPadded).toLong\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123113,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpssfqg5kz.scala:45)\n\tat Problem.main(tmpssfqg5kz.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val n = s.length\n        val half = n / 2\n        val left = s.substring(0, half)\n        val right = s.substring(half + n % 2, n)\n        val leftRev = left.reverse\n        if (leftRev > right) {\n            val leftInc = (left.toLong + 1).toString\n            val leftIncRev = leftInc.reverse\n            val leftIncRevLen = leftIncRev.length\n            val leftIncRevPad = leftIncRev.padTo(half, '0')\n            val leftIncRevPadLen = leftIncRevPad.length\n            val leftIncRevPadSub = leftIncRevPad.substring(leftIncRevLen, leftIncRevPadLen)\n            val leftIncRevPadSubLen = leftIncRevPadSub.length\n            val leftIncRevPadSubRev = leftIncRevPadSub.reverse\n            val leftIncRevPadSubRevLen = leftIncRevPadSubRev.length\n            val leftIncRevPadSubRevSub = leftIncRevPadSubRev.substring(leftIncRevPadSubLen - leftIncRevLen, leftIncRevPadSubRevLen)\n            val leftIncRevPadSubRevSubLen = leftIncRevPadSubRevSub.length\n            val leftIncRevPadSubRevSubSub = leftIncRevPadSubRevSub.substring(0, leftIncRevPadSubRevSubLen - n % 2)\n            val leftIncRevPadSubRevSubSubLen = leftIncRevPadSubRevSubSub.length\n            val leftIncRevPadSubRevSubSubRev = leftIncRevPadSubRevSubSub.reverse\n            val leftIncRevPadSubRevSubSubRevLen = leftIncRevPadSubRevSubSubRev.length\n            val leftIncRevPadSubRevSubSubRevSub = leftIncRevPadSubRevSubSubRev.substring(leftIncRevPadSubRevSubSubLen, leftIncRevPadSubRevSubSubRevLen)\n            val leftIncRevPadSubRevSubSubRevSubLen = leftIncRevPadSubRevSubSubRevSub.length\n            val leftIncRevPadSubRevSubSubRevSubSub = leftIncRevPadSubRevSubSubRevSub.substring(0, leftIncRev\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123116,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpsj49_g8f.scala:31:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpsj49_g8f.scala:39:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpsj49_g8f.scala:30:98 --------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mleftIncRevPadSubRevSubSubRevSubSub\u001b[0m = leftIncRevPadSubRevSubSubRevSub.substring(\u001b[31m0\u001b[0m, leftIncRev\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                  ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Found:    (leftIncRev : String)\n\u001b[31m   |\u001b[0m                                         Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpsj49_g8f.scala:38:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpsj49_g8f.scala:32:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m32 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val digits = num.toString.toList.map(_.toString.toInt)\n        val (left, right) = digits.splitAt(digits.length / 2)\n        val leftRev = left.reverse\n        val leftRevStr = leftRev.mkString\n        val rightStr = right.mkString\n        val leftStr = left.mkString\n        val palindrome = leftStr + leftRevStr\n        if (palindrome.toLong > num) palindrome.toLong\n        else {\n            val leftRevInt = leftRevStr.toInt\n            val rightInt = rightStr.toInt\n            val leftInt = leftStr.toInt\n            if (leftRevInt > rightInt) {\n                val newLeft = (leftInt + 1).toString.toList.map(_.toString.toInt)\n                val newLeftRev = newLeft.reverse\n                val newLeftStr = newLeft.mkString\n                val newLeftRevStr = newLeftRev.mkString\n                newLeftStr + newLeftRevStr\n            }\n            else {\n                val newLeft = left.map(_.toString.toInt)\n                val newLeftRev = newLeft.reverse\n                val newLeftStr = newLeft.mkString\n                val newLeftRevStr = newLeftRev.mkString\n                newLeftStr + newLeftRevStr\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123115,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwl_m_hrq.scala:23:16 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                newLeftStr + newLeftRevStr\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Found:    String\n\u001b[31m   |\u001b[0m                Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwl_m_hrq.scala:30:16 --------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                newLeftStr + newLeftRevStr\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Found:    String\n\u001b[31m   |\u001b[0m                Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        while (true) {\n            n += 1\n            if (isPalindrome(n)) return n\n        }\n        return -1\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123066,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3skv3vcx.scala:9:16 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m            \u001b[33mif\u001b[0m (isPalindrome(n)) \u001b[33mreturn\u001b[0m n\n\u001b[31m\u001b[31m  |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                Not found: isPalindrome\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        while(true) {\n            n += 1\n            if(isPalindrome(n)) return n\n        }\n        return -1\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1665517289,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8ynnkoj1.scala:9:15 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m            \u001b[33mif\u001b[0m(isPalindrome(n)) \u001b[33mreturn\u001b[0m n\n\u001b[31m\u001b[31m  |\u001b[0m               ^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m               Not found: isPalindrome\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        def isPalindrome(num : Long) : Boolean = {\n            val str = num.toString\n            str == str.reverse\n        }\n        def nextPalindrome(num : Long) : Long = {\n            if (isPalindrome(num)) num\n            else nextPalindrome(num + 1)\n        }\n        nextPalindrome(num + 1)\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1665517291,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val n = s.length\n        val half = n / 2\n        val left = s.substring(0, half)\n        val right = s.substring(half + n % 2, n)\n        val leftRev = left.reverse\n        if (right < leftRev) {\n            val newLeft = (left.toLong + 1).toString\n            val newRight = newLeft.reverse\n            (newLeft + newRight.substring(n % 2, n)).toLong\n        } else {\n            (left + leftRev.substring(n % 2, n)).toLong\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123115,
      "stdout": "",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin 0, end 2, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat Problem$.nextSmallestPalindrome(tmpk7i72nfo.scala:17)\n\tat Problem$.main(tmpk7i72nfo.scala:21)\n\tat Problem.main(tmpk7i72nfo.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val str = num.toString\n        val len = str.length\n        val half = len / 2\n        val left = str.substring(0, half)\n        val right = str.substring(half + len % 2, len)\n        val leftRev = left.reverse\n        val rightRev = right.reverse\n        if (leftRev == right) {\n            val leftInc = (left.toLong + 1).toString\n            val leftIncLen = leftInc.length\n            val leftIncHalf = leftIncLen / 2\n            val leftIncLeft = leftInc.substring(0, leftIncHalf)\n            val leftIncRight = leftInc.substring(leftIncHalf + leftIncLen % 2, leftIncLen)\n            val leftIncLeftRev = leftIncLeft.reverse\n            val leftIncRightRev = leftIncRight.reverse\n            if (leftIncLeftRev == leftIncRight) {\n                val leftIncRightRevLen = leftIncRightRev.length\n                val leftIncRightRevHalf = leftIncRightRevLen / 2\n                val leftIncRightRevLeft = leftIncRightRev.substring(0, leftIncRightRevHalf)\n                val leftIncRightRevRight = leftIncRightRev.substring(leftIncRightRevHalf + leftIncRightRevLen % 2, leftIncRightRevLen)\n                val leftIncRightRevLeftRev = leftIncRightRevLeft.reverse\n                val leftIncRightRevRightRev = leftIncRightRevRight.reverse\n                if (leftIncRightRevLeftRev == leftIncRightRevRight) {\n                    val leftIncRightRevRightRevLen = leftIncRightRevRightRev.length\n                    val leftIncRightRevRightRevHalf = leftIncRightRevRightRevLen / 2\n                    val leftIncRightRevRightRevLeft = leftIncRightRevRightRev.substring(0, leftIncRightRevRightRevHalf)\n                    val leftIncRightRevRightRevRight = leftIncRightRevRightRev.substring(leftIncRightRevRightRevHalf + leftIncRightRevRightRevLen % 2, leftIncRightRevRightRevLen)\n                    val leftIncRightRevRightRevLeftRev = leftIncRightRevRightRevLeft.reverse\n                    val leftIncRightRevRightRevRightRev = leftIncRightRevRightRevRight\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123114,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp5hmllgvu.scala:43:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5hmllgvu.scala:13:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mif\u001b[0m (leftRev == right) {\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    Unit\n\u001b[31m   |\u001b[0m        Required: Long\n\u001b[31m   |\u001b[0m        Maybe you are missing an else part for the conditional?\n\u001b[31m14 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mleftInc\u001b[0m = (left.toLong + \u001b[31m1\u001b[0m).toString\n\u001b[31m15 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mleftIncLen\u001b[0m = leftInc.length\n\u001b[31m16 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mleftIncHalf\u001b[0m = leftIncLen / \u001b[31m2\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mleftIncLeft\u001b[0m = leftInc.substring(\u001b[31m0\u001b[0m, leftIncHalf)\n\u001b[31m18 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mleftIncRight\u001b[0m = leftInc.substring(leftIncHalf + leftIncLen % \u001b[31m2\u001b[0m, leftIncLen)\n\u001b[31m19 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mleftIncLeftRev\u001b[0m = leftIncLeft.reverse\n\u001b[31m20 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mleftIncRightRev\u001b[0m = leftIncRight.reverse\n\u001b[31m21 |\u001b[0m            \u001b[33mif\u001b[0m (leftIncLeftRev == leftIncRight) {\n\u001b[31m22 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mleftIncRightRevLen\u001b[0m = leftIncRightRev.length\n\u001b[31m23 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mleftIncRightRevHalf\u001b[0m = leftIncRightRevLen / \u001b[31m2\u001b[0m\n\u001b[31m24 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mleftIncRightRevLeft\u001b[0m = leftIncRightRev.substring(\u001b[31m0\u001b[0m, leftIncRightRevHalf)\n\u001b[31m25 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mleftIncRightRevRight\u001b[0m = leftIncRightRev.substring(leftIncRightRevHalf + leftIncRightRevLen % \u001b[31m2\u001b[0m, leftIncRightRevLen)\n\u001b[31m26 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mleftIncRightRevLeftRev\u001b[0m = leftIncRightRevLeft.reverse\n\u001b[31m27 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mleftIncRightRevRightRev\u001b[0m = leftIncRightRevRight.reverse\n\u001b[31m28 |\u001b[0m                \u001b[33mif\u001b[0m (leftIncRightRevLeftRev == leftIncRightRevRight)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        def isPalindrome(num : Long) : Boolean = {\n            val str = num.toString\n            str == str.reverse\n        }\n        def nextPalindrome(num : Long) : Long = {\n            val str = num.toString\n            val len = str.length\n            val half = len / 2\n            val left = str.substring(0, half)\n            val right = str.substring(half + len % 2, len).reverse\n            val nextLeft = (BigInt(left) + 1).toString\n            val nextRight = nextLeft.reverse\n            if (nextLeft.length > half) {\n                val nextLeft = \"1\" + \"0\" * (len - 1) + \"1\"\n                nextLeft.toLong\n            } else {\n                (left + right).toLong\n            }\n        }\n        if (isPalindrome(num)) num else nextPalindrome(num)\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123116,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp1rjhg7ni.scala:28)\n\tat Problem.main(tmp1rjhg7ni.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var digits = new ArrayBuffer[Int]()\n        while (n > 0) {\n            digits += (n % 10).toInt\n            n /= 10\n        }\n        var i = 0\n        while (i < digits.length / 2) {\n            if (digits(i) < digits(digits.length - 1 - i)) {\n                var j = digits.length - 1 - i\n                while (j > i && digits(j) == 9) {\n                    digits(j) = 0\n                    j -= 1\n                }\n                if (j == i) {\n                    digits(j) = 0\n                    digits.insert(0, 1)\n                } else digits(j) += 1\n                i += 1\n            } else if (digits(i) > digits(digits.length - 1 - i)) {\n                digits(digits.length - 1 - i) = digits(i)\n                i += 1\n            } else i += 1\n        }\n        var result = 0L\n        for (i <- 0 until digits.length) result = result * 10 + digits(i)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123117,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpy6lwxmgu.scala:35)\n\tat Problem.main(tmpy6lwxmgu.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        def isPalindrome(num : Long) : Boolean = {\n            val str = num.toString\n            str == str.reverse\n        }\n        def nextSmallestPalindrome(num : Long, i : Int) : Long = {\n            if (i == 0) {\n                val str = num.toString\n                val half = str.length / 2\n                val left = str.substring(0, half)\n                val right = str.substring(half + (if (str.length % 2 == 0) 0 else 1), str.length)\n                val leftNum = left.toLong\n                val rightNum = right.toLong\n                if (leftNum == rightNum) num\n                else {\n                    val nextLeft = (leftNum + 1).toString\n                    val nextRight = nextLeft.reverse\n                    val nextStr = nextLeft + nextRight\n                    if (str.length % 2 == 0) nextStr.toLong\n                    else nextStr.substring(0, nextStr.length - 1).toLong\n                }\n            } else {\n                val str = num.toString\n                val half = str.length / 2\n                val left = str.substring(0, half)\n                val right = str.substring(half + (if (str.length % 2 == 0) 0 else 1), str.length)\n                val leftNum = left.toLong\n                val rightNum = right.toLong\n                if (leftNum == rightNum) num\n                else {\n                    val nextLeft = (leftNum + 1).toString\n                    val nextRight = nextLeft.reverse\n                    val nextStr = nextLeft + nextRight\n                    if (str.length % 2 == 0) nextStr.toLong\n                    else nextStr.substring(0, nextStr.length - 1).toLong\n                }\n            }\n        }\n        if (isPalindrome(num)) num\n        else {\n            val str = num.toString\n            val half = str.length / 2\n            val left = str.substring(0, half)\n            val right = str.substring(half + (if (str.length % 2 == 0) 0 else 1), str.length)\n            val leftNum = left\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123117,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp29tv99ec.scala:58:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- Error: /tmp/tmp29tv99ec.scala:52:33 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m    assert(nextSmallestPalindrome((\u001b[31m99l\u001b[0m)) == (\u001b[31m101l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter i of \u001b[33mmethod\u001b[0m \u001b[35mnextSmallestPalindrome\u001b[0m: (num: Long, i: Int): Long\n\u001b[31m\u001b[31m-- Error: /tmp/tmp29tv99ec.scala:53:33 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m    assert(nextSmallestPalindrome((\u001b[31m1221l\u001b[0m)) == (\u001b[31m1331l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter i of \u001b[33mmethod\u001b[0m \u001b[35mnextSmallestPalindrome\u001b[0m: (num: Long, i: Int): Long\n\u001b[31m\u001b[31m-- Error: /tmp/tmp29tv99ec.scala:54:33 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m    assert(nextSmallestPalindrome((\u001b[31m120l\u001b[0m)) == (\u001b[31m121l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter i of \u001b[33mmethod\u001b[0m \u001b[35mnextSmallestPalindrome\u001b[0m: (num: Long, i: Int): Long\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp29tv99ec.scala:57:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmp29tv99ec.scala:51:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m51 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        val s = num.toString\n        val n = s.length\n        var i = 0\n        while (i < n / 2 && s(i) == s(n - i - 1)) i += 1\n        if (i == n / 2) {\n            if (n % 2 == 0) {\n                val mid = s.substring(n / 2 - 1, n / 2 + 1)\n                val next = (mid.toLong + 1).toString\n                if (next.length == 2) {\n                    val prefix = s.substring(0, n / 2 - 1)\n                    prefix + next + prefix.reverse\n                } else {\n                    val prefix = s.substring(0, n / 2)\n                    prefix + next + prefix.reverse\n                }\n            } else {\n                val mid = s.substring(n / 2, n / 2 + 1)\n                val next = (mid.toLong + 1).toString\n                if (next.length == 2) {\n                    val prefix = s.substring(0, n / 2)\n                    prefix + next + prefix.reverse\n                } else {\n                    val prefix = s.substring(0, n / 2 + 1)\n                    prefix + next + prefix.reverse\n                }\n            }\n        } else {\n            val prefix = s.substring(0, i)\n            val mid = s.substring(i, n - i)\n            val next = (mid.toLong + 1).toString\n            if (next.length == mid.length) {\n                prefix + next + prefix.reverse\n            } else {\n                val prefix2 = s.substring(0, i + 1)\n                prefix2 + next + prefix2.reverse\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123117,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp803c05lt.scala:16:20 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                    prefix + next + prefix.reverse\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Found:    String\n\u001b[31m   |\u001b[0m                    Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp803c05lt.scala:19:20 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                    prefix + next + prefix.reverse\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Found:    String\n\u001b[31m   |\u001b[0m                    Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp803c05lt.scala:26:20 --------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                    prefix + next + prefix.reverse\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Found:    String\n\u001b[31m   |\u001b[0m                    Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp803c05lt.scala:29:20 --------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                    prefix + next + prefix.reverse\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Found:    String\n\u001b[31m   |\u001b[0m                    Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp803c05lt.scala:37:16 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                prefix + next + prefix.reverse\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Found:    String\n\u001b[31m   |\u001b[0m                Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explana",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var length = 0\n        while (n > 0) {\n            length += 1\n            n /= 10\n        }\n        var left = num / pow(10, length / 2).toLong\n        var right = num % pow(10, length / 2).toLong\n        var next = left * pow(10, length / 2).toLong + right\n        while (next <= num) {\n            left += 1\n            next = left * pow(10, length / 2).toLong + right\n        }\n        next\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123117,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpv25qwyh8.scala:22)\n\tat Problem.main(tmpv25qwyh8.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var digits = new ArrayBuffer[Int]()\n        while (n > 0) {\n            digits += (n % 10).toInt\n            n /= 10\n        }\n        var i = 0\n        var j = digits.length - 1\n        while (i < j) {\n            if (digits(i) < digits(j)) {\n                digits(j) = digits(i)\n            } else if (digits(i) > digits(j)) {\n                digits(j) = digits(i)\n                var k = j - 1\n                while (k >= 0 && digits(k) == 9) {\n                    digits(k) = 0\n                    k -= 1\n                }\n                if (k < 0) {\n                    digits.insert(0, 1)\n                } else {\n                    digits(k) += 1\n                }\n            }\n            i += 1\n            j -= 1\n        }\n        var result = 0L\n        for (i <- 0 until digits.length) {\n            result *= 10\n            result += digits(i)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123117,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpq1p305i6.scala:41)\n\tat Problem.main(tmpq1p305i6.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        var digits = 0\n        while (n > 0) {\n            n /= 10\n            digits += 1\n        }\n        var i = 0\n        var j = digits - 1\n        var isPalindrome = true\n        while (i < j) {\n            if ((num / pow(10, i).toLong) % 10 != (num / pow(10, j).toLong) % 10) {\n                isPalindrome = false\n                break\n            }\n            i += 1\n            j -= 1\n        }\n        if (isPalindrome) {\n            var k = digits / 2\n            while (k >= 0) {\n                if ((num / pow(10, k).toLong) % 10 == 9) {\n                    num -= pow(10, k).toLong * 9\n                    k -= 1\n                } else {\n                    num += pow(10, k).toLong\n                    return num\n                }\n            }\n            num = pow(10, digits).toLong + 1\n            return num\n        } else {\n            var k = digits / 2\n            var carry = 0\n            while (k >= 0) {\n                var digit = (num / pow(10, k).toLong) % 10\n                if (digit + carry > 9) {\n                    num -= pow(10, k).toLong * 9\n                    carry = 1\n                } else {\n                    num += pow(10, k).toLong * (10 - digit - carry)\n                    carry = 0\n                }\n                k -= 1\n            }\n            if (carry == 1) {\n                num = pow(10, digits).toLong + 1\n            }\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1666123117,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpet30ruvg.scala:18:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpet30ruvg.scala:27:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                    num -= pow(\u001b[31m10\u001b[0m, k).toLong * \u001b[31m9\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 value -= is not a member of Long - did you mean num.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpet30ruvg.scala:30:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                    num += pow(\u001b[31m10\u001b[0m, k).toLong\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 value += is not a member of Long - did you mean num.!=?\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpet30ruvg.scala:34:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            num = pow(\u001b[31m10\u001b[0m, digits).toLong + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val num\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpet30ruvg.scala:42:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m                    num -= pow(\u001b[31m10\u001b[0m, k).toLong * \u001b[31m9\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 value -= is not a member of Long - did you mean num.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpet30ruvg.scala:45:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m                    num += pow(\u001b[31m10\u001b[0m, k).toLong * (\u001b[31m10\u001b[0m - digit - carry)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 value += is not a member of Long - did you mean num.!=?\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpet30ruvg.scala:51:20 -----------------------------\u001b[0m\u001b",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n        var n = num\n        while(true) {\n            n += 1\n            if(isPalindrome(n)) return n\n        }\n        return -1\n    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
      "timestamp": 1665517289,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8ynnkoj1.scala:9:15 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m            \u001b[33mif\u001b[0m(isPalindrome(n)) \u001b[33mreturn\u001b[0m n\n\u001b[31m\u001b[31m  |\u001b[0m               ^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m               Not found: isPalindrome\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}