{
  "name": "mbpp_603_get_ludic",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to get all lucid numbers smaller than or equal to a given integer.\n    def getLudic(n : Long) : List[Long] = {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_603_get_ludic.py",
  "prompt_terminology": "reworded",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(getLudic((10l)).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(getLudic((25l)).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 23l.toLong, 25l.toLong))));\n    assert(getLudic((45l)).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 23l.toLong, 25l.toLong, 29l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        def isLudic(n : Long) : Boolean = {\n            val s = n.toString\n            val l = s.length\n            val m = s.map(x => pow(x.asDigit, l).toLong).sum\n            m == n\n        }\n        (1 to n.toInt).filter(x => isLudic(x)).toList.map(_.toLong)",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLucid(i)) result = result :+ i\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = result :+ i\n        }\n        result",
    "        def isLudic(n : Long) : Boolean = {\n            val s = n.toString\n            for (i <- 0 to s.length - 1) {\n                if (s(i) != '0' && n % (s(i) - '0') == 0) return true\n            }\n            return false\n        }\n        var l = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) l = i :: l\n        }\n        return l",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            val s = i.toString\n            var sum = 0\n            for (j <- 0 until s.length) {\n                sum += pow(s(j).toString.toInt, s.length).toInt\n            }\n            if (sum == i) result = i :: result\n        }\n        result",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val d = n % 10\n                if (d % 2 == 0) getLudic(n / 10, acc)\n                else getLudic(n / 10, n :: acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = ludic :+ i\n        }\n        ludic",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val x = n % 10\n                if (x % 2 == 0) getLudic(n / 10, acc)\n                else getLudic(n / 10, n :: acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            val s = i.toString\n            val s2 = s + s\n            val s3 = s + s + s\n            if (i == s2.toInt + s3.toInt) ludic += i\n        }\n        ludic.toList",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val ludic = (acc.head * 10) + (acc.head % 10)\n                if (ludic <= n) getLudic(n, ludic :: acc)\n                else acc\n            }\n        }\n        getLudic(n, List(0))",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        result",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = i :: ludic\n        }\n        ludic",
    "        def getLudic(n : Long, l : List[Long]) : List[Long] = {\n            if (n == 0) l\n            else if (isLudic(n)) getLudic(n - 1, n :: l)\n            else getLudic(n - 1, l)\n        }\n        getLudic(n, Nil)",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = i :: ludic\n        }\n        ludic",
    "        def getLudicHelper(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else if (isLucid(n)) getLudicHelper(n - 1, n :: acc)\n            else getLudicHelper(n - 1, acc)\n        }\n        getLudicHelper(n, Nil)",
    "        def isLudic(x : Long) : Boolean = {\n            val s = x.toString\n            val l = s.length\n            for (i <- 0 to l - 1) {\n                if (s(i) != '0' && x % (s(i) - '0') != 0) return false\n            }\n            true\n        }\n        (1 to n.toInt).filter(x => isLudic(x)).map(x => x.toLong).toList",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            var sum = 0\n            var num = i\n            while (num > 0) {\n                sum += pow(num % 10, 2).toInt\n                num /= 10\n            }\n            if (sum == 1) ludic += i\n        }\n        ludic.toList",
    "        def getLudicHelper(n : Long, l : List[Long]) : List[Long] = {\n            if (n == 0) l\n            else {\n                val m = n % 10\n                if (m == 0) getLudicHelper(n / 10, l)\n                else getLudicHelper(n / 10, n :: l)\n            }\n        }\n        getLudicHelper(n, Nil)",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLucid(i)) ludic = i :: ludic\n        }\n        ludic",
    "        val list = new ArrayBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) list += i\n        }\n        list.toList"
  ]
}