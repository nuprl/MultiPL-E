{
  "name": "mbpp_603_get_ludic",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to get all lucid numbers smaller than or equal to a given integer.\n    def getLudic(n : Long) : List[Long] = {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_603_get_ludic.py",
  "prompt_terminology": "reworded",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(getLudic((10l)).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(getLudic((25l)).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 23l.toLong, 25l.toLong))));\n    assert(getLudic((45l)).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 23l.toLong, 25l.toLong, 29l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        def isLudic(n : Long) : Boolean = {\n            val s = n.toString\n            val l = s.length\n            val m = s.map(x => pow(x.asDigit, l).toLong).sum\n            m == n\n        }\n        (1 to n.toInt).filter(x => isLudic(x)).toList.map(_.toLong)",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLucid(i)) result = result :+ i\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = result :+ i\n        }\n        result",
    "        def isLudic(n : Long) : Boolean = {\n            val s = n.toString\n            for (i <- 0 to s.length - 1) {\n                if (s(i) != '0' && n % (s(i) - '0') == 0) return true\n            }\n            return false\n        }\n        var l = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) l = i :: l\n        }\n        return l",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            val s = i.toString\n            var sum = 0\n            for (j <- 0 until s.length) {\n                sum += pow(s(j).toString.toInt, s.length).toInt\n            }\n            if (sum == i) result = i :: result\n        }\n        result",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val d = n % 10\n                if (d % 2 == 0) getLudic(n / 10, acc)\n                else getLudic(n / 10, n :: acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = ludic :+ i\n        }\n        ludic",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val x = n % 10\n                if (x % 2 == 0) getLudic(n / 10, acc)\n                else getLudic(n / 10, n :: acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            val s = i.toString\n            val s2 = s + s\n            val s3 = s + s + s\n            if (i == s2.toInt + s3.toInt) ludic += i\n        }\n        ludic.toList",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val ludic = (acc.head * 10) + (acc.head % 10)\n                if (ludic <= n) getLudic(n, ludic :: acc)\n                else acc\n            }\n        }\n        getLudic(n, List(0))",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        result",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = i :: ludic\n        }\n        ludic",
    "        def getLudic(n : Long, l : List[Long]) : List[Long] = {\n            if (n == 0) l\n            else if (isLudic(n)) getLudic(n - 1, n :: l)\n            else getLudic(n - 1, l)\n        }\n        getLudic(n, Nil)",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = i :: ludic\n        }\n        ludic",
    "        def getLudicHelper(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else if (isLucid(n)) getLudicHelper(n - 1, n :: acc)\n            else getLudicHelper(n - 1, acc)\n        }\n        getLudicHelper(n, Nil)",
    "        def isLudic(x : Long) : Boolean = {\n            val s = x.toString\n            val l = s.length\n            for (i <- 0 to l - 1) {\n                if (s(i) != '0' && x % (s(i) - '0') != 0) return false\n            }\n            true\n        }\n        (1 to n.toInt).filter(x => isLudic(x)).map(x => x.toLong).toList",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            var sum = 0\n            var num = i\n            while (num > 0) {\n                sum += pow(num % 10, 2).toInt\n                num /= 10\n            }\n            if (sum == 1) ludic += i\n        }\n        ludic.toList",
    "        def getLudicHelper(n : Long, l : List[Long]) : List[Long] = {\n            if (n == 0) l\n            else {\n                val m = n % 10\n                if (m == 0) getLudicHelper(n / 10, l)\n                else getLudicHelper(n / 10, n :: l)\n            }\n        }\n        getLudicHelper(n, Nil)",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLucid(i)) ludic = i :: ludic\n        }\n        ludic",
    "        val list = new ArrayBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) list += i\n        }\n        list.toList",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val digit = n % 10\n                if (digit % 2 == 0) getLudic(n / 10, acc)\n                else getLudic(n / 10, n :: acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = i :: ludic\n        }\n        ludic",
    "        def getLudicHelper(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val digit = n % 10\n                if (digit % 2 == 0) getLudicHelper(n / 10, acc)\n                else getLudicHelper(n / 10, n :: acc)\n            }\n        }\n        getLudicHelper(n, Nil)",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLucid(i)) result = result :+ i\n        }\n        result",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else if (n % 10 == 0) getLudic(n / 10, acc)\n            else if (n % 10 == 1) getLudic(n / 10, n :: acc)\n            else getLudic(n / 10, acc)\n        }\n        getLudic(n, Nil)",
    "        def isLudic(x : Long) : Boolean = {\n            val s = x.toString\n            val l = s.length\n            val d = s.map(c => c.toString.toInt).toList\n            val m = d.map(i => pow(i, l).toLong).sum\n            m == x\n        }\n        (1L to n).filter(isLudic).toList",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = result :+ i\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        result",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = i :: ludic\n        }\n        ludic",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic += i\n        }\n        ludic.toList",
    "        def getLudic(n : Long, l : List[Long]) : List[Long] = {\n            if (n == 0) l\n            else {\n                val m = n % 10\n                if (m % 2 == 0) getLudic(n / 10, l)\n                else getLudic(n / 10, n :: l)\n            }\n        }\n        getLudic(n, Nil)",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        result",
    "        var list = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) list = i :: list\n        }\n        list",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = i :: ludic\n        }\n        ludic",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic += i\n        }\n        ludic.toList",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = i :: ludic\n        }\n        ludic",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            var sum = 0\n            var j = i\n            while (j > 0) {\n                sum += pow(j % 10, 2).toInt\n                j /= 10\n            }\n            if (sum == 1) result = i :: result\n            else {\n                var set = Set[Int]()\n                while (sum != 1 && !set.contains(sum)) {\n                    set += sum\n                    var j = sum\n                    sum = 0\n                    while (j > 0) {\n                        sum += pow(j % 10, 2).toInt\n                        j /= 10\n                    }\n                }\n                if (sum == 1) result = i :: result\n            }\n        }\n        result",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = ludic :+ i\n        }\n        return ludic",
    "        def isLudic(x : Long) : Boolean = {\n            var sum = 0L\n            var y = x\n            while (y > 0) {\n                sum += pow(y % 10, 2).toLong\n                y /= 10\n            }\n            sum == 1\n        }\n        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        result",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = ludic :+ i\n        }\n        ludic",
    "        def isLudic(x : Long) : Boolean = {\n            val s = x.toString\n            var i = 0\n            while (i < s.length) {\n                val d = s(i).asDigit\n                if (d == 0) return false\n                if (x % d != 0) return false\n                i += 1\n            }\n            true\n        }\n        (1 to n.toInt).filter(isLudic).map(_.toLong).toList",
    "        var ludic = List[Long]()\n        for (i <- 1L to n) {\n            if (isLudic(i)) ludic = i :: ludic\n        }\n        ludic",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val m = n % 10\n                if (m % 2 == 0) getLudic(n / 10, acc)\n                else getLudic(n / 10, n :: acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            val x = i.toLong\n            if (isLudic(x)) ludic += x\n        }\n        ludic.toList",
    "        var result = List[Long]()\n        for (i <- 1L to n) {\n            if (isLudic(i)) {\n                result = i :: result\n            }\n        }\n        result",
    "        var result : List[Long] = Nil\n        for (i <- 1L to n) {\n            if (isLudic(i)) result = i :: result\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        result",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val m = n % 10\n                if (m == 0 || m == 6 || m == 9) getLudic(n / 10, n :: acc)\n                else getLudic(n / 10, acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        var ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic += i\n        }\n        ludic.toList",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            var sum = 0\n            var temp = i\n            while (temp != 0) {\n                sum += pow(temp % 10, 2).toInt\n                temp /= 10\n            }\n            if (sum == 1) result = i :: result\n            else {\n                var set = Set[Int]()\n                while (sum != 1 && !set.contains(sum)) {\n                    set += sum\n                    var temp = sum\n                    sum = 0\n                    while (temp != 0) {\n                        sum += pow(temp % 10, 2).toInt\n                        temp /= 10\n                    }\n                }\n                if (sum == 1) result = i :: result\n            }\n        }\n        result",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val d = n % 10\n                if (d % 2 == 0) getLudic(n / 10, acc)\n                else getLudic(n / 10, n :: acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        def getLudic(n : Long, l : List[Long]) : List[Long] = {\n            if (n == 0) l\n            else {\n                val d = n % 10\n                if (d % 2 == 0) getLudic(n / 10, l)\n                else getLudic(n / 10, n :: l)\n            }\n        }\n        getLudic(n, Nil)",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            var sum = 0\n            var num = i\n            while (num > 0) {\n                sum += pow(num % 10, 2).toInt\n                num /= 10\n            }\n            if (sum == 1) ludic = i :: ludic\n            else {\n                var set = Set[Int]()\n                while (sum != 1 && !set.contains(sum)) {\n                    set += sum\n                    var sum2 = 0\n                    var num2 = sum\n                    while (num2 > 0) {\n                        sum2 += pow(num2 % 10, 2).toInt\n                        num2 /= 10\n                    }\n                    sum = sum2\n                }\n                if (sum == 1) ludic = i :: ludic\n            }\n        }\n        return ludic",
    "        def isLudic(n : Long) : Boolean = {\n            def isLudic(n : Long, sum : Long) : Boolean = {\n                if (n == 0) return sum == 1\n                isLudic(n / 10, sum + pow(n % 10, 2).toLong)\n            }\n            isLudic(n, 0)\n        }\n        (1 to n.toInt).filter(isLudic(_)).toList",
    "        def getLudicHelper(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val d = n % 10\n                if (d % 2 == 0) getLudicHelper(n / 10, acc)\n                else getLudicHelper(n / 10, n :: acc)\n            }\n        }\n        getLudicHelper(n, Nil)",
    "        var result = List[Long]()\n        for (i <- 1L to n) {\n            var sum = 0L\n            var x = i\n            while (x > 0) {\n                sum += pow(x % 10, 2).toLong\n                x /= 10\n            }\n            if (sum == 1) result ::= i\n            else {\n                var set = Set[Long]()\n                while (sum != 1 && !set.contains(sum)) {\n                    set += sum\n                    var x = sum\n                    sum = 0\n                    while (x > 0) {\n                        sum += pow(x % 10, 2).toLong\n                        x /= 10\n                    }\n                }\n                if (sum == 1) result ::= i\n            }\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = result :+ i\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        result",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = i :: ludic\n        }\n        ludic",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val digits = n.toString.map(_.asDigit).toList\n                val sum = digits.map(x => pow(x, digits.length).toLong).sum\n                if (sum == n) getLudic(n - 1, n :: acc)\n                else getLudic(n - 1, acc)\n            }\n        }\n        getLudic(n, List())",
    "        def isLudic(x : Long) : Boolean = {\n            if (x == 0) return false\n            var n = x\n            var sum = 0\n            while (n > 0) {\n                sum += pow(n % 10, 2).toLong\n                n /= 10\n            }\n            if (sum == 1) return true\n            if (sum == x) return false\n            isLudic(sum)\n        }\n        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        result",
    "        def getLudicHelper(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val x = n % 10\n                if (x % 2 == 0) getLudicHelper(n / 10, acc)\n                else getLudicHelper(n / 10, n :: acc)\n            }\n        }\n        getLudicHelper(n, Nil)",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic += i\n        }\n        ludic.toList",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        result",
    "        def getLudic(n : Long, l : List[Long]) : List[Long] = {\n            if (n == 0) l\n            else {\n                val d = n % 10\n                if (d % 2 == 0) getLudic(n / 10, l)\n                else getLudic(n / 10, n :: l)\n            }\n        }\n        getLudic(n, Nil)",
    "        def getLudicHelper(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val s = n.toString\n                val sum = s.map(x => pow(x.toString.toInt, s.length).toInt).sum\n                if (sum == n) getLudicHelper(n - 1, n :: acc)\n                else getLudicHelper(n - 1, acc)\n            }\n        }\n        getLudicHelper(n, List())",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val m = n % 10\n                if (m % 2 == 0) getLudic(n / 10, acc)\n                else getLudic(n / 10, n :: acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else if (isLucid(n)) getLudic(n - 1, n :: acc)\n            else getLudic(n - 1, acc)\n        }\n        getLudic(n, List())",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic += i\n        }\n        ludic.toList",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic += i\n        }\n        ludic.toList",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = result :+ i\n        }\n        result",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = i :: ludic\n        }\n        ludic",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = ludic :+ i\n        }\n        ludic",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val m = n % 10\n                if (m % 2 == 0) getLudic(n / 10, acc)\n                else getLudic(n / 10, n :: acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            var x = i.toLong\n            while (x > 0) {\n                if (x % 10 == 6) {\n                    x = x / 10\n                    if (x % 10 == 2) {\n                        result = i :: result\n                        x = 0\n                    }\n                }\n                else x = x / 10\n            }\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = result :+ i\n        }\n        result",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic += i\n        }\n        ludic.toList",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val m = n % 10\n                if (m == 0) getLudic(n / 10, acc)\n                else if (m == 1) getLudic(n / 10, n :: acc)\n                else getLudic(n - 1, acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            var sum = 0\n            var nn = i\n            while (nn > 0) {\n                sum += pow(nn % 10, 2).toInt\n                nn /= 10\n            }\n            if (sum == 1) ludic = i :: ludic\n            else {\n                var isLudic = true\n                var set = Set[Int]()\n                while (sum != 1) {\n                    if (set.contains(sum)) {\n                        isLudic = false\n                        sum = 1\n                    }\n                    else {\n                        set += sum\n                        var sum2 = 0\n                        var nn = sum\n                        while (nn > 0) {\n                            sum2 += pow(nn % 10, 2).toInt\n                            nn /= 10\n                        }\n                        sum = sum2\n                    }\n                }\n                if (isLudic) ludic = i :: ludic\n            }\n        }\n        ludic",
    "        def getLudic(n : Long, list : List[Long]) : List[Long] = {\n            if (n == 0) list\n            else {\n                val x = n % 10\n                if (x % 2 == 0) getLudic(n / 10, list)\n                else getLudic(n / 10, n :: list)\n            }\n        }\n        getLudic(n, Nil)",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        result",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            val s = i.toString\n            if (s.contains(\"0\")) {\n                val digits = s.toList.map(_.toString.toInt)\n                val sum = digits.map(pow(_, digits.length)).sum\n                if (sum == i) ludic = i :: ludic\n            }\n        }\n        ludic",
    "        def getLudicHelper(n : Long, l : List[Long]) : List[Long] = {\n            if (n == 0) l\n            else if (isLudic(n)) getLudicHelper(n - 1, n :: l)\n            else getLudicHelper(n - 1, l)\n        }\n        getLudicHelper(n, Nil)",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic += i\n        }\n        ludic.toList",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = result :+ i\n        }\n        result",
    "        def isLudic(n : Long) : Boolean = {\n            val s = n.toString\n            for (i <- 0 until s.length) {\n                val x = s(i).toString.toInt\n                if (x != 0 && n % x != 0) return false\n            }\n            true\n        }\n        (1L to n).filter(isLudic).toList",
    "        def isLudic(x : Long) : Boolean = {\n            val s = x.toString\n            s.length == s.toSet.size\n        }\n        (1 to n.toInt).filter(x => isLudic(x)).map(x => x.toLong).toList",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = result :+ i\n        }\n        result",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val d = n % 10\n                if (d % 2 == 0) getLudic(n / 10, acc)\n                else getLudic(n / 10, n :: acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = i :: ludic\n        }\n        ludic",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            val sum = i.toString.map(x => pow(x.asDigit, 2)).sum\n            if (sum == i) ludic += i\n        }\n        ludic.toList",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLucid(i)) ludic = i :: ludic\n        }\n        ludic",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            val s = i.toString\n            if (s.contains(i.toString)) ludic += i\n        }\n        ludic.toList",
    "        def getLudic(n : Long, l : List[Long]) : List[Long] = {\n            if (n == 0) l\n            else {\n                val d = n % 10\n                if (d % 2 == 0) getLudic(n / 10, l)\n                else getLudic(n / 10, n :: l)\n            }\n        }\n        getLudic(n, Nil)",
    "        var list = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) list = list :+ i\n        }\n        list",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic += i\n        }\n        ludic.toList",
    "        def isLudic(x : Long) : Boolean = {\n            var s = x.toString\n            var i = 0\n            while (i < s.length) {\n                if (s(i) != '0' && x % (s(i) - '0') != 0) return false\n                i += 1\n            }\n            true\n        }\n        var l = List[Long]()\n        var i = 1L\n        while (i <= n) {\n            if (isLudic(i)) l = i :: l\n            i += 1\n        }\n        l",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic += i\n        }\n        ludic.toList",
    "        val ludic = ListBuffer[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic += i\n        }\n        ludic.toList",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        result",
    "        def getLudic(n : Long, l : List[Long]) : List[Long] = {\n            if (n == 0) l\n            else {\n                val s = n.toString\n                val m = s.map(x => pow(x.asDigit, s.length).toLong).sum\n                if (m == n) getLudic(n - 1, n :: l)\n                else getLudic(n - 1, l)\n            }\n        }\n        getLudic(n, Nil)",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val m = n % 10\n                if (m % 2 == 0) getLudic(n / 10, acc)\n                else getLudic(n / 10, n :: acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        def isLudic(n : Long) : Boolean = {\n            def getDigits(n : Long) : List[Int] = {\n                if (n == 0) Nil\n                else (n % 10).toInt :: getDigits(n / 10)\n            }\n            def getDigitSum(n : Long) : Long = {\n                if (n == 0) 0\n                else (n % 10) + getDigitSum(n / 10)\n            }\n            def getDigitProduct(n : Long) : Long = {\n                if (n == 0) 1\n                else (n % 10) * getDigitProduct(n / 10)\n            }\n            def getDigitSumProduct(n : Long) : Long = {\n                if (n == 0) 1\n                else getDigitSum(n) * getDigitProduct(n)\n            }\n            def getDigitSumProductSum(n : Long) : Long = {\n                if (n == 0) 0\n                else (n % 10) + getDigitSumProductSum(n / 10)\n            }\n            def getDigitSumProductProduct(n : Long) : Long = {\n                if (n == 0) 1\n                else (n % 10) * getDigitSumProductProduct(n / 10)\n            }\n            def getDigitSumProductSumProduct(n : Long) : Long = {\n                if (n == 0) 1\n                else getDigitSumProductSum(n) * getDigitSumProductProduct(n)\n            }\n            def getDigitSumProductSumProductSum(n : Long) : Long = {\n                if (n == 0) 0\n                else (n % 10) + getDigitSumProductSumProductSum(n / 10)\n            }\n            def getDigitSumProductSumProductProduct(n : Long) : Long = {\n                if (n == 0) 1\n                else (n % 10) * getDigitSumProductSumProductProduct(n / 10)\n            }\n            def getDigitSumProductSumProductSumProduct(n : Long) : Long = {\n                if (n == 0) 1\n                else getDigitSumProductSumProductSum(n) * getDigit",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = ludic :+ i\n        }\n        ludic",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = result :+ i\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            var sum = 0\n            var temp = i\n            while (temp > 0) {\n                sum += pow(temp % 10, 2).toInt\n                temp /= 10\n            }\n            if (sum == 1) result = i :: result\n            else {\n                var set = Set[Int]()\n                while (sum != 1 && !set.contains(sum)) {\n                    set += sum\n                    var temp = sum\n                    sum = 0\n                    while (temp > 0) {\n                        sum += pow(temp % 10, 2).toInt\n                        temp /= 10\n                    }\n                }\n                if (sum == 1) result = i :: result\n            }\n        }\n        result",
    "        def isLudic(n : Long) : Boolean = {\n            def isLudic(n : Long, sum : Long) : Boolean = {\n                if (n == 0) return sum == 1\n                if (n % 10 == 0) return false\n                isLudic(n / 10, sum + pow(n % 10, 2).toLong)\n            }\n            isLudic(n, 0)\n        }\n        (1 to n.toInt).filter(isLudic(_)).map(_.toLong).toList",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val m = n % 10\n                if (m % 2 == 0) getLudic(n / 10, acc)\n                else getLudic(n / 10, n :: acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        result",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic += i\n        }\n        ludic.toList",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = result :+ i\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = result :+ i\n        }\n        result",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else if (n % 10 == 0) getLudic(n / 10, acc)\n            else if (n % 10 == 1) getLudic(n / 10, n :: acc)\n            else getLudic(n - 1, acc)\n        }\n        getLudic(n, Nil)",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic += i\n        }\n        ludic.toList",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else if (n % 10 == 0) getLudic(n / 10, acc)\n            else if (n % 10 == 1) getLudic(n / 10, n :: acc)\n            else getLudic(n - 1, acc)\n        }\n        getLudic(n, Nil)",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val s = n.toString\n                if (s.length == 1) getLudic(n - 1, n :: acc)\n                else {\n                    val a = s.substring(0, s.length / 2)\n                    val b = s.substring(s.length / 2, s.length)\n                    if (a.reverse == b) getLudic(n - 1, n :: acc)\n                    else getLudic(n - 1, acc)\n                }\n            }\n        }\n        getLudic(n, List())",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val x = n % 10\n                if (x % 2 == 0) getLudic(n / 10, acc)\n                else getLudic(n / 10, n :: acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val l = acc.length\n                val ludic = acc(l - 1) + acc(l - 2)\n                if (ludic > n) acc\n                else getLudic(n, acc :+ ludic)\n            }\n        }\n        getLudic(n, List(2, 1))",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        result",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else if (n % 10 == 0) getLudic(n / 10, acc)\n            else if (n % 10 == 1) getLudic(n / 10, n :: acc)\n            else if (n % 10 == 2) getLudic(n / 10, n :: acc)\n            else if (n % 10 == 3) getLudic(n / 10, n :: acc)\n            else if (n % 10 == 4) getLudic(n / 10, n :: acc)\n            else if (n % 10 == 5) getLudic(n / 10, n :: acc)\n            else if (n % 10 == 6) getLudic(n / 10, n :: acc)\n            else if (n % 10 == 7) getLudic(n / 10, n :: acc)\n            else if (n % 10 == 8) getLudic(n / 10, n :: acc)\n            else if (n % 10 == 9) getLudic(n / 10, n :: acc)\n            else getLudic(n / 10, acc)\n        }\n        getLudic(n, List())",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic += i\n        }\n        ludic.toList",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            var sum = 0\n            var x = i\n            while (x > 0) {\n                sum += pow(x % 10, 2).toInt\n                x /= 10\n            }\n            if (sum == 1) result = i :: result\n            else {\n                var set = Set[Int]()\n                while (sum != 1 && !set.contains(sum)) {\n                    set += sum\n                    var temp = 0\n                    x = sum\n                    while (x > 0) {\n                        temp += pow(x % 10, 2).toInt\n                        x /= 10\n                    }\n                    sum = temp\n                }\n                if (sum == 1) result = i :: result\n            }\n        }\n        result",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val m = n % 10\n                if (m == 0) getLudic(n / 10, acc)\n                else getLudic(n / 10, n :: acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        def isLudic(x : Long) : Boolean = {\n            var sum = 0L\n            var y = x\n            while (y > 0) {\n                sum += pow(y % 10, 2).toLong\n                y /= 10\n            }\n            sum == 1\n        }\n        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLucid(i)) result = result :+ i\n        }\n        result",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            var sum = 0\n            for (j <- 1 to i) {\n                if (i % j == 0) sum += j\n            }\n            if (sum == 2 * i) ludic += i\n        }\n        ludic.toList",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic += i\n        }\n        ludic.toList",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = result :+ i\n        }\n        result",
    "        def getLudic(n : Long, l : List[Long]) : List[Long] = {\n            if (n == 0) l\n            else {\n                val d = n % 10\n                if (d % 2 == 0) getLudic(n / 10, l)\n                else getLudic(n / 10, n :: l)\n            }\n        }\n        getLudic(n, Nil).reverse",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = i :: ludic\n        }\n        return ludic",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = i :: ludic\n        }\n        ludic",
    "        def isLudic(n : Long) : Boolean = {\n            val s = n.toString\n            val l = s.length\n            (0 until l).map(i => s.substring(0, i) + s.substring(i + 1)).map(_.toLong).forall(n % _ != 0)\n        }\n        (1 to n.toInt).filter(isLudic).map(_.toLong).toList",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLucid(i)) result = i :: result\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) {\n                result = i :: result\n            }\n        }\n        result",
    "        def isLudic(n : Long) : Boolean = {\n            if (n < 10) return true\n            val s = n.toString\n            val m = s.length\n            val a = s.substring(0, m / 2).toLong\n            val b = s.substring(m / 2, m).toLong\n            if (a + b == n) return true\n            return false\n        }\n        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        return result",
    "        def isLudic(x : Long) : Boolean = {\n            val s = x.toString\n            val l = s.length\n            val d = s.map(c => (c - '0').toLong).toList\n            val sum = d.map(x => pow(x, l).toLong).sum\n            sum == x\n        }\n        (1L to n).filter(isLudic).toList",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else if (n % 10 == 0) getLudic(n / 10, acc)\n            else if (n % 10 == 1) getLudic(n / 10, n :: acc)\n            else getLudic(n - 1, acc)\n        }\n        getLudic(n, Nil)",
    "        var list = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) list = i :: list\n        }\n        return list",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = result :+ i\n        }\n        result",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = ludic :+ i\n        }\n        ludic",
    "        def isLudic(n : Long) : Boolean = {\n            val digits = n.toString.map(_.asDigit).toList\n            val sum = digits.map(x => pow(x, digits.length).toLong).sum\n            sum == n\n        }\n        (1 to n.toInt).filter(x => isLudic(x)).toList.map(_.toLong)",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val digits = n.toString.map(_.asDigit).toList\n                val sum = digits.map(x => pow(x, 2).toLong).sum\n                if (sum == 1) getLudic(n - 1, n :: acc)\n                else if (acc.contains(sum)) getLudic(n - 1, acc)\n                else getLudic(n - 1, getLudic(sum, acc))\n            }\n        }\n        getLudic(n, List())",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else if (n % 10 == 0) getLudic(n / 10, acc)\n            else if (n % 10 == 1) getLudic(n / 10, n :: acc)\n            else if (n % 10 == 2) getLudic(n / 10, n :: acc)\n            else if (n % 10 == 3) getLudic(n / 10, n :: acc)\n            else if (n % 10 == 4) getLudic(n / 10, n :: acc)\n            else if (n % 10 == 5) getLudic(n / 10, n :: acc)\n            else if (n % 10 == 6) getLudic(n / 10, n :: acc)\n            else if (n % 10 == 7) getLudic(n / 10, n :: acc)\n            else if (n % 10 == 8) getLudic(n / 10, n :: acc)\n            else if (n % 10 == 9) getLudic(n / 10, n :: acc)\n            else getLudic(n / 10, acc)\n        }\n        getLudic(n, Nil)",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = result :+ i\n        }\n        result",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic += i\n        }\n        ludic.toList",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = result :+ i\n        }\n        result",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val m = n % 10\n                if (m == 0 || m == 6 || m == 9) getLudic(n / 10, n :: acc)\n                else getLudic(n / 10, acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        result",
    "        val ludic = ListBuffer[Long]()\n        var i = 1L\n        while (i <= n) {\n            if (isLudic(i)) ludic += i\n            i += 1\n        }\n        ludic.toList",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = result :+ i\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        result",
    "        val ludic = new ListBuffer[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLucid(i)) ludic += i\n        }\n        ludic.toList",
    "        def getLudicHelper(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val x = n % 10\n                if (x % 2 == 0) getLudicHelper(n / 10, acc)\n                else getLudicHelper(n / 10, n :: acc)\n            }\n        }\n        getLudicHelper(n, Nil)",
    "        def getLudicHelper(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val s = n.toString\n                if (s.length == 1) getLudicHelper(n - 1, n :: acc)\n                else {\n                    val m = s.map(x => pow(x.asDigit, s.length).toLong).sum\n                    if (m == n) getLudicHelper(n - 1, n :: acc)\n                    else getLudicHelper(n - 1, acc)\n                }\n            }\n        }\n        getLudicHelper(n, List())",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = i :: ludic\n        }\n        ludic",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else if (n % 10 == 0) getLudic(n / 10, acc)\n            else if (n % 10 == 1) getLudic(n - 1, n :: acc)\n            else getLudic(n - 2, n :: acc)\n        }\n        getLudic(n, Nil)",
    "        def isLudic(n : Long) : Boolean = {\n            val s = n.toString\n            val m = s.length\n            val a = s.map(c => pow(c.asDigit, m).toLong).sum\n            a == n\n        }\n        (1L to n).filter(isLudic).toList",
    "        def getLudicHelper(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val x = n % 10\n                if (x % 2 == 0) getLudicHelper(n / 10, acc)\n                else getLudicHelper(n / 10, n :: acc)\n            }\n        }\n        getLudicHelper(n, Nil)",
    "        val ludic = ListBuffer[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic += i\n        }\n        ludic.toList",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLucid(i)) result = result :+ i\n        }\n        result",
    "        val digits = n.toString.map(_.toString.toInt).toList\n        val ludic = new ListBuffer[Long]\n        def getLudic(digits : List[Int], current : Long) {\n            if (current > n) return\n            if (current != 0) ludic += current\n            for (i <- digits) getLudic(digits.filter(_ != i), current * 10 + i)\n        }\n        getLudic(digits, 0)\n        ludic.toList",
    "        def isLudic(n : Long) : Boolean = {\n            def isLudic(n : Long, sum : Long) : Boolean = {\n                if (n == 0) return (sum == 1)\n                isLudic(n / 10, sum + pow(n % 10, 2).toLong)\n            }\n            isLudic(n, 0)\n        }\n        (1 to n.toInt).filter(isLudic(_)).map(_.toLong).toList",
    "        val ludic = ListBuffer[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic += i\n        }\n        ludic.toList",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic += i\n        }\n        ludic.toList",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        result",
    "        def isLudic(n : Long) : Boolean = {\n            val s = n.toString\n            val d = s.map(c => c.toString.toInt).toList\n            val sum = d.map(i => pow(i, d.length).toLong).sum\n            sum == n\n        }\n        (1 to n.toInt).filter(isLudic).map(_.toLong).toList",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val d = n % 10\n                if (d % 2 == 0) getLudic(n / 10, acc)\n                else getLudic(n / 10, n :: acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            var sum = 0\n            var num = i\n            while (num > 0) {\n                sum += pow(num % 10, 2).toInt\n                num /= 10\n            }\n            if (sum == 1) result = i :: result\n            else {\n                var set = Set[Int]()\n                while (sum != 1 && !set.contains(sum)) {\n                    set += sum\n                    var temp = 0\n                    var num = sum\n                    while (num > 0) {\n                        temp += pow(num % 10, 2).toInt\n                        num /= 10\n                    }\n                    sum = temp\n                }\n                if (sum == 1) result = i :: result\n            }\n        }\n        result",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = i :: ludic\n        }\n        ludic",
    "        var list = List[Long]()\n        for (i <- 1 to n.toInt) {\n            var sum = 0\n            var num = i\n            while (num > 0) {\n                sum += pow(num % 10, 2).toInt\n                num /= 10\n            }\n            if (sum == 1) list = i :: list\n            else {\n                var set = Set[Int]()\n                while (sum != 1 && !set.contains(sum)) {\n                    set += sum\n                    var temp = 0\n                    num = sum\n                    while (num > 0) {\n                        temp += pow(num % 10, 2).toInt\n                        num /= 10\n                    }\n                    sum = temp\n                }\n                if (sum == 1) list = i :: list\n            }\n        }\n        list",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else if (n % 10 == 0) getLudic(n / 10, acc)\n            else if (n % 10 == 1) getLudic(n / 10, n :: acc)\n            else getLudic(n - 1, acc)\n        }\n        getLudic(n, Nil)",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            var sum = 0\n            for (j <- 1 to i) {\n                if (i % j == 0) sum += j\n            }\n            if (sum == 2 * i) result = i :: result\n        }\n        result",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = i :: ludic\n        }\n        ludic",
    "        var ludic = new ListBuffer[Long]\n        var i = 1\n        while (i <= n) {\n            if (isLudic(i)) ludic += i\n            i += 1\n        }\n        ludic.toList",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLucid(i)) result = i :: result\n        }\n        result",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic += i\n        }\n        ludic.toList",
    "        val ludic = ListBuffer[Long]()\n        for (i <- 1 to n.toInt) {\n            val s = i.toString\n            val sum = s.map(c => pow(c.asDigit, s.length).toLong).sum\n            if (sum == i) ludic += i\n        }\n        ludic.toList",
    "        var ludic = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic = i :: ludic\n        }\n        ludic",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic += i\n        }\n        ludic.toList",
    "        def isLudic(n : Long) : Boolean = {\n            val digits = n.toString.map(_.toString.toInt).toList\n            val sum = digits.map(x => pow(x, digits.length).toLong).sum\n            sum == n\n        }\n        (1L to n).filter(isLudic).toList",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = result :+ i\n        }\n        result",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            val x = i.toString\n            if (x.contains(\"0\") || x.contains(\"2\") || x.contains(\"4\") || x.contains(\"6\") || x.contains(\"8\")) {\n                ludic += i\n            }\n        }\n        ludic.toList",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) result = i :: result\n        }\n        result",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 1) acc\n            else if (n % 10 == 0) getLudic(n / 10, acc)\n            else if (n % 2 == 0) getLudic(n / 2, acc :+ n)\n            else if (n % 5 == 0) getLudic(n / 5, acc :+ n)\n            else getLudic(n - 1, acc)\n        }\n        getLudic(n, List())",
    "        def isLudic(x : Long) : Boolean = {\n            val s = x.toString\n            val l = s.length\n            val a = s.substring(0, l / 2)\n            val b = s.substring(l / 2, l)\n            val c = s.substring(0, l / 2 + 1)\n            val d = s.substring(l / 2 + 1, l)\n            val e = s.substring(0, l / 2 - 1)\n            val f = s.substring(l / 2 - 1, l)\n            val g = s.substring(0, l / 2 + 2)\n            val h = s.substring(l / 2 + 2, l)\n            val i = s.substring(0, l / 2 - 2)\n            val j = s.substring(l / 2 - 2, l)\n            val k = s.substring(0, l / 2 + 3)\n            val m = s.substring(l / 2 + 3, l)\n            val o = s.substring(0, l / 2 - 3)\n            val p = s.substring(l / 2 - 3, l)\n            val q = s.substring(0, l / 2 + 4)\n            val r = s.substring(l / 2 + 4, l)\n            val t = s.substring(0, l / 2 - 4)\n            val u = s.substring(l / 2 - 4, l)\n            val v = s.substring(0, l / 2 + 5)\n            val w = s.substring(l / 2 + 5, l)\n            val y = s.substring(0, l / 2 - 5)\n            val z = s.substring(l / 2 - 5, l)\n            val aa = s.substring(0, l / 2 + 6)\n            val bb = s.substring(l / 2 + 6, l)\n            val cc = s.substring(0, l / 2 - 6)\n            val dd = s.substring(l / 2 - 6, l)\n            val ee = s.substring(0, l",
    "        var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n            if (isLucid(i)) result = i :: result\n        }\n        result",
    "        def getLudic(n : Long, l : List[Long]) : List[Long] = {\n            if (n == 0) l\n            else {\n                val m = n % 10\n                if (m % 2 == 0) getLudic(n / 10, l)\n                else getLudic(n / 10, n :: l)\n            }\n        }\n        getLudic(n, Nil)",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else if (n % 10 == 0) getLudic(n / 10, acc)\n            else if (n % 10 == 1) getLudic(n / 10, n :: acc)\n            else getLudic(n - 1, acc)\n        }\n        getLudic(n, Nil)",
    "        def getLudicHelper(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else if (isLudic(n)) getLudicHelper(n - 1, n :: acc)\n            else getLudicHelper(n - 1, acc)\n        }\n        getLudicHelper(n, Nil)",
    "        var result = List[Long]()\n        for (i <- 1L to n) {\n            var sum = 0L\n            var j = i\n            while (j > 0) {\n                sum += pow(j % 10, 2).toLong\n                j /= 10\n            }\n            if (sum == 1) result = i :: result\n            else {\n                var set = Set[Long]()\n                while (sum != 1 && !set.contains(sum)) {\n                    set += sum\n                    var tmp = 0L\n                    var k = sum\n                    while (k > 0) {\n                        tmp += pow(k % 10, 2).toLong\n                        k /= 10\n                    }\n                    sum = tmp\n                }\n                if (sum == 1) result = i :: result\n            }\n        }\n        result",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic += i\n        }\n        ludic.toList",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic += i\n        }\n        ludic.toList",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            if (isLudic(i)) ludic += i\n        }\n        ludic.toList",
    "        def getLudic(n : Long, acc : List[Long]) : List[Long] = {\n            if (n == 0) acc\n            else {\n                val x = n % 10\n                if (x % 2 == 0) getLudic(n / 10, n :: acc)\n                else getLudic(n / 10, acc)\n            }\n        }\n        getLudic(n, Nil)",
    "        val ludic = new ListBuffer[Long]\n        for (i <- 1 to n.toInt) {\n            val s = i.toString\n            if (s.contains(\"0\") || s.contains(\"2\") || s.contains(\"3\") || s.contains(\"5\") || s.contains(\"6\") || s.contains(\"8\")) {\n                ludic += i\n            }\n        }\n        return ludic.toList"
  ]
}