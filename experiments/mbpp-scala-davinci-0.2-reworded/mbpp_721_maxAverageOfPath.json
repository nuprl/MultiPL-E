{
  "name": "mbpp_721_maxAverageOfPath",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n    def maxAverageOfPath(cost : List[List[Long]]) : Float = {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_721_maxAverageOfPath.py",
  "prompt_terminology": "reworded",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(maxAverageOfPath((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong), List[Long](6l.toLong, 5l.toLong, 4l.toLong), List[Long](7l.toLong, 3l.toLong, 9l.toLong)))) == (5.2f));\n    assert(maxAverageOfPath((List[List[Long]](List[Long](2l.toLong, 3l.toLong, 4l.toLong), List[Long](7l.toLong, 6l.toLong, 5l.toLong), List[Long](8l.toLong, 4l.toLong, 10l.toLong)))) == (6.2f));\n    assert(maxAverageOfPath((List[List[Long]](List[Long](3l.toLong, 4l.toLong, 5l.toLong), List[Long](8l.toLong, 7l.toLong, 6l.toLong), List[Long](9l.toLong, 5l.toLong, 11l.toLong)))) == (7.2f));\n    assert(maxAverageOfPath((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong), List[Long](4l.toLong, 5l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong, 9l.toLong)))) == (5.8f));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        val n = cost.length\n        val dp = Array.fill(n, n)(0.0)\n        dp(0)(0) = cost(0)(0)\n        for (i <- 1 until n) {\n            dp(0)(i) = dp(0)(i - 1) + cost(0)(i)\n            dp(i)(0) = dp(i - 1)(0) + cost(i)(0)\n        }\n        for (i <- 1 until n; j <- 1 until n) {\n            dp(i)(j) = max(dp(i - 1)(j), dp(i)(j - 1)) + cost(i)(j)\n        }\n        dp(n - 1)(n - 1).toFloat / (n * n)",
    "        val n = cost.length\n        val dp = Array.ofDim[Float](n, n)\n        dp(0)(0) = cost(0)(0)\n        for (i <- 1 until n) {\n            dp(i)(0) = dp(i - 1)(0) + cost(i)(0)\n        }\n        for (j <- 1 until n) {\n            dp(0)(j) = dp(0)(j - 1) + cost(0)(j)\n        }\n        for (i <- 1 until n; j <- 1 until n) {\n            dp(i)(j) = max(dp(i - 1)(j), dp(i)(j - 1)) + cost(i)(j)\n        }\n        dp(n - 1)(n - 1) / (n + n - 1)",
    "        val n = cost.length\n        val dp = Array.ofDim[Float](n, n)\n        dp(0)(0) = cost(0)(0)\n        for (i <- 1 until n) {\n            dp(0)(i) = dp(0)(i - 1) + cost(0)(i)\n            dp(i)(0) = dp(i - 1)(0) + cost(i)(0)\n        }\n        for (i <- 1 until n; j <- 1 until n) {\n            dp(i)(j) = max(dp(i - 1)(j), dp(i)(j - 1)) + cost(i)(j)\n        }\n        dp(n - 1)(n - 1) / (n * n)",
    "        val n = cost.length\n        val dp = Array.ofDim[Float](n, n)\n        dp(0)(0) = cost(0)(0)\n        for (i <- 1 until n) dp(0)(i) = dp(0)(i - 1) + cost(0)(i)\n        for (i <- 1 until n) dp(i)(0) = dp(i - 1)(0) + cost(i)(0)\n        for (i <- 1 until n; j <- 1 until n) dp(i)(j) = max(dp(i - 1)(j), dp(i)(j - 1)) + cost(i)(j)\n        dp(n - 1)(n - 1) / (n * n)",
    "        val n = cost.length\n        val dp = Array.ofDim[Float](n, n)\n        dp(0)(0) = cost(0)(0)\n        for (i <- 1 until n) {\n            dp(0)(i) = dp(0)(i - 1) + cost(0)(i)\n            dp(i)(0) = dp(i - 1)(0) + cost(i)(0)\n        }\n        for (i <- 1 until n; j <- 1 until n) {\n            dp(i)(j) = max(dp(i - 1)(j), dp(i)(j - 1)) + cost(i)(j)\n        }\n        dp(n - 1)(n - 1) / (n * n)",
    "        val n = cost.length\n        val dp = Array.ofDim[Float](n, n)\n        dp(0)(0) = cost(0)(0)\n        for (i <- 1 until n) {\n            dp(i)(0) = dp(i - 1)(0) + cost(i)(0)\n            dp(0)(i) = dp(0)(i - 1) + cost(0)(i)\n        }\n        for (i <- 1 until n; j <- 1 until n) {\n            dp(i)(j) = max(dp(i - 1)(j), dp(i)(j - 1)) + cost(i)(j)\n        }\n        dp(n - 1)(n - 1) / (2 * n - 1)",
    "        val n = cost.length\n        val dp = Array.ofDim[Float](n, n)\n        dp(0)(0) = cost(0)(0).toFloat\n        for (i <- 1 until n) {\n            dp(0)(i) = dp(0)(i - 1) + cost(0)(i).toFloat\n            dp(i)(0) = dp(i - 1)(0) + cost(i)(0).toFloat\n        }\n        for (i <- 1 until n; j <- 1 until n) {\n            dp(i)(j) = max(dp(i - 1)(j), dp(i)(j - 1)) + cost(i)(j).toFloat\n        }\n        dp(n - 1)(n - 1) / (2 * n - 1)",
    "        val n = cost.length\n        val dp = Array.fill(n, n)(0.0)\n        dp(0)(0) = cost(0)(0)\n        for (i <- 1 until n) {\n            dp(0)(i) = dp(0)(i - 1) + cost(0)(i)\n            dp(i)(0) = dp(i - 1)(0) + cost(i)(0)\n        }\n        for (i <- 1 until n; j <- 1 until n) {\n            dp(i)(j) = max(dp(i - 1)(j), dp(i)(j - 1)) + cost(i)(j)\n        }\n        dp(n - 1)(n - 1) / (n * n)",
    "        val n = cost.length\n        val dp = Array.fill(n, n)(0.0)\n        dp(0)(0) = cost(0)(0)\n        for (i <- 1 until n) {\n            dp(0)(i) = dp(0)(i - 1) + cost(0)(i)\n            dp(i)(0) = dp(i - 1)(0) + cost(i)(0)\n        }\n        for (i <- 1 until n; j <- 1 until n) {\n            dp(i)(j) = max(dp(i - 1)(j), dp(i)(j - 1)) + cost(i)(j)\n        }\n        dp(n - 1)(n - 1) / (n * n)",
    "        val n = cost.length\n        val dp = Array.fill(n, n)(0.0)\n        dp(0)(0) = cost(0)(0)\n        for (i <- 1 until n) {\n            dp(i)(0) = dp(i - 1)(0) + cost(i)(0)\n            dp(0)(i) = dp(0)(i - 1) + cost(0)(i)\n        }\n        for (i <- 1 until n; j <- 1 until n) {\n            dp(i)(j) = max(dp(i - 1)(j), dp(i)(j - 1)) + cost(i)(j)\n        }\n        dp(n - 1)(n - 1) / (n * n).toFloat",
    "        val n = cost.length\n        val dp = Array.ofDim[Float](n, n)\n        dp(0)(0) = cost(0)(0)\n        for (i <- 1 until n) {\n            dp(0)(i) = dp(0)(i - 1) + cost(0)(i)\n            dp(i)(0) = dp(i - 1)(0) + cost(i)(0)\n        }\n        for (i <- 1 until n; j <- 1 until n) {\n            dp(i)(j) = max(dp(i - 1)(j), dp(i)(j - 1)) + cost(i)(j)\n        }\n        dp(n - 1)(n - 1) / (n * n)",
    "        val n = cost.length\n        val dp = Array.ofDim[Float](n, n)\n        dp(0)(0) = cost(0)(0)\n        for (i <- 1 until n) {\n            dp(0)(i) = dp(0)(i - 1) + cost(0)(i)\n            dp(i)(0) = dp(i - 1)(0) + cost(i)(0)\n        }\n        for (i <- 1 until n; j <- 1 until n) {\n            dp(i)(j) = max(dp(i - 1)(j), dp(i)(j - 1)) + cost(i)(j)\n        }\n        dp(n - 1)(n - 1) / (n * n)",
    "        val n = cost.length\n        val dp = Array.ofDim[Float](n, n)\n        dp(0)(0) = cost(0)(0)\n        for (i <- 1 until n) dp(i)(0) = dp(i - 1)(0) + cost(i)(0)\n        for (j <- 1 until n) dp(0)(j) = dp(0)(j - 1) + cost(0)(j)\n        for (i <- 1 until n; j <- 1 until n) dp(i)(j) = max(dp(i - 1)(j), dp(i)(j - 1)) + cost(i)(j)\n        dp(n - 1)(n - 1) / (n * n)",
    "        val n = cost.length\n        val dp = Array.ofDim[Float](n, n)\n        dp(0)(0) = cost(0)(0)\n        for (i <- 1 until n) {\n            dp(i)(0) = dp(i - 1)(0) + cost(i)(0)\n            dp(0)(i) = dp(0)(i - 1) + cost(0)(i)\n        }\n        for (i <- 1 until n) {\n            for (j <- 1 until n) {\n                dp(i)(j) = max(dp(i - 1)(j), dp(i)(j - 1)) + cost(i)(j)\n            }\n        }\n        dp(n - 1)(n - 1) / (n * n)",
    "        val n = cost.length\n        val dp = Array.ofDim[Float](n, n)\n        dp(0)(0) = cost(0)(0)\n        for (i <- 1 until n) {\n            dp(0)(i) = dp(0)(i - 1) + cost(0)(i)\n            dp(i)(0) = dp(i - 1)(0) + cost(i)(0)\n        }\n        for (i <- 1 until n; j <- 1 until n) {\n            dp(i)(j) = max(dp(i - 1)(j), dp(i)(j - 1)) + cost(i)(j)\n        }\n        dp(n - 1)(n - 1) / (n * n)",
    "        val n = cost.length\n        val dp = Array.ofDim[Float](n, n)\n        dp(0)(0) = cost(0)(0)\n        for (i <- 1 until n) {\n            dp(0)(i) = dp(0)(i - 1) + cost(0)(i)\n            dp(i)(0) = dp(i - 1)(0) + cost(i)(0)\n        }\n        for (i <- 1 until n; j <- 1 until n) {\n            dp(i)(j) = max(dp(i - 1)(j), dp(i)(j - 1)) + cost(i)(j)\n        }\n        dp(n - 1)(n - 1) / (2 * n - 1)",
    "        val n = cost.length\n        val dp = Array.ofDim[Long](n, n)\n        dp(0)(0) = cost(0)(0)\n        for (i <- 1 until n) {\n            dp(0)(i) = dp(0)(i - 1) + cost(0)(i)\n            dp(i)(0) = dp(i - 1)(0) + cost(i)(0)\n        }\n        for (i <- 1 until n; j <- 1 until n) {\n            dp(i)(j) = max(dp(i - 1)(j), dp(i)(j - 1)) + cost(i)(j)\n        }\n        dp(n - 1)(n - 1).toFloat / (n * n)",
    "        val n = cost.length\n        val dp = Array.fill(n, n)(0.0)\n        dp(0)(0) = cost(0)(0)\n        for (i <- 1 until n) dp(0)(i) = dp(0)(i - 1) + cost(0)(i)\n        for (i <- 1 until n) dp(i)(0) = dp(i - 1)(0) + cost(i)(0)\n        for (i <- 1 until n; j <- 1 until n) dp(i)(j) = max(dp(i - 1)(j), dp(i)(j - 1)) + cost(i)(j)\n        dp(n - 1)(n - 1) / (n * n).toFloat",
    "        val n = cost.length\n        val dp = Array.ofDim[Float](n, n)\n        dp(0)(0) = cost(0)(0)\n        for (i <- 1 until n) {\n            dp(0)(i) = dp(0)(i - 1) + cost(0)(i)\n            dp(i)(0) = dp(i - 1)(0) + cost(i)(0)\n        }\n        for (i <- 1 until n; j <- 1 until n) {\n            dp(i)(j) = max(dp(i - 1)(j), dp(i)(j - 1)) + cost(i)(j)\n        }\n        dp(n - 1)(n - 1) / (n * n)",
    "        val n = cost.length\n        val dp = Array.fill(n, n)(0.0)\n        dp(0)(0) = cost(0)(0)\n        for (i <- 1 until n) dp(i)(0) = dp(i - 1)(0) + cost(i)(0)\n        for (j <- 1 until n) dp(0)(j) = dp(0)(j - 1) + cost(0)(j)\n        for (i <- 1 until n; j <- 1 until n) dp(i)(j) = max(dp(i - 1)(j), dp(i)(j - 1)) + cost(i)(j)\n        dp(n - 1)(n - 1) / (n * n).toFloat"
  ]
}