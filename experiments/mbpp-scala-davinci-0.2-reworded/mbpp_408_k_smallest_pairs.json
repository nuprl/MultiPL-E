{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "reworded",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- 0 until min(k, nums1.length).toInt) {\n            for (j <- 0 until min(k, nums2.length).toInt) {\n                heap.enqueue((nums1(i), nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until min(k, nums1.length * nums2.length).toInt) {\n            val (x, y) = heap.dequeue\n            result += List(x, y)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(_._1 + _._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (x, y) = heap.dequeue\n            result += List(x, y)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList",
    "        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j, i + j))\n            }\n        }\n        val result = new ArrayBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (a, b, c) = heap.dequeue\n            result += List(a, b)\n        }\n        result.toList",
    "        val heap = new mutable.PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- 0 until min(nums1.length, k.toInt)) {\n            heap += ((i, 0, nums1(i) + nums2(0)))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && heap.nonEmpty) {\n            val (i, j, sum) = heap.dequeue\n            result += List(nums1(i.toInt), nums2(j.toInt))\n            if (j + 1 < nums2.length) heap += ((i, j + 1, nums1(i.toInt) + nums2(j.toInt + 1)))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList",
    "        val heap = new PriorityQueue[List[Long]]()(Ordering.by((_ : List[Long]).sum).reverse)\n        for (n1 <- nums1) {\n            for (n2 <- nums2) {\n                heap.enqueue(List(n1, n2))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap += ((i + j, i * j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, product) = heap.dequeue\n            result += List(sum, product)\n        }\n        result.toList",
    "        // nums1.flatMap(x => nums2.map(y => List(x, y))).sortBy(x => x(0) + x(1)).take(k.toInt)\n        val pq = new PriorityQueue[List[Long]]()(Ordering.by((x : List[Long]) => x(0) + x(1)))\n        for (x <- nums1; y <- nums2) {\n            pq.enqueue(List(x, y))\n            if (pq.size > k) pq.dequeue\n        }\n        pq.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, i, j) = heap.dequeue\n            result += List(i, j)\n        }\n        result.toList",
    "        val pairs = for (i <- nums1; j <- nums2) yield (i, j)\n        pairs.sortWith((a, b) => a._1 + a._2 < b._1 + b._2).take(k.toInt).map(x => List(x._1, x._2))",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.map(x => List(x._2, x._3)).toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            pq.enqueue((nums1(i) + nums2(0), i))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && pq.nonEmpty) {\n            val (sum, i) = pq.dequeue\n            result += List(nums1(i), nums2(0))\n            if (nums2.length > 1) pq.enqueue((nums1(i) + nums2(1), i))\n        }\n        result.toList",
    "        val result = new ListBuffer[List[Long]]\n        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(x => x._3))\n        for (i <- 0 until min(nums1.length, k.toInt)) pq.enqueue((i.toLong, 0L, nums1(i) + nums2(0)))\n        for (i <- 0 until min(k.toInt, nums1.length * nums2.length)) {\n            val (x, y, _) = pq.dequeue\n            result += List(nums1(x.toInt), nums2(y.toInt))\n            if (y + 1 < nums2.length) pq.enqueue((x, y + 1, nums1(x.toInt) + nums2(y.toInt + 1)))\n        }\n        result.toList",
    "        val map = new HashMap[Long, List[Long]]\n        for (i <- nums1) {\n            val list = new ListBuffer[Long]\n            for (j <- nums2) list += i + j\n            map += (i -> list.toList)\n        }\n        val list = new ListBuffer[Long]\n        for (i <- map.values) list ++= i\n        list.sorted.take(k.toInt).map(x => List(x - nums2.max, x - nums2.min))",
    "        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(x => x._3))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i, j, i + j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.map(x => List(x._1, x._2)).toList",
    "        val heap = new PriorityQueue[List[Long]]()(Ordering.by(x => x(0) + x(1)))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue(List(i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            pq.enqueue((nums1(i) + nums2(0), i))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && pq.nonEmpty) {\n            val (sum, i) = pq.dequeue\n            result += List(nums1(i), nums2(0))\n            if (nums2.length > 1) pq.enqueue((nums1(i) + nums2(1), i))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap.enqueue((nums1(i) + nums2(0), i))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && heap.nonEmpty) {\n            val (sum, i) = heap.dequeue\n            result += List(nums1(i), nums2(0))\n            if (nums2.length > 1) heap.enqueue((nums1(i) + nums2(1), i))\n        }\n        result.toList",
    "        var result = List[List[Long]]()\n        var heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- 0 until min(nums1.length, k.toInt)) {\n            heap.enqueue((i.toLong, 0, nums1(i.toInt) + nums2(0)))\n        }\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result\n            val (x, y, z) = heap.dequeue\n            result = List(nums1(x.toInt), nums2(y.toInt)) :: result\n            if (y + 1 < nums2.length) heap.enqueue((x, y + 1, nums1(x.toInt) + nums2(y.toInt + 1)))\n        }\n        result"
  ]
}