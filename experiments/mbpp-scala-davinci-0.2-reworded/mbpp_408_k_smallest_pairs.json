{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\n    def kSmallestPairs(nums1 : List[Long], nums2 : List[Long], k : Long) : List[List[Long]] = {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "reworded",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (2l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (1l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong)))));\n    assert(kSmallestPairs((List[Long](1l.toLong, 3l.toLong, 7l.toLong)), (List[Long](2l.toLong, 4l.toLong, 6l.toLong)), (7l)).equals((List[List[Long]](List[Long](1l.toLong, 2l.toLong), List[Long](1l.toLong, 4l.toLong), List[Long](3l.toLong, 2l.toLong), List[Long](1l.toLong, 6l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](3l.toLong, 6l.toLong), List[Long](7l.toLong, 2l.toLong)))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- 0 until min(k, nums1.length).toInt) {\n            for (j <- 0 until min(k, nums2.length).toInt) {\n                heap.enqueue((nums1(i), nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until min(k, nums1.length * nums2.length).toInt) {\n            val (x, y) = heap.dequeue\n            result += List(x, y)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(_._1 + _._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (x, y) = heap.dequeue\n            result += List(x, y)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList",
    "        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j, i + j))\n            }\n        }\n        val result = new ArrayBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (a, b, c) = heap.dequeue\n            result += List(a, b)\n        }\n        result.toList",
    "        val heap = new mutable.PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- 0 until min(nums1.length, k.toInt)) {\n            heap += ((i, 0, nums1(i) + nums2(0)))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && heap.nonEmpty) {\n            val (i, j, sum) = heap.dequeue\n            result += List(nums1(i.toInt), nums2(j.toInt))\n            if (j + 1 < nums2.length) heap += ((i, j + 1, nums1(i.toInt) + nums2(j.toInt + 1)))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList",
    "        val heap = new PriorityQueue[List[Long]]()(Ordering.by((_ : List[Long]).sum).reverse)\n        for (n1 <- nums1) {\n            for (n2 <- nums2) {\n                heap.enqueue(List(n1, n2))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap += ((i + j, i * j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, product) = heap.dequeue\n            result += List(sum, product)\n        }\n        result.toList",
    "        // nums1.flatMap(x => nums2.map(y => List(x, y))).sortBy(x => x(0) + x(1)).take(k.toInt)\n        val pq = new PriorityQueue[List[Long]]()(Ordering.by((x : List[Long]) => x(0) + x(1)))\n        for (x <- nums1; y <- nums2) {\n            pq.enqueue(List(x, y))\n            if (pq.size > k) pq.dequeue\n        }\n        pq.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, i, j) = heap.dequeue\n            result += List(i, j)\n        }\n        result.toList",
    "        val pairs = for (i <- nums1; j <- nums2) yield (i, j)\n        pairs.sortWith((a, b) => a._1 + a._2 < b._1 + b._2).take(k.toInt).map(x => List(x._1, x._2))",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.map(x => List(x._2, x._3)).toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            pq.enqueue((nums1(i) + nums2(0), i))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && pq.nonEmpty) {\n            val (sum, i) = pq.dequeue\n            result += List(nums1(i), nums2(0))\n            if (nums2.length > 1) pq.enqueue((nums1(i) + nums2(1), i))\n        }\n        result.toList",
    "        val result = new ListBuffer[List[Long]]\n        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(x => x._3))\n        for (i <- 0 until min(nums1.length, k.toInt)) pq.enqueue((i.toLong, 0L, nums1(i) + nums2(0)))\n        for (i <- 0 until min(k.toInt, nums1.length * nums2.length)) {\n            val (x, y, _) = pq.dequeue\n            result += List(nums1(x.toInt), nums2(y.toInt))\n            if (y + 1 < nums2.length) pq.enqueue((x, y + 1, nums1(x.toInt) + nums2(y.toInt + 1)))\n        }\n        result.toList",
    "        val map = new HashMap[Long, List[Long]]\n        for (i <- nums1) {\n            val list = new ListBuffer[Long]\n            for (j <- nums2) list += i + j\n            map += (i -> list.toList)\n        }\n        val list = new ListBuffer[Long]\n        for (i <- map.values) list ++= i\n        list.sorted.take(k.toInt).map(x => List(x - nums2.max, x - nums2.min))",
    "        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(x => x._3))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i, j, i + j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.map(x => List(x._1, x._2)).toList",
    "        val heap = new PriorityQueue[List[Long]]()(Ordering.by(x => x(0) + x(1)))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue(List(i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            pq.enqueue((nums1(i) + nums2(0), i))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && pq.nonEmpty) {\n            val (sum, i) = pq.dequeue\n            result += List(nums1(i), nums2(0))\n            if (nums2.length > 1) pq.enqueue((nums1(i) + nums2(1), i))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap.enqueue((nums1(i) + nums2(0), i))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && heap.nonEmpty) {\n            val (sum, i) = heap.dequeue\n            result += List(nums1(i), nums2(0))\n            if (nums2.length > 1) heap.enqueue((nums1(i) + nums2(1), i))\n        }\n        result.toList",
    "        var result = List[List[Long]]()\n        var heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- 0 until min(nums1.length, k.toInt)) {\n            heap.enqueue((i.toLong, 0, nums1(i.toInt) + nums2(0)))\n        }\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result\n            val (x, y, z) = heap.dequeue\n            result = List(nums1(x.toInt), nums2(y.toInt)) :: result\n            if (y + 1 < nums2.length) heap.enqueue((x, y + 1, nums1(x.toInt) + nums2(y.toInt + 1)))\n        }\n        result",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq += ((i + j, i * j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.map(x => List(x._2, x._1)).toList",
    "        val n = nums1.length\n        val m = nums2.length\n        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(n, k.toInt)) {\n            heap.enqueue((nums1(i) + nums2(0), i, 0))\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until min(k, n * m)) {\n            val (sum, x, y) = heap.dequeue\n            result += List(nums1(x.toInt), nums2(y.toInt))\n            if (y + 1 < m) heap.enqueue((nums1(x.toInt) + nums2(y.toInt + 1), x, y + 1))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            pq.enqueue((nums1(i) + nums2(0), i))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && pq.nonEmpty) {\n            val (sum, i) = pq.dequeue\n            result += List(nums1(i), nums2(0))\n            if (nums2.length > 1) pq.enqueue((nums1(i) + nums2(1), i))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        val result = new ListBuffer[List[Long]]()\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        while (heap.nonEmpty) {\n            val (sum, i, j) = heap.dequeue\n            result += List(i, j)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j, i + j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(x._1, x._2)).toList",
    "        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(x => x._3))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                pq.enqueue((i, j, nums1(i) + nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (x, y, z) = pq.dequeue\n            result.append(List(nums1(x.toInt), nums2(y.toInt)))\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by((_ : (Long, Long))._1).reverse)\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (sum, i, j) = pq.dequeue\n            result += List(i, j)\n        }\n        result.toList",
    "        val queue = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                queue.enqueue((nums1(i) + nums2(j), (i, j)))\n            }\n        }\n        var result = List[List[Long]]()\n        var count = 0\n        while (count < k && queue.nonEmpty) {\n            val (sum, (i, j)) = queue.dequeue\n            result = List(nums1(i), nums2(j)) :: result\n            count += 1\n        }\n        result",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, i, j) = heap.dequeue\n            result += List(i, j)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap += ((i + j, i * j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, product) = heap.dequeue\n            result += List(sum, product)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, i, j) = heap.dequeue\n            result += List(i, j)\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.toList.map(x => List(x._2, x._3))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._2, x._3))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- 0 until min(k, nums1.length)) {\n            for (j <- 0 until min(k, nums2.length)) {\n                heap.enqueue((nums1(i), nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until min(k, heap.size)) {\n            val pair = heap.dequeue\n            result += List(pair._1, pair._2)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, i, j) = heap.dequeue\n            result += List(i, j)\n        }\n        result.toList",
    "        val pairs = for (i <- nums1; j <- nums2) yield List(i, j)\n        pairs.sortWith((a, b) => a(0) + a(1) < b(0) + b(1)).take(k.toInt)",
    "        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- 0 until min(k, nums1.length)) {\n            pq += ((i, 0, nums1(i) + nums2(0)))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && pq.nonEmpty) {\n            val (i, j, sum) = pq.dequeue\n            result += List(nums1(i.toInt), nums2(j.toInt))\n            if (j + 1 < nums2.length) {\n                pq += ((i, j + 1, nums1(i.toInt) + nums2(j.toInt + 1)))\n            }\n        }\n        result.toList",
    "        var result = List[List[Long]]()\n        var heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (num1 <- nums1) {\n            for (num2 <- nums2) {\n                heap.enqueue((num1, num2))\n            }\n        }\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result\n            val pair = heap.dequeue\n            result = List(pair._1, pair._2) :: result\n        }\n        result",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((nums1(i) + nums2(j), (i, j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, (x, y)) = heap.dequeue\n            result += List(nums1(x), nums2(y))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((nums1(i), nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val pair = heap.dequeue\n            result += List(pair._1, pair._2)\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- 0 until min(k, nums1.length).toInt) {\n            pq.enqueue((i.toLong, 0L, nums1(i.toInt) + nums2(0)))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !pq.isEmpty) {\n            val (i, j, sum) = pq.dequeue\n            result += List(nums1(i.toInt), nums2(j.toInt))\n            if (j + 1 < nums2.length) pq.enqueue((i, j + 1, nums1(i.toInt) + nums2(j.toInt + 1)))\n        }\n        result.toList",
    "        val m = nums1.length\n        val n = nums2.length\n        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(m, k.toInt)) heap.enqueue((nums1(i) + nums2(0), i, 0))\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until min(m * n, k.toInt)) {\n            val (sum, x, y) = heap.dequeue\n            result += List(nums1(x.toInt), nums2(y.toInt))\n            if (y < n - 1) heap.enqueue((nums1(x.toInt) + nums2(y.toInt + 1), x, y + 1))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap.enqueue((nums1(i) + nums2(0), i))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !heap.isEmpty) {\n            val (sum, i) = heap.dequeue\n            result += List(nums1(i), nums2(0))\n            if (nums2.length > 1) heap.enqueue((nums1(i) + nums2(1), i))\n        }\n        result.toList",
    "        val heap = new mutable.PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- nums1.indices) {\n            for (j <- nums2.indices) {\n                heap.enqueue((i.toLong, j.toLong, nums1(i) + nums2(j)))\n            }\n        }\n        var result = List[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result\n            val (x, y, _) = heap.dequeue\n            result = List(nums1(x.toInt), nums2(y.toInt)) :: result\n        }\n        result",
    "        val heap = new PriorityQueue[List[Long]]()(Ordering.by((_ : List[Long]).sum).reverse)\n        for (i <- 0 until min(k, nums1.length)) {\n            for (j <- 0 until min(k, nums2.length)) {\n                val pair = List(nums1(i), nums2(j))\n                heap.enqueue(pair)\n                if (heap.length > k) heap.dequeue\n            }\n        }\n        heap.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.toList.map(x => List(x._2, x._3))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (x, y) = heap.dequeue\n            result += List(x, y)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))",
    "        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(x => x._3))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j, i + j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (a, b, c) = heap.dequeue\n            result += List(a, b)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, i, j) = heap.dequeue\n            result += List(i, j)\n        }\n        result.toList",
    "        val heap = new mutable.PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap += ((nums1(i) + nums2(0), i))\n        }\n        var result = List[List[Long]]()\n        for (i <- 0 until min(k, nums1.length * nums2.length)) {\n            val (sum, index) = heap.dequeue\n            result = List(nums1(index.toInt), nums2(i / nums1.length)) :: result\n            if (i / nums1.length + 1 < nums2.length) heap += ((nums1(index.toInt) + nums2(i / nums1.length + 1), index))\n        }\n        result",
    "        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                pq.enqueue((i.toLong, j.toLong, nums1(i) + nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]\n        for (i <- 0 until k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (i, j, _) = pq.dequeue\n            result += List(nums1(i.toInt), nums2(j.toInt))\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i, j))\n            }\n        }\n        var result = List[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (pq.isEmpty) return result\n            val (x, y) = pq.dequeue\n            result = List(x, y) :: result\n        }\n        result",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((nums1(i) + nums2(j), (i, j)))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(nums1(x._2._1), nums2(x._2._2))).toList",
    "        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until nums1.length) {\n            heap.enqueue((i, 0, nums1(i) + nums2(0)))\n        }\n        for (i <- 0 until k) {\n            if (heap.isEmpty) return result.toList\n            val (x, y, z) = heap.dequeue\n            result += List(nums1(x.toInt), nums2(y.toInt))\n            if (y + 1 < nums2.length) heap.enqueue((x, y + 1, nums1(x.toInt) + nums2(y.toInt + 1)))\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.map(x => List(x._2, x._3)).toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList",
    "        val heap = new PriorityQueue[List[Long]]()(Ordering.by(x => x(0) + x(1)))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue(List(nums1(i), nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            result += heap.dequeue\n        }\n        result.toList",
    "        val n = nums1.length\n        val m = nums2.length\n        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(x => x._1))\n        for (i <- 0 until min(n, k.toInt)) heap.enqueue((nums1(i) + nums2(0), i, 0))\n        val result = new ListBuffer[List[Long]]()\n        while (k > 0 && heap.nonEmpty) {\n            val (sum, i, j) = heap.dequeue\n            result += List(nums1(i.toInt), nums2(j.toInt))\n            if (j < m - 1) heap.enqueue((nums1(i.toInt) + nums2(j.toInt + 1), i, j + 1))\n            k -= 1\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (heap.nonEmpty) {\n            val (sum, i, j) = heap.dequeue\n            result.append(List(i, j))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        var result = List[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result\n            val (sum, x, y) = heap.dequeue\n            result = List(x, y) :: result\n        }\n        result",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, x, y) = heap.dequeue\n            result += List(x, y)\n        }\n        result.toList",
    "        var result = List[List[Long]]()\n        var heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((nums1(i), nums2(j)))\n            }\n        }\n        for (i <- 0 until k) {\n            if (heap.isEmpty) return result\n            val pair = heap.dequeue\n            result = List(pair._1, pair._2) :: result\n        }\n        result",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList",
    "        val map = new HashMap[Long, List[Long]]()\n        for (i <- nums1) {\n            for (j <- nums2) {\n                val sum = i + j\n                if (map.contains(sum)) map(sum) = map(sum) :+ i :+ j\n                else map(sum) = List(i, j)\n            }\n        }\n        map.toList.sortWith((a, b) => a._1 < b._1).map(_._2).take(k.toInt)",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until k.toInt if i < nums1.length) {\n            for (j <- 0 until k.toInt if j < nums2.length) {\n                heap.enqueue((nums1(i) + nums2(j), (i, j)))\n            }\n        }\n        var result = List[List[Long]]()\n        while (result.length < k.toInt && heap.nonEmpty) {\n            val (sum, (i, j)) = heap.dequeue\n            result ::= List(nums1(i), nums2(j))\n            if (j + 1 < nums2.length) heap.enqueue((nums1(i) + nums2(j + 1), (i, j + 1)))\n        }\n        result",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.map(x => List(x._2, x._3)).toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            pq.enqueue((nums1(i) + nums2(0), i))\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until min(k, nums1.length * nums2.length)) {\n            val (sum, index) = pq.dequeue\n            result += List(nums1(index), nums2(i / nums1.length))\n            if (i / nums1.length + 1 < nums2.length) {\n                pq.enqueue((nums1(index) + nums2(i / nums1.length + 1), index))\n            }\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i, j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.toList.map(x => List(x._1, x._2))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, x, y) = heap.dequeue\n            result += List(x, y)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by((_ : (Long, Long))._1).reverse)\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((nums1(i) + nums2(j), (i, j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, (i, j)) = heap.dequeue\n            result += List(nums1(i), nums2(j))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._2, x._3))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap += ((nums1(i) + nums2(0), i))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !heap.isEmpty) {\n            val (sum, i) = heap.dequeue\n            result += List(nums1(i), nums2(0))\n            if (nums2.length > 1) heap += ((nums1(i) + nums2(1), i))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length).toInt) {\n            heap.enqueue((nums1(i) + nums2(0), i * nums2.length))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !heap.isEmpty) {\n            val (sum, index) = heap.dequeue\n            result += List(nums1(index / nums2.length), nums2(index % nums2.length))\n            if (index % nums2.length < nums2.length - 1) {\n                heap.enqueue((nums1(index / nums2.length) + nums2(index % nums2.length + 1), index + 1))\n            }\n        }\n        result.toList",
    "        val n = nums1.length\n        val m = nums2.length\n        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(x => x._3))\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until min(n, k.toInt)) heap.enqueue((i.toLong, 0L, nums1(i.toInt) + nums2(0)))\n        for (i <- 0 until min(k.toInt, n * m)) {\n            val (x, y, _) = heap.dequeue\n            result += List(nums1(x.toInt), nums2(y.toInt))\n            if (y + 1 < m) heap.enqueue((x, y + 1, nums1(x.toInt) + nums2(y.toInt + 1)))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[List[Long]]()(Ordering.by(-_(0) - _(1)))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue(List(nums1(i), nums2(j)))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList",
    "        val heap = new mutable.PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                val sum = nums1(i) + nums2(j)\n                if (heap.size < k) heap.enqueue((i, j, sum))\n                else if (sum < heap.head._3) {\n                    heap.dequeue\n                    heap.enqueue((i, j, sum))\n                }\n            }\n        }\n        heap.map(x => List(nums1(x._1), nums2(x._2))).toList",
    "        val heap = new mutable.PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((i, j, nums1(i) + nums2(j)))\n            }\n        }\n        var result = List[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result\n            val (i, j, sum) = heap.dequeue\n            result = List(nums1(i), nums2(j)) :: result\n        }\n        result",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap.enqueue((nums1(i) + nums2(0), i * nums2.length))\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until min(k, nums1.length * nums2.length)) {\n            val (sum, index) = heap.dequeue\n            val x = index / nums2.length\n            val y = index % nums2.length\n            result += List(nums1(x), nums2(y))\n            if (y < nums2.length - 1) {\n                heap.enqueue((nums1(x) + nums2(y + 1), index + 1))\n            }\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                if (heap.size < k) heap.enqueue((i, j))\n                else {\n                    if (i + j < heap.head._1 + heap.head._2) {\n                        heap.dequeue\n                        heap.enqueue((i, j))\n                    }\n                }\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))",
    "        val map = new HashMap[Long, List[Long]]()\n        for (i <- nums1) {\n            for (j <- nums2) {\n                val sum = i + j\n                if (map.contains(sum)) {\n                    map(sum) = map(sum) :+ i :+ j\n                } else {\n                    map(sum) = List(i, j)\n                }\n            }\n        }\n        val sorted = map.toList.sortBy(_._1)\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until min(k, sorted.length).toInt) {\n            result += sorted(i)._2\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.map(x => List(x._2, x._3)).toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, x, y) = heap.dequeue\n            result += List(x, y)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((nums1(i) + nums2(j), (i, j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, (i, j)) = heap.dequeue\n            result += List(nums1(i), nums2(j))\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                pq.enqueue((nums1(i) + nums2(j), i, j))\n            }\n        }\n        var result = List[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (pq.isEmpty) return result\n            val (sum, x, y) = pq.dequeue\n            result = List(nums1(x), nums2(y)) :: result\n        }\n        result",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n            }\n        }\n        var result = List[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (pq.isEmpty) return result\n            val (sum, i, j) = pq.dequeue\n            result = List(i, j) :: result\n        }\n        result",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, x, y) = heap.dequeue\n            result += List(x, y)\n        }\n        result.toList",
    "        val heap = new mutable.PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((nums1(i) + nums2(j), i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, i, j) = heap.dequeue\n            result += List(nums1(i), nums2(j))\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.toList.map(x => List(x._2, x._3))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((nums1(i) + nums2(j), (i, j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        var count = 0\n        while (count < k && heap.nonEmpty) {\n            val (sum, (i, j)) = heap.dequeue\n            result += List(nums1(i), nums2(j))\n            count += 1\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, x, y) = heap.dequeue\n            result += List(x, y)\n        }\n        result.toList",
    "        val heap = new mutable.PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        var result = List[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result\n            val (sum, x, y) = heap.dequeue\n            result = List(x, y) :: result\n        }\n        result",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (n1 <- nums1) {\n            for (n2 <- nums2) {\n                pq.enqueue((n1, n2))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.toList.map(x => List(x._1, x._2))",
    "        val pq = new PriorityQueue[List[Long]]()(Ordering.by((_ : List[Long]).sum).reverse)\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                pq.enqueue(List(nums1(i), nums2(j)))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.toList",
    "        val heap = new PriorityQueue[List[Long]]()(Ordering.by(x => x(0) + x(1)))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                if (heap.size < k) heap.enqueue(List(nums1(i), nums2(j)))\n                else {\n                    val top = heap.head\n                    if (top(0) + top(1) > nums1(i) + nums2(j)) {\n                        heap.dequeue\n                        heap.enqueue(List(nums1(i), nums2(j)))\n                    }\n                }\n            }\n        }\n        heap.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, x, y) = heap.dequeue\n            result += List(x, y)\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq += ((i + j, i * j))\n            }\n        }\n        var result = List[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (pq.isEmpty) return result\n            val (sum, product) = pq.dequeue\n            result = List(sum, product) :: result\n        }\n        result",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                val sum = nums1(i) + nums2(j)\n                if (heap.size < k) heap.enqueue((sum, nums1(i), nums2(j)))\n                else if (sum < heap.head._1) {\n                    heap.dequeue\n                    heap.enqueue((sum, nums1(i), nums2(j)))\n                }\n            }\n        }\n        heap.toList.map(x => List(x._2, x._3))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.map(x => List(x._2, x._3)).toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- 0 until min(k, nums1.length).toInt) {\n            for (j <- 0 until min(k, nums2.length).toInt) {\n                if (heap.size < k) heap.enqueue((nums1(i), nums2(j)))\n                else {\n                    val (a, b) = heap.head\n                    if (nums1(i) + nums2(j) < a + b) {\n                        heap.dequeue\n                        heap.enqueue((nums1(i), nums2(j)))\n                    }\n                }\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap += ((i + j, i * j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, product) = heap.dequeue\n            result += List(sum, product)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.toList.map(x => List(x._2, x._3))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap.enqueue((nums1(i) + nums2(0), i))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !heap.isEmpty) {\n            val (sum, i) = heap.dequeue\n            result += List(nums1(i), nums2(0))\n            if (nums2.length > 1) heap.enqueue((nums1(i) + nums2(1), i))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((nums1(i) + nums2(j), (i, j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, (x, y)) = heap.dequeue\n            result += List(nums1(x), nums2(y))\n        }\n        result.toList",
    "        val heap = new mutable.PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap += ((nums1(i) + nums2(j), i * nums2.length + j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, index) = heap.dequeue\n            val i = index / nums2.length\n            val j = index % nums2.length\n            result += List(nums1(i), nums2(j))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) for (j <- nums2) {\n            heap.enqueue((i + j, i, j))\n            if (heap.size > k) heap.dequeue\n        }\n        heap.toList.map(x => List(x._2, x._3))",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (sum, a, b) = pq.dequeue\n            result += List(a, b)\n        }\n        result.toList",
    "        var result = new ListBuffer[List[Long]]\n        var heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length).toInt) {\n            heap.enqueue((nums1(i) + nums2(0), i))\n        }\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, index) = heap.dequeue\n            result += List(nums1(index), nums2(i))\n            if (i < nums2.length - 1) heap.enqueue((nums1(index) + nums2(i + 1), index))\n        }\n        result.toList",
    "        var result = List[List[Long]]()\n        var heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(x => x._3))\n        for (i <- 0 until nums1.length) {\n            heap.enqueue((i.toLong, 0, nums1(i) + nums2(0)))\n        }\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result\n            val (i, j, _) = heap.dequeue\n            result = List(nums1(i.toInt), nums2(j.toInt)) :: result\n            if (j < nums2.length - 1) heap.enqueue((i, j + 1, nums1(i.toInt) + nums2(j.toInt + 1)))\n        }\n        result",
    "        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(x => x._3))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap.enqueue((i, 0, nums1(i) + nums2(0)))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && heap.nonEmpty) {\n            val (i, j, sum) = heap.dequeue\n            result += List(nums1(i.toInt), nums2(j.toInt))\n            if (j < nums2.length - 1) heap.enqueue((i, j + 1, nums1(i.toInt) + nums2(j.toInt + 1)))\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i, j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.toList.map(x => List(x._1, x._2))",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i, j))\n            }\n        }\n        var result = List[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (pq.isEmpty) return result\n            val (a, b) = pq.dequeue\n            result = List(a, b) :: result\n        }\n        result",
    "        val result = ArrayBuffer[List[Long]]()\n        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(x => x._1))\n        for (i <- 0 until min(k, nums1.length)) heap.enqueue((nums1(i) + nums2(0), i, 0))\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, i, j) = heap.dequeue\n            result += List(nums1(i.toInt), nums2(j.toInt))\n            if (j + 1 < nums2.length) heap.enqueue((nums1(i.toInt) + nums2(j.toInt + 1), i, j + 1))\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (pq.isEmpty) return result.toList\n            val (sum, x, y) = pq.dequeue\n            result += List(x, y)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList",
    "        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        val result = new ListBuffer[List[Long]]()\n        for (i <- nums1.indices) {\n            heap.enqueue((i.toLong, 0, nums1(i) + nums2(0)))\n        }\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (i, j, sum) = heap.dequeue\n            result += List(nums1(i.toInt), nums2(j.toInt))\n            if (j + 1 < nums2.length) {\n                heap.enqueue((i, j + 1, nums1(i.toInt) + nums2(j.toInt + 1)))\n            }\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length).toInt) {\n            for (j <- 0 until min(k, nums2.length).toInt) {\n                val sum = nums1(i) + nums2(j)\n                if (heap.size < k) heap.enqueue((sum, nums1(i), nums2(j)))\n                else if (sum < heap.head._1) {\n                    heap.dequeue\n                    heap.enqueue((sum, nums1(i), nums2(j)))\n                }\n            }\n        }\n        heap.toList.map(x => List(x._2, x._3))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap += ((nums1(i) + nums2(0), i))\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until min(k, nums1.length * nums2.length)) {\n            val (sum, index) = heap.dequeue\n            result += List(nums1(index), nums2(i / nums1.length))\n            if (i / nums1.length + 1 < nums2.length) {\n                heap += ((nums1(index) + nums2(i / nums1.length + 1), index))\n            }\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- 0 until min(k, nums1.length)) {\n            for (j <- 0 until min(k, nums2.length)) {\n                pq += ((nums1(i), nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until min(k, pq.size)) {\n            val (a, b) = pq.dequeue\n            result += List(a, b)\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- 0 until min(k, nums1.length).toInt) {\n            for (j <- 0 until min(k, nums2.length).toInt) {\n                pq.enqueue((nums1(i), nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until min(k, pq.size).toInt) {\n            val pair = pq.dequeue()\n            result += List(pair._1, pair._2)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, i, j) = heap.dequeue\n            result += List(i, j)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap.enqueue((nums1(i) + nums2(0), i))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !heap.isEmpty) {\n            val (sum, i) = heap.dequeue\n            result += List(nums1(i), nums2(0))\n            if (nums2.length > 1) heap.enqueue((nums1(i) + nums2(1), i))\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.toList.map(x => List(x._2, x._3))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._2, x._3))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._2, x._3))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((nums1(i), nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val pair = heap.dequeue\n            result += List(pair._1, pair._2)\n        }\n        result.toList",
    "        val pq = new PriorityQueue[List[Long]]()(Ordering.by(x => x(0) + x(1)))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue(List(i, j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((nums1(i) + nums2(j), (i, j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, (i, j)) = heap.dequeue\n            result += List(nums1(i), nums2(j))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap += ((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, i, j) = heap.dequeue\n            result += List(i, j)\n        }\n        result.toList",
    "        val pairs = for (i <- nums1; j <- nums2) yield List(i, j)\n        pairs.sortBy(x => x(0) + x(1)).take(k.toInt)",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length).toInt) {\n            heap.enqueue((nums1(i) + nums2(0), i * nums2.length))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && heap.nonEmpty) {\n            val (sum, index) = heap.dequeue\n            result += List(nums1(index / nums2.length), nums2(index % nums2.length))\n            if (index % nums2.length < nums2.length - 1) {\n                heap.enqueue((nums1(index / nums2.length) + nums2(index % nums2.length + 1), index + 1))\n            }\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                pq.enqueue((nums1(i) + nums2(j), (i, j)))\n            }\n        }\n        var result = List[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (pq.isEmpty) return result\n            val (sum, (i, j)) = pq.dequeue\n            result = List(nums1(i), nums2(j)) :: result\n        }\n        result",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until k.toInt) {\n            if (i < nums1.length) {\n                for (j <- 0 until k.toInt) {\n                    if (j < nums2.length) {\n                        heap.enqueue((nums1(i) + nums2(j), (i, j)))\n                    }\n                }\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (heap.nonEmpty) {\n            val (sum, (i, j)) = heap.dequeue\n            result += List(nums1(i), nums2(j))\n            if (j + 1 < nums2.length) {\n                heap.enqueue((nums1(i) + nums2(j + 1), (i, j + 1)))\n            }\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            pq.enqueue((nums1(i) + nums2(0), i))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !pq.isEmpty) {\n            val (sum, i) = pq.dequeue\n            result += List(nums1(i), nums2(0))\n            if (nums2.length > 1) pq.enqueue((nums1(i) + nums2(1), i))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                val sum = nums1(i) + nums2(j)\n                if (heap.size < k) heap.enqueue((sum, nums1(i), nums2(j)))\n                else if (sum < heap.head._1) {\n                    heap.dequeue\n                    heap.enqueue((sum, nums1(i), nums2(j)))\n                }\n            }\n        }\n        heap.toList.map(x => List(x._2, x._3))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, i, j) = heap.dequeue\n            result += List(i, j)\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                if (pq.size < k) pq.enqueue((i, j))\n                else {\n                    if (i + j < pq.head._1 + pq.head._2) {\n                        pq.dequeue\n                        pq.enqueue((i, j))\n                    }\n                }\n            }\n        }\n        pq.toList.map(x => List(x._1, x._2))",
    "        val heap = new PriorityQueue[List[Long]]()(Ordering.by(x => x(0) + x(1)))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue(List(i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.map(x => List(x._2, x._3)).toList",
    "        val result = new ListBuffer[List[Long]]\n        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            pq.enqueue((nums1(i) + nums2(0), i, 0))\n        }\n        for (i <- 0 until min(k, nums1.length * nums2.length)) {\n            val (sum, i, j) = pq.dequeue\n            result += List(nums1(i.toInt), nums2(j.toInt))\n            if (j + 1 < nums2.length) pq.enqueue((nums1(i.toInt) + nums2(j.toInt + 1), i, j + 1))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.map(x => List(x._2, x._3)).toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap.enqueue((nums1(i) + nums2(0), i))\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until min(k, nums1.length * nums2.length)) {\n            val (sum, index1) = heap.dequeue\n            val index2 = (i % nums2.length).toInt\n            result += List(nums1(index1), nums2(index2))\n            if (index2 + 1 < nums2.length) heap.enqueue((nums1(index1) + nums2(index2 + 1), index1))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                if (heap.size < k) heap.enqueue((i + j, i, j))\n                else if (i + j < heap.head._1) {\n                    heap.dequeue\n                    heap.enqueue((i + j, i, j))\n                }\n            }\n        }\n        heap.toList.map(x => List(x._2, x._3))",
    "        val heap = new mutable.PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, i, j) = heap.dequeue\n            result += List(i, j)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, i, j) = heap.dequeue\n            result += List(i, j)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap += ((i + j, i * j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, product) = heap.dequeue\n            result += List(sum, product)\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(_._3))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                pq.enqueue((i.toLong, j.toLong, nums1(i) + nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt if !pq.isEmpty) {\n            val (x, y, _) = pq.dequeue\n            result += List(nums1(x.toInt), nums2(y.toInt))\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(x => x._3))\n        for (i <- 0 until min(k, nums1.length)) {\n            pq.enqueue((i, 0, nums1(i) + nums2(0)))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !pq.isEmpty) {\n            val (i, j, sum) = pq.dequeue\n            result += List(nums1(i.toInt), nums2(j.toInt))\n            if (j + 1 < nums2.length) {\n                pq.enqueue((i, j + 1, nums1(i.toInt) + nums2(j.toInt + 1)))\n            }\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by((_ : (Long, Long))._1).reverse)\n        for (i <- nums1.indices) {\n            for (j <- nums2.indices) {\n                val sum = nums1(i) + nums2(j)\n                if (heap.size < k) {\n                    heap.enqueue((sum, nums1(i), nums2(j)))\n                } else {\n                    if (heap.head._1 > sum) {\n                        heap.dequeue\n                        heap.enqueue((sum, nums1(i), nums2(j)))\n                    }\n                }\n            }\n        }\n        heap.toList.map(x => List(x._2, x._3))",
    "        var result = List[List[Long]]()\n        val pq = PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (num1 <- nums1) {\n            for (num2 <- nums2) {\n                pq.enqueue((num1, num2))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        while (!pq.isEmpty) {\n            val (num1, num2) = pq.dequeue\n            result = List(num1, num2) :: result\n        }\n        result",
    "        val result = new ListBuffer[List[Long]]\n        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1.indices) {\n            for (j <- nums2.indices) {\n                heap.enqueue((nums1(i) + nums2(j), i * nums2.length + j))\n            }\n        }\n        for (i <- 0 until k.toInt if !heap.isEmpty) {\n            val (sum, index) = heap.dequeue\n            val x = index / nums2.length\n            val y = index % nums2.length\n            result += List(nums1(x), nums2(y))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, x, y) = heap.dequeue\n            result += List(x, y)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, x, y) = heap.dequeue\n            result += List(x, y)\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.map(x => List(x._2, x._3)).toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, x, y) = heap.dequeue\n            result.append(List(x, y))\n        }\n        result.toList",
    "        val m = nums1.length\n        val n = nums2.length\n        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(x => x._3))\n        for (i <- 0 until m) {\n            for (j <- 0 until n) {\n                heap.enqueue((i.toLong, j.toLong, nums1(i) + nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (x, y, z) = heap.dequeue\n            result += List(nums1(x.toInt), nums2(y.toInt))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((nums1(i) + nums2(j), i * nums2.length + j))\n            }\n        }\n        var result = List[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result\n            val (sum, index) = heap.dequeue\n            val j = index % nums2.length\n            val i = index / nums2.length\n            result = List(nums1(i), nums2(j)) :: result\n        }\n        result",
    "        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap.enqueue((i, 0, nums1(i) + nums2(0)))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && heap.nonEmpty) {\n            val (i, j, _) = heap.dequeue\n            result += List(nums1(i.toInt), nums2(j.toInt))\n            if (j + 1 < nums2.length) {\n                heap.enqueue((i, j + 1, nums1(i.toInt) + nums2(j.toInt + 1)))\n            }\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                val sum = nums1(i) + nums2(j)\n                if (heap.size < k) heap.enqueue((sum, nums1(i), nums2(j)))\n                else if (sum < heap.head._1) {\n                    heap.dequeue\n                    heap.enqueue((sum, nums1(i), nums2(j)))\n                }\n            }\n        }\n        heap.toList.map(x => List(x._2, x._3))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, i, j) = heap.dequeue\n            result += List(i, j)\n        }\n        result.toList",
    "        var result = List[List[Long]]()\n        var heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                heap.enqueue((nums1(i) + nums2(j), i, j))\n            }\n        }\n        for (i <- 0 until k) {\n            if (heap.isEmpty) return result\n            val (sum, i, j) = heap.dequeue\n            result = List(nums1(i), nums2(j)) :: result\n        }\n        result",
    "        val heap = new mutable.PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1.indices) {\n            for (j <- nums2.indices) {\n                heap += ((nums1(i) + nums2(j), nums1(i), nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, x, y) = heap.dequeue\n            result += List(x, y)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, x, y) = heap.dequeue\n            result.append(List(x, y))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, i, j) = heap.dequeue\n            result += List(i, j)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))",
    "        val queue = new PriorityQueue[List[Long]]()(Ordering.by(x => x(0) + x(1)))\n        for (i <- 0 until nums1.length; j <- 0 until nums2.length) {\n            queue.enqueue(List(nums1(i), nums2(j)))\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (queue.isEmpty) return result.toList\n            result += queue.dequeue\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i, j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (x, y) = heap.dequeue\n            result.append(List(x, y))\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq.enqueue((i + j, i, j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.map(x => List(x._2, x._3)).toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by((_ : (Long, Long))._1).reverse)\n        for (i <- 0 until min(k, nums1.length)) {\n            heap.enqueue((nums1(i) + nums2(0), i))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && !heap.isEmpty) {\n            val (sum, i) = heap.dequeue\n            result += List(nums1(i), nums2(0))\n            if (nums2.length > 1) heap.enqueue((nums1(i) + nums2(1), i))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- 0 until min(k, nums1.length)) {\n            for (j <- 0 until min(k, nums2.length)) {\n                heap.enqueue((nums1(i), nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until min(k, heap.size)) {\n            val (a, b) = heap.dequeue\n            result += List(a, b)\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap += ((i + j, i * j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (sum, product) = heap.dequeue\n            result += List(sum, product)\n        }\n        result.toList",
    "        val result = new ListBuffer[List[Long]]\n        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length).toInt) {\n            heap.enqueue((nums1(i) + nums2(0), i, 0))\n        }\n        while (result.length < k && heap.nonEmpty) {\n            val (sum, i, j) = heap.dequeue\n            result += List(nums1(i.toInt), nums2(j.toInt))\n            if (j + 1 < nums2.length) heap.enqueue((nums1(i.toInt) + nums2(j.toInt + 1), i, j + 1))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap.enqueue((nums1(i) + nums2(0), i * nums2.length))\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until min(k, nums1.length * nums2.length)) {\n            val (sum, index) = heap.dequeue\n            val x = index / nums2.length\n            val y = index % nums2.length\n            result += List(nums1(x), nums2(y))\n            if (y + 1 < nums2.length) heap.enqueue((nums1(x) + nums2(y + 1), index + 1))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap.enqueue((nums1(i) + nums2(0), i * nums2.length))\n        }\n        val result = new ListBuffer[List[Long]]\n        while (result.length < k && !heap.isEmpty) {\n            val (sum, index) = heap.dequeue\n            val i = index / nums2.length\n            val j = index % nums2.length\n            result += List(nums1(i), nums2(j))\n            if (j + 1 < nums2.length) heap.enqueue((nums1(i) + nums2(j + 1), (i * nums2.length) + j + 1))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[List[Long]]()(Ordering.by(-_(0) - _(1)))\n        for (i <- 0 until min(k, nums1.length)) {\n            for (j <- 0 until min(k, nums2.length)) {\n                heap.enqueue(List(nums1(i), nums2(j)))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 0 until min(k, heap.length)) result += heap.dequeue\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap.enqueue((i + j, i, j))\n                if (heap.size > k) heap.dequeue\n            }\n        }\n        heap.toList.map(x => List(x._2, x._3))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until min(k, nums1.length)) {\n            heap.enqueue((nums1(i) + nums2(0), i))\n        }\n        val result = new ListBuffer[List[Long]]()\n        while (result.length < k && heap.nonEmpty) {\n            val (sum, i) = heap.dequeue\n            result += List(nums1(i), nums2(0))\n            if (nums2.length > 1) {\n                heap.enqueue((nums1(i) + nums2(1), i))\n            }\n        }\n        result.toList",
    "        val n = min(k, nums1.length * nums2.length)\n        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(-_._1))\n        for (i <- 0 until nums1.length) {\n            for (j <- 0 until nums2.length) {\n                val sum = nums1(i) + nums2(j)\n                if (pq.size < n) pq += ((sum, (i, j)))\n                else if (sum < pq.head._1) {\n                    pq.dequeue\n                    pq += ((sum, (i, j)))\n                }\n            }\n        }\n        pq.map(x => List(nums1(x._2._1), nums2(x._2._2))).toList",
    "        val result = new ListBuffer[List[Long]]()\n        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(x => x._3))\n        for (i <- nums1.indices) {\n            heap += ((i, 0, nums1(i) + nums2(0)))\n        }\n        for (i <- 0 until k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (i, j, sum) = heap.dequeue\n            result += List(nums1(i.toInt), nums2(j.toInt))\n            if (j + 1 < nums2.length) heap += ((i, j + 1, nums1(i.toInt) + nums2(j.toInt + 1)))\n        }\n        result.toList",
    "        val heap = new PriorityQueue[(Long, Long, Long)]()(Ordering.by(-_._3))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                heap += ((i, j, i + j))\n            }\n        }\n        val result = new ListBuffer[List[Long]]()\n        for (i <- 1 to k.toInt) {\n            if (heap.isEmpty) return result.toList\n            val (a, b, c) = heap.dequeue\n            result += List(a, b)\n        }\n        result.toList",
    "        val pq = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                pq += ((i, j))\n                if (pq.size > k) pq.dequeue\n            }\n        }\n        pq.toList.map(x => List(x._1, x._2))",
    "        val heap = new PriorityQueue[(Long, Long)]()(Ordering.by(x => x._1 + x._2))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                if (heap.size < k) heap.enqueue((i, j))\n                else {\n                    if (i + j < heap.head._1 + heap.head._2) {\n                        heap.dequeue\n                        heap.enqueue((i, j))\n                    }\n                }\n            }\n        }\n        heap.toList.map(x => List(x._1, x._2))",
    "        val heap = new PriorityQueue[List[Long]]()(Ordering.by(x => x(0) + x(1)))\n        for (i <- nums1) {\n            for (j <- nums2) {\n                if (heap.size < k) heap.enqueue(List(i, j))\n                else {\n                    val top = heap.head\n                    if (i + j < top(0) + top(1)) {\n                        heap.dequeue\n                        heap.enqueue(List(i, j))\n                    }\n                }\n            }\n        }\n        heap.toList"
  ]
}