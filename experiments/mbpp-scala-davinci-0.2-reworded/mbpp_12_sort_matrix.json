{
  "name": "mbpp_12_sort_matrix",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to sort a given matrix in ascending order according to the sum of its rows.\n    def sortMatrix(M : List[List[Long]]) : List[List[Long]] = {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_12_sort_matrix.py",
  "prompt_terminology": "reworded",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(sortMatrix((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong), List[Long](2l.toLong, 4l.toLong, 5l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong)))).equals((List[List[Long]](List[Long](1l.toLong, 1l.toLong, 1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong), List[Long](2l.toLong, 4l.toLong, 5l.toLong)))));\n    assert(sortMatrix((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong), List[Long](-2l.toLong, 4l.toLong, -5l.toLong), List[Long](1l.toLong, -1l.toLong, 1l.toLong)))).equals((List[List[Long]](List[Long](-2l.toLong, 4l.toLong, -5l.toLong), List[Long](1l.toLong, -1l.toLong, 1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong)))));\n    assert(sortMatrix((List[List[Long]](List[Long](5l.toLong, 8l.toLong, 9l.toLong), List[Long](6l.toLong, 4l.toLong, 3l.toLong), List[Long](2l.toLong, 1l.toLong, 4l.toLong)))).equals((List[List[Long]](List[Long](2l.toLong, 1l.toLong, 4l.toLong), List[Long](6l.toLong, 4l.toLong, 3l.toLong), List[Long](5l.toLong, 8l.toLong, 9l.toLong)))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((l1, l2) => l1.sum < l2.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((row1, row2) => row1.sum < row2.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((l1, l2) => l1.sum < l2.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        val sums = M.map(row => row.sum)\n        val sorted = sums.sorted\n        val indices = sorted.map(sum => sums.indexOf(sum))\n        val sortedMatrix = indices.map(index => M(index))\n        sortedMatrix",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        val sorted = M.sortWith((a, b) => a.sum < b.sum)\n        sorted",
    "        M.sortBy(x => x.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((r1, r2) => r1.sum < r2.sum)",
    "        M.sortBy(x => x.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortBy(x => x.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        val rowSums = M.map(row => row.sum)\n        val sortedRowIndices = rowSums.zipWithIndex.sortBy(_._1).map(_._2)\n        sortedRowIndices.map(i => M(i))",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortBy(x => x.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        val sums = M.map(row => row.sum)\n        M.sortBy(row => row.sum)",
    "        M.sortBy(x => x.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortBy(x => x.sum)",
    "        M.sortBy(x => x.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortBy(x => x.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortBy(x => x.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        val sums = M.map(row => row.sum)\n        val sorted = sums.sorted\n        val sortedM = new ListBuffer[List[Long]]\n        for (i <- 0 until M.length) {\n            val row = M(sums.indexOf(sorted(i)))\n            sortedM += row\n        }\n        sortedM.toList",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortBy(x => x.sum)",
    "        val rowSums = M.map(row => row.sum)\n        M.zip(rowSums).sortBy(_._2).map(_._1)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((row1, row2) => row1.sum < row2.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        val rowSums = M.map(row => row.sum)\n        val sortedIndices = rowSums.zipWithIndex.sortBy(_._1).map(_._2)\n        sortedIndices.map(i => M(i))",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortBy(row => row.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortBy(x => x.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortBy(x => x.sum)",
    "        M.sortBy(x => x.sum)",
    "        M.sortBy(x => x.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        val sums = M.map(row => row.sum)\n        M.zip(sums).sortBy(_._2).map(_._1)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        val rowSums = M.map(row => row.sum)\n        val sortedRowIndices = rowSums.zipWithIndex.sortBy(_._1).map(_._2)\n        sortedRowIndices.map(M(_)).toList",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortBy(x => x.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortBy(x => x.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortBy(x => x.sum)",
    "        M.sortBy(x => x.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortBy(x => x.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((l1, l2) => l1.sum < l2.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        val rowSums = M.map(row => row.sum)\n        val sortedIndices = rowSums.zipWithIndex.sortBy(_._1).map(_._2)\n        sortedIndices.map(i => M(i))",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortBy(x => x.sum)",
    "        val sums = M.map(row => row.sum)\n        M.sortBy(row => row.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortBy(x => x.sum)",
    "        M.sortBy(row => row.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        val sums = M.map(row => row.sum)\n        M.zip(sums).sortBy(_._2).map(_._1)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortBy(x => x.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortBy(x => x.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        val sums = M.map(row => (row, row.sum)).sortBy(_._2)\n        sums.map(_._1)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortBy(x => x.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        val sums = M.map(x => x.sum)\n        M.sortWith((x, y) => sums(M.indexOf(x)) < sums(M.indexOf(y)))",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortBy(x => x.sum)",
    "        M.sortBy(row => row.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        val sums = M.map(row => row.sum)\n        M.zip(sums).sortBy(_._2).map(_._1)",
    "        M.sortBy(x => x.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((a, b) => a.sum < b.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        val rowSums = M.map(row => row.sum)\n        val sortedRowIndices = rowSums.zipWithIndex.sortBy(x => x._1).map(x => x._2)\n        sortedRowIndices.map(i => M(i)).toList",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortWith((x, y) => x.sum < y.sum)",
    "        M.sortBy(x => x.sum)",
    "        val sorted = M.sortWith((a, b) => a.sum < b.sum)\n        sorted"
  ]
}