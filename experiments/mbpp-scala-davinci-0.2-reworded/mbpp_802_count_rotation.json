{
  "name": "mbpp_802_count_rotation",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a scalathon function to count the number of rotations required to generate a sorted list. https://www.geeksforgeeks.org/count-of-rotations-required-to-generate-a-sorted-list/\n    def countRotation(arr : List[Long]) : Long = {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_802_count_rotation.py",
  "prompt_terminology": "reworded",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(countRotation((List[Long](3l.toLong, 2l.toLong, 1l.toLong))) == (1l));\n    assert(countRotation((List[Long](4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong, 3l.toLong))) == (2l));\n    assert(countRotation((List[Long](7l.toLong, 8l.toLong, 9l.toLong, 1l.toLong, 2l.toLong, 3l.toLong))) == (3l));\n    assert(countRotation((List[Long](1l.toLong, 2l.toLong, 3l.toLong))) == (0l));\n    assert(countRotation((List[Long](1l.toLong, 3l.toLong, 2l.toLong))) == (2l));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        var count = 0\n        for (i <- 0 until arr.length) {\n            if (arr(i) > arr(i + 1)) {\n                count = i + 1\n                return count\n            }\n        }\n        return count",
    "        def countRotation(arr : List[Long], low : Long, high : Long) : Long = {\n            if (high < low) return 0\n            if (high == low) return low\n            val mid = (low + high) / 2\n            if (mid < high && arr(mid.toInt + 1) < arr(mid.toInt)) return mid + 1\n            if (mid > low && arr(mid.toInt - 1) > arr(mid.toInt)) return mid\n            if (arr(high.toInt) > arr(mid.toInt)) return countRotation(arr, low, mid - 1)\n            return countRotation(arr, mid + 1, high)\n        }\n        countRotation(arr, 0, arr.length - 1)",
    "        val n = arr.length\n        var low = 0\n        var high = n - 1\n        while (low <= high) {\n            if (arr(low) <= arr(high)) return low\n            val mid = (low + high) / 2\n            val next = (mid + 1) % n\n            val prev = (mid + n - 1) % n\n            if (arr(mid) <= arr(next) && arr(mid) <= arr(prev)) return mid\n            else if (arr(mid) <= arr(high)) high = mid - 1\n            else if (arr(mid) >= arr(low)) low = mid + 1\n        }\n        -1",
    "        def countRotation(arr : List[Long], low : Int, high : Int) : Long = {\n            if (low > high) return -1\n            if (arr(low) <= arr(high)) return low\n            val mid = (low + high) / 2\n            val next = (mid + 1) % arr.length\n            val prev = (mid + arr.length - 1) % arr.length\n            if (arr(mid) <= arr(next) && arr(mid) <= arr(prev)) return mid\n            else if (arr(mid) <= arr(high)) countRotation(arr, low, mid - 1)\n            else countRotation(arr, mid + 1, high)\n        }\n        countRotation(arr, 0, arr.length - 1)",
    "        val n = arr.length\n        var low = 0\n        var high = n - 1\n        while (low <= high) {\n            if (arr(low) <= arr(high)) return low\n            var mid = low + (high - low) / 2\n            var next = (mid + 1) % n\n            var prev = (mid + n - 1) % n\n            if (arr(mid) <= arr(next) && arr(mid) <= arr(prev)) return mid\n            else if (arr(mid) <= arr(high)) high = mid - 1\n            else if (arr(mid) >= arr(low)) low = mid + 1\n        }\n        return -1",
    "        // This is a binary search problem.\n        def countRotation(arr : List[Long], l : Int, r : Int) : Long = {\n            if (l > r) return 0\n            if (l == r) return l\n            val m = (l + r) / 2\n            if (m < r && arr(m) > arr(m + 1)) return m + 1\n            if (m > l && arr(m) < arr(m - 1)) return m\n            if (arr(r) > arr(m)) countRotation(arr, l, m - 1)\n            else countRotation(arr, m + 1, r)\n        }\n        countRotation(arr, 0, arr.size - 1)",
    "        def countRotation(arr : List[Long], low : Int, high : Int) : Long = {\n            if (high < low) return 0\n            if (high == low) return low\n            val mid = (low + high) / 2\n            if (mid < high && arr(mid + 1) < arr(mid)) return mid + 1\n            if (mid > low && arr(mid) < arr(mid - 1)) return mid\n            if (arr(high) > arr(mid)) return countRotation(arr, low, mid - 1)\n            return countRotation(arr, mid + 1, high)\n        }\n        countRotation(arr, 0, arr.length - 1)",
    "        val n = arr.length\n        var low = 0\n        var high = n - 1\n        while (low <= high) {\n            if (arr(low) <= arr(high)) return low\n            var mid = (low + high) / 2\n            var next = (mid + 1) % n\n            var prev = (mid + n - 1) % n\n            if (arr(mid) <= arr(next) && arr(mid) <= arr(prev)) return mid\n            else if (arr(mid) <= arr(high)) high = mid - 1\n            else if (arr(mid) >= arr(low)) low = mid + 1\n        }\n        return -1",
    "        var min = arr(0)\n        var minIndex = 0\n        for (i <- 0 until arr.length) {\n            if (arr(i) < min) {\n                min = arr(i)\n                minIndex = i\n            }\n        }\n        minIndex",
    "        def countRotation(arr : List[Long], low : Long, high : Long) : Long = {\n            if (high < low) return 0\n            if (high == low) return low\n            val mid = low + (high - low) / 2\n            if (mid < high && arr(mid.toInt + 1) < arr(mid.toInt)) return mid + 1\n            if (mid > low && arr(mid.toInt - 1) > arr(mid.toInt)) return mid\n            if (arr(high.toInt) > arr(mid.toInt)) return countRotation(arr, low, mid - 1)\n            return countRotation(arr, mid + 1, high)\n        }\n        countRotation(arr, 0, arr.length - 1)",
    "        var count = 0\n        var min = arr(0)\n        for (i <- 1 until arr.length) {\n            if (arr(i) < min) {\n                min = arr(i)\n                count = i\n            }\n        }\n        count",
    "        def countRotation(arr : List[Long], left : Int, right : Int) : Long = {\n            if (left > right) return 0\n            if (left == right) return left\n            val mid = (left + right) / 2\n            if (mid < right && arr(mid) > arr(mid + 1)) return mid + 1\n            if (mid > left && arr(mid - 1) > arr(mid)) return mid\n            if (arr(left) >= arr(mid)) return countRotation(arr, left, mid - 1)\n            return countRotation(arr, mid + 1, right)\n        }\n        countRotation(arr, 0, arr.length - 1)",
    "        def count(arr : List[Long], start : Long, end : Long) : Long = {\n            if (start > end) return 0\n            if (start == end) return start\n            val mid = (start + end) / 2\n            if (mid < end && arr(mid.toInt) > arr(mid.toInt + 1)) return mid + 1\n            if (mid > start && arr(mid.toInt) < arr(mid.toInt - 1)) return mid\n            if (arr(start.toInt) >= arr(mid.toInt)) return count(arr, start, mid - 1)\n            return count(arr, mid + 1, end)\n        }\n        count(arr, 0, arr.length - 1)",
    "        def countRotation(arr : List[Long], start : Long, end : Long) : Long = {\n            if (start > end) return 0\n            val mid = (start + end) / 2\n            if (mid < end && arr(mid.toInt) > arr(mid.toInt + 1)) return mid\n            if (mid > start && arr(mid.toInt) < arr(mid.toInt - 1)) return mid - 1\n            if (arr(start.toInt) >= arr(mid.toInt)) countRotation(arr, start, mid - 1)\n            else countRotation(arr, mid + 1, end)\n        }\n        countRotation(arr, 0, arr.length - 1)",
    "        def countRotation(arr : List[Long], low : Int, high : Int) : Long = {\n            if (high < low) return 0\n            if (high == low) return low\n            val mid = (low + high) / 2\n            if (mid < high && arr(mid + 1) < arr(mid)) return mid + 1\n            if (mid > low && arr(mid) < arr(mid - 1)) return mid\n            if (arr(high) > arr(mid)) return countRotation(arr, low, mid - 1)\n            return countRotation(arr, mid + 1, high)\n        }\n        countRotation(arr, 0, arr.length - 1)",
    "        var count = 0\n        for (i <- 0 until arr.length) {\n            if (arr(i) > arr((i + 1) % arr.length)) {\n                count = i + 1\n                return count\n            }\n        }\n        count",
    "        def countRotation(arr : List[Long], low : Int, high : Int) : Long = {\n            if (high < low) return 0\n            if (high == low) return low\n            val mid = low + (high - low) / 2\n            if (mid < high && arr(mid + 1) < arr(mid)) return mid + 1\n            if (mid > low && arr(mid) < arr(mid - 1)) return mid\n            if (arr(high) > arr(mid)) return countRotation(arr, low, mid - 1)\n            return countRotation(arr, mid + 1, high)\n        }\n        return countRotation(arr, 0, arr.length - 1)",
    "        var count = 0\n        for (i <- 0 until arr.length) {\n            if (arr(i) > arr(i + 1)) {\n                count = i + 1\n                return count\n            }\n        }\n        return count",
    "        val n = arr.length\n        var low = 0\n        var high = n - 1\n        while (low <= high) {\n            if (arr(low) <= arr(high)) return low\n            val mid = (low + high) / 2\n            val next = (mid + 1) % n\n            val prev = (mid + n - 1) % n\n            if (arr(mid) <= arr(next) && arr(mid) <= arr(prev)) return mid\n            else if (arr(mid) <= arr(high)) high = mid - 1\n            else if (arr(mid) >= arr(low)) low = mid + 1\n        }\n        return -1",
    "        val n = arr.length\n        var low = 0\n        var high = n - 1\n        while (low <= high) {\n            if (arr(low) <= arr(high)) return low\n            val mid = (low + high) / 2\n            val next = (mid + 1) % n\n            val prev = (mid + n - 1) % n\n            if (arr(mid) <= arr(next) && arr(mid) <= arr(prev)) return mid\n            else if (arr(mid) <= arr(high)) high = mid - 1\n            else if (arr(mid) >= arr(low)) low = mid + 1\n        }\n        return -1"
  ]
}