{
  "name": "mbpp_612_merge",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a scalathon function which takes a list of lists, where each sublist has two elements, and returns a list of two lists where the first list has the first element of each sublist and the second one has the second.\n    def merge(lst : Any) : Any = {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_612_merge.py",
  "prompt_terminology": "reworded",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(merge((Any(List[String](\"x\", \"y\"), List[String](\"a\", \"b\"), List[String](\"m\", \"n\")))).equals((Any(List[String](\"x\", \"a\", \"m\"), List[String](\"y\", \"b\", \"n\")))));\n    assert(merge((Any(List[Long](1l.toLong, 2l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](5l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong)))).equals((Any(List[Long](1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong), List[Long](2l.toLong, 4l.toLong, 6l.toLong, 8l.toLong)))));\n    assert(merge((Any(List[String](\"x\", \"y\", \"z\"), List[String](\"a\", \"b\", \"c\"), List[String](\"m\", \"n\", \"o\")))).equals((Any(List[String](\"x\", \"a\", \"m\"), List[String](\"y\", \"b\", \"n\"), List[String](\"z\", \"c\", \"o\")))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        val lst1 = lst.asInstanceOf[List[List[Any]]]\n        val lst2 = lst1.map(x => x(0))\n        val lst3 = lst1.map(x => x(1))\n        List(lst2, lst3)",
    "        lst match {\n            case Nil => Nil\n            case (x :: xs) => x match {\n                case Nil => merge(xs)\n                case (y :: ys) => merge(ys)\n                case _ => Nil\n            }\n            case _ => Nil\n        }",
    "        val lst2 = lst.asInstanceOf[List[List[Any]]]\n        val lst3 = lst2.map(x => x.asInstanceOf[List[Any]])\n        val lst4 = lst3.map(x => x.map(y => y.asInstanceOf[Int]))\n        val lst5 = lst4.map(x => x(0))\n        val lst6 = lst4.map(x => x(1))\n        List(lst5, lst6)",
    "        lst match {\n            case Nil => Nil\n            case (x:Int, y:Int) :: xs => (x :: merge(xs).asInstanceOf[List[Int]], y :: merge(xs).asInstanceOf[List[Int]])\n            case (x:String, y:String) :: xs => (x :: merge(xs).asInstanceOf[List[String]], y :: merge(xs).asInstanceOf[List[String]])\n            case _ => Nil\n        }",
    "        lst match {\n            case Nil => Nil\n            case (x :: xs) => {\n                val (a, b) = x\n                merge(xs) match {\n                    case (c, d) => (a :: c, b :: d)\n                }\n            }\n        }",
    "        lst match {\n            case Nil => Nil\n            case (x :: xs) => (x._1 :: merge(xs)._1, x._2 :: merge(xs)._2)\n        }",
    "        lst match {\n            case Nil => Nil\n            case (x :: xs) => (x._1 :: merge(xs)._1) :: (x._2 :: merge(xs)._2)\n        }",
    "        lst match {\n            case Nil => Nil\n            case (x :: xs) => x :: merge(xs)\n            case (x :: xs) => x :: merge(xs)\n        }",
    "        val lst1 = lst.asInstanceOf[List[List[Any]]]\n        val lst2 = lst1.map(x => x.head)\n        val lst3 = lst1.map(x => x.tail.head)\n        List(lst2, lst3)",
    "        lst match {\n            case Nil => Nil\n            case x :: xs => x match {\n                case y :: ys => (y :: merge(xs).asInstanceOf[List[Any]].asInstanceOf[List[Any]]) :: (ys :: merge(xs).asInstanceOf[List[Any]].asInstanceOf[List[Any]])\n                case _ => Nil\n            }\n            case _ => Nil\n        }",
    "        lst match {\n            case Nil => Nil\n            case (x :: xs) => x :: merge(xs)\n        }",
    "        val lst1 = lst.asInstanceOf[List[List[Any]]]\n        val lst2 = lst1.map(x => x(0))\n        val lst3 = lst1.map(x => x(1))\n        List(lst2, lst3)",
    "        lst match {\n            case Nil => Nil\n            case (x :: xs) => {\n                val (a, b) = x\n                merge(xs) match {\n                    case (xs, ys) => ((a :: xs), (b :: ys))\n                }\n            }\n        }",
    "        lst match {\n            case Nil => Nil\n            case (x :: xs) => x :: merge(xs)\n        }",
    "        var lst1 : List[Any] = List()\n        var lst2 : List[Any] = List()\n        for (i <- lst.asInstanceOf[List[List[Any]]]) {\n            lst1 = lst1 :+ i(0)\n            lst2 = lst2 :+ i(1)\n        }\n        return List(lst1, lst2)",
    "        var lst1 = List[Any]()\n        var lst2 = List[Any]()\n        for (i <- lst.asInstanceOf[List[List[Any]]]) {\n            lst1 = lst1 :+ i(0)\n            lst2 = lst2 :+ i(1)\n        }\n        List(lst1, lst2)",
    "        val lst1 = lst.asInstanceOf[List[List[Int]]]\n        val lst2 = lst1.map(x => x(0))\n        val lst3 = lst1.map(x => x(1))\n        List(lst2, lst3)",
    "        val lst1 = lst.asInstanceOf[List[List[Int]]]\n        val lst2 = lst1.map(x => x(0))\n        val lst3 = lst1.map(x => x(1))\n        List(lst2, lst3)",
    "        lst match {\n            case Nil => Nil\n            case x :: xs => x match {\n                case (a, b) => merge(xs) match {\n                    case (l1, l2) => (a :: l1, b :: l2)\n                }\n            }\n        }",
    "        lst match {\n            case Nil => Nil\n            case (x :: xs) => {\n                val (a, b) = x.asInstanceOf[(Int, Int)]\n                merge(xs) match {\n                    case (a1 :: b1 :: Nil) => (a :: a1 :: Nil) :: (b :: b1 :: Nil) :: Nil\n                    case _ => (a :: Nil) :: (b :: Nil) :: Nil\n                }\n            }\n        }"
  ]
}