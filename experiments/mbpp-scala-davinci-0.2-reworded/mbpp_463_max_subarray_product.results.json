{
  "name": "mbpp_463_max_subarray_product",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_463_max_subarray_product.py",
  "prompt_terminology": "reworded",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "results": [
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 until arr.length) {\n            val temp = max\n            max = max(max * arr(i), min * arr(i), arr(i))\n            min = min(temp * arr(i), min * arr(i), arr(i))\n            result = max(result, max)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517473,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpjns7hab7.scala:11:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            max = max(max * arr(i), min * arr(i), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpjns7hab7.scala:12:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            min = min(temp * arr(i), min * arr(i), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpjns7hab7.scala:13:21 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            result = max(result, max)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 until arr.length) {\n            val temp = max\n            max = max(max * arr(i), min * arr(i), arr(i))\n            min = min(temp * arr(i), min * arr(i), arr(i))\n            if (max > result) result = max\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517473,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp_65wvvz7.scala:11:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            max = max(max * arr(i), min * arr(i), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp_65wvvz7.scala:12:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            min = min(temp * arr(i), min * arr(i), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = arr(0)\n        var minProduct = arr(0)\n        var maxSoFar = arr(0)\n        for (i <- 1 to arr.length - 1) {\n            if (arr(i) > 0) {\n                maxProduct = max(maxProduct * arr(i), arr(i))\n                minProduct = min(minProduct * arr(i), arr(i))\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), arr(i))\n                minProduct = min(temp * arr(i), arr(i))\n            }\n            maxSoFar = max(maxSoFar, maxProduct)\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct = maxProduct * arr(i)\n                minProduct = min(minProduct * arr(i), 1)\n            }\n            else if (arr(i) == 0) {\n                maxProduct = 1\n                minProduct = 1\n            }\n            else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max_ending_here = 1L\n        var min_ending_here = 1L\n        var max_so_far = 1L\n        for (x <- arr) {\n            if (x > 0) {\n                max_ending_here = max_ending_here * x\n                min_ending_here = min(min_ending_here * x, 1)\n            } else if (x == 0) {\n                max_ending_here = 1\n                min_ending_here = 1\n            } else {\n                val temp = max_ending_here\n                max_ending_here = max(min_ending_here * x, 1)\n                min_ending_here = temp * x\n            }\n            if (max_so_far < max_ending_here) max_so_far = max_ending_here\n        }\n        max_so_far\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 until arr.length) {\n            val a = max * arr(i)\n            val b = min * arr(i)\n            max = max(max(a, b), arr(i))\n            min = min(min(a, b), arr(i))\n            result = max(result, max)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517472,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpfzpbae65.scala:12:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            max = max(max(a, b), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpfzpbae65.scala:12:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            max = max(max(a, b), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpfzpbae65.scala:13:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            min = min(min(a, b), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpfzpbae65.scala:13:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            min = min(min(a, b), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpfzpbae65.scala:14:21 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            result = max(result, max)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1)\n            } else if (arr(i) == 0) {\n                maxProduct = 1\n                minProduct = 1\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = arr(0)\n        var minProduct = arr(0)\n        var maxSoFar = arr(0)\n        for (i <- 1 to arr.length - 1) {\n            val maxProductTemp = max(max(maxProduct * arr(i), minProduct * arr(i)), arr(i))\n            val minProductTemp = min(min(maxProduct * arr(i), minProduct * arr(i)), arr(i))\n            maxProduct = maxProductTemp\n            minProduct = minProductTemp\n            maxSoFar = max(maxSoFar, maxProduct)\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxSoFar = arr(0)\n        var maxEndingHere = arr(0)\n        var minEndingHere = arr(0)\n        for (i <- 1 to arr.length - 1) {\n            val temp = maxEndingHere\n            maxEndingHere = max(max(maxEndingHere * arr(i), minEndingHere * arr(i)), arr(i))\n            minEndingHere = min(min(temp * arr(i), minEndingHere * arr(i)), arr(i))\n            maxSoFar = max(maxSoFar, maxEndingHere)\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = arr(0)\n        var minProduct = arr(0)\n        var maxSoFar = arr(0)\n        for (i <- 1 to arr.length - 1) {\n            val maxProductCopy = maxProduct\n            maxProduct = max(max(maxProduct * arr(i), minProduct * arr(i)), arr(i))\n            minProduct = min(min(maxProductCopy * arr(i), minProduct * arr(i)), arr(i))\n            maxSoFar = max(maxSoFar, maxProduct)\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 to arr.length - 1) {\n            val a = max * arr(i)\n            val b = min * arr(i)\n            max = max(a, max(b, arr(i)))\n            min = min(a, min(b, arr(i)))\n            result = max(result, max)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517473,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpcx_1la9q.scala:12:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            max = max(a, max(b, arr(i)))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpcx_1la9q.scala:12:25 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            max = max(a, max(b, arr(i)))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpcx_1la9q.scala:13:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            min = min(a, min(b, arr(i)))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpcx_1la9q.scala:13:25 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            min = min(a, min(b, arr(i)))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpcx_1la9q.scala:14:21 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            result = max(result, max)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (x <- arr) {\n            val tempMax = max(x, max(x * maxProduct, x * minProduct))\n            val tempMin = min(x, min(x * maxProduct, x * minProduct))\n            maxSoFar = max(maxSoFar, tempMax)\n            maxProduct = tempMax\n            minProduct = tempMin\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var maxProduct = arr(0)\n        for (i <- 1 until arr.length) {\n            val a = arr(i)\n            val b = max * a\n            val c = min * a\n            max = max(max(a, b), c)\n            min = min(min(a, b), c)\n            maxProduct = max(maxProduct, max)\n        }\n        maxProduct\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517473,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpny295_eq.scala:13:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            max = max(max(a, b), c)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpny295_eq.scala:13:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            max = max(max(a, b), c)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpny295_eq.scala:14:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            min = min(min(a, b), c)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpny295_eq.scala:14:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            min = min(min(a, b), c)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpny295_eq.scala:15:25 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            maxProduct = max(maxProduct, max)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (x <- arr) {\n            val maxProductCopy = maxProduct\n            maxProduct = max(x, max(maxProduct * x, minProduct * x))\n            minProduct = min(x, min(maxProductCopy * x, minProduct * x))\n            maxSoFar = max(maxSoFar, maxProduct)\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 until arr.length) {\n            val temp = max\n            max = max(max * arr(i), min * arr(i), arr(i))\n            min = min(temp * arr(i), min * arr(i), arr(i))\n            result = max(result, max)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517473,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpjns7hab7.scala:11:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            max = max(max * arr(i), min * arr(i), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpjns7hab7.scala:12:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            min = min(temp * arr(i), min * arr(i), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpjns7hab7.scala:13:21 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            result = max(result, max)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = arr(0)\n        var currentProduct = arr(0)\n        for (i <- 1 until arr.length) {\n            currentProduct = max(currentProduct * arr(i), arr(i))\n            maxProduct = max(maxProduct, currentProduct)\n        }\n        maxProduct\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpqhwhih_b.scala:15)\n\tat Problem.main(tmpqhwhih_b.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1L)\n            } else if (arr(i) == 0) {\n                maxProduct = 1L\n                minProduct = 1L\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1L)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 until arr.length) {\n            val temp = max\n            max = max(max * arr(i), min * arr(i), arr(i))\n            min = min(temp * arr(i), min * arr(i), arr(i))\n            result = result max max\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517472,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp3onvsfn9.scala:11:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            max = max(max * arr(i), min * arr(i), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp3onvsfn9.scala:12:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            min = min(temp * arr(i), min * arr(i), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1)\n            }\n            else if (arr(i) == 0) {\n                maxProduct = 1\n                minProduct = 1\n            }\n            else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var result = 0L\n        for (x <- arr) {\n            val a = maxProduct * x\n            val b = minProduct * x\n            maxProduct = max(max(a, b), x)\n            minProduct = min(min(a, b), x)\n            result = max(result, maxProduct)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1)\n            } else if (arr(i) == 0) {\n                maxProduct = 1\n                minProduct = 1\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = Long.MinValue\n        var product = 1L\n        for (i <- 0 until arr.length) {\n            product *= arr(i)\n            maxProduct = max(maxProduct, product)\n            if (product == 0) product = 1\n        }\n        product = 1\n        for (i <- arr.length - 1 to 0 by -1) {\n            product *= arr(i)\n            maxProduct = max(maxProduct, product)\n            if (product == 0) product = 1\n        }\n        maxProduct\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123204,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = arr(0)\n        var currentProduct = arr(0)\n        for (i <- 1 to arr.length - 1) {\n            currentProduct = max(currentProduct * arr(i), arr(i))\n            maxProduct = max(maxProduct, currentProduct)\n        }\n        maxProduct\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123204,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpfj1tg4jh.scala:15)\n\tat Problem.main(tmpfj1tg4jh.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 until arr.length) {\n            val max_copy = max\n            max = max(arr(i), max_copy * arr(i), min * arr(i))\n            min = min(arr(i), max_copy * arr(i), min * arr(i))\n            result = result max max\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123197,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpur13uss_.scala:11:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            max = max(arr(i), max_copy * arr(i), min * arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpur13uss_.scala:12:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            min = min(arr(i), max_copy * arr(i), min * arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = 0L\n        var curr = 0L\n        var neg = 0L\n        for (i <- arr) {\n            if (i > 0) {\n                curr = curr * i\n                neg = neg * i\n            } else if (i < 0) {\n                val temp = curr\n                curr = neg * i\n                neg = temp * i\n            } else {\n                curr = 0\n                neg = 0\n            }\n            if (curr > max) max = curr\n            if (curr == 0) curr = 1\n        }\n        max\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123203,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpo_qxvk9g.scala:28)\n\tat Problem.main(tmpo_qxvk9g.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1L)\n            }\n            else if (arr(i) == 0) {\n                maxProduct = 1L\n                minProduct = 1L\n            }\n            else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1L)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123204,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1)\n            } else if (arr(i) == 0) {\n                maxProduct = 1\n                minProduct = 1\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1)\n            } else if (arr(i) == 0) {\n                maxProduct = 1\n                minProduct = 1\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 until arr.length) {\n            if (arr(i) > 0) {\n                max = max * arr(i)\n                min = min * arr(i)\n            } else {\n                val temp = max\n                max = min * arr(i)\n                min = temp * arr(i)\n            }\n            max = max max arr(i)\n            min = min min arr(i)\n            result = result max max\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123204,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1L)\n            }\n            else if (arr(i) == 0) {\n                maxProduct = 1L\n                minProduct = 1L\n            }\n            else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1L)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123204,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        val n = arr.length\n        val dp = Array.fill(n)((0L, 0L))\n        dp(0) = (arr(0), arr(0))\n        for (i <- 1 until n) {\n            dp(i) = (max(max(dp(i - 1)._1 * arr(i), dp(i - 1)._2 * arr(i)), arr(i)), min(min(dp(i - 1)._1 * arr(i), dp(i - 1)._2 * arr(i)), arr(i)))\n        }\n        dp.map(_._1).max\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123205,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = Long.MinValue\n        var cur = 1L\n        for (i <- 0 until arr.length) {\n            cur *= arr(i)\n            max = max.max(cur)\n            if (cur == 0) cur = 1\n        }\n        cur = 1\n        for (i <- arr.length - 1 to 0 by -1) {\n            cur *= arr(i)\n            max = max.max(cur)\n            if (cur == 0) cur = 1\n        }\n        max\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123204,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1L)\n            } else if (arr(i) == 0) {\n                maxProduct = 1L\n                minProduct = 1L\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1L)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = arr(0)\n        var currentMax = arr(0)\n        var currentMin = arr(0)\n        for (i <- 1 until arr.length) {\n            val current = arr(i)\n            val tempMax = max(current, current * currentMax, current * currentMin)\n            val tempMin = min(current, current * currentMax, current * currentMin)\n            maxProduct = max(maxProduct, tempMax)\n            currentMax = tempMax\n            currentMin = tempMin\n        }\n        maxProduct\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123198,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmp_r99iw0o.scala:11:26 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mtempMax\u001b[0m = max(current, current * currentMax, current * currentMin)\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35mmax\u001b[0m in \u001b[33mpackage\u001b[0m \u001b[35mscala.math\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double, y: Double): Double\n\u001b[31m   |\u001b[0m (x: Float, y: Float): Float\n\u001b[31m   |\u001b[0m (x: Long, y: Long): Long\n\u001b[31m   |\u001b[0m (x: Int, y: Int): Int\n\u001b[31m   |\u001b[0mmatch arguments ((current : Long), Long, Long)\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmp_r99iw0o.scala:12:26 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mtempMin\u001b[0m = min(current, current * currentMax, current * currentMin)\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35mmin\u001b[0m in \u001b[33mpackage\u001b[0m \u001b[35mscala.math\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double, y: Double): Double\n\u001b[31m   |\u001b[0m (x: Float, y: Float): Float\n\u001b[31m   |\u001b[0m (x: Long, y: Long): Long\n\u001b[31m   |\u001b[0m (x: Int, y: Int): Int\n\u001b[31m   |\u001b[0mmatch arguments ((current : Long), Long, Long)\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = 1L\n        var min = 1L\n        var result = 0L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                max *= arr(i)\n                min = min * arr(i) min 1\n            } else if (arr(i) == 0) {\n                max = 1\n                min = 1\n            } else {\n                val temp = max\n                max = min * arr(i) max 1\n                min = temp * arr(i)\n            }\n            if (max > result) result = max\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123204,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = 0L\n        var min = 0L\n        var result = 0L\n        for (i <- 0 until arr.length) {\n            val cur = arr(i)\n            if (cur > 0) {\n                max = max * cur\n                min = min * cur\n            } else if (cur < 0) {\n                val temp = max\n                max = min * cur\n                min = temp * cur\n            } else {\n                max = 0\n                min = 0\n            }\n            if (max == 0) max = cur\n            if (min == 0) min = cur\n            result = max(result, max)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123198,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp3k51p8gx.scala:24:21 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            result = max(result, max)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var result = Long.MinValue\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1L)\n            } else if (arr(i) == 0) {\n                maxProduct = 1L\n                minProduct = 1L\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1L)\n                minProduct = temp * arr(i)\n            }\n            if (maxProduct > result) result = maxProduct\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123204,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = Long.MinValue\n        var product = 1L\n        for (i <- 0 until arr.length) {\n            product *= arr(i)\n            maxProduct = max(maxProduct, product)\n            if (product == 0) product = 1\n        }\n        product = 1\n        for (i <- arr.length - 1 to 0 by -1) {\n            product *= arr(i)\n            maxProduct = max(maxProduct, product)\n            if (product == 0) product = 1\n        }\n        maxProduct\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123204,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 until arr.length) {\n            if (arr(i) > 0) {\n                max = max * arr(i)\n                min = min * arr(i)\n            } else {\n                val temp = max\n                max = min * arr(i)\n                min = temp * arr(i)\n            }\n            if (max > result) result = max\n            if (min > result) result = min\n            if (max < 1) max = 1\n            if (min > -1) min = -1\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123204,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = arr(0)\n        var currentProduct = arr(0)\n        var currentMinProduct = arr(0)\n        var currentMaxProduct = arr(0)\n        for (i <- 1 until arr.length) {\n            val nextMinProduct = min(currentMinProduct * arr(i), currentMaxProduct * arr(i), arr(i))\n            val nextMaxProduct = max(currentMinProduct * arr(i), currentMaxProduct * arr(i), arr(i))\n            currentMinProduct = nextMinProduct\n            currentMaxProduct = nextMaxProduct\n            maxProduct = max(maxProduct, currentMaxProduct)\n        }\n        maxProduct\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123199,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpxfb0ufx5.scala:11:33 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnextMinProduct\u001b[0m = min(currentMinProduct * arr(i), currentMaxProduct * arr(i), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35mmin\u001b[0m in \u001b[33mpackage\u001b[0m \u001b[35mscala.math\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double, y: Double): Double\n\u001b[31m   |\u001b[0m (x: Float, y: Float): Float\n\u001b[31m   |\u001b[0m (x: Long, y: Long): Long\n\u001b[31m   |\u001b[0m (x: Int, y: Int): Int\n\u001b[31m   |\u001b[0mmatch arguments (Long, Long, Long)\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpxfb0ufx5.scala:12:33 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnextMaxProduct\u001b[0m = max(currentMinProduct * arr(i), currentMaxProduct * arr(i), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35mmax\u001b[0m in \u001b[33mpackage\u001b[0m \u001b[35mscala.math\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double, y: Double): Double\n\u001b[31m   |\u001b[0m (x: Float, y: Float): Float\n\u001b[31m   |\u001b[0m (x: Long, y: Long): Long\n\u001b[31m   |\u001b[0m (x: Int, y: Int): Int\n\u001b[31m   |\u001b[0mmatch arguments (Long, Long, Long)\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1)\n            } else if (arr(i) == 0) {\n                maxProduct = 1\n                minProduct = 1\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var result = 0L\n        for (x <- arr) {\n            val a = maxProduct * x\n            val b = minProduct * x\n            maxProduct = max(max(a, b), x)\n            minProduct = min(min(a, b), x)\n            result = max(maxProduct, result)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123203,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1)\n            }\n            else if (arr(i) == 0) {\n                maxProduct = 1\n                minProduct = 1\n            }\n            else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = arr(0)\n        var maxEndingHere = arr(0)\n        var minEndingHere = arr(0)\n        for (i <- 1 to arr.length - 1) {\n            val maxEndingHerePrev = maxEndingHere\n            maxEndingHere = max(arr(i), max(maxEndingHere * arr(i), minEndingHere * arr(i)))\n            minEndingHere = min(arr(i), min(maxEndingHerePrev * arr(i), minEndingHere * arr(i)))\n            maxProduct = max(maxProduct, maxEndingHere)\n        }\n        maxProduct\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123204,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 until arr.length) {\n            if (arr(i) > 0) {\n                max = max * arr(i)\n                min = min * arr(i)\n            } else {\n                val temp = max\n                max = min * arr(i)\n                min = temp * arr(i)\n            }\n            if (max > result) result = max\n            if (min > result) result = min\n            if (max < 1) max = 1\n            if (min > -1) min = -1\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123204,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = 0L\n        var min = 0L\n        var result = 0L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                max = max * arr(i)\n                min = min * arr(i)\n            } else if (arr(i) == 0) {\n                max = 0\n                min = 0\n            } else {\n                val temp = max\n                max = min * arr(i)\n                min = temp * arr(i)\n            }\n            if (max == 0) max = arr(i)\n            if (min == 0) min = arr(i)\n            if (max > result) result = max\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123204,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 until arr.length) {\n            val a = max * arr(i)\n            val b = min * arr(i)\n            max = max(max(a, b), arr(i))\n            min = min(min(a, b), arr(i))\n            if (max > result) result = max\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123198,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpr26dakcu.scala:12:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            max = max(max(a, b), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpr26dakcu.scala:12:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            max = max(max(a, b), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpr26dakcu.scala:13:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            min = min(min(a, b), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpr26dakcu.scala:13:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            min = min(min(a, b), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = arr(0)\n        var currentProduct = arr(0)\n        for (i <- 1 until arr.length) {\n            currentProduct = max(currentProduct * arr(i), arr(i))\n            maxProduct = max(maxProduct, currentProduct)\n        }\n        maxProduct\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpqhwhih_b.scala:15)\n\tat Problem.main(tmpqhwhih_b.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1)\n            } else if (arr(i) == 0) {\n                maxProduct = 1\n                minProduct = 1\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (x <- arr) {\n            if (x > 0) {\n                maxProduct *= x\n                minProduct = min(minProduct * x, 1L)\n            } else if (x == 0) {\n                maxProduct = 1L\n                minProduct = 1L\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * x, 1L)\n                minProduct = temp * x\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123204,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (x <- arr) {\n            val maxProductPrev = maxProduct\n            maxProduct = max(max(maxProduct * x, minProduct * x), x)\n            minProduct = min(min(maxProductPrev * x, minProduct * x), x)\n            maxSoFar = max(maxSoFar, maxProduct)\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123203,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1)\n            } else if (arr(i) == 0) {\n                maxProduct = 1\n                minProduct = 1\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = arr(0)\n        var minProduct = arr(0)\n        var maxSoFar = arr(0)\n        for (i <- 1 until arr.length) {\n            val temp = maxProduct\n            maxProduct = max(max(maxProduct * arr(i), minProduct * arr(i)), arr(i))\n            minProduct = min(min(temp * arr(i), minProduct * arr(i)), arr(i))\n            maxSoFar = max(maxSoFar, maxProduct)\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123204,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1)\n            } else if (arr(i) == 0) {\n                maxProduct = 1\n                minProduct = 1\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        val n = arr.length\n        val dp = Array.fill(n)(0L)\n        var max = 0L\n        for (i <- 0 until n) {\n            if (i == 0) dp(i) = arr(i)\n            else {\n                dp(i) = max(dp(i - 1) * arr(i), arr(i))\n            }\n            max = max(max, dp(i))\n        }\n        max\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123198,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpvavo133q.scala:12:24 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m                dp(i) = max(dp(i - \u001b[31m1\u001b[0m) * arr(i), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpvavo133q.scala:14:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            max = max(max, dp(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 until arr.length) {\n            val a = arr(i) * max\n            val b = arr(i) * min\n            max = max(a, b, arr(i))\n            min = min(a, b, arr(i))\n            result = max(result, max)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123199,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp2osad6ft.scala:12:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            max = max(a, b, arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp2osad6ft.scala:13:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            min = min(a, b, arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp2osad6ft.scala:14:21 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            result = max(result, max)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = arr(0)\n        var currentProduct = arr(0)\n        for (i <- 1 until arr.length) {\n            currentProduct = max(arr(i), currentProduct * arr(i))\n            maxProduct = max(maxProduct, currentProduct)\n        }\n        maxProduct\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123216,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpj9fn7pjq.scala:15)\n\tat Problem.main(tmpj9fn7pjq.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = 1L\n        var min = 1L\n        var result = 0L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                max *= arr(i)\n                min = min * arr(i) min 1\n            } else if (arr(i) == 0) {\n                max = 1\n                min = 1\n            } else {\n                val temp = max\n                max = min * arr(i) max 1\n                min = temp * arr(i)\n            }\n            if (max > result) result = max\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123204,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (x <- arr) {\n            val temp = maxProduct\n            maxProduct = max(max(x, maxProduct * x), minProduct * x)\n            minProduct = min(min(x, temp * x), minProduct * x)\n            maxSoFar = max(maxSoFar, maxProduct)\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123217,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = Long.MinValue\n        var curr = 1L\n        for (i <- 0 until arr.length) {\n            curr *= arr(i)\n            max = max.max(curr)\n            if (curr == 0) curr = 1\n        }\n        curr = 1\n        for (i <- arr.length - 1 to 0 by -1) {\n            curr *= arr(i)\n            max = max.max(curr)\n            if (curr == 0) curr = 1\n        }\n        max\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123218,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct = maxProduct * arr(i)\n                minProduct = min(minProduct * arr(i), 1)\n            } else if (arr(i) == 0) {\n                maxProduct = 1\n                minProduct = 1\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123218,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = arr(0)\n        var currentMaxProduct = arr(0)\n        var currentMinProduct = arr(0)\n        for (i <- 1 until arr.length) {\n            val current = arr(i)\n            val newMaxProduct = max(current, current * currentMaxProduct, current * currentMinProduct)\n            val newMinProduct = min(current, current * currentMaxProduct, current * currentMinProduct)\n            maxProduct = max(maxProduct, newMaxProduct)\n            currentMaxProduct = newMaxProduct\n            currentMinProduct = newMinProduct\n        }\n        maxProduct\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123211,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpinm5f9ff.scala:11:32 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnewMaxProduct\u001b[0m = max(current, current * currentMaxProduct, current * currentMinProduct)\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35mmax\u001b[0m in \u001b[33mpackage\u001b[0m \u001b[35mscala.math\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double, y: Double): Double\n\u001b[31m   |\u001b[0m (x: Float, y: Float): Float\n\u001b[31m   |\u001b[0m (x: Long, y: Long): Long\n\u001b[31m   |\u001b[0m (x: Int, y: Int): Int\n\u001b[31m   |\u001b[0mmatch arguments ((current : Long), Long, Long)\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpinm5f9ff.scala:12:32 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnewMinProduct\u001b[0m = min(current, current * currentMaxProduct, current * currentMinProduct)\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35mmin\u001b[0m in \u001b[33mpackage\u001b[0m \u001b[35mscala.math\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double, y: Double): Double\n\u001b[31m   |\u001b[0m (x: Float, y: Float): Float\n\u001b[31m   |\u001b[0m (x: Long, y: Long): Long\n\u001b[31m   |\u001b[0m (x: Int, y: Int): Int\n\u001b[31m   |\u001b[0mmatch arguments ((current : Long), Long, Long)\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = arr(0)\n        var minProduct = arr(0)\n        var maxSoFar = arr(0)\n        for (i <- 1 until arr.length) {\n            val maxProductTemp = max(max(maxProduct * arr(i), minProduct * arr(i)), arr(i))\n            val minProductTemp = min(min(maxProduct * arr(i), minProduct * arr(i)), arr(i))\n            maxProduct = maxProductTemp\n            minProduct = minProductTemp\n            maxSoFar = max(maxSoFar, maxProduct)\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123218,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 until arr.length) {\n            val temp = max\n            max = max(max * arr(i), min * arr(i), arr(i))\n            min = min(temp * arr(i), min * arr(i), arr(i))\n            result = result max max\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517472,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp3onvsfn9.scala:11:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            max = max(max * arr(i), min * arr(i), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp3onvsfn9.scala:12:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            min = min(temp * arr(i), min * arr(i), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1)\n            } else if (arr(i) == 0) {\n                maxProduct = 1\n                minProduct = 1\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 until arr.length) {\n            if (arr(i) > 0) {\n                max = max * arr(i)\n                min = min * arr(i)\n            } else {\n                val temp = max\n                max = min * arr(i)\n                min = temp * arr(i)\n            }\n            max = max max arr(i)\n            min = min min arr(i)\n            result = result max max\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123204,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (x <- arr) {\n            val temp = maxProduct\n            maxProduct = max(max(maxProduct * x, minProduct * x), x)\n            minProduct = min(min(temp * x, minProduct * x), x)\n            maxSoFar = max(maxSoFar, maxProduct)\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123217,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (x <- arr) {\n            val maxProductTemp = max(x, max(x * maxProduct, x * minProduct))\n            val minProductTemp = min(x, min(x * maxProduct, x * minProduct))\n            maxProduct = maxProductTemp\n            minProduct = minProductTemp\n            maxSoFar = max(maxSoFar, maxProduct)\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123222,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 until arr.length) {\n            val a = max * arr(i)\n            val b = min * arr(i)\n            max = max(max(a, b), arr(i))\n            min = min(min(a, b), arr(i))\n            result = max(result, max)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517472,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpfzpbae65.scala:12:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            max = max(max(a, b), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpfzpbae65.scala:12:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            max = max(max(a, b), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpfzpbae65.scala:13:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            min = min(min(a, b), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpfzpbae65.scala:13:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            min = min(min(a, b), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpfzpbae65.scala:14:21 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            result = max(result, max)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 0L\n        var product = 1L\n        for (i <- 0 until arr.length) {\n            product *= arr(i)\n            maxProduct = max(maxProduct, product)\n            if (product == 0) product = 1\n        }\n        maxProduct\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123222,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        val n = arr.length\n        val dp = Array.fill(n)(0L)\n        dp(0) = arr(0)\n        var max = dp(0)\n        for (i <- 1 until n) {\n            dp(i) = max(dp(i - 1) * arr(i), arr(i))\n            max = max(max, dp(i))\n        }\n        max\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123216,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpyznvx3uf.scala:11:20 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            dp(i) = max(dp(i - \u001b[31m1\u001b[0m) * arr(i), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpyznvx3uf.scala:12:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            max = max(max, dp(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 to arr.length - 1) {\n            val a = max * arr(i)\n            val b = min * arr(i)\n            max = max(max(a, b), arr(i))\n            min = min(min(a, b), arr(i))\n            result = max(result, max)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123217,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp6ta0ybe2.scala:12:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            max = max(max(a, b), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp6ta0ybe2.scala:12:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            max = max(max(a, b), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp6ta0ybe2.scala:13:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            min = min(min(a, b), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp6ta0ybe2.scala:13:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            min = min(min(a, b), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp6ta0ybe2.scala:14:21 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            result = max(result, max)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxEndingHere = 1L\n        var minEndingHere = 1L\n        var maxSoFar = 1L\n        for (x <- arr) {\n            val temp = maxEndingHere\n            maxEndingHere = max(x, max(x * maxEndingHere, x * minEndingHere))\n            minEndingHere = min(x, min(x * temp, x * minEndingHere))\n            maxSoFar = max(maxSoFar, maxEndingHere)\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123222,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 to arr.length - 1) {\n            if (arr(i) > 0) {\n                max = max * arr(i)\n                min = min * arr(i)\n            } else {\n                val temp = max\n                max = min * arr(i)\n                min = temp * arr(i)\n            }\n            if (max > result) result = max\n            if (min > result) result = min\n            if (max < 1) max = 1\n            if (min > -1) min = -1\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123222,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = 0L\n        var min = 0L\n        var result = 0L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                max = max * arr(i)\n                min = min * arr(i)\n            } else if (arr(i) == 0) {\n                max = 0\n                min = 0\n            } else {\n                val temp = max\n                max = min * arr(i)\n                min = temp * arr(i)\n            }\n            if (max == 0) max = arr(i)\n            if (min == 0) min = arr(i)\n            if (max > result) result = max\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123204,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = 0L\n        var min = 0L\n        var result = 0L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                max = max * arr(i)\n                min = min * arr(i)\n            } else if (arr(i) == 0) {\n                max = 0\n                min = 0\n            } else {\n                val temp = max\n                max = min * arr(i)\n                min = temp * arr(i)\n            }\n            if (max == 0) max = arr(i)\n            if (min == 0) min = arr(i)\n            if (max > result) result = max\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123204,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = arr(0)\n        var product = 1\n        var i = 0\n        while (i < arr.length) {\n            product *= arr(i)\n            maxProduct = max(maxProduct, product)\n            if (product == 0) product = 1\n            i += 1\n        }\n        product = 1\n        i = arr.length - 1\n        while (i >= 0) {\n            product *= arr(i)\n            maxProduct = max(maxProduct, product)\n            if (product == 0) product = 1\n            i -= 1\n        }\n        maxProduct\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123221,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmplwdz5xad.scala:10:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m            product *= arr(i)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value *= is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmplwdz5xad.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            product *= arr(i)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value *= is not a member of Int - did you mean Int.!=?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = Long.MinValue\n        var product = 1\n        var start = 0\n        var end = 0\n        while (end < arr.length) {\n            product *= arr(end)\n            maxProduct = max(maxProduct, product)\n            if (product == 0) {\n                product = 1\n                start = end + 1\n            }\n            end += 1\n        }\n        product = 1\n        end -= 1\n        while (start < end) {\n            product *= arr(end)\n            maxProduct = max(maxProduct, product)\n            if (product == 0) {\n                product = 1\n                start += 1\n            }\n            end -= 1\n        }\n        maxProduct\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123223,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzu9u09m1.scala:11:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            product *= arr(end)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value *= is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzu9u09m1.scala:22:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            product *= arr(end)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value *= is not a member of Int - did you mean Int.!=?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1)\n            } else if (arr(i) == 0) {\n                maxProduct = 1\n                minProduct = 1\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1L)\n            } else if (arr(i) == 0) {\n                maxProduct = 1L\n                minProduct = 1L\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1L)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = arr(0)\n        var currentProduct = arr(0)\n        for (i <- 1 until arr.length) {\n            currentProduct = max(currentProduct * arr(i), arr(i))\n            maxProduct = max(maxProduct, currentProduct)\n        }\n        maxProduct\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpqhwhih_b.scala:15)\n\tat Problem.main(tmpqhwhih_b.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 until arr.length) {\n            if (arr(i) > 0) {\n                max = max * arr(i)\n                min = min * arr(i)\n            } else {\n                val temp = max\n                max = min * arr(i)\n                min = temp * arr(i)\n            }\n            if (max > result) result = max\n            if (min > result) result = min\n            if (max < 1) max = 1\n            if (min > -1) min = -1\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123204,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (x <- arr) {\n            val maxProductPrev = maxProduct\n            maxProduct = max(x, max(x * maxProduct, x * minProduct))\n            minProduct = min(x, min(x * maxProductPrev, x * minProduct))\n            maxSoFar = max(maxSoFar, maxProduct)\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123223,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = Long.MinValue\n        var min = Long.MaxValue\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxSoFar *= arr(i)\n                max = maxSoFar max max\n            } else if (arr(i) == 0) {\n                maxSoFar = 1L\n                max = maxSoFar max max\n            } else {\n                val temp = maxSoFar\n                maxSoFar = min * arr(i)\n                min = temp * arr(i)\n                max = maxSoFar max max\n            }\n        }\n        max\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123223,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp58uw_fpn.scala:28)\n\tat Problem.main(tmp58uw_fpn.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 until arr.length) {\n            val a = arr(i)\n            val b = max * a\n            val c = min * a\n            max = max(max(a, b), c)\n            min = min(min(a, b), c)\n            result = max(result, max)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123218,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp921tse3s.scala:13:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            max = max(max(a, b), c)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp921tse3s.scala:13:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            max = max(max(a, b), c)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp921tse3s.scala:14:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            min = min(min(a, b), c)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp921tse3s.scala:14:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            min = min(min(a, b), c)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp921tse3s.scala:15:21 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            result = max(result, max)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (x <- arr) {\n            val tempMax = max(x, max(x * maxProduct, x * minProduct))\n            val tempMin = min(x, min(x * maxProduct, x * minProduct))\n            maxProduct = tempMax\n            minProduct = tempMin\n            maxSoFar = max(maxSoFar, maxProduct)\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123223,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1)\n            }\n            else if (arr(i) == 0) {\n                maxProduct = 1\n                minProduct = 1\n            }\n            else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = arr(0)\n        var currentProduct = arr(0)\n        for (i <- 1 until arr.length) {\n            currentProduct = max(arr(i), currentProduct * arr(i))\n            maxProduct = max(maxProduct, currentProduct)\n        }\n        maxProduct\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123216,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpj9fn7pjq.scala:15)\n\tat Problem.main(tmpj9fn7pjq.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = 0L\n        var min = 0L\n        var result = 0L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                max = max * arr(i)\n                min = min * arr(i)\n            }\n            else if (arr(i) == 0) {\n                max = 0\n                min = 0\n            }\n            else {\n                val temp = max\n                max = min * arr(i)\n                min = temp * arr(i)\n            }\n            if (max == 0) max = arr(i)\n            if (min == 0) min = arr(i)\n            if (max > result) result = max\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123224,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var maxEndingHere = arr(0)\n        var minEndingHere = arr(0)\n        for (i <- 1 until arr.length) {\n            val maxEndingHereOld = maxEndingHere\n            maxEndingHere = max(max(maxEndingHere * arr(i), minEndingHere * arr(i)), arr(i))\n            minEndingHere = min(min(maxEndingHereOld * arr(i), minEndingHere * arr(i)), arr(i))\n            max = max(max, maxEndingHere)\n        }\n        max\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123218,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpyykdtbq8.scala:11:28 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            maxEndingHere = max(max(maxEndingHere * arr(i), minEndingHere * arr(i)), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpyykdtbq8.scala:11:32 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            maxEndingHere = max(max(maxEndingHere * arr(i), minEndingHere * arr(i)), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpyykdtbq8.scala:13:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            max = max(max, maxEndingHere)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = arr.head\n        var minProduct = arr.head\n        var maxSoFar = arr.head\n        for (i <- 1 until arr.length) {\n            val cur = arr(i)\n            val maxProductNew = max(cur, max(cur * maxProduct, cur * minProduct))\n            val minProductNew = min(cur, min(cur * maxProduct, cur * minProduct))\n            maxSoFar = max(maxSoFar, maxProductNew)\n            maxProduct = maxProductNew\n            minProduct = minProductNew\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123223,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct = maxProduct * arr(i)\n                minProduct = min(minProduct * arr(i), 1)\n            }\n            else if (arr(i) == 0) {\n                maxProduct = 1\n                minProduct = 1\n            }\n            else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = arr(0)\n        var currentProduct = arr(0)\n        for (i <- 1 until arr.length) {\n            currentProduct = max(currentProduct * arr(i), arr(i))\n            maxProduct = max(maxProduct, currentProduct)\n        }\n        maxProduct\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpqhwhih_b.scala:15)\n\tat Problem.main(tmpqhwhih_b.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 0L\n        var maxEndingHere = 1L\n        var minEndingHere = 1L\n        for (x <- arr) {\n            if (x > 0) {\n                maxEndingHere *= x\n                minEndingHere = min(minEndingHere * x, 1L)\n            } else if (x == 0) {\n                maxEndingHere = 1L\n                minEndingHere = 1L\n            } else {\n                val temp = maxEndingHere\n                maxEndingHere = max(minEndingHere * x, 1L)\n                minEndingHere = temp * x\n            }\n            if (maxEndingHere > maxProduct) maxProduct = maxEndingHere\n        }\n        maxProduct\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123226,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = arr(0)\n        var maxProductEndingHere = arr(0)\n        var minProductEndingHere = arr(0)\n        for (i <- 1 to arr.length - 1) {\n            val maxProductEndingHereOld = maxProductEndingHere\n            maxProductEndingHere = max(max(maxProductEndingHere * arr(i), minProductEndingHere * arr(i)), arr(i))\n            minProductEndingHere = min(min(maxProductEndingHereOld * arr(i), minProductEndingHere * arr(i)), arr(i))\n            maxProduct = max(maxProduct, maxProductEndingHere)\n        }\n        maxProduct\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123232,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = Long.MinValue\n        var min = Long.MaxValue\n        var result = 1L\n        for (x <- arr) {\n            val a = max\n            val b = min\n            max = max(x, max(x * a, x * b))\n            min = min(x, min(x * a, x * b))\n            result = max(result, max)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123228,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpuc0kggwv.scala:12:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            max = max(x, max(x * a, x * b))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpuc0kggwv.scala:12:25 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            max = max(x, max(x * a, x * b))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpuc0kggwv.scala:13:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            min = min(x, min(x * a, x * b))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpuc0kggwv.scala:13:25 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            min = min(x, min(x * a, x * b))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpuc0kggwv.scala:14:21 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            result = max(result, max)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (x <- arr) {\n            val maxProductTemp = max(max(maxProduct * x, minProduct * x), x)\n            val minProductTemp = min(min(maxProduct * x, minProduct * x), x)\n            maxProduct = maxProductTemp\n            minProduct = minProductTemp\n            maxSoFar = max(maxSoFar, maxProduct)\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123236,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var result = Long.MinValue\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1L)\n            } else if (arr(i) == 0) {\n                maxProduct = 1L\n                minProduct = 1L\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1L)\n                minProduct = temp * arr(i)\n            }\n            if (maxProduct > result) result = maxProduct\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123204,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 until arr.length) {\n            val a = max * arr(i)\n            val b = min * arr(i)\n            max = max(a, b, arr(i))\n            min = min(a, b, arr(i))\n            result = max(result, max)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123229,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp5qi7gd7m.scala:12:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            max = max(a, b, arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp5qi7gd7m.scala:13:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            min = min(a, b, arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp5qi7gd7m.scala:14:21 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            result = max(result, max)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = arr(0)\n        var minProduct = arr(0)\n        var maxSoFar = arr(0)\n        for (i <- 1 until arr.length) {\n            val maxProductCopy = maxProduct\n            maxProduct = max(max(maxProduct * arr(i), minProduct * arr(i)), arr(i))\n            minProduct = min(min(maxProductCopy * arr(i), minProduct * arr(i)), arr(i))\n            maxSoFar = max(maxSoFar, maxProduct)\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123237,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (x <- arr) {\n            val maxProductCopy = maxProduct\n            maxProduct = max(max(maxProduct * x, minProduct * x), x)\n            minProduct = min(min(maxProductCopy * x, minProduct * x), x)\n            maxSoFar = max(maxSoFar, maxProduct)\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123236,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = arr(0)\n        var minProduct = arr(0)\n        var maxSoFar = arr(0)\n        for (i <- 1 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct = max(maxProduct * arr(i), arr(i))\n                minProduct = min(minProduct * arr(i), arr(i))\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), arr(i))\n                minProduct = min(temp * arr(i), arr(i))\n            }\n            maxSoFar = max(maxSoFar, maxProduct)\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123237,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (x <- arr) {\n            val maxProductPrev = maxProduct\n            maxProduct = max(x, max(x * maxProduct, x * minProduct))\n            minProduct = min(x, min(x * maxProductPrev, x * minProduct))\n            maxSoFar = max(maxSoFar, maxProduct)\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123223,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = arr(0)\n        var minProduct = arr(0)\n        var maxSoFar = arr(0)\n        for (i <- 1 until arr.length) {\n            val maxProductPrev = maxProduct\n            maxProduct = max(max(maxProduct * arr(i), minProduct * arr(i)), arr(i))\n            minProduct = min(min(maxProductPrev * arr(i), minProduct * arr(i)), arr(i))\n            maxSoFar = max(maxSoFar, maxProduct)\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123238,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 until arr.length) {\n            val temp = max\n            max = max(max * arr(i), min * arr(i), arr(i))\n            min = min(temp * arr(i), min * arr(i), arr(i))\n            result = max(max, result)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123230,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpgi592og9.scala:11:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            max = max(max * arr(i), min * arr(i), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpgi592og9.scala:12:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            min = min(temp * arr(i), min * arr(i), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpgi592og9.scala:13:21 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            result = max(max, result)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 until arr.length) {\n            if (arr(i) > 0) {\n                max = max * arr(i)\n                min = min * arr(i)\n            } else {\n                val temp = max\n                max = min * arr(i)\n                min = temp * arr(i)\n            }\n            if (max > result) result = max\n            if (min > result) result = min\n            if (max < min) {\n                val temp = max\n                max = min\n                min = temp\n            }\n            if (max < 1) max = 1\n            if (min > -1) min = -1\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123237,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 until arr.length) {\n            val temp = max\n            max = max(max * arr(i), min * arr(i), arr(i))\n            min = min(temp * arr(i), min * arr(i), arr(i))\n            result = max(result, max)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517473,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpjns7hab7.scala:11:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            max = max(max * arr(i), min * arr(i), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpjns7hab7.scala:12:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            min = min(temp * arr(i), min * arr(i), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpjns7hab7.scala:13:21 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            result = max(result, max)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (x <- arr) {\n            val tempMax = max(x, max(x * maxProduct, x * minProduct))\n            val tempMin = min(x, min(x * maxProduct, x * minProduct))\n            maxSoFar = max(maxSoFar, tempMax)\n            maxProduct = tempMax\n            minProduct = tempMin\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1)\n            } else if (arr(i) == 0) {\n                maxProduct = 1\n                minProduct = 1\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1)\n            } else if (arr(i) == 0) {\n                maxProduct = 1\n                minProduct = 1\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = Long.MinValue\n        var product = 1L\n        for (i <- 0 until arr.length) {\n            product *= arr(i)\n            max = max max product\n            if (product == 0) product = 1\n        }\n        product = 1\n        for (i <- arr.length - 1 to 0 by -1) {\n            product *= arr(i)\n            max = max max product\n            if (product == 0) product = 1\n        }\n        max\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123238,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct = maxProduct * arr(i)\n                minProduct = min(minProduct * arr(i), 1)\n            } else if (arr(i) == 0) {\n                maxProduct = 1\n                minProduct = 1\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123218,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1)\n            } else if (arr(i) == 0) {\n                maxProduct = 1\n                minProduct = 1\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (x <- arr) {\n            val maxProductTemp = max(x, max(x * maxProduct, x * minProduct))\n            val minProductTemp = min(x, min(x * maxProduct, x * minProduct))\n            maxSoFar = max(maxSoFar, maxProductTemp)\n            maxProduct = maxProductTemp\n            minProduct = minProductTemp\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123241,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 until arr.length) {\n            val temp = max\n            max = max(max * arr(i), min * arr(i), arr(i))\n            min = min(temp * arr(i), min * arr(i), arr(i))\n            result = max(result, max)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517473,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpjns7hab7.scala:11:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            max = max(max * arr(i), min * arr(i), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpjns7hab7.scala:12:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            min = min(temp * arr(i), min * arr(i), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpjns7hab7.scala:13:21 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            result = max(result, max)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = arr(0)\n        var minProduct = arr(0)\n        var maxSoFar = arr(0)\n        for (i <- 1 until arr.length) {\n            val a = maxProduct * arr(i)\n            val b = minProduct * arr(i)\n            maxProduct = max(max(a, b), arr(i))\n            minProduct = min(min(a, b), arr(i))\n            maxSoFar = max(maxSoFar, maxProduct)\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123241,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = arr(0)\n        var currentMax = arr(0)\n        var currentMin = arr(0)\n        for (i <- 1 until arr.length) {\n            val temp = currentMax\n            currentMax = max(max(currentMax * arr(i), currentMin * arr(i)), arr(i))\n            currentMin = min(min(temp * arr(i), currentMin * arr(i)), arr(i))\n            maxProduct = max(maxProduct, currentMax)\n        }\n        maxProduct\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123241,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 0L\n        var product = 1L\n        var start = 0\n        var end = 0\n        while (end < arr.length) {\n            product *= arr(end)\n            while (product == 0) {\n                product /= arr(start)\n                start += 1\n            }\n            maxProduct = max(maxProduct, product)\n            end += 1\n        }\n        maxProduct\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123241,
      "stdout": "",
      "stderr": "java.lang.ArithmeticException: / by zero\n\tat Problem$.maxSubarrayProduct(tmpnjklenv0.scala:13)\n\tat Problem$.main(tmpnjklenv0.scala:22)\n\tat Problem.main(tmpnjklenv0.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = Long.MinValue\n        var maxEndingHere = 1\n        var minEndingHere = 1\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxEndingHere *= arr(i)\n                minEndingHere = min(minEndingHere * arr(i), 1)\n            } else if (arr(i) == 0) {\n                maxEndingHere = 1\n                minEndingHere = 1\n            } else {\n                val temp = maxEndingHere\n                maxEndingHere = max(minEndingHere * arr(i), 1)\n                minEndingHere = temp * arr(i)\n            }\n            if (max < maxEndingHere) max = maxEndingHere\n        }\n        max\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123240,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpcsfgeiq9.scala:11:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m                maxEndingHere *= arr(i)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value *= is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcsfgeiq9.scala:12:36 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m                minEndingHere = min(minEndingHere * arr(i), \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Found:    Long\n\u001b[31m   |\u001b[0m                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpcsfgeiq9.scala:18:32 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                maxEndingHere = max(minEndingHere * arr(i), \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcsfgeiq9.scala:19:32 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                minEndingHere = temp * arr(i)\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Found:    Long\n\u001b[31m   |\u001b[0m                                Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr.head\n        var min = arr.head\n        var result = arr.head\n        for (i <- 1 until arr.length) {\n            val a = max * arr(i)\n            val b = min * arr(i)\n            max = max(max(a, b), arr(i))\n            min = min(min(a, b), arr(i))\n            result = max(max, result)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123236,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpsy45mejf.scala:12:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            max = max(max(a, b), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpsy45mejf.scala:12:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            max = max(max(a, b), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpsy45mejf.scala:13:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            min = min(min(a, b), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpsy45mejf.scala:13:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            min = min(min(a, b), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpsy45mejf.scala:14:21 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            result = max(max, result)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (x <- arr) {\n            if (x > 0) {\n                maxProduct *= x\n                minProduct = min(minProduct * x, 1L)\n            } else if (x == 0) {\n                maxProduct = 1L\n                minProduct = 1L\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * x, 1L)\n                minProduct = temp * x\n            }\n            maxSoFar = max(maxSoFar, maxProduct)\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123241,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1)\n            } else if (arr(i) == 0) {\n                maxProduct = 1\n                minProduct = 1\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 until arr.length) {\n            val temp = max\n            max = max(max * arr(i), min * arr(i), arr(i))\n            min = min(temp * arr(i), min * arr(i), arr(i))\n            result = max(max, result)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123230,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpgi592og9.scala:11:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            max = max(max * arr(i), min * arr(i), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpgi592og9.scala:12:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            min = min(temp * arr(i), min * arr(i), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpgi592og9.scala:13:21 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            result = max(max, result)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = Long.MinValue\n        var min = Long.MaxValue\n        var maxSoFar = 1L\n        for (x <- arr) {\n            val temp = max\n            max = max(max * x, min * x, x)\n            min = min(temp * x, min * x, x)\n            maxSoFar = max(maxSoFar, max)\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123236,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp2ws35z7u.scala:11:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            max = max(max * x, min * x, x)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp2ws35z7u.scala:12:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            min = min(temp * x, min * x, x)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp2ws35z7u.scala:13:23 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            maxSoFar = max(maxSoFar, max)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var currentProduct = 1L\n        var start = 0\n        var end = 0\n        var i = 0\n        while (i < arr.length) {\n            if (arr(i) == 0) {\n                maxProduct = max(maxProduct, 0)\n                currentProduct = 1\n                start = i + 1\n                end = i + 1\n            } else {\n                currentProduct *= arr(i)\n                if (currentProduct > 0) {\n                    maxProduct = max(maxProduct, currentProduct)\n                } else {\n                    maxProduct = max(maxProduct, currentProduct / arr(start))\n                    start = i\n                }\n                end = i\n            }\n            i += 1\n        }\n        maxProduct\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123243,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = 0L\n        var min = 0L\n        var result = 0L\n        for (x <- arr) {\n            if (x > 0) {\n                max = max * x\n                min = min * x\n            } else if (x < 0) {\n                val temp = max\n                max = min * x\n                min = temp * x\n            } else {\n                max = 0\n                min = 0\n            }\n            if (max == 0) max = x\n            if (min == 0) min = x\n            if (max < min) {\n                val temp = max\n                max = min\n                min = temp\n            }\n            if (max > result) result = max\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123243,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1)\n            } else if (arr(i) == 0) {\n                maxProduct = 1\n                minProduct = 1\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = arr(0)\n        var currentProduct = arr(0)\n        for (i <- 1 until arr.length) {\n            currentProduct = max(currentProduct * arr(i), arr(i))\n            maxProduct = max(maxProduct, currentProduct)\n        }\n        maxProduct\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpqhwhih_b.scala:15)\n\tat Problem.main(tmpqhwhih_b.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1)\n            } else if (arr(i) == 0) {\n                maxProduct = 1\n                minProduct = 1\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1)\n            } else if (arr(i) == 0) {\n                maxProduct = 1\n                minProduct = 1\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 to arr.length - 1) {\n            val a = max * arr(i)\n            val b = min * arr(i)\n            max = max(max(a, b), arr(i))\n            min = min(min(a, b), arr(i))\n            result = max(result, max)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123217,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp6ta0ybe2.scala:12:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            max = max(max(a, b), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp6ta0ybe2.scala:12:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            max = max(max(a, b), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp6ta0ybe2.scala:13:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            min = min(min(a, b), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp6ta0ybe2.scala:13:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            min = min(min(a, b), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp6ta0ybe2.scala:14:21 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            result = max(result, max)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 to arr.length - 1) {\n            val a = arr(i) * max\n            val b = arr(i) * min\n            max = max(a, b, arr(i))\n            min = min(a, b, arr(i))\n            result = max(result, max)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123237,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpbw7ofe8u.scala:12:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            max = max(a, b, arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpbw7ofe8u.scala:13:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            min = min(a, b, arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpbw7ofe8u.scala:14:21 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            result = max(result, max)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1)\n            } else if (arr(i) == 0) {\n                maxProduct = 1\n                minProduct = 1\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = Long.MinValue\n        var currentMax = 1\n        var currentMin = 1\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                currentMax *= arr(i)\n                currentMin = min(currentMin * arr(i), 1)\n            }\n            else if (arr(i) == 0) {\n                currentMax = 1\n                currentMin = 1\n            }\n            else {\n                val temp = currentMax\n                currentMax = max(currentMin * arr(i), 1)\n                currentMin = temp * arr(i)\n            }\n            max = max(max, currentMax)\n        }\n        max\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123245,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgil2vpzy.scala:11:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m                currentMax *= arr(i)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value *= is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpgil2vpzy.scala:12:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m                currentMin = min(currentMin * arr(i), \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    Long\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpgil2vpzy.scala:20:29 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                currentMax = max(currentMin * arr(i), \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpgil2vpzy.scala:21:29 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                currentMin = temp * arr(i)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Found:    Long\n\u001b[31m   |\u001b[0m                             Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpgil2vpzy.scala:23:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            max = max(max, currentMax)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct = maxProduct * arr(i)\n                minProduct = min(minProduct * arr(i), 1)\n            } else if (arr(i) == 0) {\n                maxProduct = 1\n                minProduct = 1\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123218,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1)\n            } else if (arr(i) == 0) {\n                maxProduct = 1\n                minProduct = 1\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1)\n            } else if (arr(i) == 0) {\n                maxProduct = 1\n                minProduct = 1\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max_so_far = 1\n        var min_so_far = 1\n        var max_ending_here = 1\n        var result = 0\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                max_ending_here = max_ending_here * arr(i)\n                min_so_far = min(min_so_far * arr(i), 1)\n            }\n            else if (arr(i) == 0) {\n                max_ending_here = 1\n                min_so_far = 1\n            }\n            else {\n                val temp = max_ending_here\n                max_ending_here = max(min_so_far * arr(i), 1)\n                min_so_far = temp * arr(i)\n            }\n            if (max_so_far < max_ending_here) max_so_far = max_ending_here\n        }\n        max_so_far\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123248,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv9ffl68o.scala:12:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m                max_ending_here = max_ending_here * arr(i)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    Long\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv9ffl68o.scala:13:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m                min_so_far = min(min_so_far * arr(i), \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    Long\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv9ffl68o.scala:21:38 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                max_ending_here = max(min_so_far * arr(i), \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Found:    Long\n\u001b[31m   |\u001b[0m                                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv9ffl68o.scala:22:29 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                min_so_far = temp * arr(i)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Found:    Long\n\u001b[31m   |\u001b[0m                             Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 until arr.length) {\n            val a = arr(i)\n            val b = max * a\n            val c = min * a\n            max = max(max(a, b), c)\n            min = min(min(a, b), c)\n            result = max(result, max)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123218,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp921tse3s.scala:13:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            max = max(max(a, b), c)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp921tse3s.scala:13:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            max = max(max(a, b), c)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp921tse3s.scala:14:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            min = min(min(a, b), c)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp921tse3s.scala:14:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            min = min(min(a, b), c)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp921tse3s.scala:15:21 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            result = max(result, max)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = arr(0)\n        var minProduct = arr(0)\n        var maxSoFar = arr(0)\n        for (i <- 1 until arr.length) {\n            val temp = maxProduct\n            maxProduct = max(max(maxProduct * arr(i), minProduct * arr(i)), arr(i))\n            minProduct = min(min(temp * arr(i), minProduct * arr(i)), arr(i))\n            maxSoFar = max(maxSoFar, maxProduct)\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123204,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1)\n            }\n            else if (arr(i) == 0) {\n                maxProduct = 1\n                minProduct = 1\n            }\n            else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = arr(0)\n        var currentProduct = arr(0)\n        for (i <- 1 until arr.length) {\n            currentProduct = max(currentProduct * arr(i), arr(i))\n            maxProduct = max(maxProduct, currentProduct)\n        }\n        maxProduct\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpqhwhih_b.scala:15)\n\tat Problem.main(tmpqhwhih_b.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 to arr.length - 1) {\n            val a = max * arr(i)\n            val b = min * arr(i)\n            max = max(max(a, b), arr(i))\n            min = min(min(a, b), arr(i))\n            result = max(result, max)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123217,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp6ta0ybe2.scala:12:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            max = max(max(a, b), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp6ta0ybe2.scala:12:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            max = max(max(a, b), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp6ta0ybe2.scala:13:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            min = min(min(a, b), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp6ta0ybe2.scala:13:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            min = min(min(a, b), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp6ta0ybe2.scala:14:21 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            result = max(result, max)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = arr(0)\n        var maxProductEndingHere = arr(0)\n        var minProductEndingHere = arr(0)\n        for (i <- 1 until arr.length) {\n            if (arr(i) > 0) {\n                maxProductEndingHere = max(maxProductEndingHere * arr(i), arr(i))\n                minProductEndingHere = min(minProductEndingHere * arr(i), arr(i))\n            } else {\n                val temp = maxProductEndingHere\n                maxProductEndingHere = max(minProductEndingHere * arr(i), arr(i))\n                minProductEndingHere = min(temp * arr(i), arr(i))\n            }\n            maxProduct = max(maxProduct, maxProductEndingHere)\n        }\n        maxProduct\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123251,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1)\n            } else if (arr(i) == 0) {\n                maxProduct = 1\n                minProduct = 1\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1)\n            } else if (arr(i) == 0) {\n                maxProduct = 1\n                minProduct = 1\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = arr(0)\n        var maxProductEndingHere = arr(0)\n        var minProductEndingHere = arr(0)\n        for (i <- 1 until arr.length) {\n            val product1 = maxProductEndingHere * arr(i)\n            val product2 = minProductEndingHere * arr(i)\n            maxProductEndingHere = max(max(product1, product2), arr(i))\n            minProductEndingHere = min(min(product1, product2), arr(i))\n            maxProduct = max(maxProduct, maxProductEndingHere)\n        }\n        maxProduct\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123252,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 until arr.length) {\n            val a = max * arr(i)\n            val b = min * arr(i)\n            max = max(a, b, arr(i))\n            min = min(a, b, arr(i))\n            result = max(result, max)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123229,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp5qi7gd7m.scala:12:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            max = max(a, b, arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp5qi7gd7m.scala:13:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            min = min(a, b, arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp5qi7gd7m.scala:14:21 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            result = max(result, max)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (x <- arr) {\n            val temp = maxProduct\n            maxProduct = max(x, max(x * maxProduct, x * minProduct))\n            minProduct = min(x, min(x * temp, x * minProduct))\n            maxSoFar = max(maxSoFar, maxProduct)\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123252,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = arr(0)\n        var currentProduct = arr(0)\n        for (i <- 1 until arr.length) {\n            currentProduct = max(currentProduct * arr(i), arr(i))\n            maxProduct = max(maxProduct, currentProduct)\n        }\n        maxProduct\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpqhwhih_b.scala:15)\n\tat Problem.main(tmpqhwhih_b.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 0L\n        var maxProductEndingHere = 1L\n        var minProductEndingHere = 1L\n        for (x <- arr) {\n            if (x > 0) {\n                maxProductEndingHere *= x\n                minProductEndingHere = min(minProductEndingHere * x, 1L)\n            } else if (x == 0) {\n                maxProductEndingHere = 1L\n                minProductEndingHere = 1L\n            } else {\n                val temp = maxProductEndingHere\n                maxProductEndingHere = max(minProductEndingHere * x, 1L)\n                minProductEndingHere = temp * x\n            }\n            if (maxProduct < maxProductEndingHere) maxProduct = maxProductEndingHere\n        }\n        maxProduct\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123254,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 until arr.length) {\n            val temp = max\n            max = max(max * arr(i), min * arr(i), arr(i))\n            min = min(temp * arr(i), min * arr(i), arr(i))\n            result = max(result, max)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517473,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpjns7hab7.scala:11:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            max = max(max * arr(i), min * arr(i), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpjns7hab7.scala:12:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            min = min(temp * arr(i), min * arr(i), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpjns7hab7.scala:13:21 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            result = max(result, max)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 to arr.length - 1) {\n            val a = max * arr(i)\n            val b = min * arr(i)\n            max = max(a, b, arr(i))\n            min = min(a, b, arr(i))\n            result = max(result, max)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123248,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpz2p95drx.scala:12:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            max = max(a, b, arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpz2p95drx.scala:13:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            min = min(a, b, arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpz2p95drx.scala:14:21 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            result = max(result, max)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = arr(0)\n        var minProduct = arr(0)\n        var maxSoFar = arr(0)\n        for (i <- 1 until arr.length) {\n            val maxProductCopy = maxProduct\n            maxProduct = max(max(maxProduct * arr(i), minProduct * arr(i)), arr(i))\n            minProduct = min(min(maxProductCopy * arr(i), minProduct * arr(i)), arr(i))\n            maxSoFar = max(maxSoFar, maxProduct)\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123237,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 0L\n        var currentProduct = 1L\n        var start = 0\n        var end = 0\n        while (end < arr.length) {\n            currentProduct *= arr(end)\n            if (currentProduct > maxProduct) maxProduct = currentProduct\n            if (currentProduct == 0) {\n                currentProduct = 1\n                start = end + 1\n            }\n            end += 1\n        }\n        maxProduct\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123255,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = arr(0)\n        var minProduct = arr(0)\n        var maxSoFar = arr(0)\n        for (i <- 1 to arr.length - 1) {\n            val maxProductCopy = maxProduct\n            maxProduct = max(max(maxProduct * arr(i), minProduct * arr(i)), arr(i))\n            minProduct = min(min(maxProductCopy * arr(i), minProduct * arr(i)), arr(i))\n            maxSoFar = max(maxSoFar, maxProduct)\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1)\n            } else if (arr(i) == 0) {\n                maxProduct = 1\n                minProduct = 1\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = 0L\n        var min = 0L\n        var result = 0L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                max = max * arr(i)\n                min = min * arr(i)\n            } else if (arr(i) == 0) {\n                max = 0\n                min = 0\n            } else {\n                val temp = max\n                max = min * arr(i)\n                min = temp * arr(i)\n            }\n            if (max == 0) max = arr(i)\n            if (min == 0) min = arr(i)\n            if (max > result) result = max\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123204,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = arr(0)\n        var currentMaxProduct = arr(0)\n        var currentMinProduct = arr(0)\n        for (i <- 1 until arr.length) {\n            val temp = currentMaxProduct\n            currentMaxProduct = max(max(currentMaxProduct * arr(i), currentMinProduct * arr(i)), arr(i))\n            currentMinProduct = min(min(temp * arr(i), currentMinProduct * arr(i)), arr(i))\n            maxProduct = max(maxProduct, currentMaxProduct)\n        }\n        maxProduct\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123255,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxEndingHere = 1\n        var minEndingHere = 1\n        var maxSoFar = 1\n        for (x <- arr) {\n            if (x > 0) {\n                maxEndingHere *= x\n                minEndingHere = min(minEndingHere * x, 1)\n            } else if (x == 0) {\n                maxEndingHere = 1\n                minEndingHere = 1\n            } else {\n                val temp = maxEndingHere\n                maxEndingHere = max(minEndingHere * x, 1)\n                minEndingHere = temp * x\n            }\n            if (maxSoFar < maxEndingHere) maxSoFar = maxEndingHere\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123255,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpav9nqtkg.scala:11:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m                maxEndingHere *= x\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value *= is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpav9nqtkg.scala:12:36 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m                minEndingHere = min(minEndingHere * x, \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Found:    Long\n\u001b[31m   |\u001b[0m                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpav9nqtkg.scala:18:36 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                maxEndingHere = max(minEndingHere * x, \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Found:    Long\n\u001b[31m   |\u001b[0m                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpav9nqtkg.scala:19:32 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                minEndingHere = temp * x\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Found:    Long\n\u001b[31m   |\u001b[0m                                Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 to arr.length - 1) {\n            val a = max * arr(i)\n            val b = min * arr(i)\n            max = max(a, b, arr(i))\n            min = min(a, b, arr(i))\n            result = max(result, max)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123248,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpz2p95drx.scala:12:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            max = max(a, b, arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpz2p95drx.scala:13:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            min = min(a, b, arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpz2p95drx.scala:14:21 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            result = max(result, max)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 until arr.length) {\n            if (arr(i) > 0) {\n                max = max * arr(i)\n                min = min * arr(i)\n            } else {\n                val temp = max\n                max = min * arr(i)\n                min = temp * arr(i)\n            }\n            if (max > result) result = max\n            if (min > result) result = min\n            if (max < 1) max = 1\n            if (min > -1) min = -1\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123204,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1)\n            } else if (arr(i) == 0) {\n                maxProduct = 1\n                minProduct = 1\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (x <- arr) {\n            val tempMax = max(x, max(x * maxProduct, x * minProduct))\n            val tempMin = min(x, min(x * maxProduct, x * minProduct))\n            maxSoFar = max(maxSoFar, tempMax)\n            maxProduct = tempMax\n            minProduct = tempMin\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1L)\n            } else if (arr(i) == 0) {\n                maxProduct = 1L\n                minProduct = 1L\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1L)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var currentProduct = 1L\n        var i = 0\n        while (i < arr.length) {\n            currentProduct *= arr(i)\n            maxProduct = max(maxProduct, currentProduct)\n            if (currentProduct == 0) currentProduct = 1\n            i += 1\n        }\n        maxProduct\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123255,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (x <- arr) {\n            val tempMax = max(x, max(x * maxProduct, x * minProduct))\n            val tempMin = min(x, min(x * maxProduct, x * minProduct))\n            maxSoFar = max(maxSoFar, tempMax)\n            maxProduct = tempMax\n            minProduct = tempMin\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 until arr.length) {\n            val mx = max\n            max = max(max * arr(i), min * arr(i), arr(i))\n            min = min(min * arr(i), mx * arr(i), arr(i))\n            if (max > result) result = max\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123249,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpwc4mow76.scala:11:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            max = max(max * arr(i), min * arr(i), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpwc4mow76.scala:12:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            min = min(min * arr(i), mx * arr(i), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var result = 0L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct = maxProduct * arr(i)\n                minProduct = min(minProduct * arr(i), 1)\n            }\n            else if (arr(i) == 0) {\n                maxProduct = 1\n                minProduct = 1\n            }\n            else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1)\n                minProduct = temp * arr(i)\n            }\n            if (maxProduct > result) result = maxProduct\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123256,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (x <- arr) {\n            val a = maxProduct * x\n            val b = minProduct * x\n            maxProduct = max(max(a, b), x)\n            minProduct = min(min(a, b), x)\n            maxSoFar = max(maxSoFar, maxProduct)\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123256,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1)\n            }\n            else if (arr(i) == 0) {\n                maxProduct = 1\n                minProduct = 1\n            }\n            else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = arr(0)\n        var currentMaxProduct = arr(0)\n        var currentMinProduct = arr(0)\n        for (i <- 1 until arr.length) {\n            val current = arr(i)\n            val newMaxProduct = max(current, max(current * currentMaxProduct, current * currentMinProduct))\n            val newMinProduct = min(current, min(current * currentMaxProduct, current * currentMinProduct))\n            maxProduct = max(maxProduct, newMaxProduct)\n            currentMaxProduct = newMaxProduct\n            currentMinProduct = newMinProduct\n        }\n        maxProduct\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123256,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            val cur = arr(i)\n            if (cur > 0) {\n                maxProduct *= cur\n                minProduct = min(minProduct * cur, 1L)\n            } else if (cur == 0) {\n                maxProduct = 1L\n                minProduct = 1L\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * cur, 1L)\n                minProduct = temp * cur\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1)\n            } else if (arr(i) == 0) {\n                maxProduct = 1\n                minProduct = 1\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1)\n            } else if (arr(i) == 0) {\n                maxProduct = 1\n                minProduct = 1\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 until arr.length) {\n            val a = arr(i) * max\n            val b = arr(i) * min\n            max = max(max(a, b), arr(i))\n            min = min(min(a, b), arr(i))\n            result = max(result, max)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123254,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpnsot4v2_.scala:12:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            max = max(max(a, b), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpnsot4v2_.scala:12:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            max = max(max(a, b), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpnsot4v2_.scala:13:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            min = min(min(a, b), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpnsot4v2_.scala:13:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            min = min(min(a, b), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpnsot4v2_.scala:14:21 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            result = max(result, max)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var res = arr(0)\n        for (i <- 1 until arr.length) {\n            val cur = arr(i)\n            val temp = max\n            max = max(max * cur, min * cur, cur)\n            min = min(temp * cur, min * cur, cur)\n            res = max(res, max)\n        }\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123254,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp7tyb7qxp.scala:12:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            max = max(max * cur, min * cur, cur)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp7tyb7qxp.scala:13:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            min = min(temp * cur, min * cur, cur)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp7tyb7qxp.scala:14:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            res = max(res, max)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 until arr.length) {\n            if (arr(i) > 0) {\n                max = max * arr(i)\n                min = min * arr(i)\n            } else {\n                val temp = max\n                max = min * arr(i)\n                min = temp * arr(i)\n            }\n            max = max max arr(i)\n            min = min min arr(i)\n            result = result max max\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123204,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 until arr.length) {\n            val a = max * arr(i)\n            val b = min * arr(i)\n            max = max(max(a, b), arr(i))\n            min = min(min(a, b), arr(i))\n            if (max > result) result = max\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123198,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpr26dakcu.scala:12:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            max = max(max(a, b), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpr26dakcu.scala:12:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            max = max(max(a, b), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpr26dakcu.scala:13:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            min = min(min(a, b), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpr26dakcu.scala:13:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            min = min(min(a, b), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1L)\n            } else if (arr(i) == 0) {\n                maxProduct = 1L\n                minProduct = 1L\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1L)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (x <- arr) {\n            val tempMax = max(x, max(x * maxProduct, x * minProduct))\n            val tempMin = min(x, min(x * maxProduct, x * minProduct))\n            maxSoFar = max(maxSoFar, tempMax)\n            maxProduct = tempMax\n            minProduct = tempMin\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = 0L\n        var min = 0L\n        var result = 0L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                max = max * arr(i)\n                min = min * arr(i)\n            } else if (arr(i) == 0) {\n                max = 0\n                min = 0\n            } else {\n                val temp = max\n                max = min * arr(i)\n                min = temp * arr(i)\n            }\n            if (max == 0) max = arr(i)\n            if (min == 0) min = arr(i)\n            if (max > result) result = max\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123204,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxEndingHere = 1L\n        var minEndingHere = 1L\n        var maxSoFar = 1L\n        for (x <- arr) {\n            val temp = maxEndingHere\n            maxEndingHere = max(max(maxEndingHere * x, minEndingHere * x), x)\n            minEndingHere = min(min(temp * x, minEndingHere * x), x)\n            maxSoFar = max(maxSoFar, maxEndingHere)\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1L)\n            } else if (arr(i) == 0) {\n                maxProduct = 1L\n                minProduct = 1L\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1L)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 until arr.length) {\n            val temp = max\n            max = max(max * arr(i), min * arr(i), arr(i))\n            min = min(temp * arr(i), min * arr(i), arr(i))\n            result = max(result, max)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517473,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpjns7hab7.scala:11:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            max = max(max * arr(i), min * arr(i), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpjns7hab7.scala:12:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            min = min(temp * arr(i), min * arr(i), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpjns7hab7.scala:13:21 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            result = max(result, max)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1)\n            } else if (arr(i) == 0) {\n                maxProduct = 1\n                minProduct = 1\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 until arr.length) {\n            val a = max * arr(i)\n            val b = min * arr(i)\n            max = max(max(a, b), arr(i))\n            min = min(min(a, b), arr(i))\n            result = max(result, max)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517472,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpfzpbae65.scala:12:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            max = max(max(a, b), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpfzpbae65.scala:12:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            max = max(max(a, b), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpfzpbae65.scala:13:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            min = min(min(a, b), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpfzpbae65.scala:13:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            min = min(min(a, b), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpfzpbae65.scala:14:21 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            result = max(result, max)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1)\n            } else if (arr(i) == 0) {\n                maxProduct = 1\n                minProduct = 1\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        val n = arr.length\n        val dp = Array.fill(n)((0L, 0L))\n        dp(0) = (arr(0), arr(0))\n        for (i <- 1 until n) {\n            val a = dp(i - 1)._1 * arr(i)\n            val b = dp(i - 1)._2 * arr(i)\n            val c = arr(i)\n            dp(i) = (a max b max c, a min b min c)\n        }\n        dp.map(_._1).max\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = 0L\n        var min = 0L\n        var result = 0L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                max = max * arr(i)\n                min = min * arr(i)\n            } else if (arr(i) == 0) {\n                max = 0\n                min = 0\n            } else {\n                val temp = max\n                max = min * arr(i)\n                min = temp * arr(i)\n            }\n            if (max == 0) max = arr(i)\n            if (min == 0) min = arr(i)\n            if (max > result) result = max\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123204,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (x <- arr) {\n            val temp = maxProduct\n            maxProduct = max(max(x * maxProduct, x * minProduct), x)\n            minProduct = min(min(x * temp, x * minProduct), x)\n            maxSoFar = max(maxSoFar, maxProduct)\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1L)\n            } else if (arr(i) == 0) {\n                maxProduct = 1L\n                minProduct = 1L\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1L)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1L)\n            } else if (arr(i) == 0) {\n                maxProduct = 1L\n                minProduct = 1L\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1L)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 until arr.length) {\n            val a = max * arr(i)\n            val b = min * arr(i)\n            max = max(a, b, arr(i))\n            min = min(a, b, arr(i))\n            result = max(result, max)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123229,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp5qi7gd7m.scala:12:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            max = max(a, b, arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp5qi7gd7m.scala:13:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            min = min(a, b, arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp5qi7gd7m.scala:14:21 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            result = max(result, max)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = arr(0)\n        var maxEndingHere = arr(0)\n        var minEndingHere = arr(0)\n        for (i <- 1 until arr.length) {\n            val product1 = maxEndingHere * arr(i)\n            val product2 = minEndingHere * arr(i)\n            maxEndingHere = max(max(product1, product2), arr(i))\n            minEndingHere = min(min(product1, product2), arr(i))\n            maxProduct = max(maxProduct, maxEndingHere)\n        }\n        maxProduct\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = arr(0)\n        var currentMaxProduct = arr(0)\n        var currentMinProduct = arr(0)\n        for (i <- 1 to arr.length - 1) {\n            val current = arr(i)\n            val tempMax = max(current, currentMaxProduct * current, currentMinProduct * current)\n            val tempMin = min(current, currentMaxProduct * current, currentMinProduct * current)\n            maxProduct = max(maxProduct, tempMax)\n            currentMaxProduct = tempMax\n            currentMinProduct = tempMin\n        }\n        return maxProduct\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123256,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmp7zx7e_96.scala:11:26 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mtempMax\u001b[0m = max(current, currentMaxProduct * current, currentMinProduct * current)\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35mmax\u001b[0m in \u001b[33mpackage\u001b[0m \u001b[35mscala.math\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double, y: Double): Double\n\u001b[31m   |\u001b[0m (x: Float, y: Float): Float\n\u001b[31m   |\u001b[0m (x: Long, y: Long): Long\n\u001b[31m   |\u001b[0m (x: Int, y: Int): Int\n\u001b[31m   |\u001b[0mmatch arguments ((current : Long), Long, Long)\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmp7zx7e_96.scala:12:26 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mtempMin\u001b[0m = min(current, currentMaxProduct * current, currentMinProduct * current)\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35mmin\u001b[0m in \u001b[33mpackage\u001b[0m \u001b[35mscala.math\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double, y: Double): Double\n\u001b[31m   |\u001b[0m (x: Float, y: Float): Float\n\u001b[31m   |\u001b[0m (x: Long, y: Long): Long\n\u001b[31m   |\u001b[0m (x: Int, y: Int): Int\n\u001b[31m   |\u001b[0mmatch arguments ((current : Long), Long, Long)\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1)\n            } else if (arr(i) == 0) {\n                maxProduct = 1\n                minProduct = 1\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (x <- arr) {\n            val maxTemp = max(x, max(maxProduct * x, minProduct * x))\n            val minTemp = min(x, min(maxProduct * x, minProduct * x))\n            maxProduct = maxTemp\n            minProduct = minTemp\n            maxSoFar = max(maxSoFar, maxProduct)\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1666123257,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var max = arr(0)\n        var min = arr(0)\n        var result = arr(0)\n        for (i <- 1 until arr.length) {\n            val temp = max\n            max = max(max * arr(i), min * arr(i), arr(i))\n            min = min(temp * arr(i), min * arr(i), arr(i))\n            result = max(result, max)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517473,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpjns7hab7.scala:11:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            max = max(max * arr(i), min * arr(i), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpjns7hab7.scala:12:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            min = min(temp * arr(i), min * arr(i), arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmin\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpjns7hab7.scala:13:21 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            result = max(result, max)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the maximum product sublist of the given list.\n    def maxSubarrayProduct(arr : List[Long]) : Long = {\n        var maxProduct = 1L\n        var minProduct = 1L\n        var maxSoFar = 1L\n        for (i <- 0 until arr.length) {\n            if (arr(i) > 0) {\n                maxProduct *= arr(i)\n                minProduct = min(minProduct * arr(i), 1)\n            } else if (arr(i) == 0) {\n                maxProduct = 1\n                minProduct = 1\n            } else {\n                val temp = maxProduct\n                maxProduct = max(minProduct * arr(i), 1)\n                minProduct = temp * arr(i)\n            }\n            if (maxSoFar < maxProduct) maxSoFar = maxProduct\n        }\n        maxSoFar\n    }\n    def main(args: Array[String]) = {\n    assert(maxSubarrayProduct((List[Long](1l.toLong, -2l.toLong, -3l.toLong, 0l.toLong, 7l.toLong, -8l.toLong, -2l.toLong))) == (112l));\n    assert(maxSubarrayProduct((List[Long](6l.toLong, -3l.toLong, -10l.toLong, 0l.toLong, 2l.toLong))) == (180l));\n    assert(maxSubarrayProduct((List[Long](-2l.toLong, -40l.toLong, 0l.toLong, -2l.toLong, -3l.toLong))) == (80l));\n    }\n\n}\n",
      "timestamp": 1665517475,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    }
  ]
}