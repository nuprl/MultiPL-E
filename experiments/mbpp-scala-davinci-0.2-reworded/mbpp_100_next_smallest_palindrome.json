{
  "name": "mbpp_100_next_smallest_palindrome",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n    def nextSmallestPalindrome(num : Long) : Long = {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_100_next_smallest_palindrome.py",
  "prompt_terminology": "reworded",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(nextSmallestPalindrome((99l)) == (101l));\n    assert(nextSmallestPalindrome((1221l)) == (1331l));\n    assert(nextSmallestPalindrome((120l)) == (121l));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        var n = num\n        var length = n.toString.length\n        var half = length / 2\n        var left = n / pow(10, half).toLong\n        var right = n % pow(10, half).toLong\n        var left_reverse = 0L\n        var right_reverse = 0L\n        for (i <- 0 until half) {\n            left_reverse = left_reverse * 10 + left % 10\n            left /= 10\n            right_reverse = right_reverse * 10 + right % 10\n            right /= 10\n        }\n        if (left == right && left_reverse == right_reverse) {\n            var left_next = left + 1\n            var right_next = 0L\n            for (i <- 0 until half) {\n                right_next = right_next * 10 + left_next % 10\n                left_next /= 10\n            }\n            left_next * pow(10, half).toLong + right_next\n        } else if (left_reverse > right) {\n            left * pow(10, half).toLong + left_reverse\n        } else {\n            var left_next = left + 1\n            var right_next = 0L\n            for (i <- 0 until half) {\n                right_next = right_next * 10 + left_next % 10\n                left_next /= 10\n            }\n            left_next * pow(10, half).toLong + right_next\n        }",
    "        val str = num.toString\n        val len = str.length\n        val half = len / 2\n        val left = str.substring(0, half)\n        val right = str.substring(len - half, len)\n        val leftRev = left.reverse\n        if (leftRev > right) {\n            val leftInt = left.toInt\n            return (leftInt + 1).toString + leftRev.substring(1, half).reverse\n        }\n        else {\n            val leftInt = left.toInt\n            return leftInt.toString + leftRev.substring(1, half).reverse\n        }",
    "        def isPalindrome(num : Long) : Boolean = {\n            val str = num.toString\n            str.reverse == str\n        }\n        def nextPalindrome(num : Long) : Long = {\n            if (isPalindrome(num)) num\n            else nextPalindrome(num + 1)\n        }\n        nextPalindrome(num + 1)",
    "        def isPalindrome(num : Long) : Boolean = {\n            val str = num.toString\n            str == str.reverse\n        }\n        def nextPalindrome(num : Long) : Long = {\n            val str = num.toString\n            val len = str.length\n            val half = len / 2\n            val left = str.substring(0, half)\n            val right = str.substring(half + len % 2, len)\n            val leftRev = left.reverse\n            val leftNum = left.toLong\n            val leftRevNum = leftRev.toLong\n            val rightNum = right.toLong\n            if (leftNum == leftRevNum) {\n                val nextLeft = (leftNum + 1).toString\n                val nextLeftLen = nextLeft.length\n                val nextLeftRev = nextLeft.reverse\n                val nextLeftRevLen = nextLeftRev.length\n                val nextLeftRevStr = if (nextLeftLen > nextLeftRevLen) \"0\" + nextLeftRev else nextLeftRev\n                val nextLeftStr = if (nextLeftLen > nextLeftRevLen) nextLeft + \"0\" else nextLeft\n                val nextLeftNum = nextLeftStr.toLong\n                val nextLeftRevNum = nextLeftRevStr.toLong\n                if (nextLeftNum == nextLeftRevNum) nextLeftNum\n                else nextPalindrome(nextLeftNum)\n            } else {\n                val nextLeft = leftNum.toString\n                val nextLeftRev = leftRevNum.toString\n                val nextLeftLen = nextLeft.length\n                val nextLeftRevLen = nextLeftRev.length\n                val nextLeftRevStr = if (nextLeftLen > nextLeftRevLen) \"0\" + nextLeftRev else nextLeftRev\n                val nextLeftStr = if (nextLeftLen > nextLeftRevLen) nextLeft + \"0\" else nextLeft\n                val nextLeftNum = nextLeftStr.toLong\n                val nextLeftRevNum = nextLeftRevStr.toLong\n                if (nextLeftNum == nextLeftRevNum) nextLeftNum\n                else nextPalindrome(nextLeftNum)\n            }\n        }\n        if (isPalindrome(num)) num\n        else nextPal",
    "        val numString = num.toString\n        val numLength = numString.length\n        val halfLength = numLength / 2\n        val leftHalf = numString.substring(0, halfLength)\n        val rightHalf = numString.substring(numLength - halfLength, numLength)\n        val leftHalfReversed = leftHalf.reverse\n        val leftHalfInt = leftHalf.toInt\n        val leftHalfReversedInt = leftHalfReversed.toInt\n        if (leftHalfInt == leftHalfReversedInt) {\n            val nextLeftHalf = (leftHalfInt + 1).toString\n            val nextLeftHalfLength = nextLeftHalf.length\n            val nextLeftHalfHalfLength = nextLeftHalfLength / 2\n            val nextLeftHalfLeftHalf = nextLeftHalf.substring(0, nextLeftHalfHalfLength)\n            val nextLeftHalfRightHalf = nextLeftHalf.substring(nextLeftHalfLength - nextLeftHalfHalfLength, nextLeftHalfLength)\n            val nextLeftHalfRightHalfReversed = nextLeftHalfRightHalf.reverse\n            val nextLeftHalfLeftHalfInt = nextLeftHalfLeftHalf.toInt\n            val nextLeftHalfRightHalfReversedInt = nextLeftHalfRightHalfReversed.toInt\n            if (nextLeftHalfLeftHalfInt == nextLeftHalfRightHalfReversedInt) {\n                val nextLeftHalfRightHalfReversedIntString = nextLeftHalfRightHalfReversedInt.toString\n                val nextLeftHalfRightHalfReversedIntStringLength = nextLeftHalfRightHalfReversedIntString.length\n                val nextLeftHalfRightHalfReversedIntStringHalfLength = nextLeftHalfRightHalfReversedIntStringLength / 2\n                val nextLeftHalfRightHalfReversedIntStringLeftHalf = nextLeftHalfRightHalfReversedIntString.substring(0, nextLeftHalfRightHalfReversedIntStringHalfLength)\n                val nextLeftHalfRightHalfReversedIntStringRightHalf = nextLeftHalfRightHalfReversedIntString.substring(nextLeftHalfRightHalfReversedIntStringLength - nextLeftHalfRightHalfReversedIntStringHalfLength, nextLeftHalfRightHalfReversedIntStringLength)\n                val nextLeftHalfRightHalf",
    "        val s = num.toString\n        val n = s.length\n        val half = n / 2\n        val left = s.substring(0, half)\n        val right = s.substring(half + n % 2, n)\n        val leftRev = left.reverse\n        val leftInt = left.toInt\n        val leftRevInt = leftRev.toInt\n        if (leftInt < leftRevInt) {\n            val leftInc = (leftInt + 1).toString\n            val leftIncRev = leftInc.reverse\n            val leftIncRevLen = leftIncRev.length\n            val leftIncRevPad = leftIncRev + \"0\" * (half - leftIncRevLen)\n            val leftIncRevInt = leftIncRevPad.toInt\n            val rightInt = right.toInt\n            if (leftIncRevInt > rightInt) {\n                val leftIncRevPadInt = leftIncRevPad.toInt\n                val leftIncRevPadStr = leftIncRevPadInt.toString\n                val leftIncRevPadStrRev = leftIncRevPadStr.reverse\n                val leftIncRevPadStrRevInt = leftIncRevPadStrRev.toInt\n                val leftIncRevPadStrRevIntStr = leftIncRevPadStrRevInt.toString\n                val leftIncRevPadStrRevIntStrPad = leftIncRevPadStrRevIntStr + \"0\" * (n - leftIncRevPadStrRevIntStr.length)\n                leftIncRevPadStrRevIntStrPad.toLong\n            } else {\n                val leftIncRevPadInt = leftIncRevPad.toInt\n                val leftIncRevPadStr = leftIncRevPadInt.toString\n                val leftIncRevPadStrRev = leftIncRevPadStr.reverse\n                val leftIncRevPadStrRevInt = leftIncRevPadStrRev.toInt\n                val leftIncRevPadStrRevIntStr = leftIncRevPadStrRevInt.toString\n                val leftIncRevPadStrRevIntStrPad = leftIncRevPadStrRevIntStr + \"0\" * (n - leftIncRevPadStrRevIntStr.length)\n                leftIncRevPadStrRevIntStrPad.toLong\n            }\n        } else {\n            val leftRevIntStr",
    "        val numStr = num.toString\n        val len = numStr.length\n        val halfLen = len / 2\n        val leftHalf = numStr.substring(0, halfLen)\n        val rightHalf = numStr.substring(halfLen + (len % 2), len)\n        val leftHalfReversed = leftHalf.reverse\n        val leftHalfInt = leftHalf.toInt\n        val leftHalfReversedInt = leftHalfReversed.toInt\n        if (leftHalfInt < leftHalfReversedInt) {\n            val leftHalfPlusOne = (leftHalfInt + 1).toString\n            val leftHalfPlusOneReversed = leftHalfPlusOne.reverse\n            val leftHalfPlusOneLen = leftHalfPlusOne.length\n            val leftHalfPlusOneReversedLen = leftHalfPlusOneReversed.length\n            val leftHalfPlusOneReversedPadded = leftHalfPlusOneReversed + \"0\" * (leftHalfPlusOneLen - leftHalfPlusOneReversedLen)\n            val leftHalfPlusOnePadded = leftHalfPlusOne + \"0\" * (leftHalfPlusOneLen - leftHalfPlusOneReversedLen)\n            val leftHalfPlusOneInt = leftHalfPlusOnePadded.toInt\n            val leftHalfPlusOneReversedInt = leftHalfPlusOneReversedPadded.toInt\n            if (leftHalfPlusOneInt < leftHalfPlusOneReversedInt) leftHalfPlusOnePadded + leftHalfPlusOneReversedPadded\n            else leftHalfPlusOnePadded + leftHalfPlusOnePadded\n        } else leftHalf + leftHalfReversed",
    "        var n = num\n        var i = 0\n        while (i < n.toString.length / 2) {\n            if (n.toString.charAt(i) != n.toString.charAt(n.toString.length - 1 - i)) {\n                n = n + pow(10, i).toLong\n                i = 0\n            } else i += 1\n        }\n        n",
    "        def isPalindrome(num : Long) : Boolean = {\n            val str = num.toString\n            str == str.reverse\n        }\n        def nextPalindrome(num : Long) : Long = {\n            if (isPalindrome(num)) num\n            else nextPalindrome(num + 1)\n        }\n        nextPalindrome(num + 1)",
    "        def isPalindrome(num : Long) : Boolean = {\n            val str = num.toString\n            str == str.reverse\n        }\n        def nextPalindrome(num : Long) : Long = {\n            if (isPalindrome(num)) num\n            else nextPalindrome(num + 1)\n        }\n        nextPalindrome(num + 1)",
    "        var n = num\n        var digits = new ArrayBuffer[Int]\n        while (n > 0) {\n            digits += (n % 10).toInt\n            n /= 10\n        }\n        var i = 0\n        var j = digits.length - 1\n        while (i < j) {\n            if (digits(i) < digits(j)) {\n                digits(j) = digits(i)\n            } else if (digits(i) > digits(j)) {\n                digits(j) = digits(i)\n                var k = j - 1\n                while (k >= 0 && digits(k) == 9) {\n                    digits(k) = 0\n                    k -= 1\n                }\n                if (k < 0) {\n                    digits.insert(0, 1)\n                } else {\n                    digits(k) += 1\n                }\n            }\n            i += 1\n            j -= 1\n        }\n        var result = 0L\n        for (i <- 0 until digits.length) result = result * 10 + digits(i)\n        result",
    "        val s = num.toString\n        val n = s.length\n        val half = n / 2\n        val isOdd = n % 2 == 1\n        val left = s.substring(0, half)\n        val right = s.substring(half + (if (isOdd) 1 else 0))\n        val leftReverse = left.reverse\n        val leftReverseInt = leftReverse.toInt\n        val leftInt = left.toInt\n        val rightInt = right.toInt\n        if (leftInt < leftReverseInt) {\n            val newLeft = (leftInt + 1).toString\n            val newRight = newLeft.reverse\n            val newRightInt = newRight.toInt\n            val newLeftInt = newLeft.toInt\n            if (newLeftInt < newRightInt) {\n                val newLeft = (leftInt + 1).toString\n                val newRight = newLeft.reverse\n                val newRightInt = newRight.toInt\n                val newLeftInt = newLeft.toInt\n                val newLeftPadded = newLeft.padTo(half, '0')\n                val newRightPadded = newRight.padTo(half, '0')\n                val newLeftPaddedInt = newLeftPadded.toInt\n                val newRightPaddedInt = newRightPadded.toInt\n                if (newLeftPaddedInt < newRightPaddedInt) {\n                    val newLeftPadded = newLeft.padTo(half, '0')\n                    val newRightPadded = newRight.padTo(half, '0')\n                    val newLeftPaddedInt = newLeftPadded.toInt\n                    val newRightPaddedInt = newRightPadded.toInt\n                    val newLeftPaddedReverse = newLeftPadded.reverse\n                    val newLeftPaddedReverseInt = newLeftPaddedReverse.toInt\n                    val newLeftPaddedInt = newLeftPadded.toInt\n                    if (newLeftPaddedInt < newLeftPaddedReverseInt) {\n                        val newLeftPadded = newLeft.padTo(half, '0')\n                        val newRightPadded = newRight.padTo(half, '",
    "        def isPalindrome(num : Long) : Boolean = {\n            val str = num.toString\n            str == str.reverse\n        }\n        def nextPalindrome(num : Long) : Long = {\n            if (isPalindrome(num)) num\n            else nextPalindrome(num + 1)\n        }\n        nextPalindrome(num + 1)",
    "        val digits = num.toString.map(_.asDigit)\n        val half = digits.length / 2\n        val left = digits.take(half)\n        val right = digits.drop(half + digits.length % 2).reverse\n        if (left.mkString.toLong < right.mkString.toLong) {\n            val newRight = left.reverse\n            val newDigits = left ++ (if (digits.length % 2 == 1) digits(half) :: newRight else newRight)\n            newDigits.mkString.toLong\n        } else {\n            val newLeft = (left.mkString.toLong + 1).toString.map(_.asDigit)\n            val newRight = newLeft.reverse\n            val newDigits = newLeft ++ (if (digits.length % 2 == 1) digits(half) :: newRight else newRight)\n            newDigits.mkString.toLong\n        }",
    "        def isPalindrome(num : Long) : Boolean = {\n            val str = num.toString\n            str == str.reverse\n        }\n        def nextPalindrome(num : Long) : Long = {\n            if (isPalindrome(num)) num\n            else nextPalindrome(num + 1)\n        }\n        nextPalindrome(num + 1)",
    "        val str = num.toString\n        val len = str.length\n        val half = len / 2\n        val left = str.substring(0, half)\n        val right = str.substring(half + len % 2, len)\n        val leftRev = left.reverse\n        if (leftRev > right) {\n            val newLeft = (left.toLong + 1).toString\n            val newRight = newLeft.reverse\n            val newStr = newLeft + newRight.substring(newRight.length - len % 2, newRight.length)\n            newStr.toLong\n        } else {\n            val newLeft = left + leftRev.substring(leftRev.length - len % 2, leftRev.length)\n            newLeft.toLong\n        }",
    "        val str = num.toString\n        val len = str.length\n        val half = len / 2\n        val left = str.substring(0, half)\n        val right = str.substring(half + len % 2)\n        val leftRev = left.reverse\n        val leftRevInt = leftRev.toInt\n        val leftInt = left.toInt\n        if (leftRevInt > right.toInt) {\n            val leftRevStr = leftRevInt.toString\n            val leftRevStrLen = leftRevStr.length\n            val leftRevStrHalf = leftRevStrLen / 2\n            val leftRevStrLeft = leftRevStr.substring(0, leftRevStrHalf)\n            val leftRevStrRight = leftRevStr.substring(leftRevStrHalf + leftRevStrLen % 2)\n            val leftRevStrLeftInt = leftRevStrLeft.toInt\n            val leftRevStrRightInt = leftRevStrRight.toInt\n            if (leftRevStrLeftInt == leftRevStrRightInt) {\n                val leftStr = leftRevStrLeftInt.toString\n                val leftStrLen = leftStr.length\n                val leftStrHalf = leftStrLen / 2\n                val leftStrLeft = leftStr.substring(0, leftStrHalf)\n                val leftStrRight = leftStr.substring(leftStrHalf + leftStrLen % 2)\n                val leftStrLeftInt = leftStrLeft.toInt\n                val leftStrRightInt = leftStrRight.toInt\n                if (leftStrLeftInt == leftStrRightInt) {\n                    val leftStrLeftIntNext = leftStrLeftInt + 1\n                    val leftStrLeftIntNextStr = leftStrLeftIntNext.toString\n                    val leftStrLeftIntNextStrLen = leftStrLeftIntNextStr.length\n                    val leftStrLeftIntNextStrHalf = leftStrLeftIntNextStrLen / 2\n                    val leftStrLeftIntNextStrLeft = leftStrLeftIntNextStr.substring(0, leftStrLeftIntNextStrHalf)\n                    val leftStrLeftIntNextStrRight = leftStrLeftIntNextStr.substring(leftStrLeftIntNextStrHalf + leftStrLeftIntNextStrLen % 2)\n                    val leftStrLeftIntNextStrLeft",
    "        val s = num.toString\n        val n = s.length\n        val mid = n / 2\n        val left = s.substring(0, mid)\n        val right = s.substring(mid + (n % 2), n).reverse\n        val leftNum = left.toLong\n        val rightNum = right.toLong\n        if (leftNum == rightNum) {\n            val nextLeft = (leftNum + 1).toString\n            val nextRight = nextLeft.reverse\n            if (nextLeft.length > left.length) nextRight.toLong * pow(10, n / 2 + 1).toLong + nextLeft.toLong * pow(10, n / 2).toLong\n            else nextRight.toLong * pow(10, n / 2).toLong + nextLeft.toLong * pow(10, n / 2).toLong\n        }\n        else if (leftNum > rightNum) {\n            val nextLeft = left\n            val nextRight = nextLeft.reverse\n            if (nextLeft.length > left.length) nextRight.toLong * pow(10, n / 2 + 1).toLong + nextLeft.toLong * pow(10, n / 2).toLong\n            else nextRight.toLong * pow(10, n / 2).toLong + nextLeft.toLong * pow(10, n / 2).toLong\n        }\n        else {\n            val nextLeft = (leftNum + 1).toString\n            val nextRight = nextLeft.reverse\n            if (nextLeft.length > left.length) nextRight.toLong * pow(10, n / 2 + 1).toLong + nextLeft.toLong * pow(10, n / 2).toLong\n            else nextRight.toLong * pow(10, n / 2).toLong + nextLeft.toLong * pow(10, n / 2).toLong\n        }",
    "        val str = num.toString\n        val len = str.length\n        val half = len / 2\n        val (left, right) = str.splitAt(half)\n        val leftRev = left.reverse\n        val leftRevInt = leftRev.toInt\n        val leftInt = left.toInt\n        if (leftRevInt < leftInt) {\n            val newLeft = (leftInt + 1).toString\n            val newLeftRev = newLeft.reverse\n            val newLeftRevLen = newLeftRev.length\n            val newLeftLen = newLeft.length\n            val newLeftRevDiff = half - newLeftRevLen\n            val newLeftDiff = half - newLeftLen\n            val newLeftRevPadded = \"0\" * newLeftRevDiff + newLeftRev\n            val newLeftPadded = \"0\" * newLeftDiff + newLeft\n            val newStr = newLeftPadded + newLeftRevPadded\n            newStr.toLong\n        } else {\n            val newStr = left + leftRev\n            newStr.toLong\n        }",
    "        var n = num\n        while(true) {\n            n += 1\n            if(isPalindrome(n)) return n\n        }\n        return -1"
  ]
}