{
  "name": "mbpp_779_unique_sublists",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to count the number of lists within a list. The function should return a map, where every list is turned to a tuple, and the value of the tuple is the number of its occurrences.\n    def uniqueSublists(list1 : Any) : Any = {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_779_unique_sublists.py",
  "prompt_terminology": "reworded",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(uniqueSublists((Any(List[Long](1l.toLong, 3l.toLong), List[Long](5l.toLong, 7l.toLong), List[Long](1l.toLong, 3l.toLong), List[Long](13l.toLong, 15l.toLong, 17l.toLong), List[Long](5l.toLong, 7l.toLong), List[Long](9l.toLong, 11l.toLong)))).equals((Any((1l, 3l) -> 2l, (5l, 7l) -> 2l, (13l, 15l, 17l) -> 1l, (9l, 11l) -> 1l))));\n    assert(uniqueSublists((Any(List[String](\"green\", \"orange\"), List[String](\"black\"), List[String](\"green\", \"orange\"), List[String](\"white\")))).equals((Any((\"green\", \"orange\") -> 2l, (\"black\") -> 1l, (\"white\") -> 1l))));\n    assert(uniqueSublists((Any(List[Long](1l.toLong, 2l.toLong), List[Long](3l.toLong, 4l.toLong), List[Long](4l.toLong, 5l.toLong), List[Long](6l.toLong, 7l.toLong)))).equals((Any((1l, 2l) -> 1l, (3l, 4l) -> 1l, (4l, 5l) -> 1l, (6l, 7l) -> 1l))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        var map = Map[Any, Int]()\n        list1 match {\n            case Nil => map\n            case x :: xs => {\n                if (map.contains(x)) {\n                    map(x) += 1\n                } else {\n                    map(x) = 1\n                }\n                uniqueSublists(xs)\n            }\n        }\n        map",
    "        var map = new HashMap[Any, Int]()\n        for (i <- 0 until list1.length) {\n            var tuple = list1(i)\n            if (map.contains(tuple)) {\n                map(tuple) += 1\n            } else {\n                map(tuple) = 1\n            }\n        }\n        map",
    "        var list = list1.asInstanceOf[List[Any]]\n        var map = Map[Any, Int]()\n        for (i <- list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        map",
    "        var map = Map[Any, Int]()\n        list1 match {\n            case list : List[Any] => {\n                for (i <- list) {\n                    if (map.contains(i)) {\n                        map(i) += 1\n                    } else {\n                        map(i) = 1\n                    }\n                }\n            }\n            case _ => {\n                if (map.contains(list1)) {\n                    map(list1) += 1\n                } else {\n                    map(list1) = 1\n                }\n            }\n        }\n        map",
    "        var map = Map[Any, Int]()\n        for (i <- 0 to list1.asInstanceOf[List[Any]].length - 1) {\n            var list = list1.asInstanceOf[List[Any]].slice(i, list1.asInstanceOf[List[Any]].length)\n            for (j <- 0 to list.length - 1) {\n                var sublist = list.slice(0, j + 1)\n                if (map.contains(sublist)) {\n                    map(sublist) += 1\n                } else {\n                    map(sublist) = 1\n                }\n            }\n        }\n        map",
    "        list1 match {\n            case Nil => Nil\n            case x :: xs => List(x) :: uniqueSublists(xs)\n        }",
    "        var map = Map[Any, Int]()\n        for (i <- list1.asInstanceOf[List[Any]]) {\n            if (map.contains(i)) {\n                map(i) += 1\n            } else {\n                map(i) = 1\n            }\n        }\n        map",
    "        var map = Map[Any, Int]()\n        for (i <- list1.asInstanceOf[List[Any]]) {\n            if (map.contains(i)) map(i) += 1 else map += (i -> 1)\n        }\n        map",
    "        val list = list1.asInstanceOf[List[Any]]\n        val map = new HashMap[Any, Int]\n        for (i <- 0 until list.length) {\n            val sublist = list.slice(i, list.length)\n            if (map.contains(sublist)) map(sublist) += 1\n            else map(sublist) = 1\n        }\n        map",
    "        var map = Map[Any, Int]()\n        var list = list1.asInstanceOf[List[Any]]\n        for (i <- 0 until list.length) {\n            if (map.contains(list(i))) {\n                map(list(i)) += 1\n            } else {\n                map(list(i)) = 1\n            }\n        }\n        map",
    "        val list = list1.asInstanceOf[List[Any]]\n        val map = new HashMap[Any, Int]\n        for (i <- 0 until list.length) {\n            val sublist = list.slice(i, list.length)\n            if (map.contains(sublist)) map(sublist) += 1\n            else map(sublist) = 1\n        }\n        map",
    "        var map = Map[Any, Int]()\n        for (i <- 0 to list1.asInstanceOf[List[Any]].length - 1) {\n            if (map.contains(list1.asInstanceOf[List[Any]].apply(i))) {\n                map(list1.asInstanceOf[List[Any]].apply(i)) = map(list1.asInstanceOf[List[Any]].apply(i)) + 1\n            } else {\n                map(list1.asInstanceOf[List[Any]].apply(i)) = 1\n            }\n        }\n        map",
    "        var list2 = list1.asInstanceOf[List[Any]]\n        var map = Map[Any, Int]()\n        for (i <- 0 until list2.length) {\n            if (map.contains(list2(i))) {\n                map(list2(i)) = map(list2(i)) + 1\n            } else {\n                map(list2(i)) = 1\n            }\n        }\n        return map",
    "        var map = Map[Any, Int]()\n        for (i <- 0 to list1.length - 1) {\n            if (map.contains(list1(i))) {\n                map(list1(i)) += 1\n            } else {\n                map += (list1(i) -> 1)\n            }\n        }\n        map",
    "        var map = Map[Any, Int]()\n        for (i <- list1.asInstanceOf[List[Any]]) {\n            if (map.contains(i)) {\n                map(i) += 1\n            } else {\n                map(i) = 1\n            }\n        }\n        map",
    "        val list = list1.asInstanceOf[List[Any]]\n        val map = Map[Any, Int]()\n        for (i <- 0 until list.length) {\n            val sublist = list.slice(i, list.length)\n            if (map.contains(sublist)) {\n                map(sublist) += 1\n            } else {\n                map(sublist) = 1\n            }\n        }\n        map",
    "        list1 match {\n            case Nil => Map()\n            case head :: tail => {\n                val map = uniqueSublists(tail).asInstanceOf[Map[Any, Int]]\n                map + (head -> (map.getOrElse(head, 0) + 1))\n            }\n        }",
    "        var map = Map[Any, Int]()\n        for (i <- list1.asInstanceOf[List[Any]]) {\n            if (map.contains(i)) {\n                map(i) += 1\n            } else {\n                map(i) = 1\n            }\n        }\n        map",
    "        var map = Map[Any, Int]()\n        for (i <- 0 to list1.asInstanceOf[List[Any]].length - 1) {\n            if (map.contains(list1.asInstanceOf[List[Any]].apply(i))) {\n                map += (list1.asInstanceOf[List[Any]].apply(i) -> (map.apply(list1.asInstanceOf[List[Any]].apply(i)) + 1))\n            } else {\n                map += (list1.asInstanceOf[List[Any]].apply(i) -> 1)\n            }\n        }\n        map",
    "        var map = Map[Any, Int]()\n        for (i <- 0 to list1.asInstanceOf[List[Any]].length-1) {\n            if (map.contains(list1.asInstanceOf[List[Any]].apply(i))) {\n                map(list1.asInstanceOf[List[Any]].apply(i)) += 1\n            } else {\n                map += (list1.asInstanceOf[List[Any]].apply(i) -> 1)\n            }\n        }\n        map"
  ]
}