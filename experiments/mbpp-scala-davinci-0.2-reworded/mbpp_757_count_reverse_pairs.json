{
  "name": "mbpp_757_count_reverse_pairs",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to count the pairs of reverse strings in the given string list. https://www.geeksforgeeks.org/scalathon-program-to-count-the-pairs-of-reverse-strings/\n    def countReversePairs(test_list : List[String]) : Long = {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_757_count_reverse_pairs.py",
  "prompt_terminology": "reworded",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(countReversePairs((List[String](\"julia\", \"best\", \"tseb\", \"for\", \"ailuj\"))) == (2l));\n    assert(countReversePairs((List[String](\"geeks\", \"best\", \"for\", \"skeeg\"))) == (1l));\n    assert(countReversePairs((List[String](\"makes\", \"best\", \"sekam\", \"for\", \"rof\"))) == (2l));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        val test_map = test_list.groupBy(x => x).mapValues(x => x.length)\n        val reverse_map = test_map.map(x => (x._1.reverse, x._2))\n        val reverse_pairs = test_map.map(x => reverse_map.getOrElse(x._1, 0) * x._2)\n        reverse_pairs.sum / 2",
    "        val test_list_rev = test_list.map(x => x.reverse)\n        val test_list_rev_set = test_list_rev.toSet\n        val test_list_set = test_list.toSet\n        val intersection = test_list_set.intersect(test_list_rev_set)\n        intersection.size",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                map(reverse) += 1\n            } else {\n                map(i) = 1\n            }\n        }\n        var count = 0L\n        for (i <- map.keys) {\n            if (map.contains(i.reverse)) {\n                count += map(i) * map(i.reverse)\n            }\n        }\n        count",
    "        val test_map = test_list.groupBy(x => x)\n        var count = 0L\n        for ((k, v) <- test_map) {\n            if (v.length > 1) {\n                val rev = k.reverse\n                if (test_map.contains(rev)) {\n                    count += test_map(rev).length\n                }\n            }\n        }\n        count",
    "        val reverse_map = new HashMap[String, Int]\n        for (str <- test_list) {\n            val reverse_str = str.reverse\n            if (reverse_map.contains(reverse_str)) {\n                reverse_map(reverse_str) += 1\n            } else {\n                reverse_map(reverse_str) = 1\n            }\n        }\n        var count = 0L\n        for (str <- test_list) {\n            val reverse_str = str.reverse\n            if (reverse_map.contains(str)) {\n                count += reverse_map(str)\n                reverse_map(str) = 0\n            }\n        }\n        count",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val test_list_size = test_list.size\n        var count = 0\n        for (i <- 0 until test_list_size) {\n            for (j <- i + 1 until test_list_size) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (i <- 0 until test_list.length) {\n            val rev = test_list(i).reverse\n            if (map.contains(rev)) {\n                map(rev) += 1\n            } else {\n                map(rev) = 1\n            }\n        }\n        var count = 0\n        for (i <- 0 until test_list.length) {\n            val rev = test_list(i).reverse\n            if (map.contains(rev)) {\n                count += map(rev)\n                map(rev) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]()\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- map.keys) {\n            val rev = i.reverse\n            if (map.contains(rev)) {\n                if (i != rev) count += map(i) * map(rev)\n                else count += map(i) * (map(i) - 1)\n            }\n        }\n        count / 2",
    "        val reverse_map = new HashMap[String, Long]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (reverse_map.contains(reverse)) reverse_map(reverse) += 1\n            else reverse_map(reverse) = 1\n        }\n        var count = 0L\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (reverse_map.contains(i)) count += reverse_map(i)\n        }\n        count",
    "        val test_map = new HashMap[String, Int]\n        for (i <- test_list) {\n            if (test_map.contains(i)) test_map(i) += 1\n            else test_map(i) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (test_map.contains(reverse)) {\n                if (i == reverse) count += test_map(i) - 1\n                else count += test_map(reverse)\n            }\n        }\n        count / 2",
    "        val test_map = new HashMap[String, Long]()\n        for (test_str <- test_list) {\n            val reverse_str = test_str.reverse\n            if (test_map.contains(reverse_str)) test_map(reverse_str) += 1\n            else test_map(reverse_str) = 1\n        }\n        var result = 0L\n        for (test_str <- test_list) {\n            val reverse_str = test_str.reverse\n            if (test_map.contains(test_str)) {\n                result += test_map(test_str)\n                test_map(test_str) = 0\n            }\n        }\n        result",
    "        val test_map = new HashMap[String, Int]\n        for (i <- test_list) {\n            if (test_map.contains(i)) test_map(i) += 1\n            else test_map(i) = 1\n        }\n        var count = 0L\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (test_map.contains(reverse)) {\n                count += test_map(reverse)\n                test_map(reverse) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (i <- 0 until test_list.length) {\n            val str = test_list(i)\n            val reverse = str.reverse\n            if (map.contains(reverse)) {\n                map(reverse) += 1\n            } else {\n                map(str) = 0\n            }\n        }\n        var count = 0L\n        for (i <- 0 until test_list.length) {\n            val str = test_list(i)\n            val reverse = str.reverse\n            if (map.contains(str)) {\n                count += map(str)\n            }\n        }\n        count",
    "        val test_map = new HashMap[String, Int]\n        for (i <- test_list) {\n            if (test_map.contains(i)) {\n                test_map(i) = test_map(i) + 1\n            } else {\n                test_map(i) = 1\n            }\n        }\n        var count = 0\n        for (i <- test_map.keys) {\n            val reverse_string = i.reverse\n            if (test_map.contains(reverse_string)) {\n                count = count + test_map(i) * test_map(reverse_string)\n            }\n        }\n        count / 2",
    "        val test_list_size = test_list.size\n        var count = 0\n        for (i <- 0 until test_list_size) {\n            for (j <- i + 1 until test_list_size) {\n                if (test_list(i) == test_list(j).reverse) {\n                    count += 1\n                }\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                count += map(reverse)\n                map(reverse) = 0\n            }\n        }\n        count",
    "        val test_map = new HashMap[String, Int]()\n        for (str <- test_list) {\n            val reverse_str = str.reverse\n            if (test_map.contains(reverse_str)) {\n                test_map(reverse_str) += 1\n            } else {\n                test_map(reverse_str) = 1\n            }\n        }\n        var count = 0L\n        for (str <- test_list) {\n            val reverse_str = str.reverse\n            if (test_map.contains(str)) {\n                count += test_map(str)\n                test_map(str) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]()\n        for (i <- 0 until test_list.length) {\n            val rev = test_list(i).reverse\n            if (map.contains(rev)) map(rev) += 1\n            else map(rev) = 1\n        }\n        var count = 0L\n        for (i <- 0 until test_list.length) {\n            val rev = test_list(i).reverse\n            if (map.contains(rev)) {\n                count += map(rev)\n                map -= rev\n            }\n        }\n        count"
  ]
}