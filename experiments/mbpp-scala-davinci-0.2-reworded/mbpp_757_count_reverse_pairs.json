{
  "name": "mbpp_757_count_reverse_pairs",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to count the pairs of reverse strings in the given string list. https://www.geeksforgeeks.org/scalathon-program-to-count-the-pairs-of-reverse-strings/\n    def countReversePairs(test_list : List[String]) : Long = {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_757_count_reverse_pairs.py",
  "prompt_terminology": "reworded",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(countReversePairs((List[String](\"julia\", \"best\", \"tseb\", \"for\", \"ailuj\"))) == (2l));\n    assert(countReversePairs((List[String](\"geeks\", \"best\", \"for\", \"skeeg\"))) == (1l));\n    assert(countReversePairs((List[String](\"makes\", \"best\", \"sekam\", \"for\", \"rof\"))) == (2l));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        val test_map = test_list.groupBy(x => x).mapValues(x => x.length)\n        val reverse_map = test_map.map(x => (x._1.reverse, x._2))\n        val reverse_pairs = test_map.map(x => reverse_map.getOrElse(x._1, 0) * x._2)\n        reverse_pairs.sum / 2",
    "        val test_list_rev = test_list.map(x => x.reverse)\n        val test_list_rev_set = test_list_rev.toSet\n        val test_list_set = test_list.toSet\n        val intersection = test_list_set.intersect(test_list_rev_set)\n        intersection.size",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                map(reverse) += 1\n            } else {\n                map(i) = 1\n            }\n        }\n        var count = 0L\n        for (i <- map.keys) {\n            if (map.contains(i.reverse)) {\n                count += map(i) * map(i.reverse)\n            }\n        }\n        count",
    "        val test_map = test_list.groupBy(x => x)\n        var count = 0L\n        for ((k, v) <- test_map) {\n            if (v.length > 1) {\n                val rev = k.reverse\n                if (test_map.contains(rev)) {\n                    count += test_map(rev).length\n                }\n            }\n        }\n        count",
    "        val reverse_map = new HashMap[String, Int]\n        for (str <- test_list) {\n            val reverse_str = str.reverse\n            if (reverse_map.contains(reverse_str)) {\n                reverse_map(reverse_str) += 1\n            } else {\n                reverse_map(reverse_str) = 1\n            }\n        }\n        var count = 0L\n        for (str <- test_list) {\n            val reverse_str = str.reverse\n            if (reverse_map.contains(str)) {\n                count += reverse_map(str)\n                reverse_map(str) = 0\n            }\n        }\n        count",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val test_list_size = test_list.size\n        var count = 0\n        for (i <- 0 until test_list_size) {\n            for (j <- i + 1 until test_list_size) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (i <- 0 until test_list.length) {\n            val rev = test_list(i).reverse\n            if (map.contains(rev)) {\n                map(rev) += 1\n            } else {\n                map(rev) = 1\n            }\n        }\n        var count = 0\n        for (i <- 0 until test_list.length) {\n            val rev = test_list(i).reverse\n            if (map.contains(rev)) {\n                count += map(rev)\n                map(rev) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]()\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- map.keys) {\n            val rev = i.reverse\n            if (map.contains(rev)) {\n                if (i != rev) count += map(i) * map(rev)\n                else count += map(i) * (map(i) - 1)\n            }\n        }\n        count / 2",
    "        val reverse_map = new HashMap[String, Long]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (reverse_map.contains(reverse)) reverse_map(reverse) += 1\n            else reverse_map(reverse) = 1\n        }\n        var count = 0L\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (reverse_map.contains(i)) count += reverse_map(i)\n        }\n        count",
    "        val test_map = new HashMap[String, Int]\n        for (i <- test_list) {\n            if (test_map.contains(i)) test_map(i) += 1\n            else test_map(i) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (test_map.contains(reverse)) {\n                if (i == reverse) count += test_map(i) - 1\n                else count += test_map(reverse)\n            }\n        }\n        count / 2",
    "        val test_map = new HashMap[String, Long]()\n        for (test_str <- test_list) {\n            val reverse_str = test_str.reverse\n            if (test_map.contains(reverse_str)) test_map(reverse_str) += 1\n            else test_map(reverse_str) = 1\n        }\n        var result = 0L\n        for (test_str <- test_list) {\n            val reverse_str = test_str.reverse\n            if (test_map.contains(test_str)) {\n                result += test_map(test_str)\n                test_map(test_str) = 0\n            }\n        }\n        result",
    "        val test_map = new HashMap[String, Int]\n        for (i <- test_list) {\n            if (test_map.contains(i)) test_map(i) += 1\n            else test_map(i) = 1\n        }\n        var count = 0L\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (test_map.contains(reverse)) {\n                count += test_map(reverse)\n                test_map(reverse) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (i <- 0 until test_list.length) {\n            val str = test_list(i)\n            val reverse = str.reverse\n            if (map.contains(reverse)) {\n                map(reverse) += 1\n            } else {\n                map(str) = 0\n            }\n        }\n        var count = 0L\n        for (i <- 0 until test_list.length) {\n            val str = test_list(i)\n            val reverse = str.reverse\n            if (map.contains(str)) {\n                count += map(str)\n            }\n        }\n        count",
    "        val test_map = new HashMap[String, Int]\n        for (i <- test_list) {\n            if (test_map.contains(i)) {\n                test_map(i) = test_map(i) + 1\n            } else {\n                test_map(i) = 1\n            }\n        }\n        var count = 0\n        for (i <- test_map.keys) {\n            val reverse_string = i.reverse\n            if (test_map.contains(reverse_string)) {\n                count = count + test_map(i) * test_map(reverse_string)\n            }\n        }\n        count / 2",
    "        val test_list_size = test_list.size\n        var count = 0\n        for (i <- 0 until test_list_size) {\n            for (j <- i + 1 until test_list_size) {\n                if (test_list(i) == test_list(j).reverse) {\n                    count += 1\n                }\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                count += map(reverse)\n                map(reverse) = 0\n            }\n        }\n        count",
    "        val test_map = new HashMap[String, Int]()\n        for (str <- test_list) {\n            val reverse_str = str.reverse\n            if (test_map.contains(reverse_str)) {\n                test_map(reverse_str) += 1\n            } else {\n                test_map(reverse_str) = 1\n            }\n        }\n        var count = 0L\n        for (str <- test_list) {\n            val reverse_str = str.reverse\n            if (test_map.contains(str)) {\n                count += test_map(str)\n                test_map(str) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]()\n        for (i <- 0 until test_list.length) {\n            val rev = test_list(i).reverse\n            if (map.contains(rev)) map(rev) += 1\n            else map(rev) = 1\n        }\n        var count = 0L\n        for (i <- 0 until test_list.length) {\n            val rev = test_list(i).reverse\n            if (map.contains(rev)) {\n                count += map(rev)\n                map -= rev\n            }\n        }\n        count",
    "        val reverse_map = new HashMap[String, Int]()\n        for (i <- 0 until test_list.length) {\n            val reverse_string = test_list(i).reverse\n            if (reverse_map.contains(reverse_string)) reverse_map(reverse_string) += 1\n            else reverse_map(reverse_string) = 1\n        }\n        var count = 0L\n        for (i <- 0 until test_list.length) {\n            val reverse_string = test_list(i).reverse\n            if (reverse_map.contains(reverse_string)) {\n                count += reverse_map(reverse_string)\n                reverse_map(reverse_string) = 0\n            }\n        }\n        count",
    "        val test_list_rev = test_list.map(x => x.reverse)\n        val test_list_rev_set = test_list_rev.toSet\n        var count = 0\n        for (x <- test_list) {\n            if (test_list_rev_set.contains(x)) {\n                count += 1\n            }\n        }\n        count / 2",
    "        val test_set = test_list.toSet\n        var count = 0\n        for (i <- test_set) {\n            if (test_set.contains(i.reverse)) count += 1\n        }\n        count / 2",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0L\n        for (i <- map.values) {\n            if (i > 1) count += (i * (i - 1)) / 2\n        }\n        return count",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- map.keys) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                count += map(i) * map(reverse)\n            }\n        }\n        count / 2",
    "        val test_list_sorted = test_list.sorted\n        var count = 0\n        for (i <- 0 until test_list_sorted.length) {\n            val rev = test_list_sorted(i).reverse\n            val index = test_list_sorted.indexOf(rev)\n            if (index != -1) {\n                count += 1\n            }\n        }\n        count",
    "        val reverse_list = test_list.map(x => x.reverse)\n        val reverse_set = reverse_list.toSet\n        val count_map = HashMap[String, Int]()\n        for (i <- test_list) {\n            if (count_map.contains(i)) {\n                count_map(i) += 1\n            } else {\n                count_map(i) = 1\n            }\n        }\n        var count = 0\n        for (i <- reverse_set) {\n            if (count_map.contains(i)) {\n                count += count_map(i)\n            }\n        }\n        count",
    "        val test_map = new HashMap[String, Int]\n        for (s <- test_list) {\n            val reverse = s.reverse\n            if (test_map.contains(reverse)) {\n                test_map(reverse) += 1\n            } else {\n                test_map(s) = 1\n            }\n        }\n        var count = 0\n        for (s <- test_map.keys) {\n            val reverse = s.reverse\n            if (test_map.contains(reverse)) {\n                count += test_map(s) * test_map(reverse)\n            }\n        }\n        count / 2",
    "        val reverse_map = new HashMap[String, Int]\n        for (i <- 0 until test_list.length) {\n            val reverse_string = test_list(i).reverse\n            if (reverse_map.contains(reverse_string)) {\n                reverse_map(reverse_string) += 1\n            } else {\n                reverse_map(reverse_string) = 1\n            }\n        }\n        var count = 0L\n        for (i <- 0 until test_list.length) {\n            val reverse_string = test_list(i).reverse\n            if (reverse_map.contains(test_list(i))) {\n                count += reverse_map(test_list(i))\n                reverse_map(reverse_string) = 0\n            }\n        }\n        count",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val test_list_set = test_list.toSet\n        var count = 0\n        for (i <- test_list_set) {\n            if (test_list_set.contains(i.reverse)) count += 1\n        }\n        return count",
    "        val test_list_rev = test_list.map(_.reverse)\n        val test_list_rev_map = test_list_rev.groupBy(identity).mapValues(_.size)\n        val test_list_map = test_list.groupBy(identity).mapValues(_.size)\n        var count = 0L\n        for (i <- test_list_map.keys) {\n            if (test_list_rev_map.contains(i)) {\n                count += test_list_map(i) * test_list_rev_map(i)\n            }\n        }\n        count",
    "        val test_map = HashMap[String, Long]()\n        for (i <- test_list) {\n            val reverse_string = i.reverse\n            if (test_map.contains(reverse_string)) test_map(reverse_string) += 1\n            else test_map(reverse_string) = 1\n        }\n        var count = 0L\n        for (i <- test_map.keys) {\n            if (test_map.contains(i.reverse)) {\n                count += test_map(i) * test_map(i.reverse)\n            }\n        }\n        count",
    "        val map = HashMap[String, Int]()\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0L\n        for (i <- map) {\n            if (i._2 > 1) count += (i._2 * (i._2 - 1)) / 2\n        }\n        count",
    "        val reverse_map = new HashMap[String, Int]\n        for (i <- test_list) {\n            val reverse_i = i.reverse\n            if (reverse_map.contains(reverse_i)) reverse_map(reverse_i) += 1\n            else reverse_map(reverse_i) = 1\n        }\n        var count = 0L\n        for (i <- test_list) {\n            val reverse_i = i.reverse\n            if (reverse_map.contains(i)) {\n                count += reverse_map(i)\n                reverse_map(i) = 0\n            }\n        }\n        count",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val test_list_sorted = test_list.sorted\n        var count = 0\n        for (i <- 0 until test_list_sorted.length - 1) {\n            val cur = test_list_sorted(i)\n            val next = test_list_sorted(i + 1)\n            if (cur.reverse == next) count += 1\n        }\n        count",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val test_list_sorted = test_list.sorted\n        val test_list_sorted_reversed = test_list_sorted.map(x => x.reverse)\n        var count = 0\n        for (i <- 0 until test_list_sorted.length) {\n            val index = test_list_sorted_reversed.indexOf(test_list_sorted(i))\n            if (index != -1) {\n                count += 1\n                test_list_sorted_reversed(index) = \"\"\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (str <- test_list) {\n            val reverse = str.reverse\n            if (map.contains(reverse)) {\n                map(reverse) += 1\n            } else {\n                map(reverse) = 1\n            }\n        }\n        var count = 0L\n        for (str <- test_list) {\n            val reverse = str.reverse\n            if (map.contains(str)) {\n                count += map(str)\n                map(reverse) -= 1\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (i <- 0 until test_list.length) {\n            val rev = test_list(i).reverse\n            if (map.contains(rev)) {\n                map(rev) += 1\n            } else {\n                map(rev) = 1\n            }\n        }\n        var count = 0\n        for (i <- 0 until test_list.length) {\n            if (map.contains(test_list(i))) {\n                count += map(test_list(i))\n                map(test_list(i)) = 0\n            }\n        }\n        count",
    "        val test_map = Map[String, Int]()\n        for (i <- test_list) {\n            val reverse_i = i.reverse\n            if (test_map.contains(reverse_i)) test_map(reverse_i) += 1\n            else test_map(reverse_i) = 1\n        }\n        var count = 0L\n        for (i <- test_map) {\n            if (i._2 > 1) count += i._2 * (i._2 - 1) / 2\n        }\n        return count",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val test_list_length = test_list.length\n        var count = 0\n        for (i <- 0 until test_list_length) {\n            for (j <- i + 1 until test_list_length) {\n                if (test_list(i) == test_list(j).reverse) {\n                    count += 1\n                }\n            }\n        }\n        return count",
    "        val reverse_list = test_list.map(_.reverse)\n        val reverse_list_set = reverse_list.toSet\n        var count = 0\n        for (i <- 0 until test_list.length) {\n            if (reverse_list_set.contains(test_list(i))) count += 1\n        }\n        count / 2",
    "        var count : Long = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i).equals(test_list(j).reverse)) count += 1\n            }\n        }\n        return count",
    "        val test_list_rev = test_list.map(_.reverse)\n        val test_list_rev_set = test_list_rev.toSet\n        var count = 0\n        for (i <- test_list) {\n            if (test_list_rev_set.contains(i)) count += 1\n        }\n        count / 2",
    "        val reverse_list = test_list.map(_.reverse)\n        val reverse_map = reverse_list.groupBy(identity).mapValues(_.size)\n        val count = test_list.map(reverse_map.getOrElse(_, 0)).sum\n        count",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val test_list_rev = test_list.map(x => x.reverse)\n        val test_list_rev_set = test_list_rev.toSet\n        var count = 0\n        for (i <- test_list) {\n            if (test_list_rev_set.contains(i)) {\n                count += 1\n            }\n        }\n        count / 2",
    "        val map = new HashMap[String, Long]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                map(reverse) += 1\n            } else {\n                map(reverse) = 1\n            }\n        }\n        var count = 0L\n        for (i <- test_list) {\n            if (map.contains(i)) {\n                count += map(i)\n                map(i) = 0\n            }\n        }\n        count",
    "        val test_map = new HashMap[String, Int]()\n        for (i <- 0 until test_list.length) {\n            val reversed = test_list(i).reverse\n            if (test_map.contains(reversed)) test_map(reversed) += 1\n            else test_map(reversed) = 1\n        }\n        var count = 0L\n        for (i <- 0 until test_list.length) {\n            val reversed = test_list(i).reverse\n            if (test_map.contains(reversed)) {\n                count += test_map(reversed)\n                test_map(reversed) = 0\n            }\n        }\n        count",
    "        val test_map = new HashMap[String, Long]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (test_map.contains(reverse)) {\n                test_map(reverse) += 1\n            } else {\n                test_map(i) = 1\n            }\n        }\n        var count : Long = 0\n        for (i <- test_map.keys) {\n            if (test_map.contains(i.reverse)) {\n                count += test_map(i) * test_map(i.reverse)\n            }\n        }\n        count",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val reverse_map = new HashMap[String, Int]\n        for (i <- test_list) {\n            val reverse_i = i.reverse\n            if (reverse_map.contains(reverse_i)) reverse_map(reverse_i) += 1\n            else reverse_map(reverse_i) = 1\n        }\n        var count = 0L\n        for (i <- test_list) {\n            val reverse_i = i.reverse\n            if (reverse_map.contains(i)) {\n                count += reverse_map(i)\n                reverse_map(reverse_i) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]()\n        for (i <- 0 until test_list.length) {\n            val s = test_list(i)\n            val r = s.reverse\n            if (map.contains(r)) {\n                map(r) += 1\n            } else {\n                map(s) = 1\n            }\n        }\n        var result = 0L\n        for (i <- 0 until test_list.length) {\n            val s = test_list(i)\n            val r = s.reverse\n            if (map.contains(s)) {\n                result += map(s) - 1\n            }\n        }\n        result / 2",
    "        val reverse_map = HashMap[String, Int]()\n        for (str <- test_list) {\n            val reverse_str = str.reverse\n            if (reverse_map.contains(reverse_str)) reverse_map(reverse_str) += 1\n            else reverse_map += (reverse_str -> 1)\n        }\n        var count = 0L\n        for (str <- test_list) {\n            val reverse_str = str.reverse\n            if (reverse_map.contains(str)) {\n                count += reverse_map(str)\n                reverse_map(str) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (str <- test_list) {\n            if (map.contains(str)) map(str) += 1\n            else map += (str -> 1)\n        }\n        var count = 0L\n        for (str <- test_list) {\n            val reverse = str.reverse\n            if (map.contains(reverse)) {\n                count += map(reverse)\n                map(reverse) = 0\n            }\n        }\n        count",
    "        val test_map = new HashMap[String, Int]\n        for (i <- 0 until test_list.length) {\n            val reverse_string = test_list(i).reverse\n            if (test_map.contains(reverse_string)) {\n                test_map(reverse_string) += 1\n            } else {\n                test_map(reverse_string) = 1\n            }\n        }\n        var count = 0L\n        for (i <- 0 until test_list.length) {\n            if (test_map.contains(test_list(i))) {\n                count += test_map(test_list(i))\n                test_map(test_list(i)) = 0\n            }\n        }\n        count",
    "        test_list.map(x => x.reverse).groupBy(x => x).map(x => x._2.length).map(x => x * (x - 1) / 2).sum",
    "        val test_list_rev = test_list.map(x => x.reverse)\n        val test_list_rev_set = test_list_rev.toSet\n        val test_list_set = test_list.toSet\n        val test_list_intersect = test_list_set.intersect(test_list_rev_set)\n        val test_list_intersect_count = test_list_intersect.size\n        val test_list_intersect_count_double = test_list_intersect_count * 2\n        val test_list_size = test_list.size\n        val test_list_size_double = test_list_size * 2\n        val test_list_size_double_minus_intersect_count_double = test_list_size_double - test_list_intersect_count_double\n        val test_list_size_double_minus_intersect_count_double_divide_2 = test_list_size_double_minus_intersect_count_double / 2\n        test_list_size_double_minus_intersect_count_double_divide_2",
    "        val map = new HashMap[String, Long]\n        for (str <- test_list) {\n            val rev = str.reverse\n            if (map.contains(rev)) map(rev) += 1\n            else map(rev) = 1\n        }\n        var count = 0L\n        for (str <- test_list) {\n            val rev = str.reverse\n            if (map.contains(str)) count += map(str)\n        }\n        count",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        return count",
    "        val test_list_length = test_list.length\n        var count = 0\n        for (i <- 0 until test_list_length) {\n            for (j <- i + 1 until test_list_length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (s <- test_list) {\n            val reverse = s.reverse\n            if (map.contains(reverse)) {\n                map(reverse) += 1\n            } else {\n                map(reverse) = 1\n            }\n        }\n        var count = 0L\n        for (s <- test_list) {\n            val reverse = s.reverse\n            if (map.contains(s)) {\n                count += map(s)\n                map(reverse) -= 1\n            }\n        }\n        count",
    "        val counts = test_list.groupBy(identity).mapValues(_.size)\n        val reverse_counts = test_list.map(_.reverse).groupBy(identity).mapValues(_.size)\n        var count = 0L\n        for (key <- counts.keys) {\n            if (reverse_counts.contains(key)) {\n                count += counts(key) * reverse_counts(key)\n            }\n        }\n        count",
    "        val test_map = new HashMap[String, Int]()\n        for (str <- test_list) {\n            val reverse_str = str.reverse\n            if (test_map.contains(reverse_str)) {\n                test_map(reverse_str) += 1\n            } else {\n                test_map(reverse_str) = 1\n            }\n        }\n        var count = 0L\n        for (str <- test_list) {\n            val reverse_str = str.reverse\n            if (test_map.contains(str)) {\n                count += test_map(str)\n                test_map(str) = 0\n            }\n        }\n        count",
    "        val reverse_map = new HashMap[String, Int]()\n        for (i <- test_list) {\n            val reverse_string = i.reverse\n            if (reverse_map.contains(reverse_string)) {\n                reverse_map(reverse_string) += 1\n            } else {\n                reverse_map(reverse_string) = 1\n            }\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse_string = i.reverse\n            if (reverse_map.contains(i)) {\n                count += reverse_map(i)\n                reverse_map(reverse_string) = 0\n            }\n        }\n        count",
    "        val test_map = new HashMap[String, Int]\n        for (i <- test_list) {\n            if (test_map.contains(i)) test_map(i) += 1\n            else test_map(i) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse_string = i.reverse\n            if (test_map.contains(reverse_string)) {\n                count += test_map(reverse_string)\n                test_map(reverse_string) = 0\n            }\n        }\n        count",
    "        val test_map = new HashMap[String, Int]\n        for (i <- test_list) {\n            if (test_map.contains(i)) test_map(i) += 1\n            else test_map(i) = 1\n        }\n        var count = 0\n        for (i <- test_map.keys) {\n            val reverse = i.reverse\n            if (test_map.contains(reverse)) {\n                count += test_map(i) * test_map(reverse)\n            }\n        }\n        count / 2",
    "        val test_map = new HashMap[String, Int]()\n        for (i <- test_list) {\n            if (test_map.contains(i)) test_map(i) += 1\n            else test_map(i) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (test_map.contains(reverse)) {\n                count += test_map(reverse)\n                test_map(reverse) = 0\n            }\n        }\n        count",
    "        var count : Long = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        return count",
    "        val test_map = new HashMap[String, Int]()\n        for (i <- test_list) {\n            if (test_map.contains(i)) test_map(i) += 1\n            else test_map(i) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (test_map.contains(reverse)) {\n                count += test_map(reverse)\n                test_map(reverse) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (str <- test_list) {\n            val reverse = str.reverse\n            if (map.contains(reverse)) {\n                map(reverse) += 1\n            } else {\n                map(reverse) = 1\n            }\n        }\n        var count = 0L\n        for (str <- test_list) {\n            if (map.contains(str)) {\n                count += map(str)\n                map(str) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (i <- 0 until test_list.length) {\n            val s = test_list(i)\n            val r = s.reverse\n            if (map.contains(r)) {\n                map(r) += 1\n            } else {\n                map(s) = 1\n            }\n        }\n        var count = 0L\n        for (i <- 0 until test_list.length) {\n            val s = test_list(i)\n            val r = s.reverse\n            if (map.contains(s)) {\n                count += map(s)\n            }\n        }\n        count / 2",
    "        val test_list_sorted = test_list.sorted\n        var count = 0\n        for (i <- 0 until test_list_sorted.length - 1) {\n            if (test_list_sorted(i) == test_list_sorted(i + 1).reverse) count += 1\n        }\n        count",
    "        var count : Long = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        var count = 0\n        for (i <- test_list) {\n            if (map.contains(i.reverse)) {\n                count += map(i.reverse)\n            }\n            if (map.contains(i)) {\n                map(i) += 1\n            } else {\n                map(i) = 1\n            }\n        }\n        count",
    "        val test_map = new HashMap[String, Int]()\n        test_list.foreach(x => {\n            if (test_map.contains(x)) test_map(x) += 1\n            else test_map(x) = 1\n        })\n        var count = 0\n        test_map.foreach(x => {\n            if (test_map.contains(x._1.reverse)) count += x._2 * test_map(x._1.reverse)\n        })\n        count",
    "        val map = new HashMap[String, Int]()\n        for (str <- test_list) {\n            val rev = str.reverse\n            if (map.contains(rev)) {\n                map(rev) += 1\n            } else {\n                map(rev) = 1\n            }\n        }\n        var count = 0L\n        for (str <- test_list) {\n            val rev = str.reverse\n            if (map.contains(str)) {\n                count += map(str)\n                map(rev) -= 1\n                if (map(rev) == 0) map.remove(rev)\n            }\n        }\n        count",
    "        val test_list_rev = test_list.map(_.reverse)\n        val test_list_rev_map = test_list_rev.groupBy(identity).mapValues(_.size)\n        val test_list_map = test_list.groupBy(identity).mapValues(_.size)\n        var count = 0L\n        for (i <- test_list_map.keys) {\n            if (test_list_rev_map.contains(i)) {\n                count += test_list_map(i) * test_list_rev_map(i)\n            }\n        }\n        count",
    "        val test_map = new HashMap[String, Int]()\n        for (i <- test_list) {\n            if (test_map.contains(i)) test_map(i) += 1\n            else test_map += (i -> 1)\n        }\n        var count = 0L\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (test_map.contains(reverse)) {\n                if (i == reverse) count += test_map(i) - 1\n                else count += test_map(i) * test_map(reverse)\n            }\n        }\n        count / 2",
    "        val test_map = new HashMap[String, Int]()\n        for (i <- test_list) {\n            if (test_map.contains(i)) test_map(i) += 1\n            else test_map(i) = 1\n        }\n        var result = 0L\n        for (i <- test_map.keys) {\n            val reverse_i = i.reverse\n            if (test_map.contains(reverse_i)) {\n                result += test_map(i) * test_map(reverse_i)\n            }\n        }\n        result",
    "        val map = HashMap[String, Int]()\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                map(reverse) += 1\n            } else {\n                map(reverse) = 1\n            }\n        }\n        var count = 0L\n        for (i <- test_list) {\n            if (map.contains(i)) {\n                count += map(i)\n                map(i) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Long]()\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0L\n        for (i <- map.values) {\n            count += i * (i - 1) / 2\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0L\n        for (i <- map.keys) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                count += map(i) * map(reverse)\n                map(i) = 0\n                map(reverse) = 0\n            }\n        }\n        count",
    "        val test_list_rev = test_list.map(_.reverse)\n        val test_list_rev_set = test_list_rev.toSet\n        var count = 0\n        for (i <- 0 until test_list.length) {\n            if (test_list_rev_set.contains(test_list(i))) count += 1\n        }\n        count / 2",
    "        val n = test_list.length\n        val test_list_sorted = test_list.sortWith(_.length < _.length)\n        var count = 0\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                if (test_list_sorted(i).length * 2 == test_list_sorted(j).length) {\n                    if (test_list_sorted(i) == test_list_sorted(j).reverse) count += 1\n                }\n            }\n        }\n        count",
    "        val test_list_sorted = test_list.sorted\n        var count = 0\n        for (i <- 0 until test_list_sorted.length - 1) {\n            if (test_list_sorted(i) == test_list_sorted(i + 1).reverse) count += 1\n        }\n        count",
    "        val counts = new HashMap[String, Int]\n        for (str <- test_list) {\n            val rev = str.reverse\n            if (counts.contains(rev)) counts(rev) += 1\n            else counts(rev) = 1\n        }\n        var result = 0L\n        for (str <- test_list) {\n            val rev = str.reverse\n            if (counts.contains(str)) {\n                result += counts(str)\n                counts(str) = 0\n            }\n        }\n        result",
    "        val test_map = new HashMap[String, Int]\n        var count = 0\n        for (i <- test_list) {\n            if (test_map.contains(i.reverse)) {\n                count += test_map(i.reverse)\n            }\n            if (test_map.contains(i)) {\n                test_map(i) += 1\n            } else {\n                test_map(i) = 1\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                map(reverse) += 1\n            } else {\n                map(reverse) = 1\n            }\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(i)) {\n                count += map(i)\n                map(reverse) -= 1\n            }\n        }\n        count / 2",
    "        // Write your code here\n        val test_map = Map[String, Int]()\n        for (i <- test_list) {\n            if (test_map.contains(i)) {\n                test_map(i) += 1\n            } else {\n                test_map(i) = 1\n            }\n        }\n        var count = 0\n        for (i <- test_map.keys) {\n            val reverse = i.reverse\n            if (test_map.contains(reverse)) {\n                count += test_map(i) * test_map(reverse)\n            }\n        }\n        count / 2",
    "        val test_map = new HashMap[String, Long]\n        for (i <- test_list) {\n            val reverse_string = i.reverse\n            if (test_map.contains(reverse_string)) {\n                test_map(reverse_string) += 1\n            } else {\n                test_map(i) = 1\n            }\n        }\n        var count = 0L\n        for (i <- test_map.values) {\n            count += (i * (i - 1)) / 2\n        }\n        count",
    "        val test_map = test_list.groupBy(identity).mapValues(_.size)\n        var count = 0L\n        for ((k, v) <- test_map) {\n            val reverse = k.reverse\n            if (test_map.contains(reverse)) {\n                count += v * test_map(reverse)\n            }\n        }\n        count",
    "        val n = test_list.length\n        val test_list_sorted = test_list.sorted\n        var count = 0\n        for (i <- 0 until n) {\n            var j = i + 1\n            while (j < n) {\n                if (test_list_sorted(i) == test_list_sorted(j).reverse) count += 1\n                j += 1\n            }\n        }\n        count",
    "        test_list.map(x => x.reverse).groupBy(x => x).map(x => x._2.size).map(x => (x * (x - 1)) / 2).sum",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val test_map = test_list.groupBy(x => x)\n        var count : Long = 0\n        for (x <- test_map.keys) {\n            val rev = x.reverse\n            if (test_map.contains(rev)) {\n                count += test_map(x).length * test_map(rev).length\n            }\n        }\n        count",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val map = HashMap[String, Long]()\n        for (i <- 0 until test_list.length) {\n            val reverse = test_list(i).reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var result = 0L\n        for (i <- 0 until test_list.length) {\n            val reverse = test_list(i).reverse\n            if (map.contains(reverse)) {\n                result += map(reverse)\n                map(reverse) = 0\n            }\n        }\n        result",
    "        val test_map = test_list.groupBy(x => x)\n        val test_map_values = test_map.values.map(x => x.length)\n        val test_map_values_sum = test_map_values.map(x => (x * (x - 1)) / 2)\n        test_map_values_sum.sum",
    "        val test_map = new HashMap[String, Int]\n        for (i <- 0 until test_list.length) {\n            val key = test_list(i).reverse\n            if (test_map.contains(key)) test_map(key) += 1\n            else test_map(key) = 1\n        }\n        var count = 0L\n        for (i <- 0 until test_list.length) {\n            val key = test_list(i)\n            if (test_map.contains(key)) {\n                count += test_map(key)\n                test_map(key) = 0\n            }\n        }\n        count",
    "        val test_map = new HashMap[String, Int]()\n        for (i <- 0 until test_list.length) {\n            val rev_str = test_list(i).reverse\n            if (test_map.contains(rev_str)) test_map(rev_str) += 1\n            else test_map(rev_str) = 1\n        }\n        var count = 0L\n        for (i <- 0 until test_list.length) {\n            val rev_str = test_list(i).reverse\n            if (test_map.contains(rev_str)) {\n                count += test_map(rev_str)\n                test_map(rev_str) = 0\n            }\n        }\n        count",
    "        val reverse_list = test_list.map(x => x.reverse)\n        val reverse_set = reverse_list.toSet\n        val reverse_map = reverse_list.groupBy(x => x)\n        val reverse_count_map = reverse_map.map(x => (x._1, x._2.length))\n        var count : Long = 0\n        for (i <- 0 until test_list.length) {\n            if (reverse_set.contains(test_list(i))) {\n                count += reverse_count_map(test_list(i)) - 1\n            }\n        }\n        count",
    "        val test_map = new HashMap[String, Long]()\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (test_map.contains(reverse)) test_map(reverse) += 1\n            else test_map(reverse) = 1\n        }\n        var result = 0L\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (test_map.contains(i)) {\n                result += test_map(i)\n                test_map(i) = 0\n            }\n        }\n        result",
    "        val test_list_sorted = test_list.sorted\n        var count = 0\n        for (i <- 0 until test_list_sorted.length - 1) {\n            if (test_list_sorted(i) == test_list_sorted(i + 1).reverse) {\n                count += 1\n            }\n        }\n        count",
    "        val reverse_map = HashMap[String, Int]()\n        for (i <- 0 until test_list.length) {\n            val reverse_string = test_list(i).reverse\n            if (reverse_map.contains(reverse_string)) {\n                reverse_map(reverse_string) += 1\n            } else {\n                reverse_map(reverse_string) = 1\n            }\n        }\n        var count = 0L\n        for (i <- 0 until test_list.length) {\n            val reverse_string = test_list(i).reverse\n            if (reverse_map.contains(reverse_string)) {\n                count += reverse_map(reverse_string)\n                reverse_map(reverse_string) = 0\n            }\n        }\n        count",
    "        val n = test_list.length\n        val map = new HashMap[String, Int]\n        for (i <- 0 until n) {\n            val s = test_list(i)\n            val t = s.reverse\n            if (map.contains(t)) {\n                map(t) += 1\n            } else {\n                map(t) = 1\n            }\n        }\n        var count = 0\n        for (i <- 0 until n) {\n            val s = test_list(i)\n            if (map.contains(s)) {\n                count += map(s)\n                map(s) = 0\n            }\n        }\n        count",
    "        val test_map = new HashMap[String, Long]()\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (test_map.contains(reverse)) {\n                test_map(reverse) += 1\n            } else {\n                test_map(i) = 1\n            }\n        }\n        var count = 0L\n        for (i <- test_map.keys) {\n            if (test_map.contains(i.reverse)) {\n                count += test_map(i) * test_map(i.reverse)\n            }\n        }\n        count / 2",
    "        val count = test_list.map(x => x.reverse).groupBy(identity).mapValues(_.size).filter(x => x._2 > 1).map(x => x._2 * (x._2 - 1) / 2).sum\n        return count",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                map(reverse) += 1\n            } else {\n                map(i) = 1\n            }\n        }\n        var count = 0\n        for (i <- map.keys) {\n            if (map.contains(i.reverse)) {\n                count += map(i) * map(i.reverse)\n            }\n        }\n        count / 2",
    "        val map = new HashMap[String, Long]()\n        for (str <- test_list) {\n            val rev = str.reverse\n            if (map.contains(rev)) {\n                map(rev) += 1\n            } else {\n                map(rev) = 1\n            }\n        }\n        var count = 0L\n        for (str <- test_list) {\n            val rev = str.reverse\n            if (map.contains(str)) {\n                count += map(str)\n                map(rev) -= 1\n            }\n        }\n        count",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                map(reverse) += 1\n            } else {\n                map(reverse) = 1\n            }\n        }\n        var count = 0\n        for (i <- test_list) {\n            if (map.contains(i)) {\n                count += map(i)\n                map(i) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Long]()\n        for (i <- test_list) {\n            val rev = i.reverse\n            if (map.contains(rev)) map(rev) += 1\n            else map(rev) = 1\n        }\n        var count = 0L\n        for (i <- test_list) {\n            val rev = i.reverse\n            if (map.contains(i) && map(i) > 1) {\n                count += map(i) - 1\n                map(i) = 1\n            }\n            if (map.contains(rev) && map(rev) > 0) {\n                count += map(rev)\n                map(rev) = 0\n            }\n        }\n        count",
    "        val test_map = test_list.groupBy(x => x)\n        var count = 0L\n        for (x <- test_map) {\n            val reverse = x._1.reverse\n            if (test_map.contains(reverse)) {\n                count += x._2.length * test_map(reverse).length\n            }\n        }\n        count",
    "        val test_map = test_list.groupBy(x => x.reverse)\n        var count = 0\n        for (x <- test_map) {\n            if (x._2.length > 1) {\n                count += x._2.length * (x._2.length - 1) / 2\n            }\n        }\n        return count",
    "        val n = test_list.length\n        var count = 0\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val reverse_list = test_list.map(_.reverse)\n        val reverse_map = reverse_list.groupBy(identity).mapValues(_.size)\n        val count = test_list.map(reverse_map.getOrElse(_, 0)).sum\n        count",
    "        val test_map = test_list.groupBy(x => x)\n        val test_map_count = test_map.map(x => (x._1, x._2.length))\n        val test_map_count_reverse = test_map_count.map(x => (x._1.reverse, x._2))\n        var count = 0\n        for ((k, v) <- test_map_count) {\n            if (test_map_count_reverse.contains(k)) {\n                count += v * test_map_count_reverse(k)\n            }\n        }\n        count / 2",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (str <- test_list) {\n            val reverse = str.reverse\n            if (map.contains(reverse)) {\n                map(reverse) += 1\n            } else {\n                map(str) = 1\n            }\n        }\n        var count = 0\n        for (str <- test_list) {\n            val reverse = str.reverse\n            if (map.contains(reverse)) {\n                count += map(reverse)\n                map(reverse) = 0\n            }\n        }\n        count",
    "        val reverse_map = new HashMap[String, Int]\n        for (i <- 0 until test_list.length) {\n            val reverse_string = test_list(i).reverse\n            if (reverse_map.contains(reverse_string)) reverse_map(reverse_string) += 1\n            else reverse_map(reverse_string) = 1\n        }\n        var count = 0L\n        for (i <- 0 until test_list.length) {\n            val reverse_string = test_list(i).reverse\n            if (reverse_map.contains(reverse_string)) {\n                count += reverse_map(reverse_string)\n                reverse_map(reverse_string) = 0\n            }\n        }\n        count",
    "        val test_map = new HashMap[String, Int]()\n        for (i <- test_list) {\n            if (test_map.contains(i)) test_map(i) += 1\n            else test_map(i) = 1\n        }\n        var count = 0\n        for (i <- test_map.keys) {\n            val reverse = i.reverse\n            if (test_map.contains(reverse)) {\n                if (i == reverse) count += test_map(i) - 1\n                else count += test_map(i) * test_map(reverse)\n            }\n        }\n        count / 2",
    "        val map = new HashMap[String, Int]\n        for (str <- test_list) {\n            val reverse = str.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0L\n        for (str <- test_list) {\n            val reverse = str.reverse\n            if (map.contains(str)) count += map(str)\n            if (map.contains(reverse)) count += map(reverse)\n        }\n        count / 2",
    "        val test_list_rev = test_list.map(x => x.reverse)\n        val test_list_rev_set = test_list_rev.toSet\n        val test_list_set = test_list.toSet\n        val common_set = test_list_rev_set.intersect(test_list_set)\n        val common_list = common_set.toList\n        val common_list_count = common_list.map(x => test_list.count(_ == x))\n        val common_list_count_pairs = common_list_count.map(x => x * (x - 1) / 2)\n        common_list_count_pairs.sum",
    "        val test_map = new HashMap[String, Long]()\n        for (i <- test_list) {\n            val reverse_i = i.reverse\n            if (test_map.contains(reverse_i)) test_map(reverse_i) += 1\n            else test_map(i) = 1\n        }\n        var result = 0L\n        for (i <- test_map.keys) {\n            if (test_map.contains(i.reverse)) result += test_map(i) * test_map(i.reverse)\n        }\n        result",
    "        val map = new HashMap[String, Int]\n        for (s <- test_list) {\n            val reverse = s.reverse\n            if (map.contains(reverse)) {\n                map(reverse) += 1\n            } else {\n                map(reverse) = 1\n            }\n        }\n        var count = 0L\n        for (s <- test_list) {\n            if (map.contains(s)) {\n                count += map(s)\n                map(s) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (str <- test_list) {\n            val reverse = str.reverse\n            if (map.contains(reverse)) {\n                map(reverse) += 1\n            } else {\n                map(reverse) = 1\n            }\n        }\n        var count = 0L\n        for (str <- test_list) {\n            if (map.contains(str)) {\n                count += map(str)\n                map(str) = 0\n            }\n        }\n        count",
    "        val test_map = new HashMap[String, Int]\n        for (i <- test_list) {\n            val reverse_i = i.reverse\n            if (test_map.contains(reverse_i)) {\n                test_map(reverse_i) += 1\n            } else {\n                test_map += (reverse_i -> 1)\n            }\n        }\n        var count = 0L\n        for (i <- test_list) {\n            if (test_map.contains(i)) {\n                count += test_map(i)\n                test_map -= i\n            }\n        }\n        count",
    "        val test_map = test_list.groupBy(x => x)\n        var count = 0L\n        for (key <- test_map.keys) {\n            val reverse_key = key.reverse\n            if (test_map.contains(reverse_key)) {\n                count += test_map(key).size * test_map(reverse_key).size\n            }\n        }\n        return count",
    "        val map = new HashMap[String, Int]\n        for (s <- test_list) {\n            val reverse = s.reverse\n            if (map.contains(reverse)) {\n                map(reverse) += 1\n            } else {\n                map(reverse) = 1\n            }\n        }\n        var count = 0L\n        for (s <- test_list) {\n            if (map.contains(s)) {\n                count += map(s)\n                map(s) = 0\n            }\n        }\n        count",
    "        val test_map = new HashMap[String, Long]\n        for (i <- test_list) {\n            val rev_i = i.reverse\n            if (test_map.contains(rev_i)) test_map(rev_i) += 1\n            else test_map += (rev_i -> 1)\n        }\n        var count = 0L\n        for (i <- test_list) {\n            val rev_i = i.reverse\n            if (test_map.contains(i)) {\n                count += test_map(i)\n                test_map(i) = 0\n            }\n        }\n        count",
    "        val test_map = new HashMap[String, Int]()\n        for (i <- test_list) {\n            if (test_map.contains(i)) test_map(i) += 1\n            else test_map(i) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse_i = i.reverse\n            if (test_map.contains(reverse_i)) {\n                count += test_map(reverse_i)\n                test_map(reverse_i) = 0\n            }\n        }\n        count",
    "        val test_list_rev = test_list.map(_.reverse)\n        val test_list_rev_set = test_list_rev.toSet\n        var count = 0\n        for (i <- test_list) {\n            if (test_list_rev_set.contains(i)) count += 1\n        }\n        count / 2",
    "        val test_list_rev = test_list.map(x => x.reverse)\n        val test_list_rev_set = test_list_rev.toSet\n        val test_list_set = test_list.toSet\n        val common_set = test_list_rev_set.intersect(test_list_set)\n        val common_list = common_set.toList\n        val common_list_rev = common_list.map(x => x.reverse)\n        val common_list_rev_set = common_list_rev.toSet\n        val common_list_set = common_list.toSet\n        val common_list_rev_count = common_list_rev.groupBy(x => x).map(x => (x._1, x._2.length))\n        val common_list_count = common_list.groupBy(x => x).map(x => (x._1, x._2.length))\n        var count = 0L\n        for (x <- common_list_rev_count) {\n            if (common_list_count.contains(x._1)) {\n                count += x._2 * common_list_count(x._1)\n            }\n        }\n        count",
    "        val test_map = new HashMap[String, Int]()\n        for (test_str <- test_list) {\n            val reverse_str = test_str.reverse\n            if (test_map.contains(reverse_str)) {\n                test_map(reverse_str) += 1\n            } else {\n                test_map(reverse_str) = 1\n            }\n        }\n        var count = 0L\n        for (test_str <- test_list) {\n            val reverse_str = test_str.reverse\n            if (test_map.contains(test_str)) {\n                count += test_map(test_str)\n                test_map(test_str) = 0\n            }\n        }\n        count",
    "        val test_map = test_list.groupBy(x => x)\n        var count = 0\n        for (x <- test_map) {\n            if (x._2.length > 1) {\n                val reverse_string = x._1.reverse\n                if (test_map.contains(reverse_string)) {\n                    count += x._2.length * test_map(reverse_string).length\n                }\n            }\n        }\n        count",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val test_map = test_list.groupBy(x => x)\n        var count = 0\n        for ((k, v) <- test_map) {\n            val reverse_k = k.reverse\n            if (test_map.contains(reverse_k)) {\n                count += test_map(reverse_k).length\n            }\n        }\n        count / 2",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val test_map = test_list.groupBy(x => x)\n        var count = 0L\n        for ((k, v) <- test_map) {\n            if (v.length > 1) {\n                val reverse_string = k.reverse\n                if (test_map.contains(reverse_string)) {\n                    count += v.length * test_map(reverse_string).length\n                }\n            }\n        }\n        return count",
    "        val map = new HashMap[String, Long]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                map(reverse) += 1\n            } else {\n                map(i) = 1\n            }\n        }\n        var result = 0L\n        for (i <- map.keys) {\n            if (map.contains(i.reverse)) {\n                result += map(i) * map(i.reverse)\n            }\n        }\n        result",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val reverse_map = new HashMap[String, Int]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (reverse_map.contains(reverse)) {\n                reverse_map(reverse) += 1\n            } else {\n                reverse_map(reverse) = 1\n            }\n        }\n        var count = 0L\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (reverse_map.contains(i)) {\n                count += reverse_map(i)\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            val rev = i.reverse\n            if (map.contains(rev)) map(rev) += 1\n            else map(rev) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val rev = i.reverse\n            if (map.contains(i)) count += map(i)\n        }\n        count / 2",
    "        val test_map = new HashMap[String, Int]\n        for (test_string <- test_list) {\n            if (test_map.contains(test_string)) test_map(test_string) += 1\n            else test_map(test_string) = 1\n        }\n        var count = 0L\n        for (test_string <- test_list) {\n            val reverse_string = test_string.reverse\n            if (test_map.contains(reverse_string)) {\n                count += test_map(reverse_string)\n                test_map(reverse_string) = 0\n            }\n        }\n        count",
    "        val test_map = test_list.groupBy(x => x)\n        var count = 0\n        for (x <- test_map) {\n            val key = x._1\n            val value = x._2\n            val reverse_key = key.reverse\n            if (test_map.contains(reverse_key)) {\n                val reverse_value = test_map(reverse_key)\n                count += value.length * reverse_value.length\n            }\n        }\n        return count",
    "        val test_map = test_list.groupBy(x => x)\n        var count = 0L\n        for (x <- test_map.keys) {\n            val reverse = x.reverse\n            if (test_map.contains(reverse)) {\n                count += test_map(reverse).length\n            }\n        }\n        count",
    "        val reverse_map = new HashMap[String, Int]\n        for (s <- test_list) {\n            val reverse = s.reverse\n            if (reverse_map.contains(reverse)) reverse_map(reverse) += 1\n            else reverse_map(reverse) = 1\n        }\n        var count = 0L\n        for (s <- test_list) {\n            val reverse = s.reverse\n            if (reverse_map.contains(reverse)) {\n                count += reverse_map(reverse)\n                reverse_map(reverse) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map += (i -> 1)\n        }\n        var count = 0L\n        for (i <- map.keys) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) count += map(i) * map(reverse)\n        }\n        count / 2",
    "        val map = new HashMap[String, Int]\n        for (i <- 0 until test_list.length) {\n            val reverse = test_list(i).reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0L\n        for (i <- 0 until test_list.length) {\n            val reverse = test_list(i).reverse\n            if (map.contains(reverse)) {\n                count += map(reverse)\n                map(reverse) = 0\n            }\n        }\n        count",
    "        val test_map = new HashMap[String, Int]\n        for (i <- test_list) {\n            if (test_map.contains(i)) test_map(i) += 1\n            else test_map(i) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (test_map.contains(reverse)) {\n                count += test_map(reverse)\n                test_map(reverse) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (s <- test_list) {\n            val reverse = s.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0L\n        for (s <- test_list) {\n            val reverse = s.reverse\n            if (map.contains(s)) {\n                count += map(s)\n                map(s) = 0\n            }\n        }\n        count",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                map(reverse) += 1\n            } else {\n                map(i) = 1\n            }\n        }\n        var count = 0\n        for (i <- map.keys) {\n            if (map.contains(i.reverse)) {\n                count += map(i) * map(i.reverse)\n            }\n        }\n        count / 2",
    "        val test_map = HashMap[String, Int]()\n        for (i <- test_list) {\n            if (test_map.contains(i)) test_map(i) += 1\n            else test_map(i) = 1\n        }\n        var count = 0L\n        for (i <- test_map.keys) {\n            val reverse = i.reverse\n            if (test_map.contains(reverse)) {\n                if (reverse == i) count += (test_map(i) * (test_map(i) - 1)) / 2\n                else count += test_map(i) * test_map(reverse)\n            }\n        }\n        count",
    "        var count = 0L\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val test_map = test_list.groupBy(x => x).mapValues(x => x.length)\n        val reverse_map = test_map.map(x => (x._1.reverse, x._2))\n        val result = test_map.map(x => reverse_map.getOrElse(x._1, 0) * x._2).sum\n        result",
    "        val map = new HashMap[String, Long]\n        for (str <- test_list) {\n            val reverse = str.reverse\n            if (map.contains(reverse)) {\n                map(reverse) += 1\n            } else {\n                map(reverse) = 1\n            }\n        }\n        var count = 0L\n        for (str <- test_list) {\n            val reverse = str.reverse\n            if (map.contains(str)) {\n                count += map(str)\n                map(reverse) -= 1\n                if (map(reverse) == 0) map.remove(reverse)\n            }\n        }\n        count",
    "        val test_map = new HashMap[String, Int]\n        for (i <- test_list) {\n            val reverse_string = i.reverse\n            if (test_map.contains(reverse_string)) {\n                test_map(reverse_string) += 1\n            } else {\n                test_map(i) = 1\n            }\n        }\n        var count = 0\n        for (i <- test_map.keys) {\n            if (test_map.contains(i.reverse)) {\n                count += test_map(i.reverse)\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            val rev = i.reverse\n            if (map.contains(rev)) {\n                map(rev) += 1\n            } else {\n                map(rev) = 1\n            }\n        }\n        var count = 0\n        for (i <- test_list) {\n            val rev = i.reverse\n            if (map.contains(i)) {\n                count += map(i)\n                map(rev) -= 1\n            }\n        }\n        count / 2",
    "        val map = new HashMap[String, Long]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var count = 0L\n        for (i <- map.keys) {\n            if (map.contains(i)) {\n                count += map(i) * map(i.reverse)\n                map -= i\n            }\n        }\n        count",
    "        val test_map = new HashMap[String, Int]\n        for (i <- test_list) {\n            if (test_map.contains(i)) test_map(i) += 1\n            else test_map(i) = 1\n        }\n        var count = 0\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (test_map.contains(reverse)) {\n                count += test_map(reverse)\n                test_map(reverse) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Long]()\n        for (s <- test_list) {\n            val reverse = s.reverse\n            if (map.contains(reverse)) {\n                map(reverse) += 1\n            } else {\n                map(reverse) = 1\n            }\n        }\n        var count = 0L\n        for (s <- test_list) {\n            val reverse = s.reverse\n            if (map.contains(s)) {\n                count += map(s)\n                map(s) = 0\n            }\n        }\n        count",
    "        val map = new HashMap[String, Long]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) map(reverse) += 1\n            else map(reverse) = 1\n        }\n        var result = 0L\n        for (i <- map) {\n            if (i._2 > 1) result += (i._2 * (i._2 - 1)) / 2\n        }\n        result",
    "        val test_map = new HashMap[String, Long]\n        for (i <- test_list) {\n            val reverse_string = i.reverse\n            if (test_map.contains(reverse_string)) {\n                test_map(reverse_string) += 1\n            } else {\n                test_map(i) = 0\n            }\n        }\n        var count = 0L\n        for (i <- test_map.keys) {\n            count += test_map(i)\n        }\n        count",
    "        val test_list_length = test_list.length\n        var count = 0\n        for (i <- 0 until test_list_length) {\n            for (j <- i + 1 until test_list_length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- map.keys) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                count += map(i) * map(reverse)\n                map(reverse) = 0\n            }\n        }\n        count",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val test_map = new HashMap[String, Int]\n        for (i <- test_list) {\n            if (test_map.contains(i)) test_map(i) += 1\n            else test_map(i) = 1\n        }\n        var count = 0L\n        for (i <- test_map.keys) {\n            if (test_map.contains(i.reverse)) {\n                if (i == i.reverse) count += test_map(i) * (test_map(i) - 1) / 2\n                else count += test_map(i) * test_map(i.reverse)\n            }\n        }\n        count",
    "        val test_map = new HashMap[String, Int]()\n        for (i <- test_list) {\n            if (!test_map.contains(i)) test_map(i) = 0\n            test_map(i) += 1\n        }\n        var count = 0L\n        for (i <- test_map.keys) {\n            val reverse = i.reverse\n            if (test_map.contains(reverse)) count += test_map(i) * test_map(reverse)\n        }\n        count / 2",
    "        val test_list_length = test_list.length\n        var count = 0\n        for (i <- 0 until test_list_length) {\n            for (j <- i + 1 until test_list_length) {\n                if (test_list(i) == test_list(j).reverse) {\n                    count += 1\n                }\n            }\n        }\n        count",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val test_map = new HashMap[String, Int]()\n        for (i <- 0 until test_list.length) {\n            val reverse = test_list(i).reverse\n            if (test_map.contains(reverse)) test_map(reverse) += 1\n            else test_map += (reverse -> 1)\n        }\n        var count = 0L\n        for (i <- 0 until test_list.length) {\n            if (test_map.contains(test_list(i))) {\n                count += test_map(test_list(i))\n                test_map -= test_list(i)\n            }\n        }\n        count",
    "        val reverse_list = test_list.map(x => x.reverse)\n        val reverse_set = reverse_list.toSet\n        val reverse_map = new HashMap[String, Int]\n        for (i <- reverse_set) {\n            reverse_map(i) = 0\n        }\n        for (i <- reverse_list) {\n            reverse_map(i) += 1\n        }\n        var count = 0\n        for (i <- reverse_map) {\n            if (i._2 > 1) {\n                count += i._2 * (i._2 - 1) / 2\n            }\n        }\n        count",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        return count",
    "        val map = HashMap[String, Int]()\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- map.keys) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                if (i == reverse) count += map(i) * (map(i) - 1)\n                else count += map(i) * map(reverse)\n            }\n        }\n        count / 2",
    "        val n = test_list.size\n        var count = 0\n        for (i <- 0 until n) {\n            for (j <- i + 1 until n) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val test_map = test_list.groupBy(x => x)\n        var count = 0\n        for (x <- test_map) {\n            val reverse = x._1.reverse\n            if (test_map.contains(reverse)) {\n                count += x._2.length * test_map(reverse).length\n            }\n        }\n        count",
    "        val reverse_map = new HashMap[String, Int]\n        for (i <- 0 until test_list.length) {\n            val reverse = test_list(i).reverse\n            if (reverse_map.contains(reverse)) reverse_map(reverse) += 1\n            else reverse_map(reverse) = 1\n        }\n        var count = 0L\n        for (i <- 0 until test_list.length) {\n            val reverse = test_list(i).reverse\n            if (reverse_map.contains(reverse)) {\n                count += reverse_map(reverse)\n                reverse_map(reverse) = 0\n            }\n        }\n        count",
    "        val test_set = test_list.toSet\n        var count = 0\n        for (i <- test_set) {\n            val reverse = i.reverse\n            if (test_set.contains(reverse)) count += 1\n        }\n        count / 2",
    "        val map = new HashMap[String, Long]\n        for (i <- test_list) {\n            val reverse = i.reverse\n            if (map.contains(reverse)) {\n                map(reverse) += 1\n            } else {\n                map(i) = 1\n            }\n        }\n        var count = 0L\n        for (i <- map.keys) {\n            if (map.contains(i.reverse)) {\n                count += map(i) * map(i.reverse)\n            }\n        }\n        count",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val reverse_list = test_list.map(x => x.reverse)\n        val reverse_set = reverse_list.toSet\n        val count_map = new HashMap[String, Int]()\n        for (x <- reverse_list) {\n            if (count_map.contains(x)) count_map(x) += 1\n            else count_map(x) = 1\n        }\n        var count = 0L\n        for (x <- test_list) {\n            if (reverse_set.contains(x)) {\n                count += count_map(x.reverse)\n                count_map(x.reverse) = 0\n            }\n        }\n        count",
    "        var count = 0\n        for (i <- 0 until test_list.length) {\n            for (j <- i + 1 until test_list.length) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val map = new HashMap[String, Int]()\n        for (i <- test_list) {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n        var count = 0\n        for (i <- map.keys) {\n            if (map.contains(i.reverse)) {\n                count += map(i) * map(i.reverse)\n            }\n        }\n        count / 2",
    "        // Write your code here\n        val reversed_list = test_list.map(x => x.reverse)\n        val reversed_list_set = reversed_list.toSet\n        var count = 0\n        for (i <- 0 until test_list.length) {\n            if (reversed_list_set.contains(test_list(i))) {\n                count += 1\n            }\n        }\n        count / 2",
    "        val map = new HashMap[String, Int]\n        for (i <- test_list) {\n            val rev = i.reverse\n            if (map.contains(rev)) {\n                map(rev) += 1\n            } else {\n                map(rev) = 1\n            }\n        }\n        var result = 0L\n        for (i <- test_list) {\n            if (map.contains(i)) {\n                result += map(i)\n                map(i) = 0\n            }\n        }\n        result",
    "        val test_map = test_list.groupBy(x => x)\n        var count = 0\n        for ((k, v) <- test_map) {\n            if (v.length > 1) {\n                count += v.length * (v.length - 1) / 2\n            }\n        }\n        return count",
    "        val test_map = new HashMap[String, Long]()\n        for (i <- test_list) {\n            val reverse_string = i.reverse\n            if (test_map.contains(reverse_string)) test_map(reverse_string) += 1\n            else test_map += reverse_string -> 1\n        }\n        var count = 0L\n        for (i <- test_map.values) {\n            count += i * (i - 1) / 2\n        }\n        count",
    "        val reverse_map = new HashMap[String, Int]()\n        for (str <- test_list) {\n            val reverse_str = str.reverse\n            if (reverse_map.contains(reverse_str)) reverse_map(reverse_str) += 1\n            else reverse_map(reverse_str) = 1\n        }\n        var count = 0L\n        for (str <- test_list) {\n            val reverse_str = str.reverse\n            if (reverse_map.contains(str)) {\n                count += reverse_map(str)\n                reverse_map(str) = 0\n            }\n        }\n        count",
    "        val reverse_map = new HashMap[String, Int]\n        for (s <- test_list) {\n            val reverse = s.reverse\n            if (reverse_map.contains(reverse)) reverse_map(reverse) += 1\n            else reverse_map(reverse) = 1\n        }\n        var count = 0L\n        for (s <- test_list) {\n            val reverse = s.reverse\n            if (reverse_map.contains(reverse)) {\n                count += reverse_map(reverse)\n                reverse_map(reverse) = 0\n            }\n        }\n        count",
    "        val test_list_sorted = test_list.sorted\n        val test_list_sorted_reverse = test_list_sorted.map(x => x.reverse)\n        var count = 0\n        for (i <- 0 until test_list_sorted.length) {\n            if (test_list_sorted(i) == test_list_sorted_reverse(i)) count += 1\n        }\n        count",
    "        val test_list_size = test_list.size\n        var count = 0\n        for (i <- 0 until test_list_size - 1) {\n            for (j <- i + 1 until test_list_size) {\n                if (test_list(i) == test_list(j).reverse) count += 1\n            }\n        }\n        count",
    "        val map = new HashMap[String, Long]()\n        for (i <- test_list) {\n            val rev = i.reverse\n            if (map.contains(rev)) {\n                map(rev) += 1\n            } else {\n                map(rev) = 1\n            }\n        }\n        var count = 0L\n        for (i <- test_list) {\n            if (map.contains(i)) {\n                count += map(i)\n                map(i) = 0\n            }\n        }\n        count",
    "        val test_list_rev = test_list.map(x => x.reverse)\n        val test_list_rev_set = test_list_rev.toSet\n        var count = 0\n        for (i <- 0 until test_list.length) {\n            if (test_list_rev_set.contains(test_list(i))) count += 1\n        }\n        count / 2"
  ]
}