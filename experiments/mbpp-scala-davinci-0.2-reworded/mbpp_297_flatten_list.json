{
  "name": "mbpp_297_flatten_list",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to flatten a given nested list structure.\n    def flattenList(list1 : Any) : List[Long] = {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_297_flatten_list.py",
  "prompt_terminology": "reworded",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(flattenList((Any(0l, 10l, List[Long](20l.toLong, 30l.toLong), 40l, 50l, List[Long](60l.toLong, 70l.toLong, 80l.toLong), List[Long](90l.toLong, 100l.toLong, 110l.toLong, 120l.toLong)))).equals((List[Long](0l.toLong, 10l.toLong, 20l.toLong, 30l.toLong, 40l.toLong, 50l.toLong, 60l.toLong, 70l.toLong, 80l.toLong, 90l.toLong, 100l.toLong, 110l.toLong, 120l.toLong))));\n    assert(flattenList((Any(List[Long](10l.toLong, 20l.toLong), List[Long](40l.toLong), List[Long](30l.toLong, 56l.toLong, 25l.toLong), List[Long](10l.toLong, 20l.toLong), List[Long](33l.toLong), List[Long](40l.toLong)))).equals((List[Long](10l.toLong, 20l.toLong, 40l.toLong, 30l.toLong, 56l.toLong, 25l.toLong, 10l.toLong, 20l.toLong, 33l.toLong, 40l.toLong))));\n    assert(flattenList((Any(List[Long](1l.toLong, 2l.toLong, 3l.toLong), List[Long](4l.toLong, 5l.toLong, 6l.toLong), List[Long](10l.toLong, 11l.toLong, 12l.toLong), List[Long](7l.toLong, 8l.toLong, 9l.toLong)))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 10l.toLong, 11l.toLong, 12l.toLong, 7l.toLong, 8l.toLong, 9l.toLong))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        list1 match {\n            case Nil => Nil\n            case x :: xs => x match {\n                case y : List[Any] => flattenList(y) ::: flattenList(xs)\n                case y : Long => y :: flattenList(xs)\n            }\n        }",
    "        list1 match {\n            case list : List[Any] => list.flatMap(flattenList)\n            case x : Long => List(x)\n            case _ => List()\n        }",
    "        var list2 = List[Long]()\n        list1 match {\n            case x : List[Any] => x.foreach(x => list2 = list2 ::: flattenList(x))\n            case x : Long => list2 = list2 :+ x\n        }\n        list2",
    "        list1 match {\n            case list : List[Any] => list.flatMap(flattenList)\n            case num : Long => List(num)\n            case _ => List()\n        }",
    "        list1 match {\n            case list: List[Any] => list.flatMap(flattenList)\n            case element: Long => List(element)\n        }",
    "        list1 match {\n            case Nil => Nil\n            case (x : Long) :: xs => x :: flattenList(xs)\n            case (x : List[Any]) :: xs => flattenList(x) ::: flattenList(xs)\n        }",
    "        var list2 = List[Long]()\n        list1 match {\n            case list : List[Any] => {\n                for (i <- list) {\n                    list2 = list2 ::: flattenList(i)\n                }\n            }\n            case num : Long => {\n                list2 = list2 :+ num\n            }\n            case _ => {\n                println(\"error\")\n            }\n        }\n        return list2",
    "        list1 match {\n            case list : List[Any] => list.flatMap(flattenList)\n            case x : Long => List(x)\n            case _ => List()\n        }",
    "        var list2 : List[Long] = List()\n        list1 match {\n            case list : List[Any] => {\n                for (i <- list) {\n                    list2 = list2 ::: flattenList(i)\n                }\n            }\n            case num : Long => {\n                list2 = list2 :+ num\n            }\n        }\n        list2",
    "        list1 match {\n            case list : List[Any] => list.flatMap(flattenList)\n            case x : Long => List(x)\n            case _ => List()\n        }",
    "        list1 match {\n            case list : List[Any] => list.flatMap(flattenList)\n            case x : Long => List(x)\n        }",
    "        var list = List[Long]()\n        list1 match {\n            case l : List[Any] => {\n                for (i <- l) {\n                    list = list ::: flattenList(i)\n                }\n            }\n            case i : Int => list = list ::: List(i.toLong)\n            case i : Long => list = list ::: List(i)\n            case i : Double => list = list ::: List(i.toLong)\n            case i : Float => list = list ::: List(i.toLong)\n            case i : Char => list = list ::: List(i.toLong)\n            case i : Byte => list = list ::: List(i.toLong)\n            case i : Short => list = list ::: List(i.toLong)\n            case i : String => list = list ::: List(i.toLong)\n            case _ => list = list ::: List(0)\n        }\n        list",
    "        list1 match {\n            case list : List[Any] => list.flatMap(flattenList)\n            case x : Long => List(x)\n            case _ => List()\n        }",
    "        list1 match {\n            case list : List[Any] => list.flatMap(flattenList)\n            case x : Long => List(x)\n            case _ => List()\n        }",
    "        list1 match {\n            case list : List[Any] => list.flatMap(flattenList)\n            case x : Long => List(x)\n            case _ => List()\n        }",
    "        var list2 = List[Long]()\n        list1 match {\n            case Nil => list2\n            case (x : Int) :: xs => list2 = list2 :+ x.toLong\n            case (x : Long) :: xs => list2 = list2 :+ x\n            case (x : List[Any]) :: xs => list2 = list2 ::: flattenList(x)\n            case _ => list2\n        }\n        list2",
    "        list1 match {\n            case list : List[Any] => list.flatMap(flattenList)\n            case x : Long => List(x)\n            case _ => List()\n        }",
    "        var list2 = List[Long]()\n        list1 match {\n            case list : List[Any] => {\n                for (element <- list) {\n                    list2 = list2 ::: flattenList(element)\n                }\n            }\n            case element : Long => {\n                list2 = list2 :+ element\n            }\n        }\n        return list2",
    "        var list2 : List[Long] = List()\n        list1 match {\n            case list : List[Any] => {\n                for (x <- list) {\n                    list2 = list2 ::: flattenList(x)\n                }\n            }\n            case x : Long => list2 = list2 :+ x\n        }\n        list2",
    "        list1 match {\n            case Nil => Nil\n            case (x:List[Any]) :: tail => flattenList(x) ::: flattenList(tail)\n            case x :: tail => x :: flattenList(tail)\n        }"
  ]
}