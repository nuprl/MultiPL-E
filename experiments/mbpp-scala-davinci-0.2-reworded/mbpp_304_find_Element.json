{
  "name": "mbpp_304_find_Element",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a scalathon function to find element at a given index after number of rotations.\n    def findElement(arr : List[Long], ranges : List[List[Long]], rotations : Long, index : Long) : Long = {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_304_find_Element.py",
  "prompt_terminology": "reworded",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(findElement((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)), (List[List[Long]](List[Long](0l.toLong, 2l.toLong), List[Long](0l.toLong, 3l.toLong))), (2l), (1l)) == (3l));\n    assert(findElement((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)), (List[List[Long]](List[Long](0l.toLong, 1l.toLong), List[Long](0l.toLong, 2l.toLong))), (1l), (2l)) == (3l));\n    assert(findElement((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong)), (List[List[Long]](List[Long](0l.toLong, 1l.toLong), List[Long](0l.toLong, 2l.toLong))), (1l), (1l)) == (1l));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        val len = arr.length\n        val newIndex = (index + rotations) % len\n        arr(newIndex.toInt)",
    "        val n = arr.length\n        val r = rotations % n\n        val i = (index + r) % n\n        arr(i.toInt)",
    "        val n = arr.length\n        val r = rotations % n\n        val i = (index + r) % n\n        arr(i.toInt)",
    "        val n = arr.length\n        val r = rotations % n\n        val i = (index + r) % n\n        arr(i.toInt)",
    "        val n = arr.length\n        val r = rotations % n\n        val i = (index - r + n) % n\n        arr(i.toInt)",
    "        val n = arr.length\n        val r = rotations % n\n        val i = (index + n - r) % n\n        arr(i.toInt)",
    "        val n = arr.length\n        val r = rotations % n\n        val i = (index - r + n) % n\n        arr(i.toInt)",
    "        val n = arr.length\n        val r = rotations % n\n        val i = (index - r + n) % n\n        arr(i.toInt)",
    "        val n = arr.length\n        val r = rotations % n\n        val i = (index + r) % n\n        arr(i.toInt)",
    "        val n = arr.length\n        val r = rotations % n\n        val i = (index - r + n) % n\n        arr(i.toInt)",
    "        val n = arr.length\n        val r = rotations % n\n        val i = (index - r + n) % n\n        arr(i.toInt)",
    "        val n = arr.length\n        val r = rotations % n\n        val i = index % n\n        val j = (i + r) % n\n        arr(j.toInt)",
    "        val n = arr.length\n        val r = rotations % n\n        val i = index - r\n        if (i < 0) arr(n + i) else arr(i)",
    "        val n = arr.length\n        val r = rotations % n\n        val i = (index - r + n) % n\n        arr(i.toInt)",
    "        val n = arr.length\n        val r = rotations % n\n        val i = (index - r + n) % n\n        arr(i.toInt)",
    "        val n = arr.length\n        val r = rotations % n\n        val i = (index - r + n) % n\n        arr(i.toInt)",
    "        val n = arr.length\n        val newIndex = (index + rotations) % n\n        arr(newIndex.toInt)",
    "        val n = arr.length\n        val r = rotations % n\n        val i = index - r\n        if (i < 0) arr(n + i) else arr(i.toInt)",
    "        var newArr = arr\n        for (i <- 0 until rotations.toInt) {\n            newArr = rotate(newArr, ranges(i.toInt))\n        }\n        newArr(index.toInt)",
    "        val n = arr.length\n        val r = rotations % n\n        val i = index % n\n        if (r == 0) arr(i.toInt)\n        else if (r > i) arr((i + n - r).toInt)\n        else arr((i - r).toInt)"
  ]
}