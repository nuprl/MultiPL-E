{
  "name": "mbpp_578_interleave_lists",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to interleave 3 lists of the same length into a single flat list.\n    def interleaveLists(list1 : List[Long], list2 : List[Long], list3 : List[Long]) : List[Long] = {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_578_interleave_lists.py",
  "prompt_terminology": "reworded",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(interleaveLists((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 7l.toLong)), (List[Long](10l.toLong, 20l.toLong, 30l.toLong, 40l.toLong, 50l.toLong, 60l.toLong, 70l.toLong)), (List[Long](100l.toLong, 200l.toLong, 300l.toLong, 400l.toLong, 500l.toLong, 600l.toLong, 700l.toLong))).equals((List[Long](1l.toLong, 10l.toLong, 100l.toLong, 2l.toLong, 20l.toLong, 200l.toLong, 3l.toLong, 30l.toLong, 300l.toLong, 4l.toLong, 40l.toLong, 400l.toLong, 5l.toLong, 50l.toLong, 500l.toLong, 6l.toLong, 60l.toLong, 600l.toLong, 7l.toLong, 70l.toLong, 700l.toLong))));\n    assert(interleaveLists((List[Long](10l.toLong, 20l.toLong)), (List[Long](15l.toLong, 2l.toLong)), (List[Long](5l.toLong, 10l.toLong))).equals((List[Long](10l.toLong, 15l.toLong, 5l.toLong, 20l.toLong, 2l.toLong, 10l.toLong))));\n    assert(interleaveLists((List[Long](11l.toLong, 44l.toLong)), (List[Long](10l.toLong, 15l.toLong)), (List[Long](20l.toLong, 5l.toLong))).equals((List[Long](11l.toLong, 10l.toLong, 20l.toLong, 44l.toLong, 15l.toLong, 5l.toLong))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        val result = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            result += list1(i)\n            result += list2(i)\n            result += list3(i)\n        }\n        result.toList",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        def interleaveListsHelper(list1 : List[Long], list2 : List[Long], list3 : List[Long], result : List[Long]) : List[Long] = {\n            if (list1.isEmpty) result\n            else interleaveListsHelper(list1.tail, list2.tail, list3.tail, result :+ list1.head :+ list2.head :+ list3.head)\n        }\n        interleaveListsHelper(list1, list2, list3, List())",
    "        if (list1.isEmpty) Nil\n        else list1.head :: list2.head :: list3.head :: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        val list = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            list += list1(i)\n            list += list2(i)\n            list += list3(i)\n        }\n        list.toList",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i)\n            result = result :+ list2(i)\n            result = result :+ list3(i)\n        }\n        result",
    "        if (list1.length != list2.length || list2.length != list3.length) throw new IllegalArgumentException(\"Lists must be the same length\")\n        val result = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            result += list1(i)\n            result += list2(i)\n            result += list3(i)\n        }\n        result.toList",
    "        if (list1.length == 0) Nil\n        else List(list1.head, list2.head, list3.head) ::: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        if (list1.isEmpty) Nil\n        else List(list1.head, list2.head, list3.head) ::: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        if (list1.isEmpty) Nil\n        else list1.head :: list2.head :: list3.head :: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i)\n            result = result :+ list2(i)\n            result = result :+ list3(i)\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        if (list1.length != list2.length || list2.length != list3.length) throw new IllegalArgumentException(\"Lists must be of equal length\")\n        val result = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            result += list1(i)\n            result += list2(i)\n            result += list3(i)\n        }\n        result.toList",
    "        if (list1.isEmpty) Nil\n        else list1.head :: list2.head :: list3.head :: interleaveLists(list1.tail, list2.tail, list3.tail)",
    "        if (list1.length != list2.length || list2.length != list3.length) {\n            throw new IllegalArgumentException(\"All lists must be of the same length\")\n        }\n        val result = new ListBuffer[Long]\n        for (i <- 0 until list1.length) {\n            result += list1(i)\n            result += list2(i)\n            result += list3(i)\n        }\n        result.toList",
    "        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result",
    "        if (list1.length != list2.length || list2.length != list3.length) {\n            throw new IllegalArgumentException(\"Lists must be of equal length\")\n        }\n        var result = List[Long]()\n        for (i <- 0 until list1.length) {\n            result = result :+ list1(i) :+ list2(i) :+ list3(i)\n        }\n        result"
  ]
}