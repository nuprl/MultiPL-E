{
  "name": "mbpp_272_rear_extract",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function that takes in a list of tuples and returns a list containing the rear element of each tuple.\n    def rearExtract(test_list : List[Either[String, Long]]) : List[Long] = {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_272_rear_extract.py",
  "prompt_terminology": "reworded",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(rearExtract((List[Either[String, Long]]((1l, \"Rash\", 21l), (2l, \"Varsha\", 20l), (3l, \"Kil\", 19l)))).equals((List[Long](21l.toLong, 20l.toLong, 19l.toLong))));\n    assert(rearExtract((List[Either[String, Long]]((1l, \"Sai\", 36l), (2l, \"Ayesha\", 25l), (3l, \"Salman\", 45l)))).equals((List[Long](36l.toLong, 25l.toLong, 45l.toLong))));\n    assert(rearExtract((List[Either[String, Long]]((1l, \"Sudeep\", 14l), (2l, \"Vandana\", 36l), (3l, \"Dawood\", 56l)))).equals((List[Long](14l.toLong, 36l.toLong, 56l.toLong))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        test_list.map(x => x.right.getOrElse(0))",
    "        test_list.map(x => x.right.getOrElse(0))",
    "        test_list.map(x => x match {\n            case Left(x) => 0\n            case Right(x) => x\n        })",
    "        test_list.map(x => x.right.get)",
    "        test_list.map(x => x match {\n            case Left(x) => 0\n            case Right(x) => x\n        })",
    "        test_list.map(x => x.right.get)",
    "        var result = List[Long]()\n        for (i <- test_list) {\n            i match {\n                case Right(x) => result = result :+ x\n                case _ =>\n            }\n        }\n        return result",
    "        test_list.map(x => x.right.getOrElse(0))",
    "        test_list.map(x => x.right.get)",
    "        var rear_list : List[Long] = List()\n        for (i <- test_list) {\n            i match {\n                case Left(s) => rear_list = rear_list :+ s.toLong\n                case Right(l) => rear_list = rear_list :+ l\n            }\n        }\n        return rear_list",
    "        var result = List[Long]()\n        for (i <- test_list) {\n            i match {\n                case Left(s) => result = result :+ 0\n                case Right(l) => result = result :+ l\n            }\n        }\n        return result",
    "        test_list.map(x => x match {\n            case Left(a) => 0\n            case Right(b) => b\n        })",
    "        test_list.map(x => x.right.get)",
    "        test_list.map(x => x.right.get)",
    "        var result : List[Long] = List()\n        for (i <- test_list) {\n            i match {\n                case Left(s) => result = result :+ s.toLong\n                case Right(s) => result = result :+ s\n            }\n        }\n        return result",
    "        test_list.map(x => x match {\n            case Left(x) => 0\n            case Right(x) => x\n        })",
    "        test_list.map(x => x match {\n            case Left(x) => 0\n            case Right(x) => x\n        })",
    "        test_list.map(x => x.right.get)",
    "        test_list.map(x => x match {\n            case Left(x) => 0\n            case Right(x) => x\n        })",
    "        test_list.map(x => x match {\n            case Left(x) => 0\n            case Right(x) => x\n        })"
  ]
}