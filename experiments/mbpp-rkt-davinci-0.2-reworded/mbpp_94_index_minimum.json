{
  "name": "mbpp_94_index_minimum",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Given a list of lists, write a function that returns the first value of the list with the smallest second value.\n(define (index_minimum test_list)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_94_index_minimum.py",
  "prompt_terminology": "reworded",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate index_minimum))\n    (check-equal? (candidate (list (list \"Rash\" 143) (list \"Manjeet\" 200) (list \"Varsha\" 100))) \"Varsha\")\n    (check-equal? (candidate (list (list \"Yash\" 185) (list \"Dawood\" 125) (list \"Sanya\" 175))) \"Dawood\")\n    (check-equal? (candidate (list (list \"Sai\" 345) (list \"Salman\" 145) (list \"Ayesha\" 96))) \"Ayesha\")\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (cond\n    [(empty? test_list) #f]\n    [(empty? (rest test_list)) 0]\n    [else\n     (let* ([min_index (index_minimum (rest test_list))]\n            [min_value (list-ref (rest test_list) min_index)]\n            [cur_value (list-ref test_list 1)])\n       (if (&lt; cur_value min_value)\n           0\n           (+ min_index 1)))]))\n",
    "  (let loop ((test_list test_list)\n             (min_index 0)\n             (min_value (cadr (car test_list))))\n    (cond ((null? test_list) min_index)\n          ((&lt; (cadr (car test_list)) min_value)\n           (loop (cdr test_list)\n                 (add1 min_index)\n                 (cadr (car test_list))))\n          (else (loop (cdr test_list)\n                      min_index\n                      min_value)))))\n</code>\n",
    "  (cond\n    [(empty? test_list) empty]\n    [else\n     (let* ([min_index (index_minimum (rest test_list))]\n            [min_value (if (empty? min_index) empty (second (list-ref test_list min_index)))]\n            [current_value (second (first test_list))])\n       (if (empty? min_index)\n           0\n           (if (< current_value min_value)\n               0\n               (+ 1 min_index))))]))\n",
    "  (let ([min_index (apply min (map second test_list))])\n    (find min_index test_list)))\n",
    "  (cond\n    [(empty? test_list) '()]\n    [(empty? (rest test_list)) (first test_list)]\n    [else\n     (let* ([first_list (first test_list)]\n            [second_list (first (rest test_list))]\n            [first_second (second first_list)]\n            [second_second (second second_list)])\n       (if (< first_second second_second)\n           first_list\n           (index_minimum (rest test_list))))]))\n",
    "  (let loop ([index 0] [min_index 0] [min_value (second (list-ref test_list 0))])\n    (if (= index (length test_list))\n        min_index\n        (let ([new_value (second (list-ref test_list index))])\n          (if (< new_value min_value)\n              (loop (+ index 1) index new_value)\n              (loop (+ index 1) min_index min_value))))))\n",
    "  (cond\n    [(null? test_list) (error \"index_minimum: empty list\")]\n    [(null? (cdr test_list)) (car test_list)]\n    [else\n     (let* ([first_pair (car test_list)]\n            [first_value (car first_pair)]\n            [first_index (cdr first_pair)]\n            [second_pair (index_minimum (cdr test_list))]\n            [second_value (car second_pair)]\n            [second_index (cdr second_pair)])\n       (if (< first_index second_index)\n           first_pair\n           second_pair))]))\n",
    "  (let ([min_index (apply min (map second test_list))])\n    (filter (lambda (x) (= (second x) min_index)) test_list)))\n",
    "  (cond\n    [(empty? test_list) (error \"empty list\")]\n    [(null? (cdr test_list)) (car test_list)]\n    [else (let ([min (index_minimum (cdr test_list))])\n            (if (< (cadr min) (cadr (car test_list)))\n                min\n                (car test_list)))]))\n",
    "  (let ([min_index (apply min (map second test_list))])\n    (find-first (lambda (x) (= (second x) min_index)) test_list)))\n",
    "  (let loop ([test_list test_list]\n             [min_index 0]\n             [min_value (second (car test_list))])\n    (cond [(null? test_list) min_index]\n          [(< min_value (second (car test_list)))\n           (loop (cdr test_list)\n                 (add1 min_index)\n                 min_value)]\n          [else (loop (cdr test_list)\n                      min_index\n                      (second (car test_list)))])))\n",
    "  (cond\n    [(empty? test_list) (error \"empty list\")]\n    [else (index_minimum_helper test_list (first test_list) 0)]))\n",
    "  (cond\n    [(empty? test_list) '()]\n    [(empty? (rest test_list)) (first test_list)]\n    [else\n     (let*\n         ([first_list (first test_list)]\n          [first_list_second_value (second first_list)]\n          [rest_list (rest test_list)]\n          [rest_list_minimum (index_minimum rest_list)]\n          [rest_list_minimum_second_value (second rest_list_minimum)])\n       (if (< first_list_second_value rest_list_minimum_second_value)\n           first_list\n           rest_list_minimum))]))\n",
    "  (let ([min_index (index_minimum_helper test_list 0 0)])\n    (list-ref test_list min_index)))\n",
    "  (let ((min_index 0)\n        (min_value (cadr (car test_list))))\n    (for ([(index value) (in-indexed test_list)])\n      (when (< value min_value)\n        (set! min_index index)\n        (set! min_value value)))\n    min_index))\n",
    "  (cond\n    [(null? test_list) #f]\n    [(null? (cdr test_list)) (car test_list)]\n    [else (if (&lt; (cadr (car test_list)) (cadr (cadr test_list)))\n             (car test_list)\n             (index_minimum (cdr test_list)))]))\n</code>\n",
    "  (cond\n    [(empty? test_list) '()]\n    [else (index_minimum_helper test_list (first test_list) 0)]))\n",
    "  (let ([min_index (apply min (map second test_list))])\n    (filter (lambda (x) (= (second x) min_index)) test_list)))\n",
    "  (let ([min_index (index_minimum_helper test_list 0)])\n    (list-ref test_list min_index)))\n",
    "  (cond\n    [(empty? test_list) empty]\n    [else\n     (let* ([first_item (first test_list)]\n            [first_item_second (second first_item)]\n            [rest_of_list (rest test_list)]\n            [rest_of_list_minimum (index_minimum rest_of_list)])\n       (if (empty? rest_of_list_minimum)\n           first_item\n           (let* ([rest_of_list_minimum_second (second rest_of_list_minimum)])\n             (if (< first_item_second rest_of_list_minimum_second)\n                 first_item\n                 rest_of_list_minimum))))]))\n"
  ]
}