{
  "name": "mbpp_126_sum",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a rktthon function to find the sum of common divisors of two given numbers.\n(define (sum a b)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_126_sum.py",
  "prompt_terminology": "reworded",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sum))\n    (check-equal? (candidate 10 15) 6)\n    (check-equal? (candidate 100 150) 93)\n    (check-equal? (candidate 4 6) 3)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (gcd a b)\n    (if (= b 0)\n        a\n        (gcd b (remainder a b))))\n  (define (divisors n)\n    (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n      (if (zero? (remainder n i))\n          i)))\n  (define (common-divisors a b)\n    (for/list ([i (in-range 1 (add1 (quotient (gcd a b) 2)))])\n      (if (zero? (remainder (gcd a b) i))\n          i)))\n  (apply + (common-divisors a b)))\n",
    "  (define (divisors n)\n    (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n      (if (zero? (modulo n i)) i)))\n  (define (common-divisors a b)\n    (for/list ([i (in-range 1 (add1 (quotient (min a b) 2)))])\n      (if (and (zero? (modulo a i)) (zero? (modulo b i))) i)))\n  (apply + (common-divisors a b)))\n",
    "  (define (divisors n)\n    (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n      (if (zero? (modulo n i)) i)))\n  (for/sum ([i (in-range 1 (add1 (quotient (min a b) 2)))])\n    (if (zero? (modulo a i)) i)))\n",
    "  (define (gcd a b)\n    (if (= b 0)\n        a\n        (gcd b (remainder a b))))\n  (define (lcm a b)\n    (/ (* a b) (gcd a b)))\n  (define (sum-divisors n)\n    (define (iter i sum)\n      (if (= i n)\n          sum\n          (if (= (remainder n i) 0)\n              (iter (+ i 1) (+ sum i))\n              (iter (+ i 1) sum))))\n    (iter 1 0))\n  (+ (sum-divisors (lcm a b)) (sum-divisors (gcd a b))))\n",
    "  (define (divisors n)\n    (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n      (if (zero? (modulo n i)) i)))\n  (apply + (intersection (divisors a) (divisors b))))\n",
    "  (define (gcd a b)\n    (if (= b 0)\n        a\n        (gcd b (remainder a b))))\n  (define (divisors n)\n    (define (iter i)\n      (if (= i n)\n          (list n)\n          (if (= (remainder n i) 0)\n              (cons i (iter (+ i 1)))\n              (iter (+ i 1)))))\n    (iter 1))\n  (define (common-divisors a b)\n    (define (iter lst)\n      (if (null? lst)\n          (list)\n          (if (member (car lst) (divisors b))\n              (cons (car lst) (iter (cdr lst)))\n              (iter (cdr lst)))))\n    (iter (divisors a)))\n  (apply + (common-divisors a b)))\n",
    "  (let ([lst (list a b)])\n    (for/sum ([i (in-range 1 (apply min lst))])\n      (if (and (= (modulo (car lst) i) 0)\n               (= (modulo (cadr lst) i) 0))\n          i\n          0))))\n",
    "  (define (gcd a b)\n    (if (= b 0)\n        a\n        (gcd b (remainder a b))))\n  (define (divisors n)\n    (define (divisors-iter n i)\n      (if (= i n)\n          '()\n          (if (= (remainder n i) 0)\n              (cons i (divisors-iter n (+ i 1)))\n              (divisors-iter n (+ i 1)))))\n    (divisors-iter n 1))\n  (define (sum-divisors n)\n    (define (sum-divisors-iter n divs)\n      (if (null? divs)\n          0\n          (+ (car divs) (sum-divisors-iter n (cdr divs)))))\n    (sum-divisors-iter n (divisors n)))\n  (+ (sum-divisors (gcd a b)) (sum-divisors (/ a (gcd a b))) (sum-divisors (/ b (gcd a b)))))\n</code>\n",
    "  (define (divisors n)\n    (for/list ([i (in-range 1 n)])\n      (if (zero? (modulo n i)) i)))\n  (apply + (intersection (divisors a) (divisors b))))\n",
    "  (define (gcd a b)\n    (if (= b 0)\n        a\n        (gcd b (remainder a b))))\n  (define (lcm a b)\n    (/ (* a b) (gcd a b)))\n  (define (sum-divisors n)\n    (define (sum-divisors-iter i sum)\n      (if (= i n)\n          sum\n          (if (= (remainder n i) 0)\n              (sum-divisors-iter (+ i 1) (+ sum i))\n              (sum-divisors-iter (+ i 1) sum))))\n    (sum-divisors-iter 1 0))\n  (+ (sum-divisors (lcm a b)) (sum-divisors (gcd a b))))\n",
    "  (define (divisors n)\n    (for/list ([i (in-range 1 n)])\n      (if (zero? (modulo n i)) i)))\n  (apply + (intersection (divisors a) (divisors b))))\n",
    "  (define (divisors n)\n    (define (divisors-iter n i)\n      (if (= i n)\n          '()\n          (if (= (modulo n i) 0)\n              (cons i (divisors-iter n (+ i 1)))\n              (divisors-iter n (+ i 1)))))\n    (divisors-iter n 1))\n  (define (common-divisors a b)\n    (define (common-divisors-iter a b lst)\n      (if (null? lst)\n          '()\n          (if (and (member (car lst) a) (member (car lst) b))\n              (cons (car lst) (common-divisors-iter a b (cdr lst)))\n              (common-divisors-iter a b (cdr lst)))))\n    (common-divisors-iter a b (divisors (+ a b))))\n  (define (sum-list lst)\n    (if (null? lst)\n        0\n        (+ (car lst) (sum-list (cdr lst)))))\n  (sum-list (common-divisors a b)))\n",
    "  (define (gcd a b)\n    (if (= b 0)\n        a\n        (gcd b (remainder a b))))\n  (define (lcm a b)\n    (/ (* a b) (gcd a b)))\n  (define (sum-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (= (remainder n i) 0)\n            i)))\n    (apply + (divisors n)))\n  (sum-divisors (lcm a b)))\n",
    "  (define (divisors a)\n    (define (divisors-iter a b)\n      (if (= b a)\n          (list a)\n          (if (= (remainder a b) 0)\n              (cons b (divisors-iter a (+ b 1)))\n              (divisors-iter a (+ b 1)))))\n    (divisors-iter a 1))\n  (define (common a b)\n    (cond ((null? a) '())\n          ((member (car a) b) (cons (car a) (common (cdr a) b)))\n          (else (common (cdr a) b))))\n  (define (sum-iter a)\n    (if (null? a)\n        0\n        (+ (car a) (sum-iter (cdr a)))))\n  (sum-iter (common (divisors a) (divisors b))))\n",
    "  (define (divisors n)\n    (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n      (if (zero? (modulo n i)) i)))\n  (apply + (intersection (divisors a) (divisors b))))\n",
    "  (define (divisors n)\n    (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n      (if (zero? (modulo n i)) i)))\n  (apply + (intersection (divisors a) (divisors b))))\n",
    "  (define (divisors n)\n    (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n      (if (zero? (modulo n i)) i)))\n  (apply + (intersection (divisors a) (divisors b))))\n",
    "  (define (divisors n)\n    (for/list ([i (in-range 1 n)])\n      (if (zero? (modulo n i)) i)))\n  (define (common-divisors a b)\n    (for/list ([i (in-range 1 (min a b))])\n      (if (zero? (modulo a i)) i)))\n  (apply + (common-divisors a b)))\n",
    "  (define (divisors n)\n    (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n      (if (zero? (modulo n i)) i)))\n  (apply + (intersection (divisors a) (divisors b))))\n",
    "  (define (divisors n)\n    (for/list ([i (in-range 1 n)]\n               #:when (zero? (modulo n i)))\n      i))\n  (define (common-divisors a b)\n    (for/list ([i (in-range 1 (min a b))]\n               #:when (and (member i (divisors a))\n                           (member i (divisors b))))\n      i))\n  (apply + (common-divisors a b)))\n"
  ]
}