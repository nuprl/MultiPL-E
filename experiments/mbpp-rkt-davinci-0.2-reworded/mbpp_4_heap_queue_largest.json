{
  "name": "mbpp_4_heap_queue_largest",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to find the n largest integers from a given list of numbers, returned in descending order.\n(define (heap_queue_largest nums n)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_4_heap_queue_largest.py",
  "prompt_terminology": "reworded",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate heap_queue_largest))\n    (check-equal? (candidate (list 25 35 22 85 14 65 75 22 58) 3) (list 85 75 65))\n    (check-equal? (candidate (list 25 35 22 85 14 65 75 22 58) 2) (list 85 75))\n    (check-equal? (candidate (list 25 35 22 85 14 65 75 22 58) 5) (list 85 75 65 58 35))\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (heap_queue_largest_iter nums n acc)\n    (if (= n 0)\n        acc\n        (heap_queue_largest_iter (remove (max nums) nums) (- n 1) (cons (max nums) acc))))\n  (heap_queue_largest_iter nums n '()))\n",
    "  (define (heap_queue_largest_iter nums n result)\n    (if (zero? n)\n        result\n        (heap_queue_largest_iter (remove-max nums) (- n 1) (cons (max nums) result))))\n  (heap_queue_largest_iter nums n '()))\n",
    "  (define (heap_queue_largest_helper nums n result)\n    (if (or (= n 0) (null? nums))\n        result\n        (heap_queue_largest_helper (cdr nums) (- n 1) (cons (car nums) result))))\n  (heap_queue_largest_helper nums n '()))\n",
    "  (define (heap_queue_largest-helper nums n result)\n    (if (or (zero? n) (null? nums))\n        result\n        (heap_queue_largest-helper (cdr nums) (- n 1) (cons (car nums) result))))\n  (heap_queue_largest-helper nums n '()))\n",
    "  (define (heap_queue_largest_helper nums n heap)\n    (if (zero? n)\n        (reverse heap)\n        (heap_queue_largest_helper (cdr nums) (- n 1) (cons (heap-max heap) (heap-delete-max heap)))))\n  (heap_queue_largest_helper nums n (heap-build nums)))\n",
    "  (define (heap_queue_largest-helper nums n)\n    (if (empty? nums)\n        '()\n        (let* ([max (max (first nums) (apply max (rest nums)))]\n               [rest (filter (lambda (x) (not (= x max))) nums)])\n          (cons max (heap_queue_largest-helper rest (- n 1))))))\n  (heap_queue_largest-helper nums n))\n",
    "  (define (heap_queue_largest_helper nums n result)\n    (if (or (= n 0) (null? nums))\n        result\n        (heap_queue_largest_helper (cdr nums) (- n 1) (cons (car nums) result))))\n  (heap_queue_largest_helper nums n '()))\n",
    "  (define (heap_queue_largest_helper nums n result)\n    (if (= n 0)\n        result\n        (heap_queue_largest_helper (remove (max nums) nums) (- n 1) (cons (max nums) result))))\n  (heap_queue_largest_helper nums n '()))\n",
    "  (define (heap-queue-largest-helper nums n)\n    (if (empty? nums)\n        '()\n        (let ([max (max (first nums) (heap-queue-largest-helper (rest nums) n))])\n          (if (= n 1)\n              (list max)\n              (cons max (heap-queue-largest-helper (rest nums) (- n 1)))))))\n  (heap-queue-largest-helper nums n))\n",
    "  (define (heap_queue_largest-helper nums n)\n    (if (= n 0)\n        '()\n        (let ([max (apply max nums)])\n          (cons max (heap_queue_largest-helper (remove max nums) (- n 1))))))\n  (heap_queue_largest-helper nums n))\n",
    "  (define (heap_queue_largest_helper nums n acc)\n    (cond\n      [(empty? nums) (reverse acc)]\n      [(> n 0) (heap_queue_largest_helper (rest nums) (- n 1) (cons (first nums) acc))]\n      [else (heap_queue_largest_helper (rest nums) n acc)]))\n  (heap_queue_largest_helper nums n '()))\n",
    "  (define (heap-queue-largest-helper nums n hq)\n    (if (zero? n)\n        (reverse (heap-queue->list hq))\n        (heap-queue-largest-helper (cdr nums) (- n 1) (heap-queue-enqueue hq (car nums)))))\n  (heap-queue-largest-helper nums n (make-heap-queue <)))\n",
    "  (define (heap_queue_largest_helper nums n result)\n    (if (zero? n)\n        result\n        (heap_queue_largest_helper (rest nums) (- n 1) (cons (max (first nums) (first result)) (rest result)))))\n  (heap_queue_largest_helper nums n (list (first nums))))\n",
    "  (define (heap_queue_largest_helper nums n result)\n    (if (or (= n 0) (null? nums))\n        result\n        (heap_queue_largest_helper (cdr nums) (- n 1) (cons (car nums) result))))\n  (heap_queue_largest_helper nums n '()))\n",
    "  (define (heap_queue_largest-helper nums n result)\n    (if (or (= n 0) (null? nums))\n        result\n        (heap_queue_largest-helper (cdr nums) (- n 1) (cons (car nums) result))))\n  (heap_queue_largest-helper nums n '()))\n",
    "  (define (heapify nums)\n    (define (heapify-helper nums i)\n      (define (swap nums i j)\n        (define (swap-helper nums i j)\n          (if (= i j)\n              nums\n              (begin\n                (define temp (list-ref nums i))\n                (set-car! (list-ref nums i) (list-ref nums j))\n                (set-car! (list-ref nums j) temp)\n                (swap-helper nums (add1 i) (add1 j)))))\n        (swap-helper nums i j))\n      (define (heapify-helper-helper nums i)\n        (if (&lt; i (quotient (length nums) 2))\n            (begin\n              (define left (add1 (* 2 i)))\n              (define right (add1 (* 2 i 1)))\n              (if (&gt; (list-ref nums left) (list-ref nums i))\n                  (set! nums (swap nums i left))\n                  (void))\n              (if (&gt; (list-ref nums right) (list-ref nums i))\n                  (set! nums (swap nums i right))\n                  (void))\n              (heapify-helper-helper nums (add1 i)))\n            (void)))\n      (heapify-helper-helper nums i)\n      nums)\n    (heapify-helper nums 0))\n  (define (heap_queue_largest-helper nums n)\n    (if (= n 0)\n        '()\n        (begin\n          (define temp (list-ref nums 0))\n          (set-car! (list-ref nums 0) (list-ref nums (- (length nums) 1)))\n          (set-car! (list-ref nums (- (length nums) 1)) temp)\n          (set! nums (heapify (sublist nums 0 (- (length nums) 1))))\n          (cons temp (heap_queue_largest-helper nums (sub1 n))))",
    "  (define (heap-queue-largest-helper nums n)\n    (if (zero? n)\n        '()\n        (let ([max (apply max nums)])\n          (cons max (heap-queue-largest-helper (remove max nums) (- n 1))))))\n  (heap-queue-largest-helper nums n))\n",
    "  (define (heap_queue_largest_helper nums n result)\n    (if (or (null? nums) (= n 0))\n        result\n        (let* ([max (apply max nums)]\n               [rest (remove max nums)])\n          (heap_queue_largest_helper rest (- n 1) (cons max result)))))\n  (heap_queue_largest_helper nums n '()))\n",
    "  (define (heap-queue-largest-helper nums n)\n    (if (empty? nums)\n        '()\n        (let ((max (max-heap-dequeue (max-heap nums))))\n          (cons max (heap-queue-largest-helper (remove max nums) (- n 1))))))\n  (heap-queue-largest-helper nums n))\n",
    "  (define (heapify lst)\n    (define (heapify-helper lst i)\n      (define (swap lst i j)\n        (define (swap-helper lst i j)\n          (if (= i j)\n              lst\n              (begin\n                (define temp (list-ref lst i))\n                (set-car! (list-ref lst i) (list-ref lst j))\n                (set-car! (list-ref lst j) temp)\n                (swap-helper lst (+ i 1) (+ j 1)))))\n      (if (= i (length lst))\n          lst\n          (begin\n            (define left-child (+ i (* 2 1)))\n            (define right-child (+ i (* 2 2)))\n            (define largest (if (&gt; (list-ref lst left-child) (list-ref lst right-child))\n                                left-child\n                                right-child))\n            (if (&gt; (list-ref lst largest) (list-ref lst i))\n                (heapify-helper (swap lst i largest) largest)\n                (heapify-helper lst (+ i 1))))))\n    (heapify-helper lst 0))\n  (define (heap_queue_largest-helper nums n)\n    (if (= n 0)\n        '()\n        (begin\n          (define temp (list-ref nums 0))\n          (set-car! (list-ref nums 0) (list-ref nums (- (length nums) 1)))\n          (set-car! (list-ref nums (- (length nums) 1)) temp)\n          (define new-nums (heapify (sublist nums 0 (- (length nums) 1))))\n          (cons temp (heap_queue_largest-helper new-nums (- n 1))))))\n  (heap_queue_largest-helper (heapify nums) n))\n</code>\nI'm not sure if this is the best way to do it, but it works.\n\n\nA:\n\nI think this is a good solution.  It's a little"
  ]
}