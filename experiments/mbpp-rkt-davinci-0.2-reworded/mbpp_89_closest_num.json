{
  "name": "mbpp_89_closest_num",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to find the closest smaller number than n.\n(define (closest_num N)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_89_closest_num.py",
  "prompt_terminology": "reworded",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_num))\n    (check-equal? (candidate 11) 10)\n    (check-equal? (candidate 7) 6)\n    (check-equal? (candidate 12) 11)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (closest_num_iter N i)\n    (if (and (not (zero? (remainder N i)))\n             (not (zero? (remainder (sub1 N) i))))\n        (closest_num_iter N (add1 i))\n        i))\n  (closest_num_iter N 2))\n",
    "  (define (closest_num_iter N i)\n    (if (not (integer? (/ N i)))\n        (closest_num_iter N (+ i 1))\n        i))\n  (closest_num_iter N 2))\n",
    "  (define (closest_num_iter N i)\n    (cond\n      [(= N i) i]\n      [(< N i) (closest_num_iter N (- i 1))]\n      [else (closest_num_iter N (+ i 1))]))\n  (closest_num_iter N 0))\n",
    "  (define (closest_num_iter N i)\n    (cond\n      [(= i 0) (error \"no smaller number\")]\n      [(= N (expt 2 i)) (closest_num_iter N (- i 1))]\n      [else i]))\n  (closest_num_iter N (quotient N 2)))\n",
    "  (define (closest_num_iter N i)\n    (cond\n      [(= i N) N]\n      [(= (remainder N i) 0) i]\n      [else (closest_num_iter N (+ i 1))]))\n  (closest_num_iter N 1))\n",
    "  (define (closest_num_iter N i)\n    (if (= N i)\n        (closest_num_iter N (- i 1))\n        (if (= (modulo N i) 0)\n            i\n            (closest_num_iter N (- i 1)))))\n  (closest_num_iter N N))\n",
    "  (if (zero? N)\n      0\n      (if (zero? (remainder N 2))\n          (closest_num (- N 1))\n          (closest_num (/ N 2)))))\n",
    "  (let loop ([n N])\n    (if (zero? n)\n        0\n        (if (integer? (sqrt n))\n            (loop (- n 1))\n            n))))\n",
    "  (define (closest_num_iter N i)\n    (cond\n      [(= i 0) 0]\n      [(= (modulo N i) 0) i]\n      [else (closest_num_iter N (- i 1))]))\n  (closest_num_iter N (- N 1)))\n",
    "  (cond\n    [(= N 1) 0]\n    [(= N 0) 0]\n    [(= N 2) 1]\n    [(= N 3) 2]\n    [(= N 4) 3]\n    [(= N 5) 4]\n    [(= N 6) 5]\n    [(= N 7) 6]\n    [(= N 8) 7]\n    [(= N 9) 8]\n    [(= N 10) 9]\n    [(= N 11) 10]\n    [(= N 12) 11]\n    [(= N 13) 12]\n    [(= N 14) 13]\n    [(= N 15) 14]\n    [(= N 16) 15]\n    [(= N 17) 16]\n    [(= N 18) 17]\n    [(= N 19) 18]\n    [(= N 20) 19]\n    [(= N 21) 20]\n    [(= N 22) 21]\n    [(= N 23) 22]\n    [(= N 24) 23]\n    [(= N 25) 24]\n    [(= N 26) 25]\n    [(= N 27) 26]\n    [(= N 28) 27]\n    [(= N 29) 28]\n    [(= N 30) 29]\n    [(= N 31) 30]\n    [(= N 32) 31]\n    [(= N 33) 32]\n    [(= N 34) 33]\n    [(= N 35) 34]\n    [(= N 36) 35]\n    [(= N 37) 36]\n    [(= N 38) 37]\n    [(= N 39) 38]\n    [(= N 40) 39]\n    [(= N 41) 40]\n    [(= N 42) 41]\n    [(= N 43) 42]\n    [(= N 44) 43]\n    [(= N 45) 44]\n    [(= N 46) 45]\n    [(= N 47) 46]\n    [(= N 48) 47]\n    [(= N 49) 48]\n    [(= N 50) 49]\n    [(= N 51) 50]\n    [(= N 52) 51]\n    [(= N 53) 52]\n    [(= N 54) 53]\n    [(= N 55) 54]\n    [(=",
    "  (if (zero? N)\n      0\n      (if (zero? (remainder N 2))\n          (closest_num (sub1 N))\n          (sub1 N))))\n",
    "  (define (closest_num_iter N i)\n    (if (not (integer? (/ N i)))\n        (closest_num_iter N (+ i 1))\n        i))\n  (closest_num_iter N 2))\n",
    "  (define (closest_num_iter N i)\n    (if (and (integer? (/ N i)) (integer? (/ N (+ i 1))))\n        i\n        (closest_num_iter N (+ i 1))))\n  (closest_num_iter N 1))\n",
    "  (let loop ([n N])\n    (if (zero? n)\n        0\n        (if (zero? (remainder n 2))\n            (loop (quotient n 2))\n            (sub1 n)))))\n",
    "  (let loop ([i (- N 1)] [j N])\n    (if (and (integer? (/ i j)) (integer? (/ j i)))\n        i\n        (loop (- i 1) j))))\n",
    "  (define (closest_num_iter N i)\n    (if (= N i)\n        N\n        (if (= (remainder N i) 0)\n            (closest_num_iter N (+ i 1))\n            i)))\n  (closest_num_iter N 1))\n",
    "  (let loop ([n N] [i (- N 1)])\n    (if (and (not (zero? i))\n             (not (zero? (modulo N i))))\n        (loop N (- i 1))\n        i)))\n",
    "  (define (iter n)\n    (if (= n 0)\n        0\n        (if (= (remainder n 2) 0)\n            (iter (/ n 2))\n            (iter (- n 1)))))\n  (iter N))\n",
    "  (define (closest_num_iter N i)\n    (if (and (positive? N) (positive? i))\n        (if (and (positive? (remainder N i)) (positive? (remainder (- N 1) i)))\n            (closest_num_iter N (+ i 1))\n            (- N (remainder N i)))\n        (error \"N must be a positive number\")))\n  (closest_num_iter N 1))\n",
    "  (define (closest_num_iter N i)\n    (if (and (integer? (/ N i)) (integer? (/ N (+ i 1))))\n        i\n        (closest_num_iter N (+ i 1))))\n  (closest_num_iter N 1))\n"
  ]
}