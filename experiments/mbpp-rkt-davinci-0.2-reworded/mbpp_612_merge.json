{
  "name": "mbpp_612_merge",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a rktthon function which takes a list of lists, where each sublist has two elements, and returns a list of two lists where the first list has the first element of each sublist and the second one has the second.\n(define (merge lst)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_612_merge.py",
  "prompt_terminology": "reworded",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate merge))\n    (check-equal? (candidate (list (list \"x\" \"y\") (list \"a\" \"b\") (list \"m\" \"n\"))) (list (list \"x\" \"a\" \"m\") (list \"y\" \"b\" \"n\")))\n    (check-equal? (candidate (list (list 1 2) (list 3 4) (list 5 6) (list 7 8))) (list (list 1 3 5 7) (list 2 4 6 8)))\n    (check-equal? (candidate (list (list \"x\" \"y\" \"z\") (list \"a\" \"b\" \"c\") (list \"m\" \"n\" \"o\"))) (list (list \"x\" \"a\" \"m\") (list \"y\" \"b\" \"n\") (list \"z\" \"c\" \"o\")))\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (list (map first lst) (map second lst)))\n",
    "  (define (merge-helper lst1 lst2)\n    (cond ((null? lst1) lst2)\n          ((null? lst2) lst1)\n          (else (cons (car lst1) (cons (car lst2) (merge-helper (cdr lst1) (cdr lst2)))))))\n  (merge-helper (map car lst) (map cadr lst)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (let ([lst1 (map first lst)]\n        [lst2 (map second lst)])\n    (list lst1 lst2)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (let loop ([lst lst] [lst1 '()] [lst2 '()])\n    (cond [(empty? lst) (list lst1 lst2)]\n          [else (loop (rest lst) (cons (first (first lst)) lst1) (cons (second (first lst)) lst2))])))\n",
    "  (let ([l1 (map first lst)]\n        [l2 (map second lst)])\n    (list l1 l2)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (if (null? lst)\n      '()\n      (cons (map car lst) (cons (map cadr lst) '()))))\n",
    "  (if (null? lst)\n      '()\n      (cons (list (car (car lst)) (car (cdr (car lst))))\n            (merge (cdr lst)))))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (list (map car lst) (map cadr lst)))\n",
    "  (define (merge-helper lst1 lst2)\n    (cond\n      [(empty? lst1) lst2]\n      [(empty? lst2) lst1]\n      [else (cons (car lst1) (cons (car lst2) (merge-helper (cdr lst1) (cdr lst2))))]))\n  (merge-helper (map car lst) (map cadr lst)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (let ([lst1 (map first lst)]\n        [lst2 (map second lst)])\n    (list lst1 lst2)))\n",
    "  (let ([lst1 (map car lst)]\n        [lst2 (map cadr lst)])\n    (list lst1 lst2)))\n",
    "  (list (map (lambda (x) (car x)) lst)\n        (map (lambda (x) (cadr x)) lst)))\n",
    "  (apply append (map list (map first lst) (map second lst))))\n",
    "  (list (map first lst) (map second lst)))\n"
  ]
}