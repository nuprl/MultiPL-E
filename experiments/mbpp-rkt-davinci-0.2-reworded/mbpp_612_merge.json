{
  "name": "mbpp_612_merge",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a rktthon function which takes a list of lists, where each sublist has two elements, and returns a list of two lists where the first list has the first element of each sublist and the second one has the second.\n(define (merge lst)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_612_merge.py",
  "prompt_terminology": "reworded",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate merge))\n    (check-equal? (candidate (list (list \"x\" \"y\") (list \"a\" \"b\") (list \"m\" \"n\"))) (list (list \"x\" \"a\" \"m\") (list \"y\" \"b\" \"n\")))\n    (check-equal? (candidate (list (list 1 2) (list 3 4) (list 5 6) (list 7 8))) (list (list 1 3 5 7) (list 2 4 6 8)))\n    (check-equal? (candidate (list (list \"x\" \"y\" \"z\") (list \"a\" \"b\" \"c\") (list \"m\" \"n\" \"o\"))) (list (list \"x\" \"a\" \"m\") (list \"y\" \"b\" \"n\") (list \"z\" \"c\" \"o\")))\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (list (map first lst) (map second lst)))\n",
    "  (define (merge-helper lst1 lst2)\n    (cond ((null? lst1) lst2)\n          ((null? lst2) lst1)\n          (else (cons (car lst1) (cons (car lst2) (merge-helper (cdr lst1) (cdr lst2)))))))\n  (merge-helper (map car lst) (map cadr lst)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (let ([lst1 (map first lst)]\n        [lst2 (map second lst)])\n    (list lst1 lst2)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (let loop ([lst lst] [lst1 '()] [lst2 '()])\n    (cond [(empty? lst) (list lst1 lst2)]\n          [else (loop (rest lst) (cons (first (first lst)) lst1) (cons (second (first lst)) lst2))])))\n",
    "  (let ([l1 (map first lst)]\n        [l2 (map second lst)])\n    (list l1 l2)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (if (null? lst)\n      '()\n      (cons (map car lst) (cons (map cadr lst) '()))))\n",
    "  (if (null? lst)\n      '()\n      (cons (list (car (car lst)) (car (cdr (car lst))))\n            (merge (cdr lst)))))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (list (map car lst) (map cadr lst)))\n",
    "  (define (merge-helper lst1 lst2)\n    (cond\n      [(empty? lst1) lst2]\n      [(empty? lst2) lst1]\n      [else (cons (car lst1) (cons (car lst2) (merge-helper (cdr lst1) (cdr lst2))))]))\n  (merge-helper (map car lst) (map cadr lst)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (let ([lst1 (map first lst)]\n        [lst2 (map second lst)])\n    (list lst1 lst2)))\n",
    "  (let ([lst1 (map car lst)]\n        [lst2 (map cadr lst)])\n    (list lst1 lst2)))\n",
    "  (list (map (lambda (x) (car x)) lst)\n        (map (lambda (x) (cadr x)) lst)))\n",
    "  (apply append (map list (map first lst) (map second lst))))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (let ([first (map car lst)]\n        [second (map cadr lst)])\n    (list first second)))\n",
    "  (define (merge-helper lst1 lst2)\n    (if (null? lst1)\n        lst2\n        (cons (car lst1) (merge-helper (cdr lst1) lst2))))\n  (merge-helper (map car lst) (map cadr lst)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (map list lst))\n",
    "  (if (null? lst)\n      '()\n      (cons (map first lst)\n            (cons (map second lst)\n                  '()))))\n",
    "  (let ([lst1 (map first lst)]\n        [lst2 (map second lst)])\n    (list lst1 lst2)))\n",
    "  (let ([first (map car lst)]\n        [second (map cadr lst)])\n    (list first second)))\n",
    "  (let ([firsts (map first lst)]\n        [seconds (map second lst)])\n    (list firsts seconds)))\n",
    "  (if (null? lst)\n      (list '() '())\n      (let* ([first (car lst)]\n             [rest (cdr lst)]\n             [merged (merge rest)]\n             [first-lst (car merged)]\n             [second-lst (cadr merged)])\n        (list (cons (car first) first-lst)\n              (cons (cadr first) second-lst)))))\n",
    "  (define (merge-helper lst1 lst2)\n    (if (null? lst1)\n        lst2\n        (cons (car lst1) (merge-helper (cdr lst1) lst2))))\n  (merge-helper (map car lst) (map cadr lst)))\n",
    "  (list (map (lambda (x) (car x)) lst)\n        (map (lambda (x) (cadr x)) lst)))\n",
    "  (let ([l1 (map car lst)]\n        [l2 (map cadr lst)])\n    (list l1 l2)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (list (map first lst)\n        (map second lst)))\n",
    "  (let ([first (map car lst)]\n        [second (map cadr lst)])\n    (list first second)))\n",
    "  (let ([first (map car lst)]\n        [second (map cadr lst)])\n    (list first second)))\n",
    "  (apply append (map list lst)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (let ([lst1 (map first lst)]\n        [lst2 (map second lst)])\n    (list lst1 lst2)))\n",
    "  (map list lst))\n",
    "  (map (lambda (x) (list (car x) (cadr x))) lst))\n",
    "  (map (lambda (x) (list (car x) (cadr x))) lst))\n",
    "  (list (map first lst)\n        (map second lst)))\n",
    "  (let loop ((lst lst)\n             (l1 '())\n             (l2 '()))\n    (if (null? lst)\n        (list l1 l2)\n        (loop (cdr lst)\n              (cons (car (car lst)) l1)\n              (cons (cadr (car lst)) l2)))))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (let loop ([lst lst] [lst1 '()] [lst2 '()])\n    (if (null? lst)\n        (list lst1 lst2)\n        (loop (cdr lst)\n              (cons (caar lst) lst1)\n              (cons (cadar lst) lst2)))))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (map (lambda (x) (list (car x) (cadr x))) lst))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (if (null? lst)\n      (list '() '())\n      (let* ([first (car lst)]\n             [rest (cdr lst)]\n             [merged (merge rest)]\n             [first-elements (car merged)]\n             [second-elements (cadr merged)])\n        (list (cons (car first) first-elements)\n              (cons (cadr first) second-elements)))))\n",
    "  (map list lst))\n",
    "  (map (lambda (x) (list (car x) (cadr x))) lst))\n",
    "  (define (merge-helper lst1 lst2)\n    (if (null? lst1)\n        lst2\n        (cons (car lst1) (merge-helper (cdr lst1) lst2))))\n  (merge-helper (map car lst) (map cadr lst)))\n",
    "  (apply append (map list lst)))\n",
    "  (apply append (map (lambda (x) (list (car x) (cadr x))) lst)))\n",
    "  (apply append (map list lst)))\n",
    "  (if (null? lst)\n      (list '() '())\n      (let ((first (car lst))\n            (rest (cdr lst)))\n        (let ((first-first (car first))\n              (first-rest (cdr first)))\n          (let ((rest-first (car (merge rest)))\n                (rest-rest (cdr (merge rest))))\n            (list (cons first-first rest-first)\n                  (cons first-rest rest-rest)))))))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (map (lambda (x) (list (car x) (cadr x))) lst))\n",
    "  (define (merge-iter lst1 lst2)\n    (cond\n      [(empty? lst1) lst2]\n      [(empty? lst2) lst1]\n      [(< (car lst1) (car lst2)) (cons (car lst1) (merge-iter (cdr lst1) lst2))]\n      [else (cons (car lst2) (merge-iter lst1 (cdr lst2)))]))\n  (define (split lst)\n    (cond\n      [(empty? lst) (values empty empty)]\n      [(empty? (cdr lst)) (values (list (car lst)) empty)]\n      [else (let-values ([(l1 l2) (split (cdr (cdr lst)))])\n              (values (cons (car lst) l1) (cons (cadr lst) l2)))]))\n  (define (merge-sort lst)\n    (cond\n      [(empty? lst) empty]\n      [(empty? (cdr lst)) lst]\n      [else (let-values ([(l1 l2) (split lst)])\n              (merge-iter (merge-sort l1) (merge-sort l2)))]))\n  (merge-sort lst))\n",
    "  (define (merge-helper lst1 lst2)\n    (if (null? lst1)\n        lst2\n        (cons (car lst1) (merge-helper (cdr lst1) lst2))))\n  (merge-helper (map car lst) (map cadr lst)))\n",
    "  (let ([lst1 (map first lst)]\n        [lst2 (map second lst)])\n    (list lst1 lst2)))\n",
    "  (map list lst))\n",
    "  (apply append (map list lst)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (list (map (lambda (x) (car x)) lst)\n        (map (lambda (x) (cadr x)) lst)))\n",
    "  (let loop ([lst lst] [lst1 '()] [lst2 '()])\n    (cond [(empty? lst) (list lst1 lst2)]\n          [else (loop (rest lst)\n                      (append lst1 (list (first (first lst))))\n                      (append lst2 (list (second (first lst)))))])))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (let loop ([lst lst] [l1 '()] [l2 '()])\n    (cond [(empty? lst) (list l1 l2)]\n          [else (let ([e (first lst)])\n                  (loop (rest lst) (cons (first e) l1) (cons (second e) l2)))])))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (let ([firsts (map first lst)]\n        [seconds (map second lst)])\n    (list firsts seconds)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (if (null? lst)\n      '()\n      (let ([first (car lst)]\n            [rest (cdr lst)])\n        (list (map car lst)\n              (map cadr lst)))))\n",
    "  (let ([l1 (map first lst)]\n        [l2 (map second lst)])\n    (list l1 l2)))\n",
    "  (apply append (map list lst)))\n",
    "  (if (null? lst)\n      '()\n      (cons (map car lst) (cons (map cadr lst) '()))))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (define (helper lst1 lst2)\n    (if (null? lst1)\n        lst2\n        (cons (car lst1) (helper (cdr lst1) lst2))))\n  (define (helper2 lst1 lst2)\n    (if (null? lst1)\n        lst2\n        (cons (cadr lst1) (helper2 (cdr lst1) lst2))))\n  (list (helper lst '()) (helper2 lst '())))\n",
    "  (define (merge-helper lst1 lst2)\n    (if (null? lst1)\n        lst2\n        (cons (car lst1) (merge-helper (cdr lst1) lst2))))\n  (merge-helper (map car lst) (map cadr lst)))\n",
    "  (define (merge-helper lst1 lst2)\n    (cond ((null? lst1) lst2)\n          ((null? lst2) lst1)\n          (else (cons (car lst1) (cons (car lst2) (merge-helper (cdr lst1) (cdr lst2)))))))\n  (merge-helper (map car lst) (map cadr lst)))\n",
    "  (define (merge-helper lst1 lst2)\n    (if (null? lst1)\n        lst2\n        (cons (car lst1) (merge-helper (cdr lst1) lst2))))\n  (merge-helper (map car lst) (map cadr lst)))\n",
    "  (let loop ([lst lst] [l1 '()] [l2 '()])\n    (if (null? lst)\n        (list l1 l2)\n        (loop (cdr lst) (cons (caar lst) l1) (cons (cadar lst) l2)))))\n",
    "  (match lst\n    [(list (list (list a b) ...))\n     (list (list a ...) (list b ...))]))\n",
    "  (apply append (map list lst)))\n",
    "  (if (null? lst)\n      '()\n      (cons (map first lst)\n            (cons (map second lst)\n                  '()))))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (apply append (map list (map first lst) (map second lst))))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (apply append (map list lst)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (let ([firsts (map car lst)]\n        [seconds (map cadr lst)])\n    (list firsts seconds)))\n",
    "  (let ([firsts (map first lst)]\n        [seconds (map second lst)])\n    (list firsts seconds)))\n",
    "  (let ([lst1 (map first lst)]\n        [lst2 (map second lst)])\n    (list lst1 lst2)))\n",
    "  (let ([l1 (map first lst)]\n        [l2 (map second lst)])\n    (list l1 l2)))\n",
    "  (if (null? lst)\n      (list '() '())\n      (let* ([first (car lst)]\n             [rest (cdr lst)]\n             [merged (merge rest)]\n             [first-merged (car merged)]\n             [second-merged (cadr merged)])\n        (list (cons (car first) first-merged)\n              (cons (cadr first) second-merged)))))\n",
    "  (define (merge-helper lst1 lst2)\n    (if (null? lst1)\n        lst2\n        (cons (car lst1) (merge-helper (cdr lst1) lst2))))\n  (merge-helper (map car lst) (map cadr lst)))\n",
    "  (let ([firsts (map first lst)]\n        [seconds (map second lst)])\n    (list firsts seconds)))\n",
    "  (let ([l1 (map first lst)]\n        [l2 (map second lst)])\n    (list l1 l2)))\n",
    "  (let loop ([lst lst] [a '()] [b '()])\n    (cond\n      [(empty? lst) (list a b)]\n      [else (loop (rest lst) (cons (first (first lst)) a) (cons (second (first lst)) b))])))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (apply append (map (lambda (x) (list (car x) (cadr x))) lst)))\n",
    "  (let ([firsts (map first lst)]\n        [seconds (map second lst)])\n    (list firsts seconds)))\n",
    "  (cond [(empty? lst) empty]\n        [(empty? (rest lst)) empty]\n        [else (cons (cons (first (first lst)) (cons (first (rest (first lst))) (merge (rest lst))))\n                    (cons (cons (second (first lst)) (cons (second (rest (first lst))) (merge (rest lst)))) empty))]))\n</code>\nI'm getting the following error:\n<code>application: not a procedure;\n expected a procedure that can be applied to arguments\n  given: #&lt;syntax:eval:6:0&gt;\n  arguments...:\n   #&lt;syntax:eval:6:0&gt;\n</code>\nI'm not sure what I'm doing wrong.\n\n\nA:\n\nThe problem is that you're trying to use <code>cons</code> to construct a list of two lists, but that's not how it works. <code>cons</code> is used to construct a list of two elements, and the first element is the first argument and the second element is the second argument. In your case, you're trying to use <code>cons</code> to construct a list of two elements, where the first element is a list and the second element is another list. That's not how it works.\nYou can use <code>list</code> to construct a list of two elements, where the first element is a list and the second element is another list.\n<code>(list (cons (first (first lst)) (cons (first (rest (first lst))) (merge (rest lst))))\n      (cons (second (first lst)) (cons (second (rest (first lst))) (merge (rest lst)))))\n</code>\n",
    "  (list (map (lambda (x) (car x)) lst) (map (lambda (x) (cadr x)) lst)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (if (null? lst)\n      '()\n      (cons (map car lst) (cons (map cadr lst) '()))))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (define (merge-helper lst1 lst2)\n    (cond [(empty? lst1) lst2]\n          [(empty? lst2) lst1]\n          [else (cons (car lst1) (merge-helper (cdr lst1) lst2))]))\n  (merge-helper (map car lst) (map cadr lst)))\n",
    "  (let ([l1 (map first lst)]\n        [l2 (map second lst)])\n    (list l1 l2)))\n",
    "  (if (null? lst)\n      (list '() '())\n      (let* ([first (car lst)]\n             [rest (cdr lst)]\n             [merged (merge rest)]\n             [firsts (car merged)]\n             [seconds (cadr merged)])\n        (list (cons (car first) firsts)\n              (cons (cadr first) seconds)))))\n",
    "  (if (null? lst)\n      (list '() '())\n      (let* ([first (car lst)]\n             [rest (cdr lst)]\n             [merged (merge rest)]\n             [firsts (car merged)]\n             [seconds (cadr merged)])\n        (list (cons (car first) firsts)\n              (cons (cadr first) seconds)))))\n",
    "  (let loop ([lst lst] [lst1 '()] [lst2 '()])\n    (cond [(empty? lst) (list lst1 lst2)]\n          [else (loop (rest lst) (cons (first (first lst)) lst1) (cons (second (first lst)) lst2))])))\n",
    "  (define (helper lst1 lst2)\n    (if (null? lst1)\n        lst2\n        (cons (car lst1) (helper (cdr lst1) lst2))))\n  (if (null? lst)\n      lst\n      (helper (car lst) (merge (cdr lst)))))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (let ([first (map first lst)]\n        [second (map second lst)])\n    (list first second)))\n",
    "  (let ([firsts (map car lst)]\n        [seconds (map cadr lst)])\n    (list firsts seconds)))\n",
    "  (apply append (map list lst)))\n",
    "  (let ([lst1 (map first lst)]\n        [lst2 (map second lst)])\n    (list lst1 lst2)))\n",
    "  (let ([firsts (map first lst)]\n        [seconds (map second lst)])\n    (list firsts seconds)))\n",
    "  (map (lambda (x) (list (car x) (cadr x))) lst))\n",
    "  (apply append (map (lambda (x) (list (car x) (cadr x))) lst)))\n",
    "  (let loop ([lst lst] [lst1 '()] [lst2 '()])\n    (cond [(empty? lst) (list lst1 lst2)]\n          [else (let ([x (first lst)])\n                  (loop (rest lst) (cons (first x) lst1) (cons (second x) lst2)))])))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (map (lambda (x) (list (car x) (cadr x))) lst))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (let ([l1 (map first lst)]\n        [l2 (map second lst)])\n    (list l1 l2)))\n",
    "  (let ([firsts (map first lst)]\n        [seconds (map second lst)])\n    (list firsts seconds)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (let loop ([lst lst] [l1 '()] [l2 '()])\n    (if (null? lst)\n        (list l1 l2)\n        (loop (cdr lst) (cons (caar lst) l1) (cons (cadar lst) l2)))))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (let loop ([lst lst] [l1 '()] [l2 '()])\n    (if (null? lst)\n        (list l1 l2)\n        (loop (cdr lst) (cons (caar lst) l1) (cons (cadar lst) l2)))))\n",
    "  (let ([first (map car lst)]\n        [second (map cadr lst)])\n    (list first second)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (let ([firsts (map first lst)]\n        [seconds (map second lst)])\n    (list firsts seconds)))\n",
    "  (define (merge-helper lst1 lst2)\n    (if (null? lst1)\n        lst2\n        (cons (car lst1) (merge-helper (cdr lst1) lst2))))\n  (merge-helper (map car lst) (map cadr lst)))\n",
    "  (apply append (map list (map first lst) (map second lst))))\n",
    "  (let ([lst1 (map first lst)]\n        [lst2 (map second lst)])\n    (list lst1 lst2)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (list (map first lst)\n        (map second lst)))\n",
    "  (list (map first lst)\n        (map second lst)))\n",
    "  (let ([first (map car lst)]\n        [second (map cadr lst)])\n    (list first second)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (let loop ([lst lst] [lst1 '()] [lst2 '()])\n    (if (null? lst)\n        (list lst1 lst2)\n        (loop (cdr lst) (cons (car (car lst)) lst1) (cons (cadr (car lst)) lst2)))))\n",
    "  (let ([lst1 (map first lst)]\n        [lst2 (map second lst)])\n    (list lst1 lst2)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (apply append (map (lambda (x) (list (car x) (cadr x))) lst)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (apply append (map list lst)))\n",
    "  (let ([first (map car lst)]\n        [second (map cadr lst)])\n    (list first second)))\n",
    "  (apply append (map list (map first lst) (map second lst))))\n",
    "  (map (lambda (x) (list (car x) (cadr x))) lst))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (apply append (map list lst)))\n",
    "  (let ([a (map car lst)]\n        [b (map cadr lst)])\n    (list a b)))\n",
    "  (let loop ([lst lst] [first '()] [second '()])\n    (cond [(null? lst) (list first second)]\n          [else (loop (cdr lst)\n                      (cons (car (car lst)) first)\n                      (cons (cadr (car lst)) second))])))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (let ([firsts (map first lst)]\n        [seconds (map second lst)])\n    (list firsts seconds)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (let ([firsts (map first lst)]\n        [seconds (map second lst)])\n    (list firsts seconds)))\n",
    "  (if (null? lst)\n      '()\n      (cons (map car lst)\n            (cons (map cadr lst)\n                  '()))))\n",
    "  (apply append (map list (map first lst) (map second lst))))\n",
    "  (let ([l1 (map first lst)]\n        [l2 (map second lst)])\n    (list l1 l2)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (let loop ([lst lst] [l1 '()] [l2 '()])\n    (if (null? lst)\n        (list l1 l2)\n        (loop (cdr lst) (cons (car (car lst)) l1) (cons (cadr (car lst)) l2)))))\n",
    "  (define (merge-iter lst1 lst2)\n    (if (null? lst1)\n        lst2\n        (cons (car lst1) (merge-iter (cdr lst1) lst2))))\n  (merge-iter (map car lst) (map cdr lst)))\n",
    "  (define (merge-helper lst1 lst2)\n    (cond\n      [(empty? lst1) lst2]\n      [(empty? lst2) lst1]\n      [else (cons (first lst1) (cons (first lst2) (merge-helper (rest lst1) (rest lst2))))]))\n  (merge-helper (map first lst) (map second lst)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (let loop ([lst lst] [lst1 '()] [lst2 '()])\n    (if (null? lst)\n        (list lst1 lst2)\n        (loop (cdr lst) (cons (caar lst) lst1) (cons (cadar lst) lst2)))))\n",
    "  (apply append (map list lst)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (let loop ([lst lst] [l1 '()] [l2 '()])\n    (cond\n      [(empty? lst) (list l1 l2)]\n      [else (loop (rest lst)\n                  (cons (first (first lst)) l1)\n                  (cons (second (first lst)) l2))])))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (list (map (lambda (x) (car x)) lst) (map (lambda (x) (cadr x)) lst)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (let ([firsts (map first lst)]\n        [seconds (map second lst)])\n    (list firsts seconds)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (list (map first lst) (map second lst)))\n",
    "  (list (map first lst) (map second lst)))\n"
  ]
}