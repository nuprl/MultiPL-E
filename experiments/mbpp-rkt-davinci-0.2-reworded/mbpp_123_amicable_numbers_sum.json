{
  "name": "mbpp_123_amicable_numbers_sum",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to sum all amicable numbers from 1 to a specified number.\n(define (amicable_numbers_sum limit)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_123_amicable_numbers_sum.py",
  "prompt_terminology": "reworded",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate amicable_numbers_sum))\n    (check-equal? (candidate 999) 504)\n    (check-equal? (candidate 9999) 31626)\n    (check-equal? (candidate 99) 0)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (amicable-pair? a b)\n    (and (= a (sum-of-divisors b))\n         (= b (sum-of-divisors a))))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (filter (lambda (x) (= (modulo n x) 0))\n              (range 1 (add1 (quotient n 2)))))\n    (apply + (divisors n)))\n  (define (amicable-numbers)\n    (filter (lambda (x) (amicable-pair? x (sum-of-divisors x)))\n            (range 1 limit)))\n  (apply + (amicable-numbers)))\n",
    "  (define (amicable-pair? n)\n    (let* ([m (sum-of-divisors n)]\n           [n2 (sum-of-divisors m)])\n      (and (= n2 n)\n           (/= m n))))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (modulo n i)))\n        i))\n    (apply + (divisors n)))\n  (apply + (filter amicable-pair? (in-range 1 limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (define (amicable-numbers)\n    (for/list ([i (in-range 1 limit)])\n      (for ([j (in-range 1 limit)])\n        (if (amicable-pair? i j) i))))\n  (apply + (amicable-numbers)))\n",
    "  (define (amicable? n)\n    (let ((m (sum_of_divisors n)))\n      (and (not (= n m)) (= n (sum_of_divisors m)))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (remainder n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (amicable-pairs-up-to limit)\n    (for/list ([i (in-range 1 limit)])\n      (let ([divisors (filter (\u03bb (x) (not (zero? (modulo i x))))\n                              (in-range 1 (quotient i 2)))])\n        (let ([divisors-sum (apply + divisors)])\n          (if (= i (apply + (filter (\u03bb (x) (not (zero? (modulo divisors-sum x))))\n                                    (in-range 1 (quotient divisors-sum 2)))))\n              (list i divisors-sum))))))\n  (apply + (filter (\u03bb (x) (not (zero? (modulo x 2))))\n                   (apply append (amicable-pairs-up-to limit)))))\n",
    "  (define (amicable? n)\n    (let ((m (sum-of-divisors n)))\n      (and (not (= n m)) (= n (sum-of-divisors m)))))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (apply + (filter (lambda (x) (= 0 (modulo n x)))\n                     (range 1 (add1 (/ n 2))))))\n  (apply + (filter (lambda (x) (amicable-pair? x (sum-of-divisors x)))\n                   (range 1 limit))))\n",
    "  (define (sum-divisors n)\n    (define (sum-divisors-helper n divisor)\n      (if (&gt; divisor n)\n          0\n          (if (zero? (modulo n divisor))\n              (+ divisor (sum-divisors-helper n (+ divisor 1)))\n              (sum-divisors-helper n (+ divisor 1)))))\n    (sum-divisors-helper n 1))\n  (define (is-amicable? n)\n    (let ((n-sum (sum-divisors n)))\n      (and (not (= n n-sum))\n           (= n (sum-divisors n-sum)))))\n  (define (amicable-numbers-sum-helper n sum)\n    (if (&gt; n limit)\n        sum\n        (if (is-amicable? n)\n            (amicable-numbers-sum-helper (+ n 1) (+ sum n))\n            (amicable-numbers-sum-helper (+ n 1) sum))))\n  (amicable-numbers-sum-helper 1 0))\n",
    "  (define (amicable? n)\n    (let ((m (sum-of-divisors n)))\n      (and (not (= n m)) (= (sum-of-divisors m) n))))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (filter (lambda (x) (= (modulo n x) 0)) (range 1 (add1 (quotient n 2)))))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable? n)\n    (let ((m (sum_of_divisors n)))\n      (and (not (= n m)) (= n (sum_of_divisors m)))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (remainder n i)))\n        i))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (sum-of-divisors n)\n    (define (sum-of-divisors-iter n sum)\n      (cond ((= n 1) sum)\n            ((= (remainder n 2) 0)\n             (sum-of-divisors-iter (/ n 2) (+ sum (/ n 2))))\n            (else (sum-of-divisors-iter (- n 1) (+ sum (- n 1))))))\n    (sum-of-divisors-iter n 0))\n  (define (is-amicable? n)\n    (let ((sum (sum-of-divisors n)))\n      (and (= n (sum-of-divisors sum))\n           (not (= n sum)))))\n  (define (amicable-numbers-sum-iter n sum)\n    (cond ((&gt; n limit) sum)\n          ((is-amicable? n) (amicable-numbers-sum-iter (+ n 1) (+ sum n)))\n          (else (amicable-numbers-sum-iter (+ n 1) sum))))\n  (amicable-numbers-sum-iter 1 0))\n",
    "  (define (sum_of_divisors n)\n    (define (sum_of_divisors-iter n sum)\n      (cond ((= n 1) sum)\n            ((= 0 (modulo n 2)) (sum_of_divisors-iter (/ n 2) (+ sum n)))\n            (else (sum_of_divisors-iter (- n 1) sum))))\n    (sum_of_divisors-iter n 0))\n  (define (is-amicable? n)\n    (let ((m (sum_of_divisors n)))\n      (and (= n (sum_of_divisors m))\n           (not (= n m)))))\n  (define (amicable-numbers-sum-iter n sum)\n    (cond ((= n limit) sum)\n          ((is-amicable? n) (amicable-numbers-sum-iter (+ n 1) (+ n sum)))\n          (else (amicable-numbers-sum-iter (+ n 1) sum))))\n  (amicable-numbers-sum-iter 1 0))\n",
    "  (define (amicable? n)\n    (let ([m (sum-of-divisors n)])\n      (and (not (= n m)) (= (sum-of-divisors m) n))))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (amicable? n)\n    (let ((m (sum_of_divisors n)))\n      (and (not (= n m)) (= (sum_of_divisors m) n))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (sum-divisors n)\n    (define (sum-divisors-iter n divisor sum)\n      (cond ((= n 1) sum)\n            ((= n divisor) (+ sum divisor))\n            ((= (modulo n divisor) 0)\n             (sum-divisors-iter (/ n divisor) divisor (+ sum divisor (/ n divisor))))\n            (else (sum-divisors-iter n (+ divisor 1) sum))))\n    (sum-divisors-iter n 2 0))\n  (define (amicable-numbers-sum-iter n sum)\n    (cond ((= n limit) sum)\n          ((= (sum-divisors n) (sum-divisors (+ n 1)))\n           (amicable-numbers-sum-iter (+ n 2) (+ sum n (+ n 1))))\n          (else (amicable-numbers-sum-iter (+ n 1) sum))))\n  (amicable-numbers-sum-iter 1 0))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x)))\n            (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((m (sum_divisors n)))\n      (and (not (= n m)) (= n (sum_divisors m)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable? n)\n    (let ([n2 (sum_of_divisors n)])\n      (and (not (= n n2)) (= n (sum_of_divisors n2)))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (when (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (modulo n i)))\n        i))\n    (apply + (divisors n)))\n  (define (amicable-numbers)\n    (for/list ([i (in-range 1 limit)]\n               [j (in-range 1 limit)])\n      (when (amicable-pair? i j)\n        i)))\n  (apply + (amicable-numbers)))\n",
    "  (define (amicable? a b)\n    (and (= (sum-of-divisors a) b) (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (define (amicable-numbers n)\n    (for/list ([i (in-range 1 n)])\n      (if (amicable? i (sum-of-divisors i)) i)))\n  (apply + (amicable-numbers limit)))\n",
    "  (define (divisors n)\n    (for/list ([i (in-range 1 (quotient n 2))]\n               #:when (zero? (modulo n i)))\n      i))\n  (define (amicable? n)\n    (let ([d (divisors n)])\n      (and (not (null? d))\n           (= (apply + d) n))))\n  (apply + (for/list ([i (in-range 1 limit)])\n            (if (amicable? i)\n                i\n                0))))\n",
    "  (define (amicable-sum n)\n    (define (divisors n)\n      (filter (lambda (x) (= (modulo n x) 0)) (range 1 (add1 (quotient n 2)))))\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((n2 (amicable-sum n)))\n      (and (= (amicable-sum n2) n)\n           (not (= n n2)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable? a)\n    (let ([b (sum_of_divisors a)])\n      (and (not (= a b)) (= a (sum_of_divisors b)))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (amicable? n)\n    (let ((m (sum_of_divisors n)))\n      (and (not (= n m)) (= (sum_of_divisors m) n))))\n  (define (sum_of_divisors n)\n    (let loop ((i 1) (sum 0))\n      (cond ((&gt; i (/ n 2)) sum)\n            ((zero? (remainder n i)) (loop (+ i 1) (+ sum i)))\n            (else (loop (+ i 1) sum)))))\n  (let loop ((i 1) (sum 0))\n    (cond ((&gt; i limit) sum)\n          ((amicable? i) (loop (+ i 1) (+ sum i)))\n          (else (loop (+ i 1) sum)))))\n</code>\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x)))\n            (range 1 (add1 (quotient n 2)))))\n  (define (sum_of_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((m (sum_of_divisors n)))\n      (and (= n (sum_of_divisors m))\n           (not (= n m)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable? n)\n    (let ((m (sum-of-divisors n)))\n      (and (not (= n m)) (= n (sum-of-divisors m)))))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= (remainder n x) 0))\n            (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((m (sum_divisors n)))\n      (and (not (= n m))\n           (= (sum_divisors m) n))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable? n)\n    (let ([m (sum_proper_divisors n)])\n      (and (not (= n m)) (= n (sum_proper_divisors m)))))\n  (define (sum_proper_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (exact-floor (/ n 2)))])\n        (if (zero? (remainder n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (sum-of-divisors n)\n    (define (sum-of-divisors-iter n divisor sum)\n      (cond\n        [(= n 1) sum]\n        [(= 0 (modulo n divisor))\n         (sum-of-divisors-iter (/ n divisor) divisor (+ sum divisor))]\n        [else (sum-of-divisors-iter n (+ divisor 1) sum)]))\n    (sum-of-divisors-iter n 2 0))\n  (define (amicable-numbers-sum-iter n sum)\n    (cond\n      [(= n limit) sum]\n      [(= (sum-of-divisors n) (sum-of-divisors (+ n 1)))\n       (amicable-numbers-sum-iter (+ n 2) (+ sum n (+ n 1)))]\n      [else (amicable-numbers-sum-iter (+ n 1) sum)]))\n  (amicable-numbers-sum-iter 1 0))\n",
    "  (define (amicable? a)\n    (define b (sum-of-divisors a))\n    (and (not (= a b)) (= a (sum-of-divisors b))))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (= 0 (remainder n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (filter (lambda (x) (= (remainder n x) 0))\n              (range 1 (add1 (quotient n 2)))))\n    (apply + (divisors n)))\n  (define (amicable-numbers limit)\n    (filter (lambda (x) (amicable-pair? x (sum-of-divisors x)))\n            (range 1 limit)))\n  (apply + (amicable-numbers limit)))\n",
    "  (define (amicable? a)\n    (let ((b (sum_of_divisors a)))\n      (and (not (= a b)) (= (sum_of_divisors b) a))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (filter (lambda (x) (= (modulo n x) 0)) (range 1 n)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= (remainder n x) 0)) (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (= (sum_divisors (sum_divisors n)) n))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (let loop ((i 1) (sum 0))\n    (if (&gt; i limit)\n        sum\n        (let ((d (sum_of_divisors i)))\n          (if (and (&lt; i d) (= (sum_of_divisors d) i))\n              (loop (+ i 1) (+ sum i d))\n              (loop (+ i 1) sum))))))\n",
    "  (define (amicable-pairs limit)\n    (for/list ([n (in-range 1 limit)])\n      (let ([d (sum-of-divisors n)])\n        (when (and (= (sum-of-divisors d) n)\n                   (not (= n d)))\n          (list n d)))))\n  (apply + (apply append (amicable-pairs limit))))\n",
    "  (define (amicable? n)\n    (let ((m (sum_of_divisors n)))\n      (and (not (= n m)) (= (sum_of_divisors m) n))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (let loop ((i 1) (acc '()))\n        (if (&gt; i (/ n 2))\n            acc\n            (if (zero? (modulo n i))\n                (loop (+ i 1) (cons i acc))\n                (loop (+ i 1) acc)))))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (range 1 limit))))\n</code>\n",
    "  (define (sum_of_divisors n)\n    (define (divisors n)\n      (define (divisors-iter n i)\n        (cond ((= i n) '())\n              ((= 0 (modulo n i)) (cons i (divisors-iter n (+ i 1))))\n              (else (divisors-iter n (+ i 1)))))\n      (divisors-iter n 1))\n    (apply + (divisors n)))\n  (define (is-amicable n)\n    (let ((m (sum_of_divisors n)))\n      (and (= n (sum_of_divisors m))\n           (/= n m))))\n  (define (amicable-numbers-iter n sum)\n    (cond ((= n limit) sum)\n          ((is-amicable n) (amicable-numbers-iter (+ n 1) (+ sum n)))\n          (else (amicable-numbers-iter (+ n 1) sum))))\n  (amicable-numbers-iter 1 0))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-proper-divisors a) b)\n         (= (sum-of-proper-divisors b) a)))\n  (define (sum-of-proper-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (define (sum-of-amicable-numbers limit)\n    (for/sum ([i (in-range 1 limit)]\n              #:when (amicable-pair? i (sum-of-proper-divisors i)))\n      i))\n  (sum-of-amicable-numbers limit))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x))) (range 1 (add1 (quotient n 2)))))\n  (define (sum_of_divisors n)\n    (apply + (divisors n)))\n  (define (is_amicable n)\n    (let ((m (sum_of-divisors n)))\n      (and (not (= n m)) (= (sum_of_divisors m) n))))\n  (apply + (filter is_amicable (range 1 limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (define (amicable-numbers n)\n    (for/list ([i (in-range 1 (add1 n))])\n      (if (amicable-pair? i (sum-of-divisors i)) i)))\n  (apply + (amicable-numbers limit)))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x)))\n            (range 1 (add1 (quotient n 2)))))\n  (define (sum-divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((m (sum-divisors n)))\n      (and (not (= n m)) (= n (sum-divisors m)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable? a)\n    (let ([b (sum_of_divisors a)])\n      (and (not (= a b)) (= (sum_of_divisors b) a))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (define (amicable-numbers n)\n    (for/list ([i (in-range 1 n)])\n      (if (amicable-pair? i (sum-of-divisors i)) i)))\n  (apply + (amicable-numbers limit)))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (define (amicable-numbers limit)\n    (for/list ([a (in-range 1 limit)])\n      (define b (sum-of-divisors a))\n      (if (and (not (= a b))\n               (amicable-pair? a b))\n          a)))\n  (apply + (amicable-numbers limit)))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x)))\n            (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? a b)\n    (and (= (sum_divisors a) b)\n         (= (sum_divisors b) a)))\n  (apply +\n         (filter (lambda (x)\n                   (let ((y (sum_divisors x)))\n                     (and (not (= x y))\n                          (amicable? x y))))\n                 (range 1 limit))))\n",
    "  (define (sum-divisors n)\n    (define (sum-divisors-iter n sum)\n      (cond ((= n 1) sum)\n            ((= (remainder n 2) 0) (sum-divisors-iter (/ n 2) (+ sum n)))\n            ((= (remainder n 3) 0) (sum-divisors-iter (/ n 3) (+ sum n)))\n            ((= (remainder n 5) 0) (sum-divisors-iter (/ n 5) (+ sum n)))\n            ((= (remainder n 7) 0) (sum-divisors-iter (/ n 7) (+ sum n)))\n            (else (sum-divisors-iter (- n 1) (+ sum n)))))\n    (sum-divisors-iter n 0))\n  (define (amicable-numbers-sum-iter n sum)\n    (cond ((= n limit) sum)\n          ((= (sum-divisors n) (sum-divisors (+ n 1))) (amicable-numbers-sum-iter (+ n 2) (+ sum n n (+ n 1))))\n          (else (amicable-numbers-sum-iter (+ n 1) sum))))\n  (amicable-numbers-sum-iter 1 0))\n",
    "  (define (amicable? n)\n    (let* ([d (sum_of_proper_divisors n)]\n           [d2 (sum_of_proper_divisors d)])\n      (and (not (= n d)) (= n d2))))\n  (define (sum_of_proper_divisors n)\n    (define (divisors n)\n      (let loop ([i 1] [acc '()])\n        (cond\n          [(= i n) acc]\n          [(zero? (modulo n i)) (loop (+ i 1) (cons i acc))]\n          [else (loop (+ i 1) acc)])))\n    (apply + (divisors n)))\n  (define (loop i acc)\n    (cond\n      [(= i limit) acc]\n      [(amicable? i) (loop (+ i 1) (+ acc i))]\n      [else (loop (+ i 1) acc)]))\n  (loop 1 0))\n",
    "  (define (amicable? n)\n    (let ((n2 (sum_of_divisors n)))\n      (and (= n (sum_of_divisors n2))\n           (not (= n n2)))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (amicable-sum n)\n    (define (divisors n)\n      (filter (lambda (x) (= (remainder n x) 0)) (range 1 n)))\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((n1 (amicable-sum n)))\n      (and (= n (amicable-sum n1))\n           (not (= n n1)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (sum-divisors n)\n    (define (sum-divisors-iter n sum)\n      (if (= n 1)\n          sum\n          (if (= (modulo n 2) 0)\n              (sum-divisors-iter (/ n 2) (+ sum (/ n 2)))\n              (sum-divisors-iter (/ (- n 1) 2) (+ sum (/ (- n 1) 2))))))\n    (sum-divisors-iter n 0))\n  (define (is-amicable? n)\n    (define (is-amicable?-iter n sum)\n      (if (= n 1)\n          #f\n          (if (= (modulo n 2) 0)\n              (is-amicable?-iter (/ n 2) (+ sum (/ n 2)))\n              (is-amicable?-iter (/ (- n 1) 2) (+ sum (/ (- n 1) 2))))))\n    (let ((sum (is-amicable?-iter n 0)))\n      (if (= (sum-divisors sum) n)\n          #t\n          #f)))\n  (define (amicable-numbers-sum-iter n sum)\n    (if (= n limit)\n        sum\n        (if (is-amicable? n)\n            (amicable-numbers-sum-iter (+ n 1) (+ sum n))\n            (amicable-numbers-sum-iter (+ n 1) sum))))\n  (amicable-numbers-sum-iter 1 0))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= (remainder n x) 0)) (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (is-amicable? n)\n    (let ((n-sum (sum_divisors n)))\n      (and (= n (sum_divisors n-sum))\n           (not (= n n-sum)))))\n  (apply + (filter is-amicable? (range 1 limit))))\n",
    "  (define (amicable? n)\n    (let ((m (sum_of_divisors n)))\n      (and (not (= n m)) (= n (sum_of_divisors m)))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (modulo n i)))\n        i))\n    (apply + (divisors n)))\n  (apply + (for/list ([n (in-range 1 limit)]\n                     #:when (amicable? n))\n            n)))\n",
    "  (define (amicable? n)\n    (let ((m (sum-of-divisors n)))\n      (and (not (= n m)) (= (sum-of-divisors m) n))))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (sum-of-divisors n)\n    (define (sum-of-divisors-iter n sum)\n      (cond ((= n 1) sum)\n            ((= (remainder n 2) 0) (sum-of-divisors-iter (/ n 2) (+ sum n)))\n            ((= (remainder n 3) 0) (sum-of-divisors-iter (/ n 3) (+ sum n)))\n            ((= (remainder n 5) 0) (sum-of-divisors-iter (/ n 5) (+ sum n)))\n            ((= (remainder n 7) 0) (sum-of-divisors-iter (/ n 7) (+ sum n)))\n            (else (sum-of-divisors-iter (- n 1) (+ sum n)))))\n    (sum-of-divisors-iter n 0))\n  (define (amicable-numbers-sum-iter n sum)\n    (cond ((= n limit) sum)\n          ((= (sum-of-divisors (sum-of-divisors n)) n) (amicable-numbers-sum-iter (+ n 1) (+ sum n)))\n          (else (amicable-numbers-sum-iter (+ n 1) sum))))\n  (amicable-numbers-sum-iter 1 0))\n",
    "  (define (amicable? n)\n    (let ((n2 (sum-of-proper-divisors n)))\n      (and (not (= n n2)) (= n (sum-of-proper-divisors n2)))))\n  (define (sum-of-proper-divisors n)\n    (let loop ((i 1) (sum 0))\n      (cond ((= i n) sum)\n            ((divides? i n) (loop (+ i 1) (+ sum i)))\n            (else (loop (+ i 1) sum)))))\n  (define (divides? a b) (= (remainder b a) 0))\n  (let loop ((i 1) (sum 0))\n    (cond ((= i limit) sum)\n          ((amicable? i) (loop (+ i 1) (+ sum i)))\n          (else (loop (+ i 1) sum)))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (remainder n i)) i)))\n    (apply + (divisors n)))\n  (define (amicable-numbers)\n    (for/list ([i (in-range 1 limit)])\n      (for/list ([j (in-range 1 limit)])\n        (if (and (amicable-pair? i j)\n                 (not (zero? i))\n                 (not (zero? j)))\n            i))))\n  (apply + (amicable-numbers)))\n",
    "  (define (amicable-numbers-sum-iter limit sum)\n    (cond\n      [(= limit 1) sum]\n      [(amicable? limit) (amicable-numbers-sum-iter (- limit 1) (+ sum limit))]\n      [else (amicable-numbers-sum-iter (- limit 1) sum)]))\n  (amicable-numbers-sum-iter limit 0))\n",
    "  (define (amicable-sum n)\n    (define (divisors n)\n      (filter (lambda (x) (= (remainder n x) 0)) (range 1 (add1 (quotient n 2)))))\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((n-sum (amicable-sum n)))\n      (and (not (= n n-sum)) (= (amicable-sum n-sum) n))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable? a)\n    (let ([b (sum_of_divisors a)])\n      (and (not (= a b)) (= (sum_of_divisors b) a))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (filter (lambda (x) (= 0 (modulo n x))) (range 1 (add1 (quotient n 2)))))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable? a)\n    (let ([b (sum_of_divisors a)])\n      (and (not (= a b)) (= a (sum_of_divisors b)))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (amicable? n)\n    (let ((n2 (sum_of_divisors n)))\n      (and (= n (sum_of_divisors n2))\n           (not (= n n2)))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (modulo n i)))\n        i))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= (remainder n x) 0))\n            (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((m (sum_divisors n)))\n      (and (not (= n m)) (= (sum_divisors m) n))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable-number? n)\n    (let ((n-divisors-sum (sum-divisors n)))\n      (and (not (= n n-divisors-sum))\n           (= (sum-divisors n-divisors-sum) n))))\n  (define (sum-divisors n)\n    (define (divisors n)\n      (filter (lambda (x) (= (modulo n x) 0))\n              (range 1 (add1 (quotient n 2)))))\n    (apply + (divisors n)))\n  (apply + (filter amicable-number? (range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x))) (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (is_amicable? n)\n    (let ((n' (sum_divisors n)))\n      (and (not (= n n')) (= n (sum_divisors n')))))\n  (apply + (filter is_amicable? (range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= (remainder n x) 0))\n            (range 1 (add1 (floor (/ n 2))))))\n  (define (amicable? n)\n    (let ((m (apply + (divisors n))))\n      (and (= (apply + (divisors m)) n)\n           (not (= m n)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable? n)\n    (define (divisors n)\n      (filter (lambda (x) (= 0 (modulo n x))) (range 1 (add1 (quotient n 2)))))\n    (define (sum-divisors n)\n      (apply + (divisors n)))\n    (= (sum-divisors (sum-divisors n)) n))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (filter (lambda (x) (= (remainder n x) 0)) (range 1 n)))\n    (apply + (divisors n)))\n  (define (amicable-numbers limit)\n    (filter (lambda (x)\n              (let ((y (sum-of-divisors x)))\n                (and (not (= x y))\n                     (amicable-pair? x y))))\n            (range 1 limit)))\n  (apply + (amicable-numbers limit)))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (define (amicable-numbers limit)\n    (for/list ([i (in-range 1 limit)])\n      (for/list ([j (in-range 1 limit)])\n        (if (amicable-pair? i j) i))))\n  (apply + (amicable-numbers limit)))\n",
    "  (for/sum ([i (in-range 1 limit)])\n    (let ([divisor-sum (sum-divisors i)])\n      (when (and (= i (sum-divisors divisor-sum))\n                 (not (= i divisor-sum)))\n        i))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (filter (lambda (x) (= (modulo n x) 0))\n              (range 1 n)))\n    (apply + (divisors n)))\n  (define (range a b)\n    (if (> a b)\n        '()\n        (cons a (range (+ a 1) b))))\n  (define (filter pred lst)\n    (cond ((null? lst) '())\n          ((pred (car lst)) (cons (car lst) (filter pred (cdr lst))))\n          (else (filter pred (cdr lst)))))\n  (apply + (filter (lambda (x) (amicable-pair? x (sum-of-divisors x)))\n                   (range 1 limit))))\n",
    "  (define (amicable? n)\n    (let ([n2 (sum_of_proper_divisors n)])\n      (and (not (= n n2)) (= n (sum_of_proper_divisors n2)))))\n  (define (sum_of_proper_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (remainder n i)))\n        i))\n    (apply + (divisors n)))\n  (apply + (for/list ([n (in-range 1 limit)]\n                      #:when (amicable? n))\n                    n)))\n",
    "  (define (amicable? n)\n    (let ((m (sum_of_divisors n)))\n      (and (not (= n m)) (= n (sum_of_divisors m)))))\n  (define (sum_of_divisors n)\n    (let loop ((i 1) (sum 0))\n      (if (= i n)\n          sum\n          (if (zero? (modulo n i))\n              (loop (+ i 1) (+ sum i))\n              (loop (+ i 1) sum)))))\n  (let loop ((i 1) (sum 0))\n    (if (= i limit)\n        sum\n        (if (amicable? i)\n            (loop (+ i 1) (+ sum i))\n            (loop (+ i 1) sum)))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x))) (range 1 (add1 (quotient n 2)))))\n  (define (d n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((d-n (d n)))\n      (and (not (= n d-n)) (= n (d d-n)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable-numbers-sum-iter limit sum)\n    (if (= limit 1)\n        sum\n        (let ((divisors-sum (divisors-sum limit)))\n          (if (and (= (divisors-sum divisors-sum) limit)\n                   (/= limit divisors-sum))\n              (amicable-numbers-sum-iter (- limit 1) (+ sum limit divisors-sum))\n              (amicable-numbers-sum-iter (- limit 1) sum)))))\n  (amicable-numbers-sum-iter limit 0))\n",
    "  (define (sum_divisors n)\n    (define (sum_divisors_iter n sum)\n      (cond ((= n 1) sum)\n            ((= (remainder n 2) 0) (sum_divisors_iter (/ n 2) (+ sum n)))\n            ((= (remainder n 3) 0) (sum_divisors_iter (/ n 3) (+ sum n)))\n            (else (sum_divisors_iter (- n 1) sum))))\n    (sum_divisors_iter n 0))\n  (define (is_amicable n)\n    (let ((n2 (sum_divisors n)))\n      (and (= n (sum_divisors n2))\n           (not (= n n2)))))\n  (define (amicable_numbers_sum_iter n sum)\n    (cond ((= n limit) sum)\n          ((is_amicable n) (amicable_numbers_sum_iter (+ n 1) (+ sum n)))\n          (else (amicable_numbers_sum_iter (+ n 1) sum))))\n  (amicable_numbers_sum_iter 1 0))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x)))\n            (range 1 (add1 (quotient n 2)))))\n  (define (amicable? n)\n    (let ((n2 (apply + (divisors n))))\n      (and (not (= n n2))\n           (= n (apply + (divisors n2))))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (sum-divisors n)\n    (define (sum-divisors-iter n i sum)\n      (cond\n        [(= i n) sum]\n        [(= 0 (modulo n i)) (sum-divisors-iter n (+ i 1) (+ sum i))]\n        [else (sum-divisors-iter n (+ i 1) sum)]))\n    (sum-divisors-iter n 1 0))\n  (define (is-amicable n)\n    (let ([m (sum-divisors n)])\n      (and (= n (sum-divisors m))\n           (/= n m))))\n  (define (amicable-numbers-sum-iter n sum)\n    (cond\n      [(= n limit) sum]\n      [(is-amicable n) (amicable-numbers-sum-iter (+ n 1) (+ sum n))]\n      [else (amicable-numbers-sum-iter (+ n 1) sum)]))\n  (amicable-numbers-sum-iter 1 0))\n",
    "  (define (amicable-numbers-sum-iter limit sum)\n    (cond ((&gt; limit 1)\n           (let ((divisors-sum (divisors-sum limit)))\n             (if (and (= (divisors-sum divisors-sum) limit)\n                      (not (= limit divisors-sum)))\n                 (amicable-numbers-sum-iter (- limit 1) (+ sum limit))\n               (amicable-numbers-sum-iter (- limit 1) sum))))\n          (else sum)))\n  (amicable-numbers-sum-iter limit 0))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x))) (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((m (sum_divisors n)))\n      (and (not (= n m)) (= n (sum_divisors m)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable-number? n)\n    (let ((n-divisors (divisors n)))\n      (and (not (null? n-divisors))\n           (= n (apply + (cdr n-divisors)))\n           (= (apply + (divisors n)) n))))\n  (apply + (filter amicable-number? (range 1 limit))))\n",
    "  (let loop ((n 1) (sum 0))\n    (cond ((&gt; n limit) sum)\n          ((= (sum_of_proper_divisors n) (+ n (sum_of_proper_divisors (sum_of_proper_divisors n))))\n           (loop (+ n 1) (+ sum n (sum_of_proper_divisors n))))\n          (else (loop (+ n 1) sum)))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= (remainder n x) 0))\n            (range 1 (add1 (quotient n 2)))))\n  (define (sum-of-divisors n)\n    (apply + (divisors n)))\n  (define (is-amicable? n)\n    (let ((m (sum-of-divisors n)))\n      (and (not (= n m))\n           (= (sum-of-divisors m) n))))\n  (apply + (filter is-amicable? (range 1 limit))))\n",
    "  (define (amicable-numbers-sum-iter limit sum)\n    (cond ((&gt; limit 1)\n           (let ((divisors-sum (divisors-sum limit)))\n             (if (and (= (divisors-sum divisors-sum) limit)\n                      (not (= limit divisors-sum)))\n                 (amicable-numbers-sum-iter (- limit 1) (+ sum limit))\n               (amicable-numbers-sum-iter (- limit 1) sum))))\n          (else sum)))\n  (amicable-numbers-sum-iter limit 0))\n",
    "  (define (amicable-numbers-sum-iter limit sum)\n    (if (= limit 0)\n        sum\n        (let ((divisors-sum (divisors-sum limit)))\n          (if (= (divisors-sum divisors-sum) limit)\n              (amicable-numbers-sum-iter (- limit 1) (+ sum limit))\n              (amicable-numbers-sum-iter (- limit 1) sum)))))\n  (amicable-numbers-sum-iter limit 0))\n",
    "  (define (amicable-sum n)\n    (define (sum-of-divisors n)\n      (define (divisors n)\n        (filter (lambda (x) (= (remainder n x) 0))\n                (range 1 (add1 (quotient n 2)))))\n      (apply + (divisors n)))\n    (define (amicable? n)\n      (let ((n-sum (sum-of-divisors n)))\n        (and (= (sum-of-divisors n-sum) n)\n             (not (= n n-sum)))))\n    (apply + (filter amicable? (range 1 limit))))\n  (amicable-sum limit))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= (remainder n x) 0))\n            (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((m (sum_divisors n)))\n      (and (= n (sum_divisors m))\n           (/= n m))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (sum-of-divisors n)\n    (define (sum-of-divisors-iter n sum)\n      (cond ((= n 1) sum)\n            ((= (remainder n 2) 0) (sum-of-divisors-iter (/ n 2) (+ sum n)))\n            (else (sum-of-divisors-iter (- n 1) sum))))\n    (sum-of-divisors-iter n 0))\n  (define (amicable-numbers-sum-iter n sum)\n    (cond ((= n limit) sum)\n          ((= (sum-of-divisors (sum-of-divisors n)) n) (amicable-numbers-sum-iter (+ n 1) (+ sum n)))\n          (else (amicable-numbers-sum-iter (+ n 1) sum))))\n  (amicable-numbers-sum-iter 1 0))\n",
    "  (define (sum-of-divisors n)\n    (define (divisors n)\n      (filter (lambda (x) (= (modulo n x) 0)) (range 1 n)))\n    (apply + (divisors n)))\n  (define (is-amicable? n)\n    (let ((m (sum-of-divisors n)))\n      (and (= n (sum-of-divisors m))\n           (not (= n m)))))\n  (apply + (filter is-amicable? (range 1 limit))))\n",
    "  (define (amicable? n)\n    (let ([m (sum-of-divisors n)])\n      (and (not (= n m)) (= (sum-of-divisors m) n))))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (remainder n i)))\n        i))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x))) (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((m (sum_divisors n)))\n      (and (not (= n m)) (= n (sum_divisors m)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable? n)\n    (let ([m (sum-of-divisors n)])\n      (and (= n (sum-of-divisors m))\n           (/= n m))))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (remainder n i)))\n        i))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x))) (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (is_amicable n)\n    (let ((m (sum_divisors n)))\n      (and (= n (sum_divisors m))\n           (not (= n m)))))\n  (apply + (filter is_amicable (range 1 limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (remainder n i)) i)))\n    (apply + (divisors n)))\n  (define (amicable-numbers n)\n    (for/list ([i (in-range 1 n)])\n      (if (amicable-pair? i (sum-of-divisors i)) i)))\n  (apply + (amicable-numbers limit)))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (remainder n x)))\n            (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((m (sum_divisors n)))\n      (and (not (= n m))\n           (= (sum_divisors m) n))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (sum_of_divisors n)\n    (define (divisors n)\n      (filter (lambda (x) (= (modulo n x) 0)) (range 1 n)))\n    (apply + (divisors n)))\n  (define (is_amicable? n)\n    (let ((m (sum_of_divisors n)))\n      (and (= n (sum_of_divisors m))\n           (not (= n m)))))\n  (apply + (filter is_amicable? (range 1 limit))))\n",
    "  (define (amicable-numbers-sum-iter n sum)\n    (cond\n      [(= n limit) sum]\n      [(amicable? n) (amicable-numbers-sum-iter (+ n 1) (+ sum n))]\n      [else (amicable-numbers-sum-iter (+ n 1) sum)]))\n  (amicable-numbers-sum-iter 1 0))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (remainder n i)))\n        i))\n    (apply + (divisors n)))\n  (define (amicable-pairs limit)\n    (for/list ([i (in-range 1 limit)])\n      (for/list ([j (in-range 1 limit)])\n        (and (amicable-pair? i j)\n             (list i j)))))\n  (apply + (flatten (amicable-pairs limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (remainder n i)))\n        i))\n    (apply + (divisors n)))\n  (define (amicable-numbers)\n    (for/list ([i (in-range 1 limit)]\n               [j (in-range 1 limit)])\n      (when (amicable-pair? i j)\n        (list i j))))\n  (apply + (apply append (amicable-numbers))))\n",
    "  (define (sum-divisors n)\n    (define (sum-divisors-iter n sum)\n      (cond ((= n 1) sum)\n            ((= (remainder n 2) 0)\n             (sum-divisors-iter (/ n 2) (+ sum n)))\n            (else (sum-divisors-iter (- n 1) sum))))\n    (sum-divisors-iter n 1))\n  (define (is-amicable? n)\n    (let ((m (sum-divisors n)))\n      (and (= (sum-divisors m) n)\n           (/= m n))))\n  (define (amicable-numbers-sum-iter n sum)\n    (cond ((= n limit) sum)\n          ((is-amicable? n) (amicable-numbers-sum-iter (+ n 1) (+ sum n)))\n          (else (amicable-numbers-sum-iter (+ n 1) sum))))\n  (amicable-numbers-sum-iter 1 0))\n",
    "  (for/sum ([i (in-range 1 limit)])\n    (let ([divisors (divisors i)])\n      (let ([divisors-sum (apply + divisors)])\n        (let ([divisors-of-divisors-sum (apply + (divisors divisors-sum))])\n          (if (and (= i divisors-of-divisors-sum)\n                   (not (= i divisors-sum)))\n              i\n              0))))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-proper-divisors a) b)\n         (= (sum-of-proper-divisors b) a)))\n  (define (sum-of-proper-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (define (amicable-numbers n)\n    (for/list ([i (in-range 1 n)])\n      (define j (sum-of-proper-divisors i))\n      (if (amicable-pair? i j) i)))\n  (apply + (amicable-numbers limit)))\n",
    "  (define (amicable-numbers-sum-iter limit sum)\n    (cond\n      [(= limit 1) sum]\n      [(amicable? limit) (amicable-numbers-sum-iter (- limit 1) (+ limit sum))]\n      [else (amicable-numbers-sum-iter (- limit 1) sum)]))\n  (amicable-numbers-sum-iter limit 0))\n",
    "  (define (sum-divisors n)\n    (define (sum-divisors-iter n sum)\n      (cond ((= n 1) sum)\n            ((= (remainder n 2) 0) (sum-divisors-iter (/ n 2) (+ sum n)))\n            (else (sum-divisors-iter (- n 1) sum))))\n    (sum-divisors-iter n 1))\n  (define (is-amicable n)\n    (let ((n-sum (sum-divisors n)))\n      (and (= n-sum (sum-divisors n-sum))\n           (not (= n n-sum)))))\n  (define (amicable-numbers-sum-iter n sum)\n    (cond ((= n limit) sum)\n          ((is-amicable n) (amicable-numbers-sum-iter (+ n 1) (+ sum n)))\n          (else (amicable-numbers-sum-iter (+ n 1) sum))))\n  (amicable-numbers-sum-iter 1 0))\n",
    "  (define (sum-divisors n)\n    (define (sum-divisors-iter n sum)\n      (cond\n        [(= n 1) sum]\n        [(= (remainder n 2) 0) (sum-divisors-iter (/ n 2) (+ sum n))]\n        [else (sum-divisors-iter (- n 1) sum)]))\n    (sum-divisors-iter n 0))\n  (define (is-amicable? n)\n    (let ([m (sum-divisors n)])\n      (and (= n (sum-divisors m))\n           (not (= n m)))))\n  (define (amicable-numbers-sum-iter n sum)\n    (cond\n      [(= n limit) sum]\n      [(is-amicable? n) (amicable-numbers-sum-iter (+ n 1) (+ sum n))]\n      [else (amicable-numbers-sum-iter (+ n 1) sum)]))\n  (amicable-numbers-sum-iter 1 0))\n",
    "  (define (amicable-numbers-sum-iter limit sum)\n    (if (&lt; limit 1)\n        sum\n        (let* ([d (sum-of-divisors limit)]\n               [d-sum (sum-of-divisors d)])\n          (if (and (= d-sum limit)\n                   (&lt; d limit))\n              (amicable-numbers-sum-iter (- limit 1) (+ sum limit d))\n              (amicable-numbers-sum-iter (- limit 1) sum)))))\n  (amicable-numbers-sum-iter limit 0))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= (modulo n x) 0)) (range 1 n)))\n  (define (amicable? n)\n    (let ((m (sum (divisors n))))\n      (and (= n (sum (divisors m)))\n           (not (= n m)))))\n  (sum (filter amicable? (range 1 limit))))\n",
    "  (let loop ((i 1) (sum 0))\n    (cond ((&gt; i limit) sum)\n          ((= (sum_of_divisors (sum_of_divisors i)) i)\n           (loop (+ i 1) (+ sum i)))\n          (else (loop (+ i 1) sum)))))\n",
    "  (define (amicable? n)\n    (let ([m (sum_of_divisors n)])\n      (and (not (= n m)) (= n (sum_of_divisors m)))))\n  (define (sum_of_divisors n)\n    (apply + (filter (lambda (x) (= 0 (modulo n x)))\n                     (range 1 (add1 (quotient n 2))))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x)))\n            (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((m (sum_divisors n)))\n      (and (not (= n m))\n           (= (sum_divisors m) n))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (for/fold ([sum 0]) ([i (in-range 1 limit)])\n    (let ([divisors (divisors i)])\n      (if (and (not (= i (apply + divisors)))\n               (= (apply + (divisors (apply + divisors))) i))\n          (+ sum i)\n          sum))))\n",
    "  (define (amicable-pair? n)\n    (let* ([d (sum-of-divisors n)]\n           [d2 (sum-of-divisors d)])\n      (and (= n d2)\n           (/= n d))))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (modulo n i)))\n        i))\n    (apply + (divisors n)))\n  (apply + (for/list ([n (in-range 1 limit)]\n                      #:when (amicable-pair? n))\n                n)))\n",
    "  (define (amicable? n)\n    (let ([m (sum_of_divisors n)])\n      (and (not (= n m)) (= n (sum_of_divisors m)))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (amicable? a b)\n    (and (not (= a b)) (= (sum-of-divisors a) b) (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (remainder n i)))\n        i))\n    (apply + (divisors n)))\n  (define (sum-of-amicable-numbers n)\n    (define (amicable-numbers n)\n      (for/list ([i (in-range 1 n)]\n                 #:when (amicable? i (sum-of-divisors i)))\n        i))\n    (apply + (amicable-numbers n)))\n  (sum-of-amicable-numbers limit))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (filter (lambda (x) (= (remainder n x) 0)) (range 1 n)))\n    (apply + (divisors n)))\n  (define (amicable-numbers)\n    (filter (lambda (x) (amicable-pair? x (sum-of-divisors x)))\n            (range 1 limit)))\n  (apply + (amicable-numbers)))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x))) (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((m (sum_divisors n)))\n      (and (not (= n m)) (= n (sum_divisors m)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable-pairs-sum limit)\n    (define (sum-of-divisors n)\n      (define (divisors n)\n        (for/list ([i (in-range 1 (quotient n 2))])\n          (if (zero? (remainder n i)) i)))\n      (apply + (divisors n)))\n    (define (amicable-pairs limit)\n      (for/list ([i (in-range 1 limit)])\n        (let ([s (sum-of-divisors i)])\n          (if (and (not (zero? s)) (= (sum-of-divisors s) i))\n              (list i s)))))\n    (apply + (apply append (amicable-pairs limit))))\n  (amicable-pairs-sum limit))\n",
    "  (define (amicable? n)\n    (let ((m (sum-of-proper-divisors n)))\n      (and (not (= n m)) (= (sum-of-proper-divisors m) n))))\n  (define (sum-of-proper-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (remainder n i)))\n        i))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (amicable? n)\n    (let ((m (sum_of_divisors n)))\n      (and (not (= n m))\n           (= (sum_of_divisors m) n))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= (remainder n x) 0))\n            (range 1 (add1 (quotient n 2)))))\n  (define (divisors-sum n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((m (divisors-sum n)))\n      (and (= (divisors-sum m) n)\n           (not (= m n)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable? n)\n    (let ((m (sum_of_divisors n)))\n      (and (not (= n m)) (= n (sum_of_divisors m)))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= (modulo n x) 0))\n            (range 1 (add1 (quotient n 2)))))\n  (define (amicable? n)\n    (let ((m (apply + (divisors n))))\n      (and (not (= n m)) (= n (apply + (divisors m))))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable? n)\n    (let ([m (sum_of_divisors n)])\n      (and (not (= n m)) (= (sum_of_divisors m) n))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x)))\n            (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((sum (sum_divisors n)))\n      (and (not (= n sum))\n           (= n (sum_divisors sum)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable-pair? n)\n    (let ([m (sum-of-divisors n)])\n      (and (not (= n m)) (= n (sum-of-divisors m)))))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (for/list ([n (in-range 1 limit)])\n            (if (amicable-pair? n) n 0))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= (remainder n x) 0))\n            (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((m (sum_divisors n)))\n      (and (= (sum_divisors m) n)\n           (not (= m n)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x))) (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((m (sum_divisors n)))\n      (and (not (= n m)) (= n (sum_divisors m)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (sum-divisors n)\n    (define (sum-divisors-iter n acc)\n      (if (= n 1)\n          acc\n          (if (= (remainder n 2) 0)\n              (sum-divisors-iter (/ n 2) (+ acc n))\n              (sum-divisors-iter (- n 1) acc))))\n    (sum-divisors-iter n 0))\n  (define (is-amicable n)\n    (let ((n-sum (sum-divisors n)))\n      (and (= (sum-divisors n-sum) n)\n           (not (= n n-sum)))))\n  (define (amicable-numbers-sum-iter n acc)\n    (if (= n limit)\n        acc\n        (if (is-amicable n)\n            (amicable-numbers-sum-iter (+ n 1) (+ acc n))\n            (amicable-numbers-sum-iter (+ n 1) acc))))\n  (amicable-numbers-sum-iter 1 0))\n",
    "  (define (amicable-sum n)\n    (define (divisors n)\n      (filter (lambda (x) (= (remainder n x) 0)) (range 1 (add1 (quotient n 2)))))\n    (apply + (divisors n)))\n  (define (is-amicable n)\n    (let ((n-sum (amicable-sum n)))\n      (and (not (= n n-sum)) (= (amicable-sum n-sum) n))))\n  (apply + (filter is-amicable (range 1 limit))))\n",
    "  (define (amicable-numbers-sum-iter limit sum)\n    (cond\n      [(= limit 1) sum]\n      [(amicable? limit) (amicable-numbers-sum-iter (- limit 1) (+ sum limit))]\n      [else (amicable-numbers-sum-iter (- limit 1) sum)]))\n  (amicable-numbers-sum-iter limit 0))\n",
    "  (define (amicable? n)\n    (let ([m (sum_of_proper_divisors n)])\n      (and (not (= n m)) (= (sum_of_proper_divisors m) n))))\n  (define (sum_of_proper_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (remainder n i)))\n        i))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (amicable? n)\n    (let ([n2 (sum-of-proper-divisors n)])\n      (and (not (= n n2)) (= n (sum-of-proper-divisors n2)))))\n  (define (sum-of-proper-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (amicable-numbers-sum-iter limit sum)\n    (if (= limit 1)\n        sum\n        (let ((d (sum-of-divisors (- limit 1))))\n          (if (and (= limit d)\n                   (/= limit (sum-of-divisors d)))\n              (amicable-numbers-sum-iter (- limit 1) (+ sum limit))\n              (amicable-numbers-sum-iter (- limit 1) sum)))))\n  (amicable-numbers-sum-iter limit 0))\n",
    "  (define (amicable-pairs n)\n    (define (divisors n)\n      (filter (lambda (x) (= 0 (modulo n x)))\n              (range 1 (add1 (quotient n 2)))))\n    (define (divisors-sum n)\n      (apply + (divisors n)))\n    (define (amicable-pair-p n)\n      (let ((m (divisors-sum n)))\n        (and (not (= n m))\n             (= (divisors-sum m) n))))\n    (filter amicable-pair-p (range 1 limit)))\n  (apply + (map (lambda (x) (apply + x)) (amicable-pairs limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (filter (lambda (x) (= (modulo n x) 0))\n              (range 1 (add1 (quotient n 2)))))\n    (apply + (divisors n)))\n  (apply +\n         (filter (lambda (x) (amicable-pair? x (sum-of-divisors x)))\n                 (range 1 limit))))\n",
    "  (define (amicable-sum n)\n    (define (divisors n)\n      (filter (lambda (x) (= 0 (modulo n x)))\n              (range 1 (add1 (quotient n 2)))))\n    (apply + (divisors n)))\n  (apply + (filter (lambda (x) (= (amicable-sum x) (amicable-sum (amicable-sum x))))\n                   (range 1 limit))))\n",
    "  (define (amicable-numbers-sum-iter limit sum)\n    (cond\n      [(= limit 0) sum]\n      [(amicable? limit) (amicable-numbers-sum-iter (- limit 1) (+ sum limit))]\n      [else (amicable-numbers-sum-iter (- limit 1) sum)]))\n  (amicable-numbers-sum-iter limit 0))\n",
    "  (define (sum-of-divisors n)\n    (define (sum-of-divisors-iter n divisor sum)\n      (cond ((= n 1) sum)\n            ((= 0 (remainder n divisor))\n             (sum-of-divisors-iter (/ n divisor) divisor (+ sum divisor)))\n            (else (sum-of-divisors-iter n (+ divisor 1) sum))))\n    (sum-of-divisors-iter n 2 0))\n  (define (is-amicable? n)\n    (let ((m (sum-of-divisors n)))\n      (and (= n (sum-of-divisors m))\n           (not (= n m)))))\n  (define (amicable-numbers-sum-iter n sum)\n    (cond ((= n limit) sum)\n          ((is-amicable? n) (amicable-numbers-sum-iter (+ n 1) (+ sum n)))\n          (else (amicable-numbers-sum-iter (+ n 1) sum))))\n  (amicable-numbers-sum-iter 1 0))\n",
    "  (define (amicable? n)\n    (let ((n2 (sum-of-divisors n)))\n      (and (= n (sum-of-divisors n2))\n           (not (= n n2)))))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x))) (range 1 (add1 (quotient n 2)))))\n  (define (sum_of_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((m (sum_of_divisors n)))\n      (and (= n (sum_of_divisors m))\n           (not (= n m)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable? n)\n    (let ([m (sum-of-divisors n)])\n      (and (not (= n m)) (= n (sum-of-divisors m)))))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (remainder n i)))\n        i))\n    (apply + (divisors n)))\n  (apply + (for/list ([n (in-range 1 limit)]\n                     #:when (amicable? n))\n             n)))\n",
    "  (define (sum_divisors n)\n    (define (sum_divisors_helper n divisor)\n      (cond ((&gt; divisor (/ n 2)) 0)\n            ((= (modulo n divisor) 0) (+ divisor (sum_divisors_helper n (+ divisor 1))))\n            (else (sum_divisors_helper n (+ divisor 1)))))\n    (sum_divisors_helper n 1))\n  (define (is_amicable n)\n    (let ((sum (sum_divisors n)))\n      (and (= (sum_divisors sum) n)\n           (not (= n sum)))))\n  (define (sum_amicable_numbers_helper n sum)\n    (cond ((&gt; n limit) sum)\n          ((is_amicable n) (sum_amicable_numbers_helper (+ n 1) (+ sum n)))\n          (else (sum_amicable_numbers_helper (+ n 1) sum))))\n  (sum_amicable_numbers_helper 1 0))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x))) (range 1 (add1 (quotient n 2)))))\n  (define (d n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((dn (d n)))\n      (and (not (= n dn)) (= n (d dn)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable? a b)\n    (and (= (sum_of_divisors a) b) (= (sum_of_divisors b) a)))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (when (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (define (amicable-numbers-sum-iter n sum)\n    (cond\n      [(= n limit) sum]\n      [(amicable? n (sum_of_divisors n)) (amicable-numbers-sum-iter (add1 n) (add1 sum))]\n      [else (amicable-numbers-sum-iter (add1 n) sum)]))\n  (amicable-numbers-sum-iter 1 0))\n",
    "  (define (sum-divisors n)\n    (define (divisors n)\n      (filter (lambda (x) (= (modulo n x) 0))\n              (range 1 (add1 (quotient n 2)))))\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((n2 (sum-divisors n)))\n      (and (= (sum-divisors n2) n)\n           (not (= n n2)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (divisors n)\n    (define (divisors-iter n i)\n      (if (&gt; i n)\n          '()\n          (if (zero? (modulo n i))\n              (cons i (divisors-iter n (+ i 1)))\n              (divisors-iter n (+ i 1)))))\n    (divisors-iter n 1))\n  (define (sum-divisors n)\n    (apply + (divisors n)))\n  (define (is-amicable n)\n    (let ((m (sum-divisors n)))\n      (and (not (= n m)) (= (sum-divisors m) n))))\n  (define (amicable-numbers-sum-iter n sum)\n    (if (&gt; n limit)\n        sum\n        (if (is-amicable n)\n            (amicable-numbers-sum-iter (+ n 1) (+ sum n))\n            (amicable-numbers-sum-iter (+ n 1) sum))))\n  (amicable-numbers-sum-iter 1 0))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x))) (range 1 (add1 (/ n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (is_amicable? n)\n    (let ((m (sum_divisors n)))\n      (and (= n (sum_divisors m))\n           (not (= n m)))))\n  (apply + (filter is_amicable? (range 1 limit))))\n",
    "  (define (divisors n)\n    (for/list ([i (in-range 1 (quotient n 2))]\n               #:when (zero? (modulo n i)))\n      i))\n  (define (amicable? n)\n    (let ([divs (divisors n)])\n      (and (not (empty? divs))\n           (= n (apply + (divisors (apply + divs)))))))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (divisors n)\n    (define (divisors-helper n i)\n      (if (&gt; i n)\n          '()\n          (if (zero? (modulo n i))\n              (cons i (divisors-helper n (+ i 1)))\n              (divisors-helper n (+ i 1)))))\n    (divisors-helper n 1))\n  (define (sum-divisors n)\n    (apply + (divisors n)))\n  (define (is-amicable? n)\n    (let ((sum-n (sum-divisors n)))\n      (and (not (= n sum-n))\n           (= n (sum-divisors sum-n)))))\n  (define (amicable-numbers-sum-helper n acc)\n    (if (= n limit)\n        acc\n        (if (is-amicable? n)\n            (amicable-numbers-sum-helper (+ n 1) (+ acc n))\n            (amicable-numbers-sum-helper (+ n 1) acc))))\n  (amicable-numbers-sum-helper 1 0))\n",
    "  (define (amicable? n)\n    (let ([m (sum_of_divisors n)])\n      (and (not (= n m)) (= (sum_of_divisors m) n))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (when (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= (remainder n x) 0)) (range 1 n)))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (is_amicable? n)\n    (let ((m (sum_divisors n)))\n      (and (= n (sum_divisors m))\n           (not (= n m)))))\n  (apply + (filter is_amicable? (range 1 limit))))\n",
    "  (define (sum-of-divisors n)\n    (define (sum-of-divisors-iter n divisor sum)\n      (cond ((= n 1) sum)\n            ((= (remainder n divisor) 0)\n             (sum-of-divisors-iter (/ n divisor) divisor (+ sum divisor)))\n            (else (sum-of-divisors-iter n (+ divisor 1) sum))))\n    (sum-of-divisors-iter n 2 0))\n  (define (is-amicable? n)\n    (let ((n-sum (sum-of-divisors n)))\n      (and (= n-sum (sum-of-divisors n-sum))\n           (not (= n n-sum)))))\n  (define (amicable-numbers-sum-iter n sum)\n    (cond ((= n limit) sum)\n          ((is-amicable? n) (amicable-numbers-sum-iter (+ n 1) (+ sum n)))\n          (else (amicable-numbers-sum-iter (+ n 1) sum))))\n  (amicable-numbers-sum-iter 1 0))\n",
    "  (define (amicable-numbers-sum-iter limit sum)\n    (cond ((= limit 1) sum)\n          ((amicable? limit)\n           (amicable-numbers-sum-iter (- limit 1) (+ sum limit)))\n          (else (amicable-numbers-sum-iter (- limit 1) sum))))\n  (amicable-numbers-sum-iter limit 0))\n",
    "  (define (amicable? n)\n    (let ((m (sum_of_divisors n)))\n      (and (not (= n m)) (= (sum_of_divisors m) n))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (amicable-numbers-sum-iter limit sum)\n    (cond\n      [(= limit 1) sum]\n      [(amicable? limit) (amicable-numbers-sum-iter (- limit 1) (+ limit sum))]\n      [else (amicable-numbers-sum-iter (- limit 1) sum)]))\n  (amicable-numbers-sum-iter limit 0))\n",
    "  (define (amicable? n)\n    (let ((m (sum_of_divisors n)))\n      (and (not (= n m)) (= n (sum_of_divisors m)))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (divisors n)\n    (define (divisors-iter n i)\n      (cond ((&gt; i n) '())\n            ((= (remainder n i) 0) (cons i (divisors-iter n (+ i 1))))\n            (else (divisors-iter n (+ i 1)))))\n    (divisors-iter n 1))\n  (define (sum-divisors n)\n    (apply + (divisors n)))\n  (define (amicable-pair? a b)\n    (= (sum-divisors a) b)\n    (= (sum-divisors b) a))\n  (define (amicable-numbers-sum-iter n sum)\n    (cond ((&gt; n limit) sum)\n          ((amicable-pair? n (sum-divisors n)) (amicable-numbers-sum-iter (+ n 1) (+ sum n)))\n          (else (amicable-numbers-sum-iter (+ n 1) sum))))\n  (amicable-numbers-sum-iter 1 0))\n</code>\nThe problem is that the function <code>amicable-pair?</code> always returns <code>#t</code> and I don't understand why. I tried to debug it by printing the values of <code>a</code> and <code>b</code> and it seems to be working fine.\nI'm using DrRacket.\n\n\nA:\n\nYou're using <code>=</code> instead of <code>and</code> in the <code>amicable-pair?</code> function.\n",
    "  (define (amicable? n)\n    (let ((m (sum_of_divisors n)))\n      (and (not (= n m)) (= (sum_of_divisors m) n))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (remainder n i)))\n        i))\n    (apply + (divisors n)))\n  (apply + (for/list ([n (in-range 1 limit)]\n                     #:when (amicable? n))\n              n)))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x))) (range 1 (add1 (quotient n 2)))))\n  (define (amicable? n)\n    (let ((n2 (sum (divisors n))))\n      (and (= n (sum (divisors n2))) (not (= n n2)))))\n  (sum (filter amicable? (range 1 limit))))\n",
    "  (define (sum_of_divisors n)\n    (define (divisors n)\n      (filter (lambda (x) (= (remainder n x) 0))\n              (range 1 (add1 (quotient n 2)))))\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((m (sum_of_divisors n)))\n      (and (= n (sum_of_divisors m))\n           (not (= n m)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (filter (lambda (x) (= (remainder n x) 0))\n              (range 1 (add1 (quotient n 2)))))\n    (apply + (divisors n)))\n  (apply +\n         (filter (lambda (x)\n                   (let ((y (sum-of-divisors x)))\n                     (and (not (= x y))\n                          (amicable-pair? x y))))\n                 (range 1 limit))))\n",
    "  (define (amicable-number? n)\n    (let ((m (sum-of-divisors n)))\n      (and (not (= n m)) (= (sum-of-divisors m) n))))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (let loop ((i 1) (acc '()))\n        (if (&gt; i (/ n 2))\n            acc\n            (if (zero? (modulo n i))\n                (loop (+ i 1) (cons i acc))\n                (loop (+ i 1) acc)))))\n    (apply + (divisors n)))\n  (apply + (filter amicable-number? (range 1 limit))))\n",
    "  (define (sum-divisors n)\n    (define (sum-divisors-helper n acc)\n      (cond\n        [(= n 1) acc]\n        [(= (remainder n 2) 0) (sum-divisors-helper (/ n 2) (+ acc n))]\n        [(= (remainder n 3) 0) (sum-divisors-helper (/ n 3) (+ acc n))]\n        [else (sum-divisors-helper (- n 1) acc)]))\n    (sum-divisors-helper n 0))\n  (define (is-amicable? n)\n    (let ([sum-of-divisors (sum-divisors n)])\n      (and (= n (sum-divisors sum-of-divisors))\n           (not (= n sum-of-divisors)))))\n  (define (amicable-numbers-sum-helper n acc)\n    (cond\n      [(= n limit) acc]\n      [(is-amicable? n) (amicable-numbers-sum-helper (+ n 1) (+ acc n))]\n      [else (amicable-numbers-sum-helper (+ n 1) acc)]))\n  (amicable-numbers-sum-helper 1 0))\n",
    "  (define (sum_divisors n)\n    (define (sum_divisors_iter n sum)\n      (cond ((= n 1) sum)\n            ((= (remainder n 2) 0)\n             (sum_divisors_iter (/ n 2) (+ sum n)))\n            (else (sum_divisors_iter (- n 1) sum))))\n    (sum_divisors_iter n 1))\n  (define (is_amicable? n)\n    (let ((m (sum_divisors n)))\n      (and (= n (sum_divisors m))\n           (not (= n m)))))\n  (define (sum_amicable_numbers_iter n sum)\n    (cond ((= n limit) sum)\n          ((is_amicable? n) (sum_amicable_numbers_iter (+ n 1) (+ sum n)))\n          (else (sum_amicable_numbers_iter (+ n 1) sum))))\n  (sum_amicable_numbers_iter 1 0))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x)))\n            (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((m (sum_divisors n)))\n      (and (= n (sum_divisors m))\n           (not (= n m)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-proper-divisors a) b)\n         (= (sum-of-proper-divisors b) a)))\n  (define (sum-of-proper-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (remainder n i)))\n        i))\n    (apply + (divisors n)))\n  (define (amicable-numbers limit)\n    (for/list ([i (in-range 1 limit)]\n               [j (in-range 1 limit)])\n      (when (amicable-pair? i j)\n        i)))\n  (apply + (amicable-numbers limit)))\n",
    "  (define (amicable? n)\n    (let ((m (sum-of-divisors n)))\n      (and (not (= n m))\n           (= n (sum-of-divisors m)))))\n  (define (sum-of-divisors n)\n    (let loop ((i 1) (sum 0))\n      (cond ((&gt; i (/ n 2)) sum)\n            ((zero? (remainder n i)) (loop (+ i 1) (+ sum i)))\n            (else (loop (+ i 1) sum)))))\n  (let loop ((i 1) (sum 0))\n    (cond ((&gt; i limit) sum)\n          ((amicable? i) (loop (+ i 1) (+ sum i)))\n          (else (loop (+ i 1) sum)))))\n</code>\n",
    "  (define (amicable? a)\n    (let ((b (sum_of_divisors a)))\n      (and (= a (sum_of_divisors b))\n           (not (= a b)))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (let loop ((i 1) (sum 0))\n    (cond ((&gt; i limit) sum)\n          ((= (sum_of_divisors i) (sum_of_divisors (sum_of_divisors i)))\n           (loop (+ i 1) (+ sum i (sum_of_divisors i))))\n          (else (loop (+ i 1) sum)))))\n",
    "  (define (amicable? n)\n    (let ([m (sum_of_divisors n)])\n      (and (not (= n m)) (= (sum_of_divisors m) n))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (filter (lambda (x) (= 0 (modulo n x)))\n              (range 1 (add1 (quotient n 2)))))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-proper-divisors a) b)\n         (= (sum-proper-divisors b) a)))\n  (define (sum-proper-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (remainder n i)))\n        i))\n    (apply + (divisors n)))\n  (define (amicable-numbers)\n    (for/list ([i (in-range 1 limit)]\n               [j (in-range 1 limit)])\n      (when (amicable-pair? i j)\n        i)))\n  (apply + (amicable-numbers)))\n</code>\n",
    "  (define (sum-of-divisors n)\n    (define (sum-of-divisors-iter n sum)\n      (cond ((= n 1) sum)\n            ((= (remainder n 2) 0) (sum-of-divisors-iter (/ n 2) (+ sum n)))\n            (else (sum-of-divisors-iter (- n 1) sum))))\n    (sum-of-divisors-iter n 0))\n  (define (is-amicable? n)\n    (let ((m (sum-of-divisors n)))\n      (and (= (sum-of-divisors m) n)\n           (not (= n m)))))\n  (define (amicable-numbers-sum-iter n sum)\n    (cond ((= n limit) sum)\n          ((is-amicable? n) (amicable-numbers-sum-iter (+ n 1) (+ sum n)))\n          (else (amicable-numbers-sum-iter (+ n 1) sum))))\n  (amicable-numbers-sum-iter 1 0))\n",
    "  (define (amicable? n)\n    (let ((m (sum_of_divisors n)))\n      (and (not (= n m)) (= (sum_of_divisors m) n))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b) (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (remainder n i)))\n        i))\n    (apply + (divisors n)))\n  (define (amicable-pairs limit)\n    (for/list ([i (in-range 1 limit)]\n               [j (in-range 1 limit)])\n      (when (amicable-pair? i j)\n        (list i j))))\n  (apply + (apply append (amicable-pairs limit))))\n",
    "  (define (amicable-numbers-sum-iter limit sum)\n    (cond ((&gt; limit 1)\n           (let ((divisors-sum (divisors-sum limit)))\n             (if (= limit divisors-sum)\n                 (amicable-numbers-sum-iter (- limit 1) sum)\n                 (amicable-numbers-sum-iter (- limit 1) (+ sum limit divisors-sum)))))\n          (else sum)))\n  (amicable-numbers-sum-iter limit 0))\n",
    "  (define (amicable-numbers-sum-iter limit sum)\n    (if (= limit 1)\n        sum\n        (let ((divisors-sum (divisors-sum limit)))\n          (if (= limit divisors-sum)\n              (amicable-numbers-sum-iter (- limit 1) sum)\n              (amicable-numbers-sum-iter (- limit 1) (+ sum limit divisors-sum))))))\n  (amicable-numbers-sum-iter limit 0))\n",
    "  (define (amicable-numbers-sum-iter limit sum)\n    (cond\n      [(= limit 0) sum]\n      [(amicable? limit) (amicable-numbers-sum-iter (- limit 1) (+ limit sum))]\n      [else (amicable-numbers-sum-iter (- limit 1) sum)]))\n  (amicable-numbers-sum-iter limit 0))\n",
    "  (define (amicable? a b)\n    (and (= (sum_of_divisors a) b) (= (sum_of_divisors b) a)))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (define (amicable_numbers_sum_helper n acc)\n    (if (&gt; n limit)\n        acc\n        (if (amicable? n (sum_of_divisors n))\n            (amicable_numbers_sum_helper (add1 n) (add1 acc))\n            (amicable_numbers_sum_helper (add1 n) acc))))\n  (amicable_numbers_sum_helper 1 0))\n",
    "  (define (amicable? n)\n    (let ((m (sum_of_divisors n)))\n      (and (not (= n m)) (= n (sum_of_divisors m)))))\n  (define (sum_of_divisors n)\n    (apply + (filter (lambda (x) (= (modulo n x) 0)) (range 1 n))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (sum_of_divisors n)\n    (define (divisors n)\n      (filter (lambda (x) (= (modulo n x) 0))\n              (range 1 (add1 (truncate (sqrt n))))))\n    (apply + (divisors n)))\n  (define (is_amicable? n)\n    (let ((n2 (sum_of_divisors n)))\n      (and (= n (sum_of_divisors n2))\n           (not (= n n2)))))\n  (apply + (filter is_amicable? (range 1 limit))))\n",
    "  (define (amicable-numbers-sum-iter limit sum)\n    (cond ((&gt; limit 1)\n           (let ((divisor-sum (divisor-sum limit)))\n             (if (and (not (= limit divisor-sum)) (= (divisor-sum divisor-sum) limit))\n                 (amicable-numbers-sum-iter (- limit 1) (+ sum limit))\n                 (amicable-numbers-sum-iter (- limit 1) sum))))\n          (else sum)))\n  (amicable-numbers-sum-iter limit 0))\n",
    "  (define (amicable? n)\n    (let ((n2 (sum_of_divisors n)))\n      (and (not (= n n2)) (= n (sum_of_divisors n2)))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))] #:when (zero? (modulo n i)))\n        i))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (let loop ((i 1) (sum 0))\n    (cond\n      ((&gt; i limit) sum)\n      ((= (sum_of_divisors (sum_of_divisors i)) i)\n       (loop (+ i 1) (+ sum i)))\n      (else (loop (+ i 1) sum)))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b) (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (apply + (filter (lambda (x) (= 0 (modulo n x))) (range 1 n))))\n  (apply + (filter (lambda (x) (amicable-pair? x (sum-of-divisors x))) (range 1 limit))))\n",
    "  (define (amicable? n)\n    (let ((m (sum-of-divisors n)))\n      (and (not (= n m)) (= n (sum-of-divisors m)))))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (filter (lambda (x) (= (remainder n x) 0))\n              (range 1 (add1 (quotient n 2)))))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (remainder n i)))\n        i))\n    (apply + (divisors n)))\n  (define (amicable-pairs limit)\n    (for/list ([i (in-range 1 limit)]\n               [j (in-range 1 limit)])\n      (when (amicable-pair? i j)\n        (list i j))))\n  (apply + (apply append (amicable-pairs limit))))\n",
    "  (define (amicable? n)\n    (let ((n-divisors (divisors n)))\n      (and (not (null? n-divisors))\n           (= n (apply + (cdr n-divisors)))\n           (= (apply + (divisors (car n-divisors))) n))))\n  (define (divisors n)\n    (let loop ((i 1) (divisors '()))\n      (cond ((&gt; i (/ n 2)) (cons n divisors))\n            ((zero? (modulo n i)) (loop (+ i 1) (cons i divisors)))\n            (else (loop (+ i 1) divisors)))))\n  (define (amicable-numbers-sum-iter i sum)\n    (cond ((&gt; i limit) sum)\n          ((amicable? i) (amicable-numbers-sum-iter (+ i 1) (+ sum i)))\n          (else (amicable-numbers-sum-iter (+ i 1) sum))))\n  (amicable-numbers-sum-iter 1 0))\n</code>\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= (remainder n x) 0))\n            (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((m (sum_divisors n)))\n      (and (not (= n m))\n           (= (sum_divisors m) n))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (divisors n)\n    (define (helper n i)\n      (cond\n        [(= i n) '()]\n        [(= 0 (modulo n i)) (cons i (helper n (+ i 1)))]\n        [else (helper n (+ i 1))]))\n    (helper n 1))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (is_amicable? n)\n    (let ([n2 (sum_divisors n)])\n      (and (= n (sum_divisors n2))\n           (not (= n n2)))))\n  (define (helper n)\n    (cond\n      [(= n limit) 0]\n      [(is_amicable? n) (+ n (helper (+ n 1)))]\n      [else (helper (+ n 1))]))\n  (helper 1))\n",
    "  (define (amicable? a)\n    (let ([b (sum_proper_divisors a)])\n      (and (not (= a b)) (= a (sum_proper_divisors b)))))\n  (define (sum_proper_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (remainder n i)))\n        i))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (divisors n)\n    (define (divisors-helper n divisor)\n      (if (&gt; divisor (sqrt n))\n          (list n)\n          (if (zero? (modulo n divisor))\n              (cons divisor (cons (/ n divisor) (divisors-helper n (+ divisor 1))))\n              (divisors-helper n (+ divisor 1)))))\n    (divisors-helper n 2))\n  (define (sum-divisors n)\n    (apply + (divisors n)))\n  (define (is-amicable? n)\n    (let ((m (sum-divisors n)))\n      (and (not (= n m)) (= n (sum-divisors m)))))\n  (define (amicable-numbers-sum-helper n sum)\n    (if (= n limit)\n        sum\n        (if (is-amicable? n)\n            (amicable-numbers-sum-helper (+ n 1) (+ sum n))\n            (amicable-numbers-sum-helper (+ n 1) sum))))\n  (amicable-numbers-sum-helper 1 0))\n",
    "  (define (divisors n)\n    (define (divisors-iter n i)\n      (if (&gt; i n)\n          '()\n          (if (= (remainder n i) 0)\n              (cons i (divisors-iter n (+ i 1)))\n              (divisors-iter n (+ i 1)))))\n    (divisors-iter n 1))\n  (define (sum-divisors n)\n    (apply + (divisors n)))\n  (define (is-amicable n)\n    (let ((n-sum (sum-divisors n)))\n      (and (= n (sum-divisors n-sum))\n           (not (= n n-sum)))))\n  (define (amicable-numbers-iter n sum)\n    (if (&gt; n limit)\n        sum\n        (if (is-amicable n)\n            (amicable-numbers-iter (+ n 1) (+ sum n))\n            (amicable-numbers-iter (+ n 1) sum))))\n  (amicable-numbers-iter 1 0))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x)))\n            (range 1 (add1 (quotient n 2)))))\n  (define (d n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((d-n (d n)))\n      (and (not (= n d-n))\n           (= n (d d-n)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x)))\n            (range 1 (add1 (quotient n 2)))))\n  (define (amicable? n)\n    (let ((m (apply + (divisors n))))\n      (and (not (= n m))\n           (= n (apply + (divisors m))))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x))) (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((m (sum_divisors n)))\n      (and (not (= n m)) (= (sum_divisors m) n))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable? n)\n    (let ((m (sum_of_proper_divisors n)))\n      (and (not (= n m)) (= (sum_of_proper_divisors m) n))))\n  (define (sum_of_proper_divisors n)\n    (apply + (filter (lambda (x) (= 0 (modulo n x))) (range 1 (quotient n 2)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x)))\n            (range 1 (add1 (quotient n 2)))))\n  (define (d n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((dn (d n)))\n      (and (not (= n dn))\n           (= n (d dn)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (modulo n i)))\n        i))\n    (apply + (divisors n)))\n  (define (amicable-pairs)\n    (for/list ([i (in-range 1 limit)]\n               [j (in-range 1 limit)])\n      (when (amicable-pair? i j)\n        (list i j))))\n  (apply + (apply append (amicable-pairs))))\n",
    "  (define (divisors n)\n    (for/list ([i (in-range 1 (quotient n 2))]\n               #:when (zero? (modulo n i)))\n      i))\n  (define (sum-divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ([m (sum-divisors n)])\n      (and (not (= n m)) (= (sum-divisors m) n))))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (remainder n i)))\n        i))\n    (apply + (divisors n)))\n  (define (amicable-numbers)\n    (for/list ([i (in-range 1 limit)]\n               [j (in-range 1 limit)])\n      (when (amicable-pair? i j)\n        i)))\n  (apply + (amicable-numbers)))\n",
    "  (define (amicable-pairs limit)\n    (for/list ([i (in-range 1 limit)])\n      (define (divisors n)\n        (for/list ([j (in-range 1 (quotient n 2))])\n          (if (zero? (modulo n j))\n              j)))\n      (define (sum-divisors n)\n        (apply + (divisors n)))\n      (define (amicable? n)\n        (let ([sum (sum-divisors n)])\n          (and (not (zero? sum))\n               (= (sum-divisors sum) n)\n               (not (= n sum)))))\n      (if (amicable? i)\n          (list i (sum-divisors i)))))\n  (apply + (apply append (amicable-pairs limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (remainder n i)) i)))\n    (apply + (divisors n)))\n  (define (amicable-numbers-from-to a b)\n    (for/list ([i (in-range a b)])\n      (for/list ([j (in-range a b)])\n        (if (amicable-pair? i j) i))))\n  (apply + (amicable-numbers-from-to 1 limit)))\n"
  ]
}