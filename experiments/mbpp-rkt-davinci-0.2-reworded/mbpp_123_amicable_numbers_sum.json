{
  "name": "mbpp_123_amicable_numbers_sum",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to sum all amicable numbers from 1 to a specified number.\n(define (amicable_numbers_sum limit)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_123_amicable_numbers_sum.py",
  "prompt_terminology": "reworded",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate amicable_numbers_sum))\n    (check-equal? (candidate 999) 504)\n    (check-equal? (candidate 9999) 31626)\n    (check-equal? (candidate 99) 0)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (amicable-pair? a b)\n    (and (= a (sum-of-divisors b))\n         (= b (sum-of-divisors a))))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (filter (lambda (x) (= (modulo n x) 0))\n              (range 1 (add1 (quotient n 2)))))\n    (apply + (divisors n)))\n  (define (amicable-numbers)\n    (filter (lambda (x) (amicable-pair? x (sum-of-divisors x)))\n            (range 1 limit)))\n  (apply + (amicable-numbers)))\n",
    "  (define (amicable-pair? n)\n    (let* ([m (sum-of-divisors n)]\n           [n2 (sum-of-divisors m)])\n      (and (= n2 n)\n           (/= m n))))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (modulo n i)))\n        i))\n    (apply + (divisors n)))\n  (apply + (filter amicable-pair? (in-range 1 limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (define (amicable-numbers)\n    (for/list ([i (in-range 1 limit)])\n      (for ([j (in-range 1 limit)])\n        (if (amicable-pair? i j) i))))\n  (apply + (amicable-numbers)))\n",
    "  (define (amicable? n)\n    (let ((m (sum_of_divisors n)))\n      (and (not (= n m)) (= n (sum_of_divisors m)))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (remainder n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (amicable-pairs-up-to limit)\n    (for/list ([i (in-range 1 limit)])\n      (let ([divisors (filter (\u03bb (x) (not (zero? (modulo i x))))\n                              (in-range 1 (quotient i 2)))])\n        (let ([divisors-sum (apply + divisors)])\n          (if (= i (apply + (filter (\u03bb (x) (not (zero? (modulo divisors-sum x))))\n                                    (in-range 1 (quotient divisors-sum 2)))))\n              (list i divisors-sum))))))\n  (apply + (filter (\u03bb (x) (not (zero? (modulo x 2))))\n                   (apply append (amicable-pairs-up-to limit)))))\n",
    "  (define (amicable? n)\n    (let ((m (sum-of-divisors n)))\n      (and (not (= n m)) (= n (sum-of-divisors m)))))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (apply + (filter (lambda (x) (= 0 (modulo n x)))\n                     (range 1 (add1 (/ n 2))))))\n  (apply + (filter (lambda (x) (amicable-pair? x (sum-of-divisors x)))\n                   (range 1 limit))))\n",
    "  (define (sum-divisors n)\n    (define (sum-divisors-helper n divisor)\n      (if (&gt; divisor n)\n          0\n          (if (zero? (modulo n divisor))\n              (+ divisor (sum-divisors-helper n (+ divisor 1)))\n              (sum-divisors-helper n (+ divisor 1)))))\n    (sum-divisors-helper n 1))\n  (define (is-amicable? n)\n    (let ((n-sum (sum-divisors n)))\n      (and (not (= n n-sum))\n           (= n (sum-divisors n-sum)))))\n  (define (amicable-numbers-sum-helper n sum)\n    (if (&gt; n limit)\n        sum\n        (if (is-amicable? n)\n            (amicable-numbers-sum-helper (+ n 1) (+ sum n))\n            (amicable-numbers-sum-helper (+ n 1) sum))))\n  (amicable-numbers-sum-helper 1 0))\n",
    "  (define (amicable? n)\n    (let ((m (sum-of-divisors n)))\n      (and (not (= n m)) (= (sum-of-divisors m) n))))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (filter (lambda (x) (= (modulo n x) 0)) (range 1 (add1 (quotient n 2)))))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable? n)\n    (let ((m (sum_of_divisors n)))\n      (and (not (= n m)) (= n (sum_of_divisors m)))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (remainder n i)))\n        i))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (sum-of-divisors n)\n    (define (sum-of-divisors-iter n sum)\n      (cond ((= n 1) sum)\n            ((= (remainder n 2) 0)\n             (sum-of-divisors-iter (/ n 2) (+ sum (/ n 2))))\n            (else (sum-of-divisors-iter (- n 1) (+ sum (- n 1))))))\n    (sum-of-divisors-iter n 0))\n  (define (is-amicable? n)\n    (let ((sum (sum-of-divisors n)))\n      (and (= n (sum-of-divisors sum))\n           (not (= n sum)))))\n  (define (amicable-numbers-sum-iter n sum)\n    (cond ((&gt; n limit) sum)\n          ((is-amicable? n) (amicable-numbers-sum-iter (+ n 1) (+ sum n)))\n          (else (amicable-numbers-sum-iter (+ n 1) sum))))\n  (amicable-numbers-sum-iter 1 0))\n",
    "  (define (sum_of_divisors n)\n    (define (sum_of_divisors-iter n sum)\n      (cond ((= n 1) sum)\n            ((= 0 (modulo n 2)) (sum_of_divisors-iter (/ n 2) (+ sum n)))\n            (else (sum_of_divisors-iter (- n 1) sum))))\n    (sum_of_divisors-iter n 0))\n  (define (is-amicable? n)\n    (let ((m (sum_of_divisors n)))\n      (and (= n (sum_of_divisors m))\n           (not (= n m)))))\n  (define (amicable-numbers-sum-iter n sum)\n    (cond ((= n limit) sum)\n          ((is-amicable? n) (amicable-numbers-sum-iter (+ n 1) (+ n sum)))\n          (else (amicable-numbers-sum-iter (+ n 1) sum))))\n  (amicable-numbers-sum-iter 1 0))\n",
    "  (define (amicable? n)\n    (let ([m (sum-of-divisors n)])\n      (and (not (= n m)) (= (sum-of-divisors m) n))))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (amicable? n)\n    (let ((m (sum_of_divisors n)))\n      (and (not (= n m)) (= (sum_of_divisors m) n))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (sum-divisors n)\n    (define (sum-divisors-iter n divisor sum)\n      (cond ((= n 1) sum)\n            ((= n divisor) (+ sum divisor))\n            ((= (modulo n divisor) 0)\n             (sum-divisors-iter (/ n divisor) divisor (+ sum divisor (/ n divisor))))\n            (else (sum-divisors-iter n (+ divisor 1) sum))))\n    (sum-divisors-iter n 2 0))\n  (define (amicable-numbers-sum-iter n sum)\n    (cond ((= n limit) sum)\n          ((= (sum-divisors n) (sum-divisors (+ n 1)))\n           (amicable-numbers-sum-iter (+ n 2) (+ sum n (+ n 1))))\n          (else (amicable-numbers-sum-iter (+ n 1) sum))))\n  (amicable-numbers-sum-iter 1 0))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x)))\n            (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((m (sum_divisors n)))\n      (and (not (= n m)) (= n (sum_divisors m)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable? n)\n    (let ([n2 (sum_of_divisors n)])\n      (and (not (= n n2)) (= n (sum_of_divisors n2)))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (when (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (modulo n i)))\n        i))\n    (apply + (divisors n)))\n  (define (amicable-numbers)\n    (for/list ([i (in-range 1 limit)]\n               [j (in-range 1 limit)])\n      (when (amicable-pair? i j)\n        i)))\n  (apply + (amicable-numbers)))\n",
    "  (define (amicable? a b)\n    (and (= (sum-of-divisors a) b) (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (define (amicable-numbers n)\n    (for/list ([i (in-range 1 n)])\n      (if (amicable? i (sum-of-divisors i)) i)))\n  (apply + (amicable-numbers limit)))\n",
    "  (define (divisors n)\n    (for/list ([i (in-range 1 (quotient n 2))]\n               #:when (zero? (modulo n i)))\n      i))\n  (define (amicable? n)\n    (let ([d (divisors n)])\n      (and (not (null? d))\n           (= (apply + d) n))))\n  (apply + (for/list ([i (in-range 1 limit)])\n            (if (amicable? i)\n                i\n                0))))\n"
  ]
}