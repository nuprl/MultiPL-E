{
  "name": "mbpp_442_positive_count",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to find the ration of positive numbers in a list of integers.\n(define (positive_count nums)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_442_positive_count.py",
  "prompt_terminology": "reworded",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate positive_count))\n    (check-equal? (candidate (list 0 1 2 -1 -5 6 0 -3 -2 3 4 6 8)) 0.54)\n    (check-equal? (candidate (list 2 1 2 -1 -5 6 4 -3 -2 3 4 6 8)) 0.69)\n    (check-equal? (candidate (list 2 4 -6 -9 11 -12 14 -5 17)) 0.56)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (iter nums count)\n    (if (null? nums)\n        (/ count (length nums))\n        (if (&gt; (car nums) 0)\n            (iter (cdr nums) (+ count 1))\n            (iter (cdr nums) count))))\n  (iter nums 0))\n",
    "  (define (helper nums count)\n    (cond ((null? nums) (/ count (length nums)))\n          ((> (car nums) 0) (helper (cdr nums) (+ count 1)))\n          (else (helper (cdr nums) count))))\n  (helper nums 0))\n",
    "  (cond [(empty? nums) 0]\n        [(positive? (first nums)) (+ 1 (positive_count (rest nums)))]\n        [else (positive_count (rest nums))]))\n",
    "  (define (pos? num)\n    (if (&gt; num 0)\n        1\n        0))\n  (define (pos-count nums)\n    (if (null? nums)\n        0\n        (+ (pos? (car nums)) (pos-count (cdr nums)))))\n  (/ (pos-count nums) (length nums)))\n",
    "  (define (positive? num)\n    (and (integer? num) (> num 0)))\n  (define (count-positive nums)\n    (if (null? nums)\n        0\n        (+ (if (positive? (car nums)) 1 0)\n           (count-positive (cdr nums)))))\n  (/ (count-positive nums) (length nums)))\n",
    "  (define (positive? num)\n    (if (&gt; num 0)\n        #t\n        #f))\n  (define (count-positive nums)\n    (if (null? nums)\n        0\n        (+ (positive? (car nums))\n           (count-positive (cdr nums)))))\n  (/ (count-positive nums)\n     (length nums)))\n",
    "  (define (positive? n)\n    (if (positive? n)\n        1\n        0))\n  (define (sum lst)\n    (if (null? lst)\n        0\n        (+ (positive? (car lst))\n           (sum (cdr lst)))))\n  (/ (sum nums) (length nums)))\n",
    "  (define (positive? num)\n    (and (integer? num)\n         (> num 0)))\n  (define (count-positive nums)\n    (if (null? nums)\n        0\n        (+ (if (positive? (car nums)) 1 0)\n           (count-positive (cdr nums)))))\n  (/ (count-positive nums)\n     (length nums)))\n",
    "  (define (positive? num)\n    (if (&gt; num 0) 1 0))\n  (define (sum-positive nums)\n    (if (null? nums)\n        0\n        (+ (positive? (car nums)) (sum-positive (cdr nums)))))\n  (/ (sum-positive nums) (length nums)))\n",
    "  (define (positive? n)\n    (if (&gt; n 0)\n        #t\n        #f))\n  (define (count-positive nums)\n    (if (null? nums)\n        0\n        (if (positive? (car nums))\n            (+ 1 (count-positive (cdr nums)))\n            (count-positive (cdr nums)))))\n  (/ (count-positive nums) (length nums)))\n",
    "  (define (positive? n)\n    (if (&gt; n 0)\n        #t\n        #f))\n  (define (count-positive nums)\n    (if (null? nums)\n        0\n        (+ (if (positive? (car nums))\n               1\n               0)\n           (count-positive (cdr nums)))))\n  (/ (count-positive nums) (length nums)))\n</code>\n",
    "  (define (iter nums count)\n    (if (null? nums)\n        (/ count (length nums))\n        (if (&gt; (car nums) 0)\n            (iter (cdr nums) (+ count 1))\n            (iter (cdr nums) count))))\n  (iter nums 0))\n",
    "  (define (positive? num)\n    (if (&gt; num 0)\n        1\n        0))\n  (define (count-positive nums)\n    (if (null? nums)\n        0\n        (+ (positive? (car nums))\n           (count-positive (cdr nums)))))\n  (/ (count-positive nums)\n     (length nums)))\n",
    "  (define (count nums count)\n    (if (null? nums)\n        count\n        (if (&gt; (car nums) 0)\n            (count (cdr nums) (+ count 1))\n            (count (cdr nums) count))))\n  (/ (count nums 0) (length nums)))\n",
    "  (define (pos? n)\n    (if (&gt; n 0) 1 0))\n  (define (pos-count nums)\n    (if (null? nums)\n        0\n        (+ (pos? (car nums)) (pos-count (cdr nums)))))\n  (/ (pos-count nums) (length nums)))\n",
    "  (define (positive? num)\n    (if (&gt; num 0)\n        1\n        0))\n  (define (positive-count-helper nums count)\n    (if (null? nums)\n        (/ count (length nums))\n        (positive-count-helper (cdr nums) (+ count (positive? (car nums))))))\n  (positive-count-helper nums 0))\n",
    "  (let loop ([nums nums] [count 0])\n    (if (null? nums)\n        (/ count (length nums))\n        (if (positive? (car nums))\n            (loop (cdr nums) (+ count 1))\n            (loop (cdr nums) count)))))\n",
    "  (define (positive? num)\n    (and (number? num)\n         (&gt; num 0)))\n  (define (count-positive nums)\n    (if (null? nums)\n        0\n        (+ (if (positive? (car nums)) 1 0)\n           (count-positive (cdr nums)))))\n  (/ (count-positive nums)\n     (length nums)))\n",
    "  (define (count-positive nums)\n    (cond\n      [(empty? nums) 0]\n      [(positive? (first nums)) (+ 1 (count-positive (rest nums)))]\n      [else (count-positive (rest nums))]))\n  (/ (count-positive nums) (length nums)))\n",
    "  (define (positive? num)\n    (if (&gt; num 0)\n        1\n        0))\n  (/ (apply + (map positive? nums))\n     (length nums)))\n"
  ]
}