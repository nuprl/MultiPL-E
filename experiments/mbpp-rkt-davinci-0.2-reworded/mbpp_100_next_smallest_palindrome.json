{
  "name": "mbpp_100_next_smallest_palindrome",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n(define (next_smallest_palindrome num)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_100_next_smallest_palindrome.py",
  "prompt_terminology": "reworded",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate next_smallest_palindrome))\n    (check-equal? (candidate 99) 101)\n    (check-equal? (candidate 1221) 1331)\n    (check-equal? (candidate 120) 121)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (is_palindrome? num)\n    (define (helper num rev)\n      (if (zero? num)\n          (equal? rev 0)\n          (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (helper num 0))\n  (define (next_palindrome num)\n    (if (is_palindrome? num)\n        (next_palindrome (+ num 1))\n        num))\n  (next_palindrome num))\n",
    "  (let ([num-str (number->string num)])\n    (if (string=? num-str (reverse num-str))\n        num\n        (next_smallest_palindrome (add1 num)))))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-num num)\n      (define (iter num rev-num)\n        (if (zero? num)\n            rev-num\n            (iter (quotient num 10) (+ (* rev-num 10) (remainder num 10)))))\n      (iter num 0))\n    (= num (reverse-num num)))\n  (define (iter num)\n    (if (is_palindrome? num)\n        num\n        (iter (+ num 1))))\n  (iter (+ num 1)))\n",
    "  (define (reverse-num num)\n    (define (reverse-num-iter num rev)\n      (if (zero? num)\n          rev\n          (reverse-num-iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (reverse-num-iter num 0))\n  (define (is-palindrome? num)\n    (if (= num (reverse-num num))\n        #t\n        #f))\n  (define (next-palindrome-iter num)\n    (if (is-palindrome? num)\n        num\n        (next-palindrome-iter (+ num 1))))\n  (next-palindrome-iter (+ num 1)))\n",
    "  (let loop ((num num))\n    (if (palindrome? num)\n        num\n        (loop (+ num 1)))))\n",
    "  (if (palindrome? num)\n      (next-palindrome-helper num 1)\n      (next-palindrome-helper num 0)))\n",
    "  (define (reverse-num num)\n    (define (helper num rev)\n      (if (&lt; num 10)\n          rev\n          (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (helper num 0))\n  (define (is-palindrome? num)\n    (= num (reverse-num num)))\n  (define (next-palindrome num)\n    (if (is-palindrome? num)\n        num\n        (next-palindrome (+ num 1))))\n  (next-palindrome (+ num 1)))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-digits num)\n      (define (reverse-digits-iter num rev)\n        (if (zero? num)\n            rev\n            (reverse-digits-iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n      (reverse-digits-iter num 0))\n    (if (= num (reverse-digits num))\n        #t\n        #f))\n  (define (next-palindrome-iter num)\n    (if (is_palindrome? num)\n        num\n        (next-palindrome-iter (+ num 1))))\n  (next-palindrome-iter num))\n",
    "  (let loop ([num num])\n    (if (palindrome? num)\n        num\n        (loop (+ num 1)))))\n",
    "  (if (palindrome? num)\n      (next-palindrome num)\n      (next-palindrome (next-palindrome num))))\n",
    "  (define (reverse-digits num)\n    (define (reverse-digits-iter num rev)\n      (if (&lt; num 10)\n          rev\n          (reverse-digits-iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (reverse-digits-iter num 0))\n  (define (is-palindrome? num)\n    (if (= num (reverse-digits num))\n        #t\n        #f))\n  (define (next-palindrome-iter num)\n    (if (is-palindrome? num)\n        num\n        (next-palindrome-iter (+ num 1))))\n  (next-palindrome-iter (+ num 1)))\n",
    "  (define (is_palindrome? num)\n    (define (helper num rev)\n      (if (zero? num)\n          (= rev 0)\n          (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (helper num 0))\n  (define (helper num)\n    (if (is_palindrome? num)\n        num\n        (helper (+ num 1))))\n  (helper (+ num 1)))\n",
    "  (define (reverse-num num)\n    (define (reverse-num-iter num rev)\n      (if (= num 0)\n          rev\n          (reverse-num-iter (/ num 10) (+ (* rev 10) (modulo num 10)))))\n    (reverse-num-iter num 0))\n  (define (is-palindrome? num)\n    (= num (reverse-num num)))\n  (define (next-palindrome-iter num)\n    (if (is-palindrome? num)\n        num\n        (next-palindrome-iter (+ num 1))))\n  (next-palindrome-iter num))\n",
    "  (define (is_palindrome? num)\n    (define (helper num rev)\n      (if (zero? num)\n          (equal? num rev)\n          (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (helper num 0))\n  (define (helper num)\n    (if (is_palindrome? num)\n        num\n        (helper (+ num 1))))\n  (helper (+ num 1)))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-num num)\n      (define (helper num rev)\n        (if (zero? num)\n            rev\n            (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n      (helper num 0))\n    (= num (reverse-num num)))\n  (define (next-palindrome num)\n    (if (is_palindrome? num)\n        num\n        (next-palindrome (+ num 1))))\n  (next-palindrome num))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-digits num)\n      (define (helper num rev)\n        (if (zero? num)\n            rev\n            (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n      (helper num 0))\n    (= num (reverse-digits num)))\n  (define (next-palindrome num)\n    (if (is_palindrome? num)\n        num\n        (next-palindrome (+ num 1))))\n  (next-palindrome num))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-num num)\n      (define (iter num rev)\n        (if (= num 0)\n            rev\n            (iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n      (iter num 0))\n    (= num (reverse-num num)))\n  (define (next-palindrome num)\n    (if (is_palindrome? num)\n        num\n        (next-palindrome (+ num 1))))\n  (next-palindrome num))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-num num)\n      (define (reverse-num-iter num reversed-num)\n        (if (zero? num)\n            reversed-num\n            (reverse-num-iter (/ num 10) (+ (* reversed-num 10) (modulo num 10)))))\n      (reverse-num-iter num 0))\n    (if (= num (reverse-num num))\n        #t\n        #f))\n  (define (next-palindrome-iter num)\n    (if (is_palindrome? num)\n        num\n        (next-palindrome-iter (+ num 1))))\n  (next-palindrome-iter num))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-int num)\n      (define (reverse-int-helper num acc)\n        (if (= num 0)\n            acc\n            (reverse-int-helper (quotient num 10) (+ (* acc 10) (remainder num 10)))))\n      (reverse-int-helper num 0))\n    (= num (reverse-int num)))\n  (define (next-palindrome-helper num)\n    (if (is_palindrome? num)\n        num\n        (next-palindrome-helper (+ num 1))))\n  (next-palindrome-helper (+ num 1)))\n",
    "  (define (is-palindrome? num)\n    (define (helper n)\n      (if (&lt; n 10)\n          #t\n          (and (= (modulo n 10) (quotient n 10))\n               (helper (quotient (- n (* (quotient n 10) 10)) 10)))))\n    (helper num))\n  (define (helper num)\n    (if (is-palindrome? num)\n        num\n        (helper (+ num 1))))\n  (helper num))\n</code>\n"
  ]
}