{
  "name": "mbpp_20_is_woodall",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to check if the given number is woodball or not.\n(define (is_woodall x)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_20_is_woodall.py",
  "prompt_terminology": "reworded",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_woodall))\n    (check-equal? (candidate 383) #t)\n    (check-equal? (candidate 254) #f)\n    (check-equal? (candidate 200) #f)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (is-prime? x)\n    (define (iter n)\n      (cond ((= n 1) #t)\n            ((zero? (modulo x n)) #f)\n            (else (iter (- n 1)))))\n    (iter (- x 1)))\n  (define (is-woodall? x)\n    (define (iter n)\n      (cond ((= n 1) #t)\n            ((zero? (modulo x n)) #f)\n            (else (iter (- n 1)))))\n    (iter (- x 1)))\n  (is-woodall? x))\n",
    "  (define (is-prime? x)\n    (define (iter n)\n      (cond ((= n 1) #t)\n            ((= (remainder x n) 0) #f)\n            (else (iter (- n 1)))))\n    (iter (- x 1)))\n  (define (is-woodall? x)\n    (define (iter n)\n      (cond ((= n 1) #t)\n            ((= (remainder x n) 0) #f)\n            (else (iter (- n 1)))))\n    (iter (- x 1)))\n  (and (is-prime? x) (is-woodall? x)))\n",
    "  (define (is-prime? x)\n    (define (divides? a b) (= (remainder b a) 0))\n    (define (find-divisor n test-divisor)\n      (cond ((> (square test-divisor) n) n)\n            ((divides? test-divisor n) test-divisor)\n            (else (find-divisor n (+ test-divisor 1)))))\n    (= n (find-divisor n 2)))\n  (define (is-woodall? x)\n    (define (is-woodall-iter x n)\n      (cond ((= x 1) #t)\n            ((= x n) #f)\n            ((is-prime? n) (is-woodall-iter (- x n) (+ n 1)))\n            (else (is-woodall-iter x (+ n 1)))))\n    (is-woodall-iter x 1))\n  (is-woodall? x))\n",
    "  (let loop ([x x] [i 2])\n    (cond\n      [(= i x) #t]\n      [(= (remainder x i) 0) #f]\n      [else (loop x (+ i 1))])))\n",
    "  (define (is_prime? x)\n    (define (iter n)\n      (if (= n 1)\n          #t\n          (if (= (remainder x n) 0)\n              #f\n              (iter (- n 1)))))\n    (iter (- x 1)))\n  (define (is_woodall? x)\n    (define (iter n)\n      (if (= n 1)\n          #t\n          (if (is_prime? n)\n              (if (= (expt n 2) x)\n                  #t\n                  (iter (- n 1)))\n              (iter (- n 1)))))\n    (iter (- x 1)))\n  (is_woodall? x))\n",
    "  (define (is_prime x)\n    (define (divides? a b)\n      (= (remainder b a) 0))\n    (define (find-divisor n test-divisor)\n      (cond ((> (square test-divisor) n) n)\n            ((divides? test-divisor n) test-divisor)\n            (else (find-divisor n (+ test-divisor 1)))))\n    (= (find-divisor x 2) x))\n  (define (is_woodall-helper x n)\n    (cond ((= x 1) #t)\n          ((= x n) #f)\n          ((is_prime x) (is_woodall-helper (/ x n) n))\n          (else (is_woodall-helper x (+ n 1)))))\n  (is_woodall-helper x 2))\n",
    "  (define (is-prime? x)\n    (define (iter n)\n      (cond ((= n 1) #t)\n            ((= (remainder x n) 0) #f)\n            (else (iter (- n 1)))))\n    (iter (- x 1)))\n  (define (iter n)\n    (cond ((= n 1) #t)\n          ((is-prime? n) (iter (- n 1)))\n          (else #f)))\n  (iter x))\n",
    "  (define (is_prime? x)\n    (define (iter n)\n      (cond ((= n 1) #t)\n            ((= (modulo x n) 0) #f)\n            (else (iter (- n 1)))))\n    (iter (- x 1)))\n  (define (is_woodall? x)\n    (define (iter n)\n      (cond ((= n 1) #t)\n            ((= (modulo x n) 0) #f)\n            (else (iter (- n 1)))))\n    (iter (- x 1)))\n  (and (is_prime? x) (is_woodall? x)))\n",
    "  (define (is-prime? x)\n    (define (iter n)\n      (cond ((= n 1) #t)\n            ((= (modulo x n) 0) #f)\n            (else (iter (- n 1)))))\n    (iter (- x 1)))\n  (define (is-woodall? x)\n    (define (iter n)\n      (cond ((= n 1) #t)\n            ((= (modulo x n) 0) #f)\n            (else (iter (- n 1)))))\n    (iter (- x 1)))\n  (is-woodall? x))\n",
    "  (if (= x 1)\n      #t\n      (if (= (modulo x 2) 0)\n          (is_woodall (/ x 2))\n          (is_woodall (* x 3) (+ x 1)))))\n",
    "  (define (is-prime? x)\n    (define (iter n)\n      (cond ((= n 1) #t)\n            ((= (remainder x n) 0) #f)\n            (else (iter (- n 1)))))\n    (iter (- x 1)))\n  (define (is-woodall? x)\n    (define (iter n)\n      (cond ((= n 1) #t)\n            ((= (remainder x n) 0) #f)\n            (else (iter (- n 1)))))\n    (iter (- x 1)))\n  (is-woodall? x))\n",
    "  (define (is-prime? x)\n    (define (iter n)\n      (cond\n        [(= n 1) #t]\n        [(= (remainder x n) 0) #f]\n        [else (iter (- n 1))]))\n    (iter (- x 1)))\n  (define (is-woodall? x)\n    (define (iter n)\n      (cond\n        [(= n 1) #t]\n        [(= (remainder x n) 0) #f]\n        [else (iter (- n 1))]))\n    (iter (- x 1)))\n  (is-woodall? x))\n",
    "  (define (is_prime x)\n    (define (iter i)\n      (cond\n        [(= i x) #t]\n        [(= (modulo x i) 0) #f]\n        [else (iter (+ i 1))]))\n    (iter 2))\n  (define (is_power_of_2 x)\n    (cond\n      [(= x 1) #t]\n      [(= (modulo x 2) 0) (is_power_of_2 (/ x 2))]\n      [else #f]))\n  (and (is_prime x) (is_power_of_2 x)))\n",
    "  (define (is_prime? x)\n    (define (iter n)\n      (cond ((= n 1) #t)\n            ((= (modulo x n) 0) #f)\n            (else (iter (- n 1)))))\n    (iter (- x 1)))\n  (define (is_power_of_2? x)\n    (cond ((= x 1) #t)\n          ((= (modulo x 2) 0) (is_power_of_2? (/ x 2)))\n          (else #f)))\n  (and (is_prime? x) (is_power_of_2? x)))\n",
    "  (define (is_prime x)\n    (cond ((= x 1) #f)\n          ((= x 2) #t)\n          ((even? x) #f)\n          (else (is-prime-helper x 3))))\n  (define (is-prime-helper x i)\n    (cond ((&gt; i (sqrt x)) #t)\n          ((= (remainder x i) 0) #f)\n          (else (is-prime-helper x (+ i 2)))))\n  (define (is-woodall-helper x i)\n    (cond ((&gt; i (sqrt x)) #t)\n          ((= (remainder x i) 0) (is-woodall-helper (* x i) i))\n          (else (is-woodall-helper x (+ i 2)))))\n  (cond ((is_prime x) #f)\n        ((= x 1) #f)\n        (else (is-woodall-helper x 3))))\n</code>\n",
    "  (define (is_prime x)\n    (define (iter n)\n      (if (= n 1)\n          #t\n          (if (= (modulo x n) 0)\n              #f\n              (iter (- n 1)))))\n    (iter (- x 1)))\n  (define (is_woodall-helper x n)\n    (if (= n 1)\n        #t\n        (if (is_prime n)\n            (if (= (expt n x) x)\n                (is_woodall-helper x (- n 1))\n                #f)\n            (is_woodall-helper x (- n 1)))))\n  (is_woodall-helper x x))\n",
    "  (if (zero? x)\n      #t\n      (let ([n (integer-sqrt x)])\n        (if (= x (* n n))\n            (is_woodall (+ n 1))\n            #f))))\n",
    "  (define (is-prime? x)\n    (define (iter n)\n      (cond\n        [(= n 1) #t]\n        [(= (modulo x n) 0) #f]\n        [else (iter (- n 1))]))\n    (iter (- x 1)))\n  (define (is-woodall? x)\n    (define (iter n)\n      (cond\n        [(= n 1) #t]\n        [(= (modulo x n) 0) #f]\n        [else (iter (- n 1))]))\n    (iter (- x 1)))\n  (is-woodall? x))\n",
    "  (let loop ([n x])\n    (cond\n      [(= n 1) #t]\n      [(= (modulo n 2) 0) (loop (/ n 2))]\n      [(= (modulo n 3) 0) (loop (/ n 3))]\n      [(= (modulo n 5) 0) (loop (/ n 5))]\n      [else #f])))\n",
    "  (define (is-power-of-2? x)\n    (if (= x 1)\n        #t\n        (if (= (remainder x 2) 0)\n            (is-power-of-2? (/ x 2))\n            #f)))\n  (if (is-power-of-2? x)\n      (if (= (remainder x 2) 0)\n          #t\n          #f)\n      #f))\n"
  ]
}