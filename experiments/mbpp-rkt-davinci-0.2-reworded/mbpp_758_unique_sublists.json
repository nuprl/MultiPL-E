{
  "name": "mbpp_758_unique_sublists",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to count lists within a list. The function should return a hash where every list is converted to a list and the value of such list is the number of its occurencies in the original list.\n(define (unique_sublists list1)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_758_unique_sublists.py",
  "prompt_terminology": "reworded",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate unique_sublists))\n    (check-equal? (candidate (list (list 1 3) (list 5 7) (list 1 3) (list 13 15 17) (list 5 7) (list 9 11))) #hash(((list 1 3) .  2) ((list 5 7) .  2) ((list 13 15 17) .  1) ((list 9 11) .  1)))\n    (check-equal? (candidate (list (list \"green\" \"orange\") (list \"black\") (list \"green\" \"orange\") (list \"white\"))) #hash(((list \"green\" \"orange\") .  2) ((list \"black\") .  1) ((list \"white\") .  1)))\n    (check-equal? (candidate (list (list 10 20 30 40) (list 60 70 50 50) (list 90 100 200))) #hash(((list 10 20 30 40) .  1) ((list 60 70 50 50) .  1) ((list 90 100 200) .  1)))\n    (check-equal? (candidate (list (list \"john\"))) #hash(((list \"john\") .  1)))\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (letrec ([sublists (lambda (list1)\n                       (cond [(empty? list1) empty]\n                             [(list? (first list1)) (cons (first list1) (sublists (rest list1)))]\n                             [else (sublists (rest list1))]))]\n           [sublists-unique (lambda (list1)\n                              (cond [(empty? list1) empty]\n                                    [(member (first list1) (rest list1)) (sublists-unique (rest list1))]\n                                    [else (cons (first list1) (sublists-unique (rest list1)))]))])\n    (sublists-unique (sublists list1))))\n",
    "  (let ([sublists (sublists list1)])\n    (for/hash ([sublist sublists])\n      [sublist (count sublist sublists)])))\n",
    "  (let ([sublists (sublists list1)])\n    (for/hash ([sublist sublists])\n      [sublist (count sublist sublists)])))\n",
    "  (letrec ([sublists (lambda (list1)\n                       (cond [(empty? list1) empty]\n                             [(list? (first list1)) (cons (first list1) (sublists (rest list1)))]\n                             [else (sublists (rest list1))]))]\n           [count_sublists (lambda (list1)\n                             (cond [(empty? list1) empty]\n                                   [(member (first list1) (rest list1)) (cons (first list1) (count_sublists (remove (first list1) (rest list1))))]\n                                   [else (cons (first list1) (count_sublists (rest list1)))]))])\n    (hash-map (count_sublists (sublists list1)))))\n",
    "  (letrec ([sublists (lambda (list1)\n                       (cond [(empty? list1) empty]\n                             [(list? (first list1)) (cons (first list1) (sublists (rest list1)))]\n                             [else (sublists (rest list1))]))]\n           [count (lambda (list1 list2)\n                    (cond [(empty? list2) 0]\n                          [(equal? list1 (first list2)) (+ 1 (count list1 (rest list2)))]\n                          [else (count list1 (rest list2))]))])\n    (map (lambda (x) (list x (count x (sublists list1)))) (sublists list1))))\n",
    "  (let ([hash (make-hash)])\n    (for ([x list1])\n      (hash-update! hash x add1 0))\n    hash))\n",
    "  (letrec ([sublists (lambda (list1)\n                       (cond [(empty? list1) empty]\n                             [(list? (first list1)) (cons (first list1) (sublists (rest list1)))]\n                             [else (sublists (rest list1))]))]\n           [count (lambda (list1)\n                    (cond [(empty? list1) empty]\n                          [(empty? (rest list1)) (cons (list (first list1) 1) empty)]\n                          [(equal? (first list1) (first (rest list1))) (cons (list (first list1) (+ 1 (second (first (count (rest list1)))))) (rest (count (rest list1))))]\n                          [else (cons (list (first list1) 1) (count (rest list1)))]))])\n    (count (sublists list1))))\n",
    "  (define (unique_sublists_helper list1 result)\n    (cond\n      [(empty? list1) result]\n      [(list? (first list1))\n       (let ([sublist (first list1)])\n         (if (hash-has-key? result sublist)\n             (hash-update result sublist add1 (hash-ref result sublist))\n             (hash-update result sublist add1 0))\n         (unique_sublists_helper (rest list1) result))]\n      [else (unique_sublists_helper (rest list1) result)]))\n  (unique_sublists_helper list1 (make-hash)))\n",
    "  (let ([h (make-hash)])\n    (for ([l list1])\n      (hash-update h l add1 0))\n    h))\n",
    "  (letrec ([sublists (for/list ([sublist (in-list list1)])\n                       (if (list? sublist)\n                           sublist\n                           '()))])\n    (for/hash ([sublist (in-list sublists)]\n               [count (in-range (length sublists))])\n      (if (equal? sublist '())\n          (hash)\n          (hash-update sublist (add1) 0 (hash))))))\n",
    "  (let ([sublists (sublists list1)])\n    (for/hash ([sublist sublists])\n      [sublist (length (filter (lambda (x) (equal? x sublist)) sublists))])))\n",
    "  (let ([counts (make-hash)])\n    (for ([item list1])\n      (hash-update counts item add1 0))\n    counts))\n",
    "  (define (unique_sublists_helper list1 list2)\n    (cond\n      [(empty? list1) list2]\n      [(member? (first list1) list2) (unique_sublists_helper (rest list1) list2)]\n      [else (unique_sublists_helper (rest list1) (cons (first list1) list2))]))\n  (unique_sublists_helper list1 '()))\n",
    "  (define (unique_sublists_iter list1 list2)\n    (cond\n      [(empty? list1) list2]\n      [(member? (first list1) list2) (unique_sublists_iter (rest list1) list2)]\n      [else (unique_sublists_iter (rest list1) (cons (first list1) list2))]))\n  (unique_sublists_iter list1 '()))\n",
    "  (letrec ([sublists (lambda (list1)\n                       (cond\n                         [(null? list1) '()]\n                         [(list? (car list1)) (cons (car list1) (sublists (cdr list1)))]\n                         [else (sublists (cdr list1))]))]\n           [count (lambda (list1 list2)\n                    (cond\n                      [(null? list1) '()]\n                      [(equal? (car list1) list2) (cons (car list1) (count (cdr list1) list2))]\n                      [else (count (cdr list1) list2)]))]\n           [count_all (lambda (list1)\n                        (cond\n                          [(null? list1) '()]\n                          [else (cons (cons (car list1) (length (count (sublists list1) (car list1)))) (count_all (cdr list1)))]))])\n    (count_all (remove-duplicates (sublists list1)))))\n",
    "  (letrec ([count-sublists (lambda (list1)\n                             (cond [(empty? list1) empty]\n                                   [(list? (first list1))\n                                    (cons (cons (first list1) (count-sublists (first list1)))\n                                          (count-sublists (rest list1)))]\n                                   [else (count-sublists (rest list1))]))]\n           [count-occurencies (lambda (list1)\n                                (cond [(empty? list1) empty]\n                                      [else (cons (cons (first list1) (length (filter (lambda (x) (equal? (first list1) x)) list1)))\n                                                  (count-occurencies (filter (lambda (x) (not (equal? (first list1) x))) list1)))]))])\n    (count-occurencies (count-sublists list1))))\n",
    "  (define (count_sublists list1 list2)\n    (cond ((null? list1) list2)\n          ((member? (car list1) list2) (count_sublists (cdr list1) list2))\n          (else (count_sublists (cdr list1) (cons (car list1) list2)))))\n  (define (count_occurrences list1 list2)\n    (cond ((null? list1) list2)\n          ((member? (car list1) list2) (count_occurrences (cdr list1) (cons (list (car list1) (add1 (cadr (assoc (car list1) list2)))) (remove (assoc (car list1) list2) list2))))\n          (else (count_occurrences (cdr list1) (cons (list (car list1) 1) list2)))))\n  (count_occurrences list1 (count_sublists list1 '())))\n</code>\nI'm not sure if this is the best way to do it, but it works.\n",
    "  (letrec ([sublists (lambda (list1)\n                       (cond\n                         [(empty? list1) empty]\n                         [(list? (first list1)) (cons (first list1) (sublists (rest list1)))]\n                         [else (sublists (rest list1))]))]\n           [count (lambda (list1 list2)\n                    (cond\n                      [(empty? list1) empty]\n                      [(equal? (first list1) list2) (cons (first list1) (count (rest list1) list2))]\n                      [else (count (rest list1) list2)]))])\n    (for/hash ([x (sublists list1)])\n      [x (length (count (sublists list1) x))])))\n",
    "  (define (unique_sublists_helper list1 list2)\n    (cond\n      [(empty? list1) list2]\n      [(member? (first list1) list2) (unique_sublists_helper (rest list1) list2)]\n      [else (unique_sublists_helper (rest list1) (cons (first list1) list2))]))\n  (unique_sublists_helper list1 '()))\n",
    "  (letrec ([sublists (for/list ([elem (in-list list1)])\n                       (if (list? elem)\n                           elem\n                           '()))])\n    (hash-from-alist (for/list ([elem (in-list sublists)])\n                      (cons elem (count elem sublists))))))\n"
  ]
}