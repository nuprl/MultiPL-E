{
  "name": "mbpp_755_second_smallest",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to find the second smallest number in a list.\n(define (second_smallest numbers)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_755_second_smallest.py",
  "prompt_terminology": "reworded",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate second_smallest))\n    (check-equal? (candidate (list 1 2 -8 -2 0 -2)) -2)\n    (check-equal? (candidate (list 1 1 -0.5 0 2 -2 -2)) -0.5)\n    (check-equal? (candidate (list 2 2)) #f)\n    (check-equal? (candidate (list 2 2 2)) #f)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (smallest_from_rest rest)\n    (if (null? rest)\n        (error \"List is empty\")\n        (if (null? (cdr rest))\n            (car rest)\n            (min (car rest) (smallest_from_rest (cdr rest))))))\n  (if (null? numbers)\n      (error \"List is empty\")\n      (if (null? (cdr numbers))\n          (error \"List has only one element\")\n          (min (car numbers) (smallest_from_rest (cdr numbers))))))\n",
    "  (define (smallest_of_rest numbers smallest)\n    (cond\n      [(empty? numbers) smallest]\n      [(< (first numbers) smallest) (smallest_of_rest (rest numbers) (first numbers))]\n      [else (smallest_of_rest (rest numbers) smallest)]))\n  (smallest_of_rest (rest numbers) (first numbers)))\n",
    "  (define (smallest_of_rest numbers smallest)\n    (cond\n      [(empty? numbers) smallest]\n      [(< (first numbers) smallest) (smallest_of_rest (rest numbers) (first numbers))]\n      [else (smallest_of_rest (rest numbers) smallest)]))\n  (smallest_of_rest (rest numbers) (first numbers)))\n",
    "  (define (smallest numbers)\n    (cond\n      [(empty? numbers) (error 'smallest \"empty list\")]\n      [(empty? (rest numbers)) (first numbers)]\n      [else (if (< (first numbers) (smallest (rest numbers)))\n               (first numbers)\n               (smallest (rest numbers)))]))\n  (cond\n    [(empty? numbers) (error 'second_smallest \"empty list\")]\n    [(empty? (rest numbers)) (error 'second_smallest \"list too short\")]\n    [else (if (< (first numbers) (second_smallest (rest numbers)))\n             (second_smallest (rest numbers))\n             (if (< (second_smallest (rest numbers)) (smallest (rest numbers)))\n                 (second_smallest (rest numbers))\n                 (smallest (rest numbers))))]))\n",
    "  (apply min (remove (apply min numbers) numbers)))\n",
    "  (define (smallest_of_rest numbers smallest)\n    (cond ((null? numbers) smallest)\n          ((< (car numbers) smallest) (smallest_of_rest (cdr numbers) (car numbers)))\n          (else (smallest_of_rest (cdr numbers) smallest))))\n  (smallest_of_rest (cdr numbers) (car numbers)))\n",
    "  (apply min (remove (apply min numbers) numbers)))\n",
    "  (cond [(empty? numbers) (error \"empty list\")]\n        [(empty? (rest numbers)) (error \"list has only one element\")]\n        [(< (second numbers) (first numbers)) (second_smallest (rest numbers))]\n        [else (second_smallest (cons (first numbers) (rest (rest numbers))))]))\n",
    "  (define (smallest_of_rest n rest)\n    (cond\n      [(empty? rest) n]\n      [(< n (first rest)) (smallest_of_rest n (rest rest))]\n      [else (smallest_of_rest (first rest) (rest rest))]))\n  (cond\n    [(empty? numbers) (error \"empty list\")]\n    [(empty? (rest numbers)) (error \"list too small\")]\n    [else (smallest_of_rest (first numbers) (rest numbers))]))\n",
    "  (cond\n    [(empty? numbers) (error \"empty list\")]\n    [(empty? (rest numbers)) (error \"list too short\")]\n    [(= (first numbers) (second numbers)) (second_smallest (rest numbers))]\n    [else (min (first numbers) (second numbers))]))\n",
    "  (apply min (remove (apply min numbers) numbers)))\n",
    "  (let ([smallest (apply min numbers)])\n    (apply min (filter (lambda (x) (not (= x smallest))) numbers))))\n",
    "  (cond\n    [(empty? numbers) (error \"empty list\")]\n    [(empty? (rest numbers)) (error \"list too short\")]\n    [(empty? (rest (rest numbers))) (first numbers)]\n    [else\n     (let ([smallest (first numbers)])\n       (for/fold ([smallest (first numbers)]\n                  [second_smallest (second numbers)])\n                 ([n (in-list (rest (rest numbers)))])\n         (cond\n           [(< n smallest) (values n second_smallest)]\n           [(< n second_smallest) (values smallest n)]\n           [else (values smallest second_smallest)])))]))\n",
    "  (define (smallest numbers)\n    (cond\n      [(empty? numbers) (error \"empty list\")]\n      [(empty? (rest numbers)) (first numbers)]\n      [else (min (first numbers) (smallest (rest numbers)))]))\n  (define (second_smallest_helper numbers smallest)\n    (cond\n      [(empty? numbers) (error \"empty list\")]\n      [(empty? (rest numbers)) (if (= (first numbers) smallest) (error \"list has only one element\") (first numbers))]\n      [else (if (= (first numbers) smallest) (second_smallest_helper (rest numbers) smallest) (min (first numbers) (second_smallest_helper (rest numbers) smallest)))]))\n  (second_smallest_helper numbers (smallest numbers)))\n",
    "  (define (smallest-of-rest numbers)\n    (cond\n      [(empty? numbers) empty]\n      [(empty? (rest numbers)) empty]\n      [else (if (< (first numbers) (second numbers))\n                (first numbers)\n                (second numbers))]))\n  (cond\n    [(empty? numbers) empty]\n    [(empty? (rest numbers)) empty]\n    [(empty? (rest (rest numbers))) empty]\n    [else (if (< (first numbers) (second numbers))\n              (smallest-of-rest (rest numbers))\n              (smallest-of-rest numbers))]))\n",
    "  (cond [(null? numbers) '()]\n        [(null? (cdr numbers)) '()]\n        [else (if (< (car numbers) (cadr numbers))\n                  (cons (car numbers) (second_smallest (cdr numbers)))\n                  (cons (cadr numbers) (second_smallest (cdr numbers))))]))\n",
    "  (define (smallest-and-rest numbers)\n    (define (smallest-and-rest-iter smallest rest)\n      (cond\n        [(empty? rest) (values smallest rest)]\n        [(< (first rest) smallest) (smallest-and-rest-iter (first rest) (rest rest))]\n        [else (smallest-and-rest-iter smallest (rest rest))]))\n    (smallest-and-rest-iter (first numbers) (rest numbers)))\n  (define (second-smallest-iter smallest rest)\n    (cond\n      [(empty? rest) smallest]\n      [(< (first rest) smallest) (second-smallest-iter (first rest) (rest rest))]\n      [else (second-smallest-iter smallest (rest rest))]))\n  (second-smallest-iter (first (smallest-and-rest numbers)) (rest (smallest-and-rest numbers))))\n",
    "  (define (smallest_and_second_smallest numbers)\n    (cond [(empty? numbers) (list 0 0)]\n          [(empty? (rest numbers)) (list (first numbers) 0)]\n          [else\n           (let* ([first-number (first numbers)]\n                  [second-number (first (rest numbers))]\n                  [smaller-number (if (< first-number second-number)\n                                      first-number\n                                      second-number)]\n                  [larger-number (if (< first-number second-number)\n                                     second-number\n                                     first-number)])\n             (if (= smaller-number larger-number)\n                 (smallest_and_second_smallest (rest numbers))\n                 (cons smaller-number (smallest_and_second_smallest (rest numbers)))))\n           ]))\n  (second (smallest_and_second_smallest numbers)))\n",
    "  (define (smallest_of_rest numbers smallest)\n    (if (null? numbers)\n        smallest\n        (if (< (car numbers) smallest)\n            (smallest_of_rest (cdr numbers) (car numbers))\n            (smallest_of_rest (cdr numbers) smallest))))\n  (smallest_of_rest (cdr numbers) (car numbers)))\n",
    "  (define (smallest numbers)\n    (cond\n      [(empty? numbers) empty]\n      [(empty? (rest numbers)) (first numbers)]\n      [else (if (< (first numbers) (smallest (rest numbers)))\n               (first numbers)\n               (smallest (rest numbers)))]))\n  (define (second_smallest_helper numbers smallest)\n    (cond\n      [(empty? numbers) empty]\n      [(empty? (rest numbers)) empty]\n      [else (if (< (first numbers) smallest)\n               (second_smallest_helper (rest numbers) (first numbers))\n               (second_smallest_helper (rest numbers) smallest))]))\n  (second_smallest_helper (rest numbers) (smallest numbers)))\n"
  ]
}