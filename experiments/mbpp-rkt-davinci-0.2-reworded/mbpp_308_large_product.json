{
  "name": "mbpp_308_large_product",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n(define (large_product nums1 nums2 N)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_308_large_product.py",
  "prompt_terminology": "reworded",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate large_product))\n    (check-equal? (candidate (list 1 2 3 4 5 6) (list 3 6 8 9 10 6) 3) (list 60 54 50))\n    (check-equal? (candidate (list 1 2 3 4 5 6) (list 3 6 8 9 10 6) 4) (list 60 54 50 48))\n    (check-equal? (candidate (list 1 2 3 4 5 6) (list 3 6 8 9 10 6) 5) (list 60 54 50 48 45))\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (helper nums1 nums2 N result)\n    (cond\n      [(= N 0) result]\n      [else\n       (define max1 (apply max nums1))\n       (define max2 (apply max nums2))\n       (define max-product (* max1 max2))\n       (define new-nums1 (remove max1 nums1))\n       (define new-nums2 (remove max2 nums2))\n       (helper new-nums1 new-nums2 (- N 1) (append result (list max-product)))]))\n  (helper nums1 nums2 N '()))\n",
    "  (define (helper nums1 nums2 N acc)\n    (if (zero? N)\n        acc\n        (let* ([nums1-sorted (sort nums1 <)]\n               [nums2-sorted (sort nums2 <)]\n               [nums1-max (car nums1-sorted)]\n               [nums2-max (car nums2-sorted)]\n               [nums1-rest (cdr nums1-sorted)]\n               [nums2-rest (cdr nums2-sorted)])\n          (helper nums1-rest nums2-rest (- N 1) (cons (* nums1-max nums2-max) acc)))))\n  (helper nums1 nums2 N '()))\n",
    "  (let ([sorted-nums1 (sort nums1 >)]\n        [sorted-nums2 (sort nums2 >)])\n    (for/list ([i (in-range N)]\n               #:when (not (zero? i))\n               #:when (not (zero? (- i 1)))\n               #:when (not (zero? (- i 2)))\n               #:when (not (zero? (- i 3)))\n               #:when (not (zero? (- i 4)))\n               #:when (not (zero? (- i 5)))\n               #:when (not (zero? (- i 6)))\n               #:when (not (zero? (- i 7)))\n               #:when (not (zero? (- i 8)))\n               #:when (not (zero? (- i 9))))\n      (* (list-ref sorted-nums1 i) (list-ref sorted-nums2 (- i 1))))))\n",
    "  (define (helper1 nums1 nums2 N acc)\n    (if (zero? N)\n        acc\n        (helper1 (cdr nums1) (cdr nums2) (- N 1) (cons (* (car nums1) (car nums2)) acc))))\n  (define (helper2 nums1 nums2 N acc)\n    (if (zero? N)\n        acc\n        (helper2 (cdr nums1) (cdr nums2) (- N 1) (cons (* (car nums1) (car nums2)) acc))))\n  (define (helper3 nums1 nums2 N acc)\n    (if (zero? N)\n        acc\n        (helper3 (cdr nums1) (cdr nums2) (- N 1) (cons (* (car nums1) (car nums2)) acc))))\n  (define (helper4 nums1 nums2 N acc)\n    (if (zero? N)\n        acc\n        (helper4 (cdr nums1) (cdr nums2) (- N 1) (cons (* (car nums1) (car nums2)) acc))))\n  (define (helper5 nums1 nums2 N acc)\n    (if (zero? N)\n        acc\n        (helper5 (cdr nums1) (cdr nums2) (- N 1) (cons (* (car nums1) (car nums2)) acc))))\n  (define (helper6 nums1 nums2 N acc)\n    (if (zero? N)\n        acc\n        (helper6 (cdr nums1) (cdr nums2) (- N 1) (cons (* (car nums1) (car nums2)) acc))))\n  (define (helper7 nums1 nums2 N acc)\n    (if (zero? N)\n        acc\n        (helper7 (cdr nums1) (cdr nums2) (- N 1) (cons (* (car nums1) (car nums2)) acc))))\n  (define (helper8 nums1 nums2 N acc)\n    (if (",
    "  (sort (for/list ([x nums1] [y nums2]) (* x y)) >))\n",
    "  (let ([nums1-sorted (sort nums1 >)]\n        [nums2-sorted (sort nums2 >)])\n    (for/list ([n1 nums1-sorted]\n               [n2 nums2-sorted])\n      (* n1 n2))))\n",
    "  (define (helper nums1 nums2 N result)\n    (if (zero? N)\n        result\n        (let* ([max1 (apply max nums1)]\n               [max2 (apply max nums2)]\n               [max-product (* max1 max2)])\n          (helper (remove max1 nums1) (remove max2 nums2) (- N 1) (cons max-product result)))))\n  (helper nums1 nums2 N '()))\n",
    "  (define (helper1 nums1 nums2 N acc)\n    (if (zero? N)\n        acc\n        (helper1 (cdr nums1) (cdr nums2) (- N 1) (cons (* (car nums1) (car nums2)) acc))))\n  (helper1 nums1 nums2 N '()))\n",
    "  (define (product a b) (* a b))\n  (define (sort-by-product lst1 lst2)\n    (sort (for/list ([a lst1] [b lst2]) (list (product a b) a b))\n          >))\n  (take N (sort-by-product nums1 nums2)))\n",
    "  (define (helper nums1 nums2 N acc)\n    (if (zero? N)\n        acc\n        (let* ([max1 (apply max nums1)]\n               [max2 (apply max nums2)]\n               [max-prod (* max1 max2)])\n          (helper (remove max1 nums1) (remove max2 nums2) (- N 1) (cons max-prod acc)))))\n  (helper nums1 nums2 N '()))\n",
    "  (define (helper nums1 nums2 N acc)\n    (cond\n      [(empty? nums1) acc]\n      [(empty? nums2) acc]\n      [(= N 0) acc]\n      [else\n       (let* ([n1 (first nums1)]\n              [n2 (first nums2)]\n              [p (* n1 n2)]\n              [acc (cons p acc)])\n         (helper (rest nums1) (rest nums2) (- N 1) acc))]))\n  (helper nums1 nums2 N '()))\n",
    "  (define (helper nums1 nums2 N acc)\n    (if (= N 0)\n        acc\n        (let* ([max1 (apply max nums1)]\n               [max2 (apply max nums2)]\n               [max-product (* max1 max2)])\n          (helper (remove max1 nums1) (remove max2 nums2) (- N 1) (cons max-product acc)))))\n  (reverse (helper nums1 nums2 N '())))\n",
    "  (sort (map * nums1 nums2) >))\n",
    "  (define (helper n1 n2 n)\n    (cond\n      [(zero? n) '()]\n      [else (cons (* n1 n2) (helper n1 n2 (- n 1)))]))\n  (define (helper2 n1 n2 n)\n    (cond\n      [(zero? n) '()]\n      [else (append (helper n1 n2 n) (helper2 n1 n2 (- n 1)))]))\n  (define (helper3 n1 n2 n)\n    (cond\n      [(zero? n) '()]\n      [else (append (helper2 n1 n2 n) (helper3 n1 n2 (- n 1)))]))\n  (define (helper4 n1 n2 n)\n    (cond\n      [(zero? n) '()]\n      [else (append (helper3 n1 n2 n) (helper4 n1 n2 (- n 1)))]))\n  (define (helper5 n1 n2 n)\n    (cond\n      [(zero? n) '()]\n      [else (append (helper4 n1 n2 n) (helper5 n1 n2 (- n 1)))]))\n  (define (helper6 n1 n2 n)\n    (cond\n      [(zero? n) '()]\n      [else (append (helper5 n1 n2 n) (helper6 n1 n2 (- n 1)))]))\n  (define (helper7 n1 n2 n)\n    (cond\n      [(zero? n) '()]\n      [else (append (helper6 n1 n2 n) (helper7 n1 n2 (- n 1)))]))\n  (define (helper8 n1 n2 n)\n    (cond\n      [(zero? n) '()]\n      [else (append (helper7 n1 n2 n) (helper8 n1 n2 (- n 1)))]))\n  (define (helper9 n1 n2 n)\n    (cond\n      [(zero? n) '()]\n      [else (append (helper8 n1 n2 n) (helper9 n1 n2 (- n 1",
    "  (sort (for/list ([n1 nums1] [n2 nums2]) (* n1 n2)) >))\n",
    "  (sort (for/list ([n1 nums1] [n2 nums2]) (* n1 n2)) >))\n",
    "  (define (helper nums1 nums2 acc)\n    (if (zero? (length nums1))\n        acc\n        (helper (cdr nums1) nums2 (append acc (map (lambda (x) (* (car nums1) x)) nums2)))))\n  (take (sort > (helper nums1 nums2 '())) N))\n",
    "  (define (helper nums1 nums2 N acc)\n    (if (= N 0)\n        acc\n        (let* ([max1 (apply max nums1)]\n               [max2 (apply max nums2)]\n               [max-product (* max1 max2)])\n          (helper (remove max1 nums1) (remove max2 nums2) (- N 1) (cons max-product acc)))))\n  (reverse (helper nums1 nums2 N '())))\n",
    "  (sort (for/list ([n1 nums1] [n2 nums2]) (* n1 n2)) >))\n",
    "  (define (helper1 nums1 nums2 N acc)\n    (if (zero? N)\n        acc\n        (helper1 (cdr nums1) (cdr nums2) (- N 1) (cons (* (car nums1) (car nums2)) acc))))\n  (define (helper2 nums1 nums2 N acc)\n    (if (zero? N)\n        acc\n        (helper2 (cdr nums1) (cdr nums2) (- N 1) (cons (* (car nums1) (car nums2)) acc))))\n  (define (helper3 nums1 nums2 N acc)\n    (if (zero? N)\n        acc\n        (helper3 (cdr nums1) (cdr nums2) (- N 1) (cons (* (car nums1) (car nums2)) acc))))\n  (define (helper4 nums1 nums2 N acc)\n    (if (zero? N)\n        acc\n        (helper4 (cdr nums1) (cdr nums2) (- N 1) (cons (* (car nums1) (car nums2)) acc))))\n  (define (helper5 nums1 nums2 N acc)\n    (if (zero? N)\n        acc\n        (helper5 (cdr nums1) (cdr nums2) (- N 1) (cons (* (car nums1) (car nums2)) acc))))\n  (define (helper6 nums1 nums2 N acc)\n    (if (zero? N)\n        acc\n        (helper6 (cdr nums1) (cdr nums2) (- N 1) (cons (* (car nums1) (car nums2)) acc))))\n  (define (helper7 nums1 nums2 N acc)\n    (if (zero? N)\n        acc\n        (helper7 (cdr nums1) (cdr nums2) (- N 1) (cons (* (car nums1) (car nums2)) acc))))\n  (define (helper8 nums1 nums2 N acc)\n    (if ("
  ]
}