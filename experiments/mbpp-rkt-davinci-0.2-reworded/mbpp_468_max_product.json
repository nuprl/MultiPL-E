{
  "name": "mbpp_468_max_product",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that list.\n(define (max_product arr)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_468_max_product.py",
  "prompt_terminology": "reworded",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate max_product))\n    (check-equal? (candidate (list 3 100 4 5 150 6)) 3000)\n    (check-equal? (candidate (list 4 42 55 68 80)) 50265600)\n    (check-equal? (candidate (list 10 22 9 33 21 50 41 60)) 2460)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (max_product_helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ((curr-max (max (car arr) (* (car arr) max-so-far))))\n          (max_product_helper (cdr arr) curr-max))))\n  (max_product_helper arr 1))\n",
    "  (define (max_product_helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (max_product_helper (cdr arr)\n                            (if (&gt; (* max-so-far (car arr)) max-so-far)\n                                (* max-so-far (car arr))\n                                max-so-far))))\n  (max_product_helper arr (car arr)))\n",
    "  (define (max_product_helper arr max-so-far)\n    (cond\n      [(empty? arr) max-so-far]\n      [else\n       (let ([first (first arr)])\n         (max_product_helper (rest arr)\n                             (if (&lt; first max-so-far)\n                                 (* first max-so-far)\n                                 max-so-far)))]))\n  (max_product_helper arr 1))\n",
    "  (define (max_product_helper arr max-so-far)\n    (cond [(null? arr) max-so-far]\n          [(> (car arr) max-so-far) (max_product_helper (cdr arr) (car arr))]\n          [else (max_product_helper (cdr arr) max-so-far)]))\n  (max_product_helper arr 0))\n",
    "  (let loop ((arr arr) (max 0) (prod 1))\n    (cond ((null? arr) max)\n          ((< (car arr) (cadr arr))\n           (loop (cdr arr) (max (max max prod)) (* prod (car arr))))\n          (else (loop (cdr arr) (max max prod) 1)))))\n",
    "  (define (max-product-helper arr max-so-far)\n    (cond\n      [(empty? arr) max-so-far]\n      [(> (first arr) (* max-so-far (first arr)))\n       (max-product-helper (rest arr) (first arr))]\n      [else (max-product-helper (rest arr) max-so-far)]))\n  (max-product-helper arr 1))\n",
    "  (let loop ((arr arr) (max-product 0))\n    (cond\n      [(null? arr) max-product]\n      [(null? (cdr arr)) max-product]\n      [else\n       (let ((product (* (car arr) (cadr arr))))\n         (loop (cdr arr) (if (&gt; product max-product) product max-product)))])))\n</code>\n",
    "  (define (helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ([curr (car arr)])\n          (if (&gt; curr 0)\n              (helper (cdr arr) (* curr max-product))\n              (helper (cdr arr) max-product)))))\n  (helper arr 1))\n",
    "  (define (max_product_helper arr max-so-far)\n    (cond [(empty? arr) max-so-far]\n          [(> (first arr) max-so-far) (max_product_helper (rest arr) (first arr))]\n          [else (max_product_helper (rest arr) max-so-far)]))\n  (max_product_helper arr 0))\n",
    "  (let loop ([arr arr] [acc 1])\n    (if (null? arr)\n        acc\n        (loop (cdr arr) (max acc (* acc (car arr)))))))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (if (null? arr)\n        max-product-so-far\n        (let ([curr-product (apply * arr)])\n          (max-product-helper (cdr arr) (max max-product-so-far curr-product)))))\n  (max-product-helper arr 0))\n",
    "  (let loop ((arr arr) (max 0))\n    (cond\n      [(empty? arr) max]\n      [(> (product (first arr)) max) (loop (rest arr) (product (first arr)))]\n      [else (loop (rest arr) max)])))\n",
    "  (define (max_product_helper arr max-so-far)\n    (cond\n      [(empty? arr) max-so-far]\n      [(> (first arr) (first (rest arr)))\n       (max_product_helper (rest arr) (* (first arr) (first (rest arr))))]\n      [else (max_product_helper (rest arr) max-so-far)]))\n  (max_product_helper arr 0))\n",
    "  (define (max_product_helper arr max-so-far curr-max curr-min)\n    (cond\n      [(empty? arr) max-so-far]\n      [(< (first arr) 0)\n       (max_product_helper (rest arr)\n                           (max max-so-far (* curr-max (first arr)))\n                           (min curr-max (first arr))\n                           (max curr-min (first arr)))]\n      [else\n       (max_product_helper (rest arr)\n                           (max max-so-far (* curr-max (first arr)))\n                           (max curr-max (first arr))\n                           (min curr-min (first arr)))]))\n  (max_product_helper arr 0 0 0))\n",
    "  (let loop ([arr arr] [max-product 1])\n    (if (null? arr)\n        max-product\n        (loop (cdr arr)\n              (if (&gt; (car arr) (* max-product (car arr)))\n                  (car arr)\n                  (* max-product (car arr)))))))\n",
    "  (define (max_product_helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (max_product_helper (cdr arr)\n                              (if (&gt; curr (* max-so-far curr))\n                                  curr\n                                  (* max-so-far curr))))))\n  (max_product_helper arr 1))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (cond\n      [(empty? arr) max-product-so-far]\n      [(> (first arr) (* max-product-so-far (first arr)))\n       (max-product-helper (rest arr) (* max-product-so-far (first arr)))]\n      [else (max-product-helper (rest arr) max-product-so-far)]))\n  (max-product-helper arr 1))\n",
    "  (let loop ([arr arr] [acc 1])\n    (if (null? arr)\n        acc\n        (if (&gt; (car arr) (cadr arr))\n            (loop (cdr arr) (* acc (car arr)))\n            (loop (cdr arr) acc)))))\n</code>\n",
    "  (define (max-product-helper arr max-product)\n    (cond\n      [(empty? arr) max-product]\n      [(> (first arr) (second arr))\n       (max-product-helper (rest arr) (* max-product (first arr)))]\n      [else (max-product-helper (rest arr) max-product)]))\n  (max-product-helper arr 1))\n",
    "  (let loop ((arr arr) (max 0))\n    (if (null? arr)\n        max\n        (let ((max-product (apply * (take (length arr) arr))))\n          (loop (cdr arr) (max max-product))))))\n"
  ]
}