{
  "name": "mbpp_468_max_product",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that list.\n(define (max_product arr)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_468_max_product.py",
  "prompt_terminology": "reworded",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate max_product))\n    (check-equal? (candidate (list 3 100 4 5 150 6)) 3000)\n    (check-equal? (candidate (list 4 42 55 68 80)) 50265600)\n    (check-equal? (candidate (list 10 22 9 33 21 50 41 60)) 2460)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (max_product_helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ((curr-max (max (car arr) (* (car arr) max-so-far))))\n          (max_product_helper (cdr arr) curr-max))))\n  (max_product_helper arr 1))\n",
    "  (define (max_product_helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (max_product_helper (cdr arr)\n                            (if (&gt; (* max-so-far (car arr)) max-so-far)\n                                (* max-so-far (car arr))\n                                max-so-far))))\n  (max_product_helper arr (car arr)))\n",
    "  (define (max_product_helper arr max-so-far)\n    (cond\n      [(empty? arr) max-so-far]\n      [else\n       (let ([first (first arr)])\n         (max_product_helper (rest arr)\n                             (if (&lt; first max-so-far)\n                                 (* first max-so-far)\n                                 max-so-far)))]))\n  (max_product_helper arr 1))\n",
    "  (define (max_product_helper arr max-so-far)\n    (cond [(null? arr) max-so-far]\n          [(> (car arr) max-so-far) (max_product_helper (cdr arr) (car arr))]\n          [else (max_product_helper (cdr arr) max-so-far)]))\n  (max_product_helper arr 0))\n",
    "  (let loop ((arr arr) (max 0) (prod 1))\n    (cond ((null? arr) max)\n          ((< (car arr) (cadr arr))\n           (loop (cdr arr) (max (max max prod)) (* prod (car arr))))\n          (else (loop (cdr arr) (max max prod) 1)))))\n",
    "  (define (max-product-helper arr max-so-far)\n    (cond\n      [(empty? arr) max-so-far]\n      [(> (first arr) (* max-so-far (first arr)))\n       (max-product-helper (rest arr) (first arr))]\n      [else (max-product-helper (rest arr) max-so-far)]))\n  (max-product-helper arr 1))\n",
    "  (let loop ((arr arr) (max-product 0))\n    (cond\n      [(null? arr) max-product]\n      [(null? (cdr arr)) max-product]\n      [else\n       (let ((product (* (car arr) (cadr arr))))\n         (loop (cdr arr) (if (&gt; product max-product) product max-product)))])))\n</code>\n",
    "  (define (helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ([curr (car arr)])\n          (if (&gt; curr 0)\n              (helper (cdr arr) (* curr max-product))\n              (helper (cdr arr) max-product)))))\n  (helper arr 1))\n",
    "  (define (max_product_helper arr max-so-far)\n    (cond [(empty? arr) max-so-far]\n          [(> (first arr) max-so-far) (max_product_helper (rest arr) (first arr))]\n          [else (max_product_helper (rest arr) max-so-far)]))\n  (max_product_helper arr 0))\n",
    "  (let loop ([arr arr] [acc 1])\n    (if (null? arr)\n        acc\n        (loop (cdr arr) (max acc (* acc (car arr)))))))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (if (null? arr)\n        max-product-so-far\n        (let ([curr-product (apply * arr)])\n          (max-product-helper (cdr arr) (max max-product-so-far curr-product)))))\n  (max-product-helper arr 0))\n",
    "  (let loop ((arr arr) (max 0))\n    (cond\n      [(empty? arr) max]\n      [(> (product (first arr)) max) (loop (rest arr) (product (first arr)))]\n      [else (loop (rest arr) max)])))\n",
    "  (define (max_product_helper arr max-so-far)\n    (cond\n      [(empty? arr) max-so-far]\n      [(> (first arr) (first (rest arr)))\n       (max_product_helper (rest arr) (* (first arr) (first (rest arr))))]\n      [else (max_product_helper (rest arr) max-so-far)]))\n  (max_product_helper arr 0))\n",
    "  (define (max_product_helper arr max-so-far curr-max curr-min)\n    (cond\n      [(empty? arr) max-so-far]\n      [(< (first arr) 0)\n       (max_product_helper (rest arr)\n                           (max max-so-far (* curr-max (first arr)))\n                           (min curr-max (first arr))\n                           (max curr-min (first arr)))]\n      [else\n       (max_product_helper (rest arr)\n                           (max max-so-far (* curr-max (first arr)))\n                           (max curr-max (first arr))\n                           (min curr-min (first arr)))]))\n  (max_product_helper arr 0 0 0))\n",
    "  (let loop ([arr arr] [max-product 1])\n    (if (null? arr)\n        max-product\n        (loop (cdr arr)\n              (if (&gt; (car arr) (* max-product (car arr)))\n                  (car arr)\n                  (* max-product (car arr)))))))\n",
    "  (define (max_product_helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (max_product_helper (cdr arr)\n                              (if (&gt; curr (* max-so-far curr))\n                                  curr\n                                  (* max-so-far curr))))))\n  (max_product_helper arr 1))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (cond\n      [(empty? arr) max-product-so-far]\n      [(> (first arr) (* max-product-so-far (first arr)))\n       (max-product-helper (rest arr) (* max-product-so-far (first arr)))]\n      [else (max-product-helper (rest arr) max-product-so-far)]))\n  (max-product-helper arr 1))\n",
    "  (let loop ([arr arr] [acc 1])\n    (if (null? arr)\n        acc\n        (if (&gt; (car arr) (cadr arr))\n            (loop (cdr arr) (* acc (car arr)))\n            (loop (cdr arr) acc)))))\n</code>\n",
    "  (define (max-product-helper arr max-product)\n    (cond\n      [(empty? arr) max-product]\n      [(> (first arr) (second arr))\n       (max-product-helper (rest arr) (* max-product (first arr)))]\n      [else (max-product-helper (rest arr) max-product)]))\n  (max-product-helper arr 1))\n",
    "  (let loop ((arr arr) (max 0))\n    (if (null? arr)\n        max\n        (let ((max-product (apply * (take (length arr) arr))))\n          (loop (cdr arr) (max max-product))))))\n",
    "  (define (helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([max-ending-here (apply * (take arr (length arr)))])\n          (helper (rest arr) (max max-so-far max-ending-here)))))\n  (helper arr (apply * (take arr (length arr)))))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (if (null? arr)\n        max-product-so-far\n        (let* ([first (car arr)]\n               [rest (cdr arr)]\n               [new-max-product (if (&gt; (* first max-product-so-far) max-product-so-far)\n                                    (* first max-product-so-far)\n                                    max-product-so-far)])\n          (max-product-helper rest new-max-product))))\n  (max-product-helper arr 1))\n",
    "  (define (max_product_helper arr max-product max-product-so-far)\n    (if (null? arr)\n        max-product-so-far\n        (let ([curr-product (* max-product (car arr))])\n          (if (&gt; curr-product max-product-so-far)\n              (max_product_helper (cdr arr) curr-product curr-product)\n              (max_product_helper (cdr arr) max-product max-product-so-far)))))\n  (max_product_helper arr 1 1))\n",
    "  (define (max_product_helper arr max_product_so_far)\n    (cond\n      [(empty? arr) max_product_so_far]\n      [(> (first arr) (first (rest arr)))\n       (max_product_helper (rest arr) (* max_product_so_far (first arr)))]\n      [else (max_product_helper (rest arr) max_product_so_far)]))\n  (max_product_helper arr 1))\n",
    "  (let loop ((arr arr)\n             (max-product 0))\n    (cond ((null? arr) max-product)\n          ((> (apply * (car arr)) max-product)\n           (loop (cdr arr) (apply * (car arr))))\n          (else (loop (cdr arr) max-product)))))\n",
    "  (define (max_product_helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (if (&gt; curr 0)\n              (max_product_helper (cdr arr) (* curr max-so-far))\n              (max_product_helper (cdr arr) max-so-far)))))\n  (max_product_helper arr 1))\n</code>\n",
    "  (let loop ([arr arr] [max-product 0])\n    (if (null? arr)\n        max-product\n        (let ([product (apply * (take (length arr) arr))])\n          (if (&gt; product max-product)\n              (loop (rest arr) product)\n              (loop (rest arr) max-product))))))\n</code>\n",
    "  (let loop ([arr arr] [max-product 0])\n    (cond [(null? arr) max-product]\n          [(> (apply * (take arr (length arr))) max-product)\n           (loop (cdr arr) (apply * (take arr (length arr))))]\n          [else (loop (cdr arr) max-product)])))\n",
    "  (let loop ((arr arr)\n             (max-product 0))\n    (if (null? arr)\n        max-product\n        (let ((product (apply * (take (length arr) arr))))\n          (loop (cdr arr)\n                (max max-product product))))))\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ((new-max-product (* max-product (car arr))))\n          (max-product-helper (cdr arr) (max new-max-product new-max-product)))))\n  (max-product-helper arr 1))\n",
    "  (define (max_product_helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (max_product_helper (cdr arr) (max max-so-far (* max-so-far (car arr))))))\n  (max_product_helper arr 1))\n",
    "  (define (max_product_helper arr max-so-far)\n    (cond\n      [(empty? arr) max-so-far]\n      [(> (first arr) max-so-far) (max_product_helper (rest arr) (first arr))]\n      [else (max_product_helper (rest arr) max-so-far)]))\n  (max_product_helper arr 0))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (max-product-helper (cdr arr) (max max-so-far (* curr (car arr)))))))\n  (max-product-helper arr 1))\n",
    "  (define (max_product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let* ([curr (car arr)]\n               [rest (cdr arr)]\n               [new-max (if (&gt; curr (* max-so-far curr))\n                            (* max-so-far curr)\n                            max-so-far)])\n          (max_product-helper rest new-max))))\n  (max_product-helper arr 1))\n</code>\n",
    "  (define (product lst)\n    (if (null? lst)\n        1\n        (* (car lst) (product (cdr lst)))))\n  (define (max_product_helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let* ((max-so-far (if (&gt; (product arr) max-so-far)\n                               (product arr)\n                               max-so-far))\n               (max-so-far (if (&gt; (product (cdr arr)) max-so-far)\n                               (product (cdr arr))\n                               max-so-far)))\n          (max_product_helper (cdr arr) max-so-far))))\n  (max_product_helper arr 0))\n",
    "  (let loop ((arr arr) (max-product 0))\n    (cond ((null? arr) max-product)\n          ((< (car arr) (cadr arr))\n           (loop (cdr arr) (* (car arr) (cadr arr))))\n          (else (loop (cdr arr) max-product)))))\n",
    "  (let loop ([arr arr] [max-product 0])\n    (cond [(empty? arr) max-product]\n          [(> (product (first arr)) max-product)\n           (loop (rest arr) (product (first arr)))]\n          [else (loop (rest arr) max-product)])))\n",
    "  (define (max-product-helper arr max-product max-product-so-far)\n    (cond [(empty? arr) max-product]\n          [(> (first arr) max-product-so-far) (max-product-helper (rest arr) (* max-product (first arr)) (first arr))]\n          [else (max-product-helper (rest arr) max-product max-product-so-far)]))\n  (max-product-helper arr 1 0))\n",
    "  (define (max_product_helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (max_product_helper (cdr arr)\n                              (if (&lt; curr (car max-so-far))\n                                  (list curr (car max-so-far))\n                                  max-so-far)))))\n  (apply * (max_product_helper arr (list (car arr) (car arr)))))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ((next-max (max-product-helper (cdr arr) max-so-far)))\n          (if (&gt; (car arr) max-so-far)\n              (* (car arr) next-max)\n              next-max))))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-product)\n    (cond\n      [(empty? arr) max-product]\n      [(> (first arr) max-product) (max-product-helper (rest arr) (first arr))]\n      [else (max-product-helper (rest arr) max-product)]))\n  (max-product-helper arr 0))\n",
    "  (define (helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([max-ending-here (apply * (take arr (length arr)))])\n          (helper (rest arr) (max max-so-far max-ending-here)))))\n  (helper arr 0))\n",
    "  (define (helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (if (&lt; curr 0)\n              (helper (cdr arr) max-so-far)\n              (helper (cdr arr) (* curr max-so-far))))))\n  (helper arr 1))\n",
    "  (define (max-product-iter arr max-product)\n    (if (null? arr)\n        max-product\n        (let ((max-product-so-far (max max-product (* (car arr) (cadr arr)))))\n          (max-product-iter (cdr arr) max-product-so-far))))\n  (max-product-iter arr 0))\n",
    "  (define (max_product_helper arr max-so-far)\n    (cond [(empty? arr) max-so-far]\n          [(> (first arr) max-so-far) (max_product_helper (rest arr) (first arr))]\n          [else (max_product_helper (rest arr) max-so-far)]))\n  (max_product_helper arr 0))\n",
    "  (define (helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ([curr (car arr)])\n          (if (&lt; curr 0)\n              (helper (cdr arr) max-product)\n              (helper (cdr arr) (* curr max-product))))))\n  (helper arr 1))\n",
    "  (let loop ([arr (sort < arr)] [max-product 0])\n    (cond [(empty? arr) max-product]\n          [(> (car arr) (* max-product (cadr arr))) (loop (cdr arr) (* max-product (car arr)))]\n          [else (loop (cdr arr) max-product)])))\n",
    "  (let loop ([arr arr] [max-product 0])\n    (if (null? arr)\n        max-product\n        (let ([product (* (car arr) (cadr arr))])\n          (loop (cdr arr) (if (&gt; product max-product) product max-product))))))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (if (null? arr)\n        max-product-so-far\n        (let ([current-product (apply * arr)])\n          (if (&gt; current-product max-product-so-far)\n              (max-product-helper (cdr arr) current-product)\n              (max-product-helper (cdr arr) max-product-so-far)))))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (if (null? arr)\n        max-product-so-far\n        (let ((max-product-of-subsequence (apply * (take arr (length arr)))))\n          (max-product-helper (cdr arr) (max max-product-so-far max-product-of-subsequence)))))\n  (max-product-helper arr 0))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (if (null? arr)\n        max-product-so-far\n        (let ([next-max-product (max (* (car arr) max-product-so-far) (car arr))])\n          (max-product-helper (cdr arr) next-max-product))))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-so-far)\n    (cond\n      [(empty? arr) max-so-far]\n      [(> (first arr) max-so-far) (max-product-helper (rest arr) (first arr))]\n      [else (max-product-helper (rest arr) max-so-far)]))\n  (max-product-helper arr 0))\n",
    "  (define (max_product_helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ([max-product (if (&gt; (car arr) (* max-product (car arr)))\n                               (car arr)\n                               (* max-product (car arr)))])\n          (max_product_helper (cdr arr) max-product))))\n  (max_product_helper arr 1))\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ((curr-product (* (car arr) (cadr arr))))\n          (if (&gt; curr-product max-product)\n              (max-product-helper (cdr arr) curr-product)\n              (max-product-helper (cdr arr) max-product)))))\n  (max-product-helper arr 0))\n</code>\nI'm not sure if this is the most efficient way to do it, but it works.\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let* ([first (car arr)]\n               [rest (cdr arr)]\n               [max-product (if (and (not (null? rest))\n                                     (and (< first (car rest))\n                                          (< (car rest) (car (cdr rest)))))\n                                (* first (car rest) max-product)\n                                max-product)])\n          (max-product-helper rest max-product))))\n  (max-product-helper arr 1))\n",
    "  (let loop ((arr arr) (max 0))\n    (cond\n      [(empty? arr) max]\n      [(< (first arr) (second arr))\n       (loop (rest arr) (* (first arr) (second arr)))]\n      [else\n       (loop (rest arr) max)])))\n",
    "  (let loop ([arr arr] [max-product 0])\n    (if (null? arr)\n        max-product\n        (let ([product (apply * arr)])\n          (if (&gt; product max-product)\n              (loop (cdr arr) product)\n              (loop (cdr arr) max-product))))))\n",
    "  (define (max_product_helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (max_product_helper (cdr arr) (max max-so-far (* max-so-far (car arr))))))\n  (max_product_helper arr 1))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ((next-max (max-product-helper (cdr arr) max-so-far)))\n          (if (&gt; (car arr) max-so-far)\n              (* (car arr) next-max)\n              next-max))))\n  (max-product-helper arr 1))\n",
    "  (let loop ([i 0] [j 1] [max-product 0])\n    (if (&lt; i (length arr))\n        (if (&lt; j (length arr))\n            (if (&lt; (list-ref arr i) (list-ref arr j))\n                (loop i (+ j 1) (max max-product (* (list-ref arr i) (list-ref arr j))))\n                (loop (+ i 1) (+ j 1) max-product))\n            (loop (+ i 1) (+ j 1) max-product))\n        max-product)))\n</code>\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ((curr-max (apply * arr)))\n          (max-product-helper (cdr arr) (max max-so-far curr-max)))))\n  (max-product-helper arr 1))\n",
    "  (define (max_product_helper arr max-so-far)\n    (cond\n      [(empty? arr) max-so-far]\n      [else (max_product_helper (rest arr) (max (first arr) max-so-far))]))\n  (max_product_helper arr 1))\n",
    "  (define (helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ((max-here (apply * (take arr (length arr)))))\n          (helper (cdr arr) (max max-here max-so-far)))))\n  (helper arr 0))\n",
    "  (define (max_product_helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ([curr-product (apply * arr)])\n          (max_product_helper (cdr arr) (max max-product curr-product)))))\n  (max_product_helper arr 0))\n",
    "  (let ([max-so-far 1]\n        [max-ending-here 1])\n    (for ([i (in-range (length arr))])\n      (cond [(> (vector-ref arr i) 0)\n             (set! max-ending-here (* max-ending-here (vector-ref arr i)))]\n            [(< (vector-ref arr i) 0)\n             (set! max-ending-here (/ max-ending-here (vector-ref arr i)))]\n            [else (set! max-ending-here 1)])\n      (when (> max-ending-here max-so-far)\n        (set! max-so-far max-ending-here)))\n    max-so-far))\n",
    "  (define (max_product_helper arr max-so-far)\n    (cond\n      [(empty? arr) max-so-far]\n      [(> (first arr) max-so-far) (max_product_helper (rest arr) (first arr))]\n      [else (max_product_helper (rest arr) max-so-far)]))\n  (max_product_helper arr 0))\n",
    "  (let loop ([arr arr] [max-product 1] [cur-product 1])\n    (if (null? arr)\n        max-product\n        (let ([next-product (* cur-product (car arr))])\n          (if (&gt; next-product cur-product)\n              (loop (cdr arr) (max max-product next-product) next-product)\n              (loop (cdr arr) max-product 1))))))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let* ([first (car arr)]\n               [rest (cdr arr)]\n               [rest-product (max-product-helper rest max-so-far)])\n          (if (< first 0)\n              (max rest-product (* first max-so-far))\n              (max rest-product (* first rest-product))))))\n  (max-product-helper arr 1))\n",
    "  (let loop ((arr arr) (max 0))\n    (cond ((null? arr) max)\n          ((< (car arr) (cadr arr))\n           (loop (cdr arr) (* max (car arr))))\n          (else (loop (cdr arr) max)))))\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ((max-product-candidate (* max-product (car arr))))\n          (if (&gt; max-product-candidate max-product)\n              (max-product-helper (cdr arr) max-product-candidate)\n              (max-product-helper (cdr arr) max-product)))))\n  (max-product-helper arr 1))\n",
    "  (define (max_product_helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([max-so-far (if (&gt; (car arr) max-so-far)\n                              (car arr)\n                              max-so-far)])\n          (max_product_helper (cdr arr) max-so-far))))\n  (max_product_helper arr 0))\n",
    "  (let loop ((arr arr) (max 0))\n    (if (null? arr)\n        max\n        (let ((prod (apply * (take (length arr) arr))))\n          (if (&gt; prod max)\n              (loop (rest arr) prod)\n              (loop (rest arr) max))))))\n</code>\n",
    "  (define (helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([max-so-far (if (&gt; (car arr) max-so-far) (car arr) max-so-far)])\n          (helper (cdr arr) max-so-far))))\n  (helper arr 0))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (max-product-helper (cdr arr)\n                              (if (&gt; curr (* max-so-far curr))\n                                  curr\n                                  (* max-so-far curr))))))\n  (max-product-helper arr 1))\n",
    "  (define (max_product_iter arr max-product)\n    (if (null? arr)\n        max-product\n        (let* ([curr (car arr)]\n               [rest (cdr arr)]\n               [new-max-product (if (&gt; curr (* max-product curr))\n                                    (* max-product curr)\n                                    max-product)])\n          (max_product_iter rest new-max-product))))\n  (max_product_iter arr 1))\n",
    "  (define (max_product_helper arr max-so-far)\n    (cond\n      [(empty? arr) max-so-far]\n      [(> (first arr) max-so-far) (max_product_helper (rest arr) (first arr))]\n      [else (max_product_helper (rest arr) max-so-far)]))\n  (max_product_helper arr 0))\n",
    "  (define (max_product_helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let* ([first (car arr)]\n               [rest (cdr arr)]\n               [new-max-product (if (and (not (null? rest))\n                                          (&gt; first (car rest)))\n                                     (* first max-product)\n                                     max-product)])\n          (max_product_helper rest new-max-product))))\n  (max_product_helper arr 1))\n",
    "  (define (max_product_helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (max_product_helper (cdr arr) (max max-so-far (* max-so-far curr))))))\n  (max_product_helper arr 1))\n",
    "  (let loop ([arr arr] [max-prod 0])\n    (cond [(empty? arr) max-prod]\n          [(> (product (first arr)) max-prod)\n           (loop (rest arr) (product (first arr)))]\n          [else (loop (rest arr) max-prod)])))\n",
    "  (let loop ((arr arr) (max-product 0))\n    (cond ((null? arr) max-product)\n          ((&gt; (apply * arr) max-product)\n           (loop (cdr arr) (apply * arr)))\n          (else (loop (cdr arr) max-product)))))\n</code>\n",
    "  (cond\n    [(empty? arr) 0]\n    [(= (length arr) 1) (first arr)]\n    [else (max (max_product (rest arr))\n               (* (first arr) (max_product (rest arr))))]))\n",
    "  (define (max_product_helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ((curr-product (* max-product (car arr))))\n          (max_product_helper (cdr arr) (max curr-product max-product)))))\n  (max_product_helper arr 1))\n",
    "  (define (max_product_helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let* ([cur (car arr)]\n               [rest (cdr arr)]\n               [new-max-product (if (&gt; cur (* max-product cur))\n                                    (* max-product cur)\n                                    max-product)])\n          (max_product_helper rest new-max-product))))\n  (max_product_helper arr 1))\n</code>\n",
    "  (define (max_product_helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let* ([first (car arr)]\n               [rest (cdr arr)]\n               [new-max-product (if (&gt; first (* max-product first))\n                                    (* max-product first)\n                                    max-product)])\n          (max_product_helper rest new-max-product))))\n  (max_product_helper arr 1))\n",
    "  (define (max_product_helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ((max-product-of-tail (max_product_helper (cdr arr) max-so-far)))\n          (if (&gt; (car arr) (* max-so-far (car arr)))\n              (max (car arr) max-product-of-tail)\n              (* max-so-far (car arr))))))\n  (max_product_helper arr 1))\n</code>\n",
    "  (define (max_product_helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (if (&lt; curr max-so-far)\n              (max_product_helper (cdr arr) max-so-far)\n              (max_product_helper (cdr arr) (* max-so-far curr))))))\n  (max_product_helper arr 1))\n",
    "  (define (helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr-max (max (apply * arr) max-so-far)])\n          (helper (cdr arr) curr-max))))\n  (helper arr 1))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ((curr-max (max-product-helper (cdr arr) max-so-far)))\n          (max curr-max (* max-so-far (car arr))))))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (if (null? arr)\n        max-product-so-far\n        (let ([current-product (apply * arr)])\n          (max-product-helper (cdr arr) (max max-product-so-far current-product)))))\n  (max-product-helper arr 0))\n",
    "  (define (max_product_helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (if (&gt; curr max-so-far)\n              (max_product_helper (cdr arr) (* curr max-so-far))\n              (max_product_helper (cdr arr) max-so-far)))))\n  (max_product_helper arr 1))\n",
    "  (define (max-product-helper arr max-so-far)\n    (cond\n      [(empty? arr) max-so-far]\n      [(> (first arr) (* max-so-far (first arr)))\n       (max-product-helper (rest arr) (first arr))]\n      [else (max-product-helper (rest arr) max-so-far)]))\n  (max-product-helper arr 1))\n",
    "  (let loop ((arr arr) (max 0) (prod 1))\n    (cond ((null? arr) max)\n          ((< (car arr) (cadr arr))\n           (loop (cdr arr) (max (max max prod)) (* prod (car arr))))\n          (else (loop (cdr arr) (max max prod) 1)))))\n",
    "  (define (max-product-helper arr max-so-far max-ending-here)\n    (cond\n      [(empty? arr) max-so-far]\n      [(> (first arr) max-ending-here)\n       (max-product-helper (rest arr) max-so-far (first arr))]\n      [(> (* (first arr) max-ending-here) max-so-far)\n       (max-product-helper (rest arr) (* (first arr) max-ending-here) max-ending-here)]\n      [else (max-product-helper (rest arr) max-so-far max-ending-here)]))\n  (max-product-helper arr 0 0))\n",
    "  (define (max_product_helper arr max-so-far)\n    (cond\n      [(empty? arr) max-so-far]\n      [(> (first arr) (first (rest arr)))\n       (max_product_helper (rest arr) (* max-so-far (first arr)))]\n      [else (max_product_helper (rest arr) max-so-far)]))\n  (max_product_helper arr 1))\n",
    "  (define (max_product_helper arr max-so-far)\n    (cond\n      [(empty? arr) max-so-far]\n      [(> (first arr) max-so-far) (max_product_helper (rest arr) (first arr))]\n      [else (max_product_helper (rest arr) max-so-far)]))\n  (max_product_helper arr 0))\n",
    "  (let loop ((arr arr) (max-product 0) (max-product-so-far 0))\n    (cond ((null? arr) max-product)\n          ((> (car arr) max-product-so-far)\n           (loop (cdr arr) (* max-product (car arr)) (car arr)))\n          (else (loop (cdr arr) max-product max-product-so-far)))))\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ((curr-product (* max-product (car arr))))\n          (max-product-helper (cdr arr) (max curr-product max-product)))))\n  (max-product-helper arr 1))\n",
    "  (let loop ([arr arr] [max-product 1])\n    (if (null? arr)\n        max-product\n        (loop (cdr arr)\n              (max max-product\n                   (apply * (take (cdr arr) (car arr))))))))\n",
    "  (define (max_product_helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ([curr-product (* (car arr) (car (cdr arr)) (car (cdr (cdr arr))))])\n          (if (&gt; curr-product max-product)\n              (max_product_helper (cdr arr) curr-product)\n              (max_product_helper (cdr arr) max-product)))))\n  (max_product_helper arr 0))\n",
    "  (let loop ((arr arr) (max-product 0))\n    (if (null? arr)\n        max-product\n        (let ((product (apply * (take (length arr) arr))))\n          (loop (cdr arr) (max max-product product))))))\n",
    "  (define (max_product_helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (max_product_helper (cdr arr)\n                            (if (and (not (null? (cdr arr)))\n                                     (< (car arr) (cadr arr)))\n                                (* max-so-far (car arr))\n                                max-so-far))))\n  (max_product_helper arr 1))\n",
    "  (let loop ((arr arr) (max-product 0) (max-product-so-far 0) (max-so-far 0))\n    (cond ((null? arr) max-product)\n          ((< (car arr) max-so-far) (loop (cdr arr) max-product max-product-so-far max-so-far))\n          (else (loop (cdr arr) (max max-product (* max-product-so-far (car arr))) (* max-product-so-far (car arr)) (car arr))))))\n",
    "  (define (max_product_iter arr max-product)\n    (cond [(empty? arr) max-product]\n          [else (max_product_iter (cdr arr)\n                                  (if (&gt; (car arr) (* max-product (car arr)))\n                                      (car arr)\n                                      (* max-product (car arr))))]))\n  (max_product_iter arr 1))\n",
    "  (define (helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (if (&gt; curr 0)\n              (helper (cdr arr) (* max-so-far curr))\n              (helper (cdr arr) max-so-far)))))\n  (helper arr 1))\n",
    "  (let loop ((arr arr) (max-product 1) (current-product 1))\n    (cond\n      [(empty? arr) max-product]\n      [(> (first arr) (second arr))\n       (loop (rest arr) max-product (first arr))]\n      [(< (first arr) (second arr))\n       (loop (rest arr) (max max-product (* current-product (first arr))) 1)])))\n",
    "  (define (max_product_helper arr max-so-far)\n    (cond\n      [(empty? arr) max-so-far]\n      [(> (first arr) (* max-so-far (first arr)))\n       (max_product_helper (rest arr) (first arr))]\n      [else\n       (max_product_helper (rest arr) (* max-so-far (first arr)))]))\n  (max_product_helper arr 1))\n",
    "  (define (max-product-helper arr max-prod max-so-far)\n    (cond\n      [(empty? arr) max-prod]\n      [(> (first arr) max-so-far)\n       (max-product-helper (rest arr) (* max-prod (first arr)) (first arr))]\n      [else (max-product-helper (rest arr) max-prod max-so-far)]))\n  (max-product-helper arr 1 -1))\n",
    "  (let loop ((arr arr) (max 0))\n    (cond ((null? arr) max)\n          ((> (apply * arr) max) (loop (cdr arr) (apply * arr)))\n          (else (loop (cdr arr) max)))))\n",
    "  (define (max_product_helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (max_product_helper (cdr arr)\n                              (if (< curr (car max-so-far))\n                                  max-so-far\n                                  (cons curr max-so-far))))))\n  (apply * (max_product_helper arr (list (car arr)))))\n",
    "  (define (max-product-helper arr max-product)\n    (cond [(empty? arr) max-product]\n          [(> (first arr) max-product) (max-product-helper (rest arr) (first arr))]\n          [else (max-product-helper (rest arr) max-product)]))\n  (max-product-helper arr 0))\n",
    "  (let loop ([arr arr] [max-product 0])\n    (if (null? arr)\n        max-product\n        (let ([product (apply * (take (length arr) arr))])\n          (if (&gt; product max-product)\n              (loop (rest arr) product)\n              (loop (rest arr) max-product))))))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (if (&gt; curr 0)\n              (max-product-helper (cdr arr) (* curr max-so-far))\n              (max-product-helper (cdr arr) max-so-far)))))\n  (max-product-helper arr 1))\n",
    "  (define (max_product_helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([x (car arr)])\n          (max_product_helper (cdr arr)\n                              (if (and (positive? x)\n                                       (positive? max-so-far))\n                                  (* x max-so-far)\n                                  (max x max-so-far))))))\n  (max_product_helper arr 0))\n",
    "  (define (max_product_helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ((curr-max (max (car arr) (* (car arr) max-so-far))))\n          (max_product_helper (cdr arr) curr-max))))\n  (max_product_helper arr 1))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ((max-so-far (if (&gt; (* (car arr) max-so-far) max-so-far)\n                              (* (car arr) max-so-far)\n                              max-so-far)))\n          (max-product-helper (cdr arr) max-so-far))))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (if (null? arr)\n        max-product-so-far\n        (let ([current-product (apply * arr)])\n          (max-product-helper (cdr arr) (max max-product-so-far current-product)))))\n  (max-product-helper arr 1))\n",
    "  (define (max_product_helper arr max-so-far)\n    (if (empty? arr)\n        max-so-far\n        (let ([curr (first arr)])\n          (max_product_helper (rest arr)\n                              (if (&gt; curr (* max-so-far curr))\n                                  (* max-so-far curr)\n                                  curr)))))\n  (max_product_helper arr 1))\n",
    "  (define (max_product_helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ((curr-max-product (* max-product (car arr))))\n          (max_product_helper (cdr arr) (max curr-max-product max-product)))))\n  (max_product_helper arr 1))\n",
    "  (define (helper arr acc)\n    (if (null? arr)\n        acc\n        (let* ([first (car arr)]\n               [rest (cdr arr)]\n               [new-acc (if (and (not (null? acc))\n                                 (&gt; first (car acc)))\n                            (cons first acc)\n                            acc)])\n          (helper rest new-acc))))\n  (apply * (helper arr '())))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (cond\n      [(empty? arr) max-product-so-far]\n      [(> (first arr) (first (rest arr)))\n       (max-product-helper (rest arr) (* max-product-so-far (first arr)))]\n      [else\n       (max-product-helper (rest arr) max-product-so-far)]))\n  (max-product-helper arr 1))\n",
    "  (let loop ([arr arr] [max 0])\n    (if (null? arr)\n        max\n        (let ([prod (apply * arr)])\n          (if (&gt; prod max)\n              (loop (cdr arr) prod)\n              (loop (cdr arr) max))))))\n</code>\n",
    "  (let loop ((arr arr) (max-product 0))\n    (if (null? arr)\n        max-product\n        (let ((product (apply * arr)))\n          (if (&gt; product max-product)\n              (loop (cdr arr) product)\n              (loop (cdr arr) max-product))))))\n</code>\n",
    "  (define (max_product_helper arr max_product)\n    (if (null? arr)\n        max_product\n        (let ([current_product (* (car arr) (cadr arr))])\n          (if (> current_product max_product)\n              (max_product_helper (cdr arr) current_product)\n              (max_product_helper (cdr arr) max_product)))))\n  (max_product_helper arr 0))\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ([curr-product (* (car arr) (cadr arr))])\n          (if (&gt; curr-product max-product)\n              (max-product-helper (cdr arr) curr-product)\n              (max-product-helper (cdr arr) max-product)))))\n  (max-product-helper arr 0))\n",
    "  (define (max_product_helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ((max-product (apply * (take (length arr) arr))))\n          (max-product_helper (cdr arr) (max max-product max-so-far)))))\n  (max_product_helper arr 1))\n",
    "  (define (max_product_helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (max_product_helper (cdr arr)\n                            (max max-so-far\n                                 (* max-so-far (car arr))))))\n  (max_product_helper arr 1))\n",
    "  (define (helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (helper (cdr arr) (max max-so-far (* curr (car arr)))))))\n  (helper arr 1))\n",
    "  (define (max_product_helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ((max-so-far (if (&gt; (* max-so-far (car arr)) (car arr))\n                              (* max-so-far (car arr))\n                              (car arr))))\n          (max_product_helper (cdr arr) max-so-far))))\n  (max_product_helper arr 1))\n",
    "  (define (max_product_helper arr max-so-far)\n    (cond [(empty? arr) max-so-far]\n          [(> (first arr) (* max-so-far (first arr)))\n           (max_product_helper (rest arr) (* max-so-far (first arr)))]\n          [else (max_product_helper (rest arr) max-so-far)]))\n  (max_product_helper arr 1))\n",
    "  (let loop ((i 0) (j 1) (max 0))\n    (if (&lt; i (length arr))\n        (let ((prod (* (list-ref arr i) (list-ref arr j))))\n          (if (&lt; j (length arr))\n              (loop i (+ j 1) (max prod max))\n              (loop (+ i 1) (+ i 2) (max prod max))))\n        max)))\n</code>\n",
    "  (let loop ((arr arr) (max-product 0))\n    (cond\n      [(null? arr) max-product]\n      [(> (car arr) max-product) (loop (cdr arr) (car arr))]\n      [else (loop (cdr arr) max-product)])))\n",
    "  (define (helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (helper (cdr arr)\n                  (if (&gt; curr 0)\n                      (max max-so-far (* max-so-far curr))\n                      max-so-far)))))\n  (helper arr 1))\n",
    "  (let loop ([i 0] [max-product 0])\n    (if (= i (length arr))\n        max-product\n        (let ([product (apply * (sublist arr i (add1 i)))]\n              [next-max-product (loop (add1 i) max-product)])\n          (if (&gt; product next-max-product)\n              product\n              next-max-product)))))\n</code>\n",
    "  (define (max_product_helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ((max-product (apply * (take arr (length arr)))))\n          (max_product_helper (cdr arr) (max max-product max-so-far)))))\n  (max_product_helper arr 0))\n",
    "  (let loop ([arr arr] [max-product 1])\n    (if (null? arr)\n        max-product\n        (loop (cdr arr)\n              (if (&gt; (car arr) (* max-product (car arr)))\n                  (* max-product (car arr))\n                  max-product)))))\n",
    "  (define (max_product_helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ((max-so-far (if (&gt; (car arr) max-so-far)\n                              (car arr)\n                              max-so-far)))\n          (max_product_helper (cdr arr) max-so-far))))\n  (max_product_helper arr 0))\n",
    "  (define (max_product_helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (if (&gt; curr 0)\n              (max_product_helper (cdr arr) (* max-so-far curr))\n              (max_product_helper (cdr arr) max-so-far)))))\n  (max_product_helper arr 1))\n",
    "  (define (helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ([curr-product (apply * (take (length arr) arr))])\n          (if (&gt; curr-product max-product)\n              (helper (rest arr) curr-product)\n              (helper (rest arr) max-product)))))\n  (helper arr 0))\n</code>\n",
    "  (define (max_product_helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([cur (car arr)])\n          (if (&gt; cur 0)\n              (max_product_helper (cdr arr) (* cur max-so-far))\n              (max_product_helper (cdr arr) max-so-far)))))\n  (max_product_helper arr 1))\n",
    "  (define (max_product_helper arr max-so-far)\n    (cond\n      [(empty? arr) max-so-far]\n      [(> (first arr) max-so-far) (max_product_helper (rest arr) (first arr))]\n      [else (max_product_helper (rest arr) max-so-far)]))\n  (max_product_helper arr 0))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ((curr-max (max (car arr) (* (car arr) max-so-far))))\n          (max-product-helper (cdr arr) curr-max))))\n  (max-product-helper arr 1))\n",
    "  (let loop ((arr arr)\n             (max-product 0)\n             (max-product-so-far 0))\n    (cond ((null? arr) max-product)\n          ((> (car arr) max-product-so-far)\n           (loop (cdr arr)\n                 (* max-product-so-far (car arr))\n                 (car arr)))\n          (else (loop (cdr arr)\n                      max-product\n                      max-product-so-far)))))\n",
    "  (let loop ([arr arr] [max-product 0] [max-product-so-far 0])\n    (cond [(null? arr) max-product]\n          [(> (car arr) max-product-so-far)\n           (loop (cdr arr) (* max-product (car arr)) (car arr))]\n          [else (loop (cdr arr) max-product max-product-so-far)])))\n",
    "  (let loop ((arr arr)\n             (max-product 0))\n    (cond ((null? arr) max-product)\n          ((= 0 (car arr)) (loop (cdr arr) max-product))\n          ((< 0 (car arr)) (loop (cdr arr) (max max-product (apply * arr))))\n          (else (loop (cdr arr) max-product)))))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (max-product-helper (cdr arr)\n                            (if (or (null? max-so-far)\n                                    (> (* (car arr) (car max-so-far))\n                                       (apply * max-so-far)))\n                                (list (car arr))\n                                (append max-so-far (list (car arr)))))))\n  (apply * (max-product-helper arr '())))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ((first (car arr))\n              (rest (cdr arr)))\n          (max-product-helper rest (max max-so-far (* first (apply * rest)))))))\n  (max-product-helper arr 1))\n",
    "  (define (max_product_helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let* ([first (car arr)]\n               [rest (cdr arr)]\n               [max-product-rest (max_product_helper rest max-product)])\n          (if (&gt; first (* (car max-product-rest) first))\n              (cons first max-product-rest)\n              max-product-rest))))\n  (apply * (max_product_helper arr (list 1))))\n</code>\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr-max (max-product-helper (cdr arr) max-so-far)])\n          (if (&gt; (car arr) (* max-so-far (car arr)))\n              (car arr)\n              (* max-so-far (car arr))))))\n  (max-product-helper arr 1))\n",
    "  (define (max_product_helper arr max-product)\n    (cond [(empty? arr) max-product]\n          [(> (first arr) max-product) (max_product_helper (rest arr) (first arr))]\n          [else (max_product_helper (rest arr) max-product)]))\n  (max_product_helper arr 0))\n",
    "  (define (max_product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ([curr (car arr)])\n          (max_product-helper (cdr arr)\n                              (if (&gt; curr (* max-product curr))\n                                  curr\n                                  (* max-product curr))))))\n  (max_product-helper arr 1))\n",
    "  (define (max_product_helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([max-so-far (if (&gt; (car arr) max-so-far)\n                              (car arr)\n                              max-so-far)])\n          (max_product_helper (cdr arr) max-so-far))))\n  (max_product_helper arr 0))\n",
    "  (let loop ([arr (sort < arr)]\n             [acc 1])\n    (if (null? arr)\n        acc\n        (loop (cdr arr) (* (car arr) acc)))))\n",
    "  (define (helper arr max-so-far)\n    (cond [(empty? arr) max-so-far]\n          [(< (first arr) 0) (helper (rest arr) max-so-far)]\n          [else (helper (rest arr) (* (first arr) max-so-far))]))\n  (helper arr 1))\n",
    "  (let loop ([arr arr] [max-product 0])\n    (cond [(empty? arr) max-product]\n          [(> (product (first arr)) max-product) (loop (rest arr) (product (first arr)))]\n          [else (loop (rest arr) max-product)])))\n",
    "  (define (max_product_aux arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([max-so-far (max max-so-far (* (car arr) (cadr arr)))])\n          (max_product_aux (cdr arr) max-so-far))))\n  (max_product_aux arr 0))\n",
    "  (let loop ([i 0] [j 1] [max 0])\n    (cond [(>= i (length arr)) max]\n          [(>= j (length arr)) (loop (+ i 1) (+ i 2) max)]\n          [(> (* (list-ref arr i) (list-ref arr j)) max)\n           (loop i (+ j 1) (* (list-ref arr i) (list-ref arr j)))]\n          [else (loop i (+ j 1) max)])))\n",
    "  (define (helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (helper (cdr arr) (max max-so-far (* curr (car arr)))))))\n  (helper arr 1))\n",
    "  (define (max_product_helper arr max-product-so-far)\n    (if (null? arr)\n        max-product-so-far\n        (let ((curr-product (apply * arr)))\n          (max_product_helper (cdr arr)\n                              (max max-product-so-far curr-product)))))\n  (max_product_helper arr 1))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (if (null? arr)\n        max-product-so-far\n        (let ((max-product-so-far (if (&gt; (car arr) 0)\n                                      (* max-product-so-far (car arr))\n                                      max-product-so-far)))\n          (max-product-helper (cdr arr) max-product-so-far))))\n  (max-product-helper arr 1))\n",
    "  (define (max_product_helper arr max-so-far)\n    (cond [(empty? arr) max-so-far]\n          [else (let ([curr (first arr)])\n                  (max_product_helper (rest arr)\n                                      (if (&gt; curr (* max-so-far curr))\n                                          curr\n                                          (* max-so-far curr))))]))\n  (max_product_helper arr 1))\n",
    "  (define (max-product-helper arr max-so-far)\n    (cond\n      [(empty? arr) max-so-far]\n      [else\n       (let ([curr-max (max (first arr) (* (first arr) max-so-far))])\n         (max-product-helper (rest arr) curr-max))]))\n  (max-product-helper arr 1))\n",
    "  (define (helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ([curr-product (* (car arr) (car (cdr arr)) (car (cdr (cdr arr))))])\n          (if (&gt; curr-product max-product)\n              (helper (cdr arr) curr-product)\n              (helper (cdr arr) max-product)))))\n  (helper arr 0))\n",
    "  (let loop ([arr arr] [max 0])\n    (cond [(empty? arr) max]\n          [(> (* (first arr) (second arr)) max)\n           (loop (rest arr) (* (first arr) (second arr)))]\n          [else (loop (rest arr) max)])))\n",
    "  (define (max_product_helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ([n (car arr)])\n          (if (&gt; n 0)\n              (max_product_helper (cdr arr) (* max-product n))\n              (max_product_helper (cdr arr) max-product)))))\n  (max_product_helper arr 1))\n",
    "  (define (helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ([curr (car arr)])\n          (if (&gt; curr 0)\n              (helper (cdr arr) (* curr max-product))\n              (helper (cdr arr) max-product)))))\n  (helper arr 1))\n",
    "  (define (max_product_helper arr max-so-far max-ending-here)\n    (cond\n      [(empty? arr) max-so-far]\n      [(> (first arr) max-ending-here)\n       (max_product_helper (rest arr) max-so-far (first arr))]\n      [(< (first arr) max-ending-here)\n       (max_product_helper (rest arr) (max max-so-far (* max-ending-here (first arr))) max-ending-here)]))\n  (max_product_helper arr 0 0))\n",
    "  (define (max-product-helper arr max-product max-product-so-far)\n    (cond\n      [(empty? arr) max-product]\n      [(> (first arr) (* max-product-so-far (first arr)))\n       (max-product-helper (rest arr) (* max-product-so-far (first arr)) (first arr))]\n      [else\n       (max-product-helper (rest arr) max-product (first arr))]))\n  (max-product-helper arr 1 1))\n",
    "  (let loop ((arr arr) (max-product 0) (max-product-so-far 0))\n    (if (null? arr)\n        max-product-so-far\n        (let ((product (* max-product-so-far (car arr))))\n          (if (&gt; product max-product)\n              (loop (cdr arr) product max-product)\n              (loop (cdr arr) max-product max-product-so-far))))))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (cond\n      [(empty? arr) max-product-so-far]\n      [(> (first arr) (first (rest arr)))\n       (max-product-helper (rest arr) (* max-product-so-far (first arr)))]\n      [else\n       (max-product-helper (rest arr) max-product-so-far)]))\n  (max-product-helper arr 1))\n",
    "  (define (max_product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (max_product-helper (cdr arr) (max max-so-far (* curr (car arr)))))))\n  (max_product-helper arr 1))\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ((max-product-so-far (max max-product (* (car arr) (cadr arr)))))\n          (max-product-helper (cdr arr) max-product-so-far))))\n  (max-product-helper arr 0))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (cond\n      [(empty? arr) max-product-so-far]\n      [(> (first arr) (* max-product-so-far (first arr)))\n       (max-product-helper (rest arr) (* max-product-so-far (first arr)))]\n      [else (max-product-helper (rest arr) max-product-so-far)]))\n  (max-product-helper arr 1))\n",
    "  (define (max_product_helper arr max-product)\n    (if (null? arr)\n        max-product\n        (max_product_helper (cdr arr)\n                            (if (&gt; (car arr) 0)\n                                (* max-product (car arr))\n                                max-product))))\n  (max_product_helper arr 1))\n",
    "  (let loop ([i 0] [j 1] [max 0])\n    (if (&gt;= i (length arr))\n        max\n        (let ([prod (* (list-ref arr i) (list-ref arr j))])\n          (if (&gt; prod max)\n              (loop i (+ j 1) prod)\n              (loop i (+ j 1) max))))))\n</code>\nI am getting the following error:\n<code>application: not a procedure;\n expected a procedure that can be applied to arguments\n  given: #&lt;procedure:prod&gt;\n  arguments...:\n   #&lt;procedure:prod&gt;\n   #&lt;procedure:prod&gt;\n   #&lt;procedure:prod&gt;\n   #&lt;procedure:prod&gt;\n   #&lt;procedure:prod&gt;\n   #&lt;procedure:prod&gt;\n   #&lt;procedure:prod&gt;\n   #&lt;procedure:prod&gt;\n   #&lt;procedure:prod&gt;\n   #&lt;procedure:prod&gt;\n   #&lt;procedure:prod&gt;\n   #&lt;procedure:prod&gt;\n   #&lt;procedure:prod&gt;\n   #&lt;procedure:prod&gt;\n   #&lt;procedure:prod&gt;\n   #&lt;procedure:prod&gt;\n   #&lt;procedure:prod&gt;\n   #&lt;procedure:prod&gt;\n   #&lt;procedure:prod&gt;\n   #&lt;procedure:prod&gt;\n   #&lt;procedure:prod&gt;\n   #&lt;procedure:prod&gt;\n   #&lt;procedure:prod&gt;\n   #&lt;procedure:prod&gt;\n   #&lt;procedure",
    "  (let loop ([arr arr] [max-product 0])\n    (if (null? arr)\n        max-product\n        (let ([product (apply * arr)])\n          (if (&gt; product max-product)\n              (loop (cdr arr) product)\n              (loop (cdr arr) max-product))))))\n",
    "  (let loop ([arr arr] [max-product 0])\n    (cond [(empty? arr) max-product]\n          [(> (product (first arr)) max-product)\n           (loop (rest arr) (product (first arr)))]\n          [else (loop (rest arr) max-product)])))\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ([curr-product (apply * (take arr (length arr)))])\n          (if (&gt; curr-product max-product)\n              (max-product-helper (rest arr) curr-product)\n              (max-product-helper (rest arr) max-product)))))\n  (max-product-helper arr 0))\n</code>\n",
    "  (define (max_product_helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (max_product_helper (cdr arr)\n                            (max max-so-far\n                                 (* max-so-far (car arr))))))\n  (max_product_helper arr 1))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ((curr-max (max (car arr) (* (car arr) max-so-far))))\n          (max-product-helper (cdr arr) curr-max))))\n  (max-product-helper arr 1))\n",
    "  (define (helper arr max-so-far)\n    (cond\n      [(empty? arr) max-so-far]\n      [(> (first arr) max-so-far) (helper (rest arr) (first arr))]\n      [else (helper (rest arr) max-so-far)]))\n  (helper arr 0))\n",
    "  (let loop ((arr arr)\n             (max-product 0)\n             (current-product 1))\n    (if (null? arr)\n        max-product\n        (let ((new-product (* current-product (car arr))))\n          (if (&gt; new-product current-product)\n              (loop (cdr arr)\n                    (max max-product new-product)\n                    new-product)\n              (loop (cdr arr)\n                    max-product\n                    1))))))\n</code>\n",
    "  (define (max-product-helper arr max-so-far)\n    (cond\n      [(empty? arr) max-so-far]\n      [(< (first arr) 0)\n       (max-product-helper (rest arr) (max max-so-far (first arr)))\n       ]\n      [else\n       (max-product-helper (rest arr) (max max-so-far (* max-so-far (first arr))))\n       ]))\n  (max-product-helper arr 1))\n",
    "  (let loop ([arr arr]\n             [max-product 0])\n    (if (null? arr)\n        max-product\n        (let ([product (apply * arr)])\n          (loop (cdr arr)\n                (max max-product product))))))\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ([curr-product (apply * arr)])\n          (if (&gt; curr-product max-product)\n              (max-product-helper (cdr arr) curr-product)\n              (max-product-helper (cdr arr) max-product)))))\n  (max-product-helper arr 0))\n</code>\n",
    "  (let loop ((arr arr) (max 0))\n    (if (null? arr)\n        max\n        (let ((prod (apply * (take (length arr) arr))))\n          (loop (cdr arr) (max prod max))))))\n",
    "  (let loop ([arr arr] [max-prod 0] [curr-prod 1])\n    (cond [(empty? arr) max-prod]\n          [(> (first arr) (* (first (rest arr)) curr-prod))\n           (loop (rest arr)\n                 (max max-prod curr-prod)\n                 (first arr))]\n          [else (loop (rest arr)\n                      max-prod\n                      (* curr-prod (first arr)))])))\n",
    "  (define (max_product_helper arr max-so-far)\n    (cond [(empty? arr) max-so-far]\n          [else\n           (let ([curr (first arr)])\n             (max_product_helper (rest arr)\n                                 (if (&lt; curr (first max-so-far))\n                                     (cons curr max-so-far)\n                                     max-so-far)))]))\n  (define (product lst)\n    (foldl * 1 lst))\n  (product (max_product_helper arr (list (first arr)))))\n",
    "  (define (helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (if (&gt; curr max-so-far)\n              (helper (cdr arr) (* curr max-so-far))\n              (helper (cdr arr) max-so-far)))))\n  (helper arr 1))\n",
    "  (let loop ([i 0] [j 0] [max 0])\n    (if (= i (length arr))\n        max\n        (let ([product (* (list-ref arr i) (list-ref arr j))])\n          (if (&lt; product 0)\n              (loop (+ i 1) (+ j 1) max)\n              (loop (+ i 1) (+ j 1) (max product max)))))))\n</code>\n",
    "  (define (max_product_helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([n (car arr)])\n          (if (&gt; n 0)\n              (max_product_helper (cdr arr) (* n max-so-far))\n              (max_product_helper (cdr arr) max-so-far)))))\n  (max_product_helper arr 1))\n",
    "  (define (max-product-helper arr max-product)\n    (cond [(empty? arr) max-product]\n          [(> (first arr) (* max-product (first arr)))\n           (max-product-helper (rest arr) (* max-product (first arr)))]\n          [else (max-product-helper (rest arr) max-product)]))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let* ([first (car arr)]\n               [rest (cdr arr)]\n               [new-max-product (if (and (not (null? rest))\n                                          (&gt; (car rest) first))\n                                     (* max-product first)\n                                     max-product)])\n          (max-product-helper rest new-max-product))))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-so-far)\n    (cond\n      [(empty? arr) max-so-far]\n      [(> (first arr) max-so-far) (max-product-helper (rest arr) (first arr))]\n      [else (max-product-helper (rest arr) max-so-far)]))\n  (max-product-helper arr 0))\n",
    "  (define (max-product-helper arr max-product)\n    (cond [(empty? arr) max-product]\n          [else (let ([first (first arr)])\n                  (cond [(> first 0) (max-product-helper (rest arr) (* first max-product))]\n                        [else (max-product-helper (rest arr) max-product)]))]))\n  (max-product-helper arr 1))\n",
    "  (let loop ((arr arr) (max-product 0))\n    (cond\n      [(empty? arr) max-product]\n      [(< (first arr) (second arr))\n       (loop (rest arr) (max max-product (* (first arr) (second arr))))]\n      [else (loop (rest arr) max-product)])))\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ([curr-product (apply * arr)])\n          (if (&gt; curr-product max-product)\n              (max-product-helper (cdr arr) curr-product)\n              (max-product-helper (cdr arr) max-product)))))\n  (max-product-helper arr 0))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (if (&gt; curr max-so-far)\n              (max-product-helper (cdr arr) (* curr max-so-far))\n              (max-product-helper (cdr arr) max-so-far)))))\n  (max-product-helper arr 1))\n</code>\n",
    "  (define (max_product_helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([max-here (apply * (take arr (length arr)))]\n              [max-here-1 (apply * (take arr (- (length arr) 1)))])\n          (max_product_helper (cdr arr) (max max-so-far max-here max-here-1)))))\n  (max_product_helper arr 1))\n",
    "  (let loop ([arr arr] [max-product 0])\n    (cond [(empty? arr) max-product]\n          [(>= (car arr) (cadr arr))\n           (loop (cdr arr) (* (car arr) max-product))]\n          [else (loop (cdr arr) max-product)])))\n",
    "  (let loop ([arr arr] [max-product 0] [max-product-so-far 0] [max-product-so-far-so-far 0])\n    (cond [(null? arr) max-product]\n          [(> (car arr) max-product-so-far-so-far)\n           (loop (cdr arr)\n                 (max max-product (* max-product-so-far (car arr)))\n                 (car arr)\n                 max-product-so-far)]\n          [(> (car arr) max-product-so-far)\n           (loop (cdr arr)\n                 (max max-product (* max-product-so-far (car arr)))\n                 (car arr)\n                 max-product-so-far-so-far)]\n          [else\n           (loop (cdr arr)\n                 (max max-product (* max-product-so-far (car arr)))\n                 max-product-so-far\n                 max-product-so-far-so-far)])))\n"
  ]
}