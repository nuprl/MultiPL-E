{
  "name": "mbpp_244_next_Perfect_Square",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a rktthon function to find the next perfect square greater than a given number.\n(define (next_Perfect_Square N)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_244_next_Perfect_Square.py",
  "prompt_terminology": "reworded",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate next_Perfect_Square))\n    (check-equal? (candidate 35) 36)\n    (check-equal? (candidate 6) 9)\n    (check-equal? (candidate 9) 16)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt;= (* i i) N)\n        (* i i)\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (let ([N (ceiling (sqrt N))])\n    (* N (+ N 1))))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (= (sqr i) N)\n        (sqr (+ i 1))\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        (* i i)\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (let ([n (ceiling (sqrt N))])\n    (* n n)))\n",
    "  (let loop ((N N))\n    (if (and (integer? (sqrt N)) (= (sqrt N) (round (sqrt N))))\n        N\n        (loop (+ N 1)))))\n",
    "  (define (perfect_square? N)\n    (if (= (sqrt N) (round (sqrt N)))\n        #t\n        #f))\n  (define (next_square N)\n    (if (perfect_square? N)\n        (next_square (+ N 1))\n        N))\n  (next_square (+ N 1)))\n",
    "  (cond\n    [(= (sqrt N) (floor (sqrt N))) (next_Perfect_Square (+ N 1))]\n    [else (expt (ceiling (sqrt N)) 2)]))\n",
    "  (define (is_Perfect_Square N)\n    (define (isqrt N)\n      (define (isqrt-iter guess)\n        (if (good-enough? guess)\n            guess\n            (isqrt-iter (improve guess))))\n      (define (good-enough? guess)\n        (< (abs (- (square guess) N)) 0.001))\n      (define (improve guess)\n        (average guess (/ N guess)))\n      (define (average x y)\n        (/ (+ x y) 2))\n      (isqrt-iter 1.0))\n    (if (= (isqrt N) (round (isqrt N)))\n        #t\n        #f))\n  (if (is_Perfect_Square N)\n      N\n      (next_Perfect_Square (+ N 1))))\n",
    "  (let ((N (sqrt N)))\n    (cond\n      [(= (remainder N 1) 0) (+ N 1)]\n      [else (next_Perfect_Square (+ N 1))])))\n",
    "  (define (next_Perfect_Square_iter n i)\n    (if (&gt; (* i i) n)\n        i\n        (next_Perfect_Square_iter n (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (let ([n (ceiling (sqrt N))])\n    (* n (+ n 1))))\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (let loop ((N N))\n        (if (not (integer? (sqrt N)))\n            (loop (+ N 1))\n            N))))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (cond ((= (sqr i) N) (+ i 1))\n          ((&gt; (sqr i) N) (sqr i))\n          (else (next_Perfect_Square_iter N (+ i 1)))))\n  (next_Perfect_Square_iter N 1))\n</code>\n\n\nA:\n\nThe problem is that you're using <code>sqr</code> instead of <code>sqrt</code>.\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (sqr i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (let ([n (ceiling (sqrt N))])\n    (* n (+ n 1))))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (if (= (sqrt N) (round (sqrt N)))\n      (next_Perfect_Square (+ N 1))\n      (round (sqrt N))))\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (if (not (positive? N))\n          (error \"N must be positive\")\n          (let loop ((i 1))\n            (if (&gt; (* i i) N)\n                i\n                (loop (+ i 1)))))))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&lt; N (* i i))\n        (* i i)\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (cond\n      [(= (sqr i) N) (+ i 1)]\n      [else (next_Perfect_Square_iter N (+ i 1))]))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt;= (* i i) N)\n        (* i i)\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (= i N)\n        (next_Perfect_Square_iter N (+ i 1))\n        (if (= (sqr i) N)\n            (sqr (+ i 1))\n            (next_Perfect_Square_iter N (+ i 1)))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (let loop ((i 1))\n        (if (not (< i N))\n            (let ((sqr (* i i)))\n              (if (= sqr N)\n                  (loop (+ i 1))\n                  sqr))\n            (error \"N must be a positive integer\")))))\n",
    "  (let ([N (ceiling (sqrt N))])\n    (* N (+ N 1))))\n",
    "  (define (is_Perfect_Square N)\n    (define (is_Perfect_Square_iter N i)\n      (cond ((= N (* i i)) #t)\n            ((&gt; N (* i i)) (is_Perfect_Square_iter N (+ i 1)))\n            (else #f)))\n    (is_Perfect_Square_iter N 1))\n  (define (next_Perfect_Square_iter N i)\n    (cond ((is_Perfect_Square N) N)\n          ((is_Perfect_Square (+ N i)) (+ N i))\n          (else (next_Perfect_Square_iter N (+ i 1)))))\n  (next_Perfect_Square_iter N 1))\n</code>\n",
    "  (let ([n (ceiling (sqrt N))])\n    (* n n)))\n",
    "  (let ([n (ceiling (sqrt N))])\n    (* n n)))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&lt; (sqr i) N)\n        (next_Perfect_Square_iter N (+ i 1))\n        (sqr i)))\n  (next_Perfect_Square_iter N 1))\n",
    "  (cond\n    [(= (sqrt N) (floor (sqrt N)))\n     (+ 1 (sqrt N))]\n    [else\n     (next_Perfect_Square (+ 1 N))]))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (cond [(= (sqrt N) (floor (sqrt N))) (+ N 1)]\n        [else (next_Perfect_Square (+ N 1))]))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        (* i i)\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (cond\n    [(= N 0) 1]\n    [(= N 1) 4]\n    [else (next_Perfect_Square (- N 1))]))\n",
    "  (define (is_Perfect_Square N)\n    (define (is_Perfect_Square_iter N i)\n      (cond ((= N (* i i)) #t)\n            ((&gt; N (* i i)) (is_Perfect_Square_iter N (+ i 1)))\n            (else #f)))\n    (is_Perfect_Square_iter N 1))\n  (define (next_Perfect_Square_iter N i)\n    (cond ((is_Perfect_Square N) N)\n          ((&gt; N (* i i)) (next_Perfect_Square_iter N (+ i 1)))\n          (else (* i i))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (is_Perfect_Square N)\n    (define (is_Perfect_Square_iter N i)\n      (cond\n        [(= N (* i i)) #t]\n        [(> N (* i i)) (is_Perfect_Square_iter N (+ i 1))]\n        [else #f]))\n    (is_Perfect_Square_iter N 1))\n  (define (next_Perfect_Square_iter N i)\n    (cond\n      [(is_Perfect_Square N) N]\n      [else (next_Perfect_Square_iter (+ N 1) (+ i 1))]))\n  (next_Perfect_Square_iter N 1))\n",
    "  (let loop ([N N])\n    (if (not (integer? (sqrt N)))\n        (loop (+ N 1))\n        N)))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        (* i i)\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (is_Perfect_Square N)\n    (define (is_Perfect_Square_helper N i)\n      (if (= (* i i) N)\n          #t\n          (if (&gt; (* i i) N)\n              #f\n              (is_Perfect_Square_helper N (+ i 1)))))\n    (is_Perfect_Square_helper N 1))\n  (define (next_Perfect_Square_helper N i)\n    (if (is_Perfect_Square N)\n        N\n        (if (is_Perfect_Square (+ N i))\n            (+ N i)\n            (next_Perfect_Square_helper N (+ i 1)))))\n  (next_Perfect_Square_helper N 1))\n</code>\n",
    "  (let ([n (ceiling (sqrt N))])\n    (* n n)))\n",
    "  (let ([n (ceiling (sqrt N))])\n    (* n n)))\n",
    "  (let* ([sqrt (sqrt N)]\n         [ceil (ceiling sqrt)])\n    (* ceil ceil)))\n",
    "  (if (not (integer? N))\n      (error \"Input must be an integer\")\n      (if (not (positive? N))\n          (error \"Input must be a positive integer\")\n          (let loop ((i 1))\n            (if (not (< i N))\n                (if (= (sqr i) N)\n                    (sqr (+ i 1))\n                    (sqr i))\n                (loop (+ i 1)))))))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (cond ((= (sqr i) N) (+ i 1))\n          ((&gt; (sqr i) N) (sqr i))\n          (else (next_Perfect_Square_iter N (+ i 1)))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (is_Perfect_Square N)\n    (define (is_Perfect_Square_iter N i)\n      (cond ((= N (* i i)) #t)\n            ((&gt; N (* i i)) (is_Perfect_Square_iter N (+ i 1)))\n            (else #f)))\n    (is_Perfect_Square_iter N 1))\n  (define (next_Perfect_Square_iter N i)\n    (cond ((is_Perfect_Square N) N)\n          ((&lt; N (* i i)) (* i i))\n          (else (next_Perfect_Square_iter N (+ i 1)))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (cond\n    [(= (sqrt N) (floor (sqrt N)))\n     (sqrt N)]\n    [else\n     (next_Perfect_Square (+ N 1))]))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (if (not (integer? N))\n      (error \"Input must be an integer\")\n      (if (not (positive? N))\n          (error \"Input must be a positive integer\")\n          (let loop ((i 1))\n            (if (> (* i i) N)\n                i\n                (loop (+ i 1)))))))\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (if (not (positive? N))\n          (error \"N must be positive\")\n          (let loop ([N N])\n            (if (not (integer? (sqrt N)))\n                (loop (+ N 1))\n                N)))))\n",
    "  (let ([n (ceiling (sqrt N))])\n    (* n (+ n 1))))\n",
    "  (define (next_Perfect_Square_iter n i)\n    (if (= n (* i i))\n        (next_Perfect_Square_iter (+ n 1) (+ i 1))\n        (* i i)))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        (* i i)\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (cond\n    [(= (sqrt N) (floor (sqrt N))) (+ 1 (sqrt N))]\n    [else (next_Perfect_Square (+ 1 N))]))\n",
    "  (cond\n    [(= (sqrt N) (floor (sqrt N))) (+ 1 (sqrt N))]\n    [else (+ 1 (sqrt N))]))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&lt; N (* i i))\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (let ([n (ceiling (sqrt N))])\n    (* n (+ n 1))))\n",
    "  (define (is_Perfect_Square N)\n    (define (is_Perfect_Square_iter N i)\n      (cond ((= N (* i i)) #t)\n            ((&gt; N (* i i)) (is_Perfect_Square_iter N (+ i 1)))\n            (else #f)))\n    (is_Perfect_Square_iter N 1))\n  (define (next_Perfect_Square_iter N i)\n    (cond ((is_Perfect_Square N) N)\n          ((&gt; N (* i i)) (next_Perfect_Square_iter N (+ i 1)))\n          (else (* i i))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (if (= (sqrt N) (floor (sqrt N)))\n      (sqrt N)\n      (next_Perfect_Square (+ N 1))))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (cond ((= (sqr i) N) (+ i 1))\n          ((&gt; (sqr i) N) (sqr i))\n          (else (next_Perfect_Square_iter N (+ i 1)))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (let ([sqrt-N (sqrt N)])\n    (if (integer? sqrt-N)\n        (next_Perfect_Square (+ N 1))\n        (expt (ceiling sqrt-N) 2))))\n",
    "  (define (is_Perfect_Square N)\n    (define (is_Perfect_Square_helper N i)\n      (if (= N (* i i))\n          #t\n          (if (&lt; N (* i i))\n              #f\n              (is_Perfect_Square_helper N (+ i 1)))))\n    (is_Perfect_Square_helper N 1))\n  (define (next_Perfect_Square_helper N)\n    (if (is_Perfect_Square N)\n        N\n        (next_Perfect_Square_helper (+ N 1))))\n  (next_Perfect_Square_helper N))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        (* i i)\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (= (* i i) N)\n        (next_Perfect_Square_iter N (+ i 1))\n        (* i i)))\n  (next_Perfect_Square_iter N 1))\n",
    "  (let* ([sqrt (sqrt N)]\n         [ceiling (ceiling sqrt)])\n    (* ceiling ceiling)))\n",
    "  (let ([n (ceiling (sqrt N))])\n    (* n n)))\n",
    "  (if (= (sqrt N) (floor (sqrt N)))\n      (sqrt N)\n      (sqrt (+ 1 N))))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (cond ((= (sqr i) N) (+ i 1))\n          ((&gt; (sqr i) N) (sqr i))\n          (else (next_Perfect_Square_iter N (+ i 1)))))\n  (next_Perfect_Square_iter N 1))\n</code>\n",
    "  (let ([n (ceiling (sqrt N))])\n    (* n n)))\n",
    "  (let loop ([n N])\n    (if (not (integer? (sqrt n)))\n        (loop (+ n 1))\n        n)))\n",
    "  (if (= (sqrt N) (floor (sqrt N)))\n      (sqrt N)\n      (next_Perfect_Square (+ N 1))))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt;= (* i i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (if (= (sqrt N) (floor (sqrt N)))\n      (sqrt N)\n      (next_Perfect_Square (+ N 1))))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (and (&gt; N i) (&lt; N (* i i)))\n        (next_Perfect_Square_iter N (+ i 1))\n        (* i i)))\n  (next_Perfect_Square_iter N 1))\n</code>\nI am getting the following error:\n<code>next_Perfect_Square.rkt:4:0: next_Perfect_Square_iter: undefined;\n cannot reference an identifier before its definition\n</code>\nI am not sure what is wrong with the code.\n\n\nA:\n\nThe problem is that you're trying to call <code>next_Perfect_Square_iter</code> before it's defined.\nYou can fix this by moving the definition of <code>next_Perfect_Square_iter</code> before the call to it.\n<code>(define (next_Perfect_Square N)\n  (define (next_Perfect_Square_iter N i)\n    (if (and (&gt; N i) (&lt; N (* i i)))\n        (next_Perfect_Square_iter N (+ i 1))\n        (* i i)))\n  (next_Perfect_Square_iter N 1))\n</code>\n",
    "  (define (next_Perfect_Square_iter N i)\n    (cond ((= (sqr i) N) (+ i 1))\n          ((&gt; (sqr i) N) (sqr i))\n          (else (next_Perfect_Square_iter N (+ i 1)))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (= (sqr i) N)\n        (sqr (+ i 1))\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (let ([n (ceiling (sqrt N))])\n    (* n n)))\n",
    "  (let ([n (ceiling (sqrt N))])\n    (* n (+ n 1))))\n",
    "  (let ([n (ceiling (sqrt N))])\n    (* n n)))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&lt; (sqr i) N)\n        (next_Perfect_Square_iter N (+ i 1))\n        (sqr i)))\n  (next_Perfect_Square_iter N 1))\n",
    "  (let ([sqrt (sqrt N)])\n    (if (integer? sqrt)\n        (expt (ceiling sqrt) 2)\n        (expt (ceiling sqrt) 2))))\n",
    "  (let loop ((n N))\n    (if (not (integer? (sqrt n)))\n        (loop (+ n 1))\n        n)))\n",
    "  (if (perfect_Square? N)\n      (+ N 1)\n      (next_Perfect_Square (+ N 1))))\n",
    "  (let ([n (ceiling (sqrt N))])\n    (* n n)))\n",
    "  (define (is_Perfect_Square N)\n    (= (sqrt N) (floor (sqrt N))))\n  (define (find_next_Perfect_Square N)\n    (if (is_Perfect_Square N)\n        N\n        (find_next_Perfect_Square (+ N 1))))\n  (find_next_Perfect_Square (+ N 1)))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (helper N)\n    (if (= (sqrt N) (round (sqrt N)))\n        N\n        (helper (+ N 1))))\n  (helper (+ N 1)))\n",
    "  (cond\n    [(= (sqrt N) (floor (sqrt N)))\n     (sqrt N)]\n    [else\n     (next_Perfect_Square (+ N 1))]))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (= (* i i) N)\n        (next_Perfect_Square_iter N (+ i 1))\n        (* i i)))\n  (next_Perfect_Square_iter N 1))\n",
    "  (letrec ([sqrt (lambda (N)\n                   (if (&lt; N 0)\n                       (error \"N must be positive\")\n                       (if (zero? N)\n                           0\n                           (if (zero? (remainder N 2))\n                               (let ([x (sqrt (/ N 2))])\n                                 (* 2 (+ x x)))\n                               (let ([x (sqrt (- N 1))])\n                                 (+ (* 2 x) 1))))))]\n           [next_square (lambda (N)\n                          (let ([x (sqrt N)])\n                            (* (+ x 1) (+ x 1))))])\n    (next_square N)))\n",
    "  (let ([i (ceiling (sqrt N))])\n    (* i i)))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (let ((n (ceiling (sqrt N))))\n    (* n n)))\n",
    "  (cond\n    [(= (sqrt N) (floor (sqrt N))) (sqrt N)]\n    [else (next_Perfect_Square (+ N 1))]))\n",
    "  (define (is_Perfect_Square N)\n    (define (is_Perfect_Square_iter N i)\n      (if (= N (* i i))\n          #t\n          (if (&lt; N (* i i))\n              #f\n              (is_Perfect_Square_iter N (+ i 1)))))\n    (is_Perfect_Square_iter N 1))\n  (define (next_Perfect_Square_iter N i)\n    (if (is_Perfect_Square N)\n        N\n        (if (is_Perfect_Square (+ N i))\n            (+ N i)\n            (next_Perfect_Square_iter N (+ i 1)))))\n  (next_Perfect_Square_iter N 1))\n</code>\nI am not sure if I am doing it right.\n\n\nA:\n\nI think you're overcomplicating things.\n<code>(define (next-perfect-square n)\n  (let loop ((i 1))\n    (if (&lt; n (* i i))\n        (* i i)\n        (loop (+ i 1)))))\n</code>\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (is_Perfect_Square N)\n    (define (is_Perfect_Square_iter N i)\n      (cond ((= i N) #t)\n            ((&gt; i N) #f)\n            (else (is_Perfect_Square_iter N (+ i 1)))))\n    (is_Perfect_Square_iter N 1))\n  (define (next_Perfect_Square_iter N i)\n    (cond ((is_Perfect_Square N) N)\n          ((is_Perfect_Square i) i)\n          (else (next_Perfect_Square_iter N (+ i 1)))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (cond ((= (sqr i) N) (sqr (+ i 1)))\n          ((&gt; (sqr i) N) (sqr i))\n          (else (next_Perfect_Square_iter N (+ i 1)))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (let ([n (ceiling (sqrt N))])\n    (* n n)))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (sqr i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (cond ((= (sqr i) N) (+ i 1))\n          ((&gt; (sqr i) N) (sqr i))\n          (else (next_Perfect_Square_iter N (+ i 1)))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (if (= (sqrt N) (floor (sqrt N)))\n      (sqrt N)\n      (next_Perfect_Square (+ N 1))))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (cond ((= (sqr i) N) (+ i 1))\n          ((&gt; (sqr i) N) (sqr i))\n          (else (next_Perfect_Square_iter N (+ i 1)))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (cond\n    [(= (sqrt N) (floor (sqrt N))) (+ N 1)]\n    [else (+ (floor (sqrt N)) 1) (* (+ (floor (sqrt N)) 1) (+ (floor (sqrt N)) 1))]))\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (let loop ((i 1))\n        (if (&gt; (* i i) N)\n            i\n            (loop (+ i 1))))))\n</code>\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (sqr i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_iter i)\n    (if (= (sqr i) N)\n        (sqr (+ i 1))\n        (next_Perfect_Square_iter (+ i 1))))\n  (next_Perfect_Square_iter 1))\n",
    "  (define (helper N)\n    (if (= (sqrt N) (floor (sqrt N)))\n        N\n        (helper (+ N 1))))\n  (helper (+ N 1)))\n",
    "  (cond\n    [(= (sqrt N) (floor (sqrt N))) (+ 1 (sqrt N))]\n    [else (next_Perfect_Square (+ 1 N))]))\n",
    "  (define (is_Perfect_Square N)\n    (define (square N) (* N N))\n    (define (is_Perfect_Square_iter N)\n      (if (= N (square (truncate (sqrt N))))\n          #t\n          #f))\n    (is_Perfect_Square_iter N))\n  (define (next_Perfect_Square_iter N)\n    (if (is_Perfect_Square N)\n        N\n        (next_Perfect_Square_iter (+ N 1))))\n  (next_Perfect_Square_iter N))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        (* i i)\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (cond\n    [(= (sqrt N) (floor (sqrt N))) (+ 1 (sqrt N))]\n    [else (+ 1 (sqrt N))]))\n",
    "  (let ([sqrt (sqrt N)])\n    (if (integer? sqrt)\n        (expt (+ sqrt 1) 2)\n        (expt (+ (ceiling sqrt) 1) 2))))\n",
    "  (define (is_Perfect_Square N)\n    (define (is_Perfect_Square_iter N i)\n      (if (= i N)\n          #t\n          (if (&gt; i N)\n              #f\n              (is_Perfect_Square_iter N (+ i 1)))))\n    (is_Perfect_Square_iter N 1))\n  (define (next_Perfect_Square_iter N i)\n    (if (is_Perfect_Square N)\n        N\n        (next_Perfect_Square_iter (+ N 1) (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n</code>\nI'm not sure if this is the best way to do it, but it works.\n",
    "  (define (is_Perfect_Square N)\n    (if (= N (sqr (round (sqrt N))))\n        #t\n        #f))\n  (define (next_Perfect_Square_helper N)\n    (if (is_Perfect_Square N)\n        N\n        (next_Perfect_Square_helper (+ N 1))))\n  (next_Perfect_Square_helper (+ N 1)))\n",
    "  (cond\n    [(= (sqrt N) (floor (sqrt N))) (sqrt N)]\n    [else (ceiling (sqrt N))]))\n",
    "  (let* ((sqrt (sqrt N))\n         (ceil (ceiling sqrt)))\n    (* ceil ceil)))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&lt; (sqr i) N)\n        (next_Perfect_Square_iter N (+ i 1))\n        (sqr i)))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (is_Perfect_Square N)\n    (define (is_Perfect_Square_iter N i)\n      (if (= N (* i i))\n          #t\n          (if (&lt; N (* i i))\n              #f\n              (is_Perfect_Square_iter N (+ i 1)))))\n    (is_Perfect_Square_iter N 1))\n  (define (next_Perfect_Square_iter N i)\n    (if (is_Perfect_Square N)\n        N\n        (if (is_Perfect_Square (+ N i))\n            (+ N i)\n            (next_Perfect_Square_iter N (+ i 1)))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (cond\n    [(= (sqrt N) (floor (sqrt N)))\n     (sqrt N)]\n    [else\n     (next_Perfect_Square (+ N 1))]))\n</code>\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (if (not (positive? N))\n          (error \"N must be positive\")\n          (let loop ((i 1))\n            (if (&gt; (* i i) N)\n                i\n                (loop (+ i 1)))))))\n</code>\n",
    "  (let ([N (ceiling (sqrt N))])\n    (* N (+ N 1))))\n",
    "  (letrec ([next_square (lambda (N)\n                          (if (= (sqrt N) (floor (sqrt N)))\n                              (next_square (+ N 1))\n                              N))])\n    (next_square N)))\n",
    "  (define (is_Perfect_Square N)\n    (define (is_Perfect_Square_iter N i)\n      (cond ((= N (* i i)) #t)\n            ((&gt; N (* i i)) (is_Perfect_Square_iter N (+ i 1)))\n            (else #f)))\n    (is_Perfect_Square_iter N 1))\n  (define (next_Perfect_Square_iter N)\n    (cond ((is_Perfect_Square N) N)\n          (else (next_Perfect_Square_iter (+ N 1)))))\n  (next_Perfect_Square_iter N))\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (let loop ((i 1))\n        (if (&gt; (* i i) N)\n            i\n            (loop (+ i 1))))))\n</code>\n",
    "  (define (next_Perfect_Square_helper N i)\n    (if (= (sqr i) N)\n        (sqr (+ i 1))\n        (next_Perfect_Square_helper N (+ i 1))))\n  (next_Perfect_Square_helper N 1))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (let ([n (ceiling (sqrt N))])\n    (* n (+ n 1))))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (cond ((= (sqr i) N) (+ i 1))\n          ((&gt; (sqr i) N) (sqr i))\n          (else (next_Perfect_Square_iter N (+ i 1)))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (let loop ((i 1))\n    (if (&gt; (* i i) N)\n        i\n        (loop (+ i 1)))))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (cond\n      [(= i N) (next_Perfect_Square_iter N (+ i 1))]\n      [(= (sqr i) N) i]\n      [else (next_Perfect_Square_iter N (+ i 1))]))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_helper N i)\n    (if (&gt; (* i i) N)\n        (* i i)\n        (next_Perfect_Square_helper N (+ i 1))))\n  (next_Perfect_Square_helper N 1))\n",
    "  (define (is_Perfect_Square N)\n    (define (is_Perfect_Square_iter N i)\n      (cond ((= N (* i i)) #t)\n            ((&gt; N (* i i)) (is_Perfect_Square_iter N (+ i 1)))\n            (else #f)))\n    (is_Perfect_Square_iter N 1))\n  (define (next_Perfect_Square_iter N i)\n    (cond ((is_Perfect_Square N) N)\n          ((&gt; N (* i i)) (next_Perfect_Square_iter N (+ i 1)))\n          (else (* i i))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (let loop ([N N])\n    (cond [(= (sqrt N) (floor (sqrt N))) N]\n          [else (loop (+ N 1))])))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (cond ((= N (* i i)) i)\n          ((&gt; N (* i i)) (next_Perfect_Square_iter N (+ i 1)))\n          (else i)))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (is_Perfect_Square N)\n    (define (is_Perfect_Square_iter N i)\n      (if (= (* i i) N)\n          #t\n          (if (&lt; (* i i) N)\n              (is_Perfect_Square_iter N (+ i 1))\n              #f)))\n    (is_Perfect_Square_iter N 1))\n  (define (next_Perfect_Square_iter N i)\n    (if (is_Perfect_Square N)\n        N\n        (if (is_Perfect_Square i)\n            i\n            (next_Perfect_Square_iter N (+ i 1)))))\n  (next_Perfect_Square_iter N 1))\n</code>\nI am getting the following error:\n<code>next_Perfect_Square.rkt:1:0: read: expected a `(' before a literal constant\nnext_Perfect_Square.rkt:1:0: read: expected a `(' before a literal constant\nnext_Perfect_Square.rkt:1:0: read: expected a `(' before a literal constant\nnext_Perfect_Square.rkt:1:0: read: expected a `(' before a literal constant\nnext_Perfect_Square.rkt:1:0: read: expected a `(' before a literal constant\nnext_Perfect_Square.rkt:1:0: read: expected a `(' before a literal constant\nnext_Perfect_Square.rkt:1:0: read: expected a `(' before a literal constant\nnext_Perfect_Square.rkt:1:0: read: expected a `(' before a literal constant\nnext_Perfect_Square.rkt:1:0: read: expected a `(' before a literal constant\nnext_Perfect_Square.rkt:1:0: read: expected a `(' before a literal constant\nnext_Perfect_Square.rkt:1:0: read: expected a `(' before a literal constant\nnext_Perfect_Square.rkt:1:0: read: expected a `(' before a literal constant\nnext_Perfect_Square.rkt:1:0: read: expected a `(' before a literal constant\nnext_Perfect_Square.rkt:1:0: read: expected a `(' before a literal",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (is_Perfect_Square N)\n    (define (is_Perfect_Square_iter N i)\n      (cond ((= N (* i i)) #t)\n            ((&gt; N (* i i)) (is_Perfect_Square_iter N (+ i 1)))\n            (else #f)))\n    (is_Perfect_Square_iter N 1))\n  (define (next_Perfect_Square_iter N i)\n    (cond ((is_Perfect_Square N) N)\n          ((&gt; N (* i i)) (next_Perfect_Square_iter N (+ i 1)))\n          (else (* i i))))\n  (next_Perfect_Square_iter N 1))\n</code>\n",
    "  (define (is_Perfect_Square N)\n    (define (is_Perfect_Square_iter N i)\n      (if (= N (* i i))\n          #t\n          (if (&lt; N (* i i))\n              #f\n              (is_Perfect_Square_iter N (+ i 1)))))\n    (is_Perfect_Square_iter N 1))\n  (define (next_Perfect_Square_iter N i)\n    (if (is_Perfect_Square N)\n        N\n        (if (is_Perfect_Square (+ N i))\n            (+ N i)\n            (next_Perfect_Square_iter N (+ i 1)))))\n  (next_Perfect_Square_iter N 1))\n</code>\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (= (sqr i) N)\n        (sqr (+ i 1))\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n</code>\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        (* i i)\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (= (sqr i) N)\n        (sqr (+ i 1))\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (let ([n (ceiling (sqrt N))])\n    (* n n)))\n",
    "  (let ([N (ceiling (sqrt N))])\n    (* N (add1 N))))\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (if (not (positive? N))\n          (error \"N must be positive\")\n          (let loop ((i 1))\n            (if (> (* i i) N)\n                i\n                (loop (+ i 1)))))))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        (* i i)\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (let ([n (ceiling (sqrt N))])\n    (* n n)))\n",
    "  (cond\n    [(= (sqrt N) (floor (sqrt N))) (sqrt N)]\n    [else (next_Perfect_Square (+ N 1))]))\n",
    "  (if (not (integer? N))\n      (error \"N is not an integer\")\n      (if (not (positive? N))\n          (error \"N is not positive\")\n          (let loop ((n N))\n            (if (not (integer? (sqrt n)))\n                (loop (+ n 1))\n                n)))))\n",
    "  (define (is_Perfect_Square N)\n    (define (is_Perfect_Square_iter N i)\n      (cond ((= i N) #t)\n            ((&gt; i N) #f)\n            (else (is_Perfect_Square_iter N (+ i 1)))))\n    (is_Perfect_Square_iter N 1))\n  (define (next_Perfect_Square_iter N i)\n    (cond ((is_Perfect_Square i) i)\n          (else (next_Perfect_Square_iter N (+ i 1)))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (cond\n    [(= (sqrt N) (floor (sqrt N)))\n     (+ 1 (sqrt N))]\n    [else\n     (next_Perfect_Square (+ 1 N))]))\n",
    "  (let ([n (ceiling (sqrt N))])\n    (* n (+ n 1))))\n",
    "  (define (helper N)\n    (if (= (sqrt N) (round (sqrt N)))\n        N\n        (helper (+ N 1))))\n  (helper N))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (= (sqr i) N)\n        (sqr (+ i 1))\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (let ((n (ceiling (sqrt N))))\n    (* n n)))\n",
    "  (cond\n    [(= N 0) 1]\n    [(= N 1) 4]\n    [else\n     (let* ([sqrt (sqrt N)]\n            [ceil (ceiling sqrt)])\n       (if (= sqrt ceil)\n           (next_Perfect_Square (+ N 1))\n           (* ceil ceil)))]))\n",
    "  (define (is_Perfect_Square N)\n    (define (is_Perfect_Square_helper N i)\n      (cond ((= N (* i i)) #t)\n            ((&gt; N (* i i)) (is_Perfect_Square_helper N (+ i 1)))\n            (else #f)))\n    (is_Perfect_Square_helper N 1))\n  (define (next_Perfect_Square_helper N)\n    (cond ((is_Perfect_Square N) N)\n          (else (next_Perfect_Square_helper (+ N 1)))))\n  (next_Perfect_Square_helper N))\n</code>\nI am not sure if this is the best way to do it, but it works.\n",
    "  (define (is_Perfect_Square N)\n    (define (is_Perfect_Square_iter N i)\n      (cond ((= i N) #t)\n            ((> i N) #f)\n            (else (is_Perfect_Square_iter N (+ i i)))))\n    (is_Perfect_Square_iter N 1))\n  (define (next_Perfect_Square_iter N i)\n    (cond ((is_Perfect_Square N) N)\n          ((is_Perfect_Square i) i)\n          (else (next_Perfect_Square_iter N (+ i 1)))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (is_Perfect_Square N)\n    (define (is_Perfect_Square_iter N i)\n      (if (= i N)\n          #t\n          (if (&gt; i N)\n              #f\n              (is_Perfect_Square_iter N (+ i 1)))))\n    (is_Perfect_Square_iter N 1))\n  (define (next_Perfect_Square_iter N i)\n    (if (is_Perfect_Square N)\n        N\n        (next_Perfect_Square_iter (+ N 1) (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (let ([n (ceiling (sqrt N))])\n    (* n n)))\n",
    "  (let loop ([N N])\n    (if (= (sqrt N) (floor (sqrt N)))\n        N\n        (loop (+ N 1)))))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (cond ((= (* i i) N) (+ i i))\n          ((&gt; (* i i) N) (* i i))\n          (else (next_Perfect_Square_iter N (+ i 1)))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (cond [(= (sqrt N) (floor (sqrt N))) (sqrt (+ N 1))]\n        [else (sqrt (+ N 1))]))\n",
    "  (define (next_Perfect_Square_iter N)\n    (if (= (sqr N) N)\n        N\n        (next_Perfect_Square_iter (+ N 1))))\n  (next_Perfect_Square_iter N))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (= (sqr i) N)\n        (+ i 1)\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (let* ([sqrt-N (sqrt N)]\n         [ceil-sqrt-N (ceiling sqrt-N)])\n    (* ceil-sqrt-N ceil-sqrt-N)))\n",
    "  (cond\n    [(= (sqrt N) (floor (sqrt N))) (+ 1 (sqrt N))]\n    [else (next_Perfect_Square (+ 1 N))]))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (is_Perfect_Square N)\n    (define (is_Perfect_Square_iter N i)\n      (cond ((= N (* i i)) #t)\n            ((&gt; N (* i i)) (is_Perfect_Square_iter N (+ i 1)))\n            (else #f)))\n    (is_Perfect_Square_iter N 1))\n  (define (next_Perfect_Square_iter N i)\n    (cond ((is_Perfect_Square N) N)\n          ((is_Perfect_Square (+ N i)) (+ N i))\n          (else (next_Perfect_Square_iter N (+ i 1)))))\n  (next_Perfect_Square_iter N 1))\n</code>\n",
    "  (cond\n    [(= (sqrt N) (floor (sqrt N))) (sqrt N)]\n    [else (next_Perfect_Square (+ N 1))]))\n",
    "  (let ([n (ceiling (/ N 2))])\n    (if (= (sqr n) N)\n        (sqr (+ n 1))\n        (sqr (+ n 2)))))\n",
    "  (let loop ([n N])\n    (if (= (sqr n) n)\n        n\n        (loop (+ n 1)))))\n",
    "  (define (is_Perfect_Square N)\n    (define (is_Perfect_Square_iter N i)\n      (cond ((= N (* i i)) #t)\n            ((&gt; N (* i i)) (is_Perfect_Square_iter N (+ i 1)))\n            (else #f)))\n    (is_Perfect_Square_iter N 1))\n  (define (next_Perfect_Square_iter N i)\n    (cond ((is_Perfect_Square N) N)\n          ((&gt; N (* i i)) (next_Perfect_Square_iter N (+ i 1)))\n          (else (* i i))))\n  (next_Perfect_Square_iter N 1))\n</code>\nI have a feeling that there is a better way to do this, but I can't think of it.\n\n\nA:\n\nI would do it like this:\n<code>(define (next-perfect-square n)\n  (define (is-perfect-square? n)\n    (exact-integer-sqrt n))\n  (define (next-perfect-square-iter n i)\n    (cond ((is-perfect-square? n) n)\n          ((&gt; n (* i i)) (next-perfect-square-iter n (+ i 1)))\n          (else (* i i))))\n  (next-perfect-square-iter n 1))\n</code>\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (if (not (integer? N))\n      (error \"N is not an integer\")\n      (if (not (positive? N))\n          (error \"N is not positive\")\n          (let loop ((i 1))\n            (if (&gt; (* i i) N)\n                i\n                (loop (+ i 1)))))))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        (* i i)\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (if (not (positive? N))\n          (error \"N must be positive\")\n          (let loop ((i 1))\n            (if (&gt; (* i i) N)\n                i\n                (loop (+ i 1)))))))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (cond\n    [(= (sqrt N) (floor (sqrt N))) (+ N 1)]\n    [else (next_Perfect_Square (+ N 1))]))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        (* i i)\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        (* i i)\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (let* ([sqrt (sqrt N)]\n         [ceil (ceiling sqrt)])\n    (* ceil ceil)))\n",
    "  (define (is_Perfect_Square N)\n    (define (is_Perfect_Square_iter N i)\n      (cond ((= N (* i i)) #t)\n            ((&gt; N (* i i)) (is_Perfect_Square_iter N (+ i 1)))\n            (else #f)))\n    (is_Perfect_Square_iter N 1))\n  (define (next_Perfect_Square_iter N i)\n    (cond ((is_Perfect_Square N) N)\n          ((is_Perfect_Square (+ N i)) (+ N i))\n          (else (next_Perfect_Square_iter N (+ i 1)))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (cond\n    [(= (sqrt N) (floor (sqrt N))) (sqrt N)]\n    [else (next_Perfect_Square (+ N 1))]))\n",
    "  (define (is_Perfect_Square N)\n    (define (is_Perfect_Square_iter N i)\n      (cond ((= N (* i i)) #t)\n            ((&gt; N (* i i)) (is_Perfect_Square_iter N (+ i 1)))\n            (else #f)))\n    (is_Perfect_Square_iter N 1))\n  (define (next_Perfect_Square_iter N i)\n    (cond ((is_Perfect_Square N) N)\n          ((&gt; N (* i i)) (next_Perfect_Square_iter N (+ i 1)))\n          (else (* i i))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (cond\n    [(= (sqrt N) (floor (sqrt N)))\n     (sqrt N)]\n    [else\n     (next_Perfect_Square (+ N 1))]))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (= N (* i i))\n        (* (+ i 1) (+ i 1))\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (is_Perfect_Square N)\n    (if (= (sqrt N) (floor (sqrt N)))\n        #t\n        #f))\n  (define (next_Perfect_Square_helper N)\n    (if (is_Perfect_Square N)\n        N\n        (next_Perfect_Square_helper (+ N 1))))\n  (next_Perfect_Square_helper N))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (let loop ([N N])\n    (cond [(= (sqrt N) (floor (sqrt N))) N]\n          [else (loop (+ N 1))])))\n",
    "  (define (is_Perfect_Square N)\n    (and (integer? (sqrt N))\n         (not (zero? (remainder N (sqrt N))))))\n  (define (next_Perfect_Square_iter N)\n    (if (is_Perfect_Square N)\n        N\n        (next_Perfect_Square_iter (+ N 1))))\n  (next_Perfect_Square_iter N))\n"
  ]
}