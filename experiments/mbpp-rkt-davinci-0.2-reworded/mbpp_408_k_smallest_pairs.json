{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to find k number of smallest pairs which consist of one element from the first list and one element from the second list.\n(define (k_smallest_pairs nums1 nums2 k)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "reworded",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate k_smallest_pairs))\n    (check-equal? (candidate (list 1 3 7) (list 2 4 6) 2) (list (list 1 2) (list 1 4)))\n    (check-equal? (candidate (list 1 3 7) (list 2 4 6) 1) (list (list 1 2)))\n    (check-equal? (candidate (list 1 3 7) (list 2 4 6) 7) (list (list 1 2) (list 1 4) (list 3 2) (list 1 6) (list 3 4) (list 3 6) (list 7 2)))\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (let loop ([nums1 nums1] [nums2 nums2] [k k] [result '()])\n    (cond [(empty? nums1) result]\n          [(empty? nums2) result]\n          [(zero? k) result]\n          [else\n           (let* ([a (car nums1)]\n                  [b (car nums2)]\n                  [c (car (cdr nums1))]\n                  [d (car (cdr nums2))]\n                  [sum1 (+ a b)]\n                  [sum2 (+ c d)])\n             (if (< sum1 sum2)\n                 (loop (cdr nums1) nums2 (- k 1) (cons (list a b) result))\n                 (loop nums1 (cdr nums2) (- k 1) (cons (list c d) result))))])))\n",
    "  (let ([pairs (for*/list ([n1 nums1] [n2 nums2]) (list n1 n2))])\n    (take k (sort pairs (\u03bb (p1 p2) (&lt; (apply + p1) (apply + p2)))))))\n",
    "  (define (helper nums1 nums2 k)\n    (cond\n      [(empty? nums1) empty]\n      [(empty? nums2) empty]\n      [(= k 0) empty]\n      [else\n       (let* ([n1 (first nums1)]\n              [n2 (first nums2)]\n              [rest1 (rest nums1)]\n              [rest2 (rest nums2)]\n              [rest-pairs (helper rest1 rest2 (- k 1))])\n         (cons (list n1 n2) rest-pairs))]))\n  (helper nums1 nums2 k))\n",
    "  (define (helper nums1 nums2 k acc)\n    (if (or (null? nums1) (null? nums2))\n        acc\n        (let* ([a (car nums1)]\n               [b (car nums2)]\n               [new-acc (cons (list a b) acc)])\n          (if (&gt; k (length new-acc))\n              (helper (cdr nums1) (cdr nums2) k new-acc)\n              (helper (cdr nums1) (cdr nums2) k (take k new-acc))))))\n  (helper nums1 nums2 k '()))\n",
    "  (define (helper nums1 nums2 k acc)\n    (if (or (null? nums1) (null? nums2) (zero? k))\n        acc\n        (let* ([min1 (apply min nums1)]\n               [min2 (apply min nums2)]\n               [nums1 (remove min1 nums1)]\n               [nums2 (remove min2 nums2)]\n               [acc (cons (list min1 min2) acc)])\n          (helper nums1 nums2 (- k 1) acc))))\n  (reverse (helper nums1 nums2 k '())))\n",
    "  (let loop ([nums1 nums1] [nums2 nums2] [k k] [acc '()])\n    (cond [(empty? nums1) acc]\n          [(empty? nums2) acc]\n          [(zero? k) acc]\n          [else\n           (let* ([n1 (car nums1)]\n                  [n2 (car nums2)]\n                  [n1-rest (cdr nums1)]\n                  [n2-rest (cdr nums2)]\n                  [n1-n2-pair (list n1 n2)]\n                  [n1-n2-sum (+ n1 n2)]\n                  [n1-n2-rest (loop n1-rest n2-rest (- k 1) acc)]\n                  [n1-n2-pair-rest (loop n1-rest n2-rest k (cons n1-n2-pair acc))]\n                  [n1-n2-sum-rest (loop n1-rest n2-rest k (cons n1-n2-sum acc))])\n             (cond [(empty? n1-n2-pair-rest) n1-n2-sum-rest]\n                   [(empty? n1-n2-sum-rest) n1-n2-pair-rest]\n                   [(< (car n1-n2-pair-rest) (car n1-n2-sum-rest)) n1-n2-pair-rest]\n                   [else n1-n2-sum-rest]))])))\n",
    "  (define (helper nums1 nums2 k acc)\n    (cond [(empty? nums1) acc]\n          [(empty? nums2) acc]\n          [(<= k 0) acc]\n          [else (helper (rest nums1) (rest nums2) k (cons (list (first nums1) (first nums2)) acc))]))\n  (reverse (helper nums1 nums2 k '())))\n",
    "  (define (helper nums1 nums2 k)\n    (cond [(empty? nums1) empty]\n          [(empty? nums2) empty]\n          [else (let ([first-pair (list (first nums1) (first nums2))])\n                  (append (list first-pair)\n                          (helper (rest nums1) (rest nums2) (sub1 k))))]))\n  (helper nums1 nums2 k))\n",
    "  (define (helper lst1 lst2 k acc)\n    (cond\n      [(empty? lst1) acc]\n      [(empty? lst2) acc]\n      [(<= k 0) acc]\n      [else\n       (let ([x (car lst1)]\n             [y (car lst2)]\n             [new-acc (cons (list x y) acc)])\n         (cond\n           [(< x y) (helper (cdr lst1) lst2 k new-acc)]\n           [(> x y) (helper lst1 (cdr lst2) k new-acc)]\n           [else (helper (cdr lst1) (cdr lst2) (- k 2) new-acc)]))]))\n  (reverse (helper nums1 nums2 k '())))\n",
    "  (define (helper nums1 nums2 k)\n    (if (or (null? nums1) (null? nums2))\n        '()\n        (let* ([first (car nums1)]\n               [second (car nums2)]\n               [rest (helper (cdr nums1) (cdr nums2) (- k 1))])\n          (if (or (null? rest)\n                  (and (not (null? rest))\n                       (< (+ first second) (+ (car (car rest)) (cadr (car rest))))))\n              (cons (list first second) rest)\n              (cons (car rest) (helper nums1 nums2 (- k 1)))))))\n  (helper nums1 nums2 k))\n",
    "  (define (k_smallest_pairs_helper nums1 nums2 k acc)\n    (cond\n      [(or (null? nums1) (null? nums2)) (reverse acc)]\n      [(= k 0) (reverse acc)]\n      [else\n       (let* ([n1 (car nums1)]\n              [n2 (car nums2)]\n              [sum (+ n1 n2)]\n              [rest-nums1 (cdr nums1)]\n              [rest-nums2 (cdr nums2)])\n         (cond\n           [(or (null? rest-nums1) (null? rest-nums2))\n            (k_smallest_pairs_helper rest-nums1 rest-nums2 (- k 1) (cons (list n1 n2) acc))]\n           [(< (+ n1 (car rest-nums1)) (+ n2 (car rest-nums2)))\n            (k_smallest_pairs_helper rest-nums1 nums2 (- k 1) (cons (list n1 n2) acc))]\n           [else\n            (k_smallest_pairs_helper nums1 rest-nums2 (- k 1) (cons (list n1 n2) acc))]))]))\n  (k_smallest_pairs_helper nums1 nums2 k '()))\n",
    "  (define (helper nums1 nums2 k acc)\n    (cond\n      [(empty? nums1) acc]\n      [(empty? nums2) acc]\n      [(<= k 0) acc]\n      [else\n       (define (add-pair n1 n2 acc)\n         (cons (list n1 n2) acc))\n       (define (add-pairs n1 n2s acc)\n         (foldl (\u03bb (n2 acc) (add-pair n1 n2 acc)) acc n2s))\n       (define (add-pairs-all n1s n2s acc)\n         (foldl (\u03bb (n1 acc) (add-pairs n1 n2s acc)) acc n1s))\n       (define (smallest-pairs n1s n2s k acc)\n         (cond\n           [(empty? n1s) acc]\n           [(empty? n2s) acc]\n           [(<= k 0) acc]\n           [else\n            (define (smallest-pair n1s n2s)\n              (define (smallest-pair-helper n1s n2s acc)\n                (cond\n                  [(empty? n1s) acc]\n                  [(empty? n2s) acc]\n                  [else\n                   (let* ([n1 (first n1s)]\n                          [n2 (first n2s)]\n                          [n1-n2 (list n1 n2)]\n                          [acc-n1-n2 (list (first acc) (second acc))])\n                     (cond\n                       [(< (first n1-n2) (first acc-n1-n2)) n1-n2]\n                       [(> (first n1-n2) (first acc-n1-n2)) acc-n1-n2]\n                       [(< (second n1-n2) (second acc-n1-n2)) n1-n2]\n                       [(> (second n1-n2) (second acc-n1-n2)) acc-n1-n2]\n                       [else acc-n1-n2]))]))\n                (smallest-pair-helper (rest n1",
    "  (define (helper nums1 nums2 k)\n    (cond [(empty? nums1) empty]\n          [(empty? nums2) empty]\n          [else\n           (let* ([a (first nums1)]\n                  [b (first nums2)]\n                  [c (first (rest nums2))]\n                  [d (first (rest nums1))])\n             (cond [(= k 0) empty]\n                   [(< a d) (cons (list a b) (helper (rest nums1) nums2 (- k 1)))]\n                   [(> a d) (cons (list d c) (helper nums1 (rest nums2) (- k 1)))]\n                   [(and (= a d) (< b c)) (cons (list a b) (helper (rest nums1) nums2 (- k 1)))]\n                   [(and (= a d) (> b c)) (cons (list d c) (helper nums1 (rest nums2) (- k 1)))]\n                   [else (cons (list a b) (helper (rest nums1) nums2 (- k 1)))]))]))\n  (helper nums1 nums2 k))\n",
    "  (define (helper nums1 nums2 k acc)\n    (cond\n      [(empty? nums1) acc]\n      [(empty? nums2) acc]\n      [(<= k 0) acc]\n      [else\n       (let ([n1 (first nums1)]\n             [n2 (first nums2)])\n         (helper (rest nums1)\n                 (if (< n1 n2)\n                     (rest nums2)\n                     nums2)\n                 (- k 1)\n                 (cons (list n1 n2) acc)))]))\n  (reverse (helper nums1 nums2 k '())))\n",
    "  (define (merge-sort lst)\n    (define (merge lst1 lst2)\n      (cond [(empty? lst1) lst2]\n            [(empty? lst2) lst1]\n            [(< (car lst1) (car lst2))\n             (cons (car lst1) (merge (cdr lst1) lst2))]\n            [else\n             (cons (car lst2) (merge lst1 (cdr lst2)))]))\n    (define (merge-sort-helper lst)\n      (cond [(empty? lst) empty]\n            [(empty? (cdr lst)) lst]\n            [else\n             (let* ([mid (quotient (length lst) 2)]\n                    [left (take lst mid)]\n                    [right (drop lst mid)])\n               (merge (merge-sort-helper left)\n                      (merge-sort-helper right)))]))\n    (merge-sort-helper lst))\n  (define (k_smallest_pairs-helper nums1 nums2 k)\n    (cond [(empty? nums1) empty]\n          [(empty? nums2) empty]\n          [(= k 0) empty]\n          [else\n           (let* ([pair (list (car nums1) (car nums2))]\n                  [rest (k_smallest_pairs-helper (cdr nums1) (cdr nums2) (- k 1))])\n             (cons pair rest))]))\n  (merge-sort (k_smallest_pairs-helper nums1 nums2 k)))\n",
    "  (define (helper nums1 nums2 k acc)\n    (cond [(empty? nums1) acc]\n          [(empty? nums2) acc]\n          [(zero? k) acc]\n          [else\n           (define (add-pair x y acc)\n             (cons (list x y) acc))\n           (define (add-pairs xs ys acc)\n             (foldl (lambda (x acc) (foldl (add-pair x) acc ys)) acc xs))\n           (define (add-pairs-with-limit xs ys k acc)\n             (if (zero? k)\n                 acc\n                 (add-pairs-with-limit (cdr xs) ys (- k 1) (add-pairs xs ys acc))))\n           (define (remove-pairs xs ys acc)\n             (foldl (lambda (x acc) (foldl (lambda (y acc) (remove (list x y) acc)) acc ys)) acc xs))\n           (define (remove-pairs-with-limit xs ys k acc)\n             (if (zero? k)\n                 acc\n                 (remove-pairs-with-limit (cdr xs) ys (- k 1) (remove-pairs xs ys acc))))\n           (define (remove-pairs-with-limit-and-add-pairs xs ys k acc)\n             (if (zero? k)\n                 acc\n                 (remove-pairs-with-limit-and-add-pairs (cdr xs) ys (- k 1) (add-pairs xs ys (remove-pairs xs ys acc)))))\n           (define (remove-pairs-with-limit-and-add-pairs-with-limit xs ys k acc)\n             (if (zero? k)\n                 acc\n                 (remove-pairs-with-limit-and-add-pairs-with-limit (cdr xs) ys (- k 1) (add-pairs-with-limit xs ys k (remove-pairs xs ys acc)))))\n           (define (remove-pairs-with-limit-and-",
    "  (define (merge-sort lst)\n    (define (merge lst1 lst2)\n      (cond [(empty? lst1) lst2]\n            [(empty? lst2) lst1]\n            [(< (car lst1) (car lst2)) (cons (car lst1) (merge (cdr lst1) lst2))]\n            [else (cons (car lst2) (merge lst1 (cdr lst2)))]))\n    (define (split lst)\n      (if (empty? lst)\n          (values empty empty)\n          (let* ([mid (quotient (length lst) 2)]\n                 [lst1 (take lst mid)]\n                 [lst2 (drop lst mid)])\n            (values lst1 lst2))))\n    (define (merge-sort-helper lst)\n      (if (empty? lst)\n          empty\n          (let* ([lst1 (merge-sort-helper (first (split lst)))]\n                 [lst2 (merge-sort-helper (second (split lst)))])\n            (merge lst1 lst2))))\n    (merge-sort-helper lst))\n  (define (pairs lst1 lst2)\n    (if (empty? lst1)\n        empty\n        (append (map (lambda (x) (list (car lst1) x)) lst2)\n                (pairs (cdr lst1) lst2))))\n  (take (merge-sort (pairs nums1 nums2)) k))\n",
    "  (define (merge-sort lst)\n    (define (merge lst1 lst2)\n      (cond\n        [(empty? lst1) lst2]\n        [(empty? lst2) lst1]\n        [(< (car lst1) (car lst2)) (cons (car lst1) (merge (cdr lst1) lst2))]\n        [else (cons (car lst2) (merge lst1 (cdr lst2)))]))\n    (define (split lst)\n      (if (empty? lst)\n          (values empty empty)\n          (let ([mid (quotient (length lst) 2)])\n            (values (take lst mid) (drop lst mid)))))\n    (define (merge-sort-helper lst)\n      (if (empty? lst)\n          empty\n          (let-values ([(lst1 lst2) (split lst)])\n            (merge (merge-sort-helper lst1) (merge-sort-helper lst2)))))\n    (merge-sort-helper lst))\n  (define (k_smallest_pairs_helper nums1 nums2 k)\n    (if (zero? k)\n        empty\n        (let ([n1 (car nums1)]\n              [n2 (car nums2)])\n          (cons (list n1 n2) (k_smallest_pairs_helper (cdr nums1) (cdr nums2) (- k 1))))))\n  (define (k_smallest_pairs_helper2 nums1 nums2 k)\n    (if (zero? k)\n        empty\n        (let ([n1 (car nums1)]\n              [n2 (car nums2)])\n          (cons (list n1 n2) (k_smallest_pairs_helper2 (cdr nums1) (cdr nums2) (- k 1))))))\n  (define (k_smallest_pairs_helper3 nums1 nums2 k)\n    (if (zero? k)",
    "  (define (k_smallest_pairs_helper nums1 nums2 k result)\n    (if (or (zero? k) (null? nums1) (null? nums2))\n        result\n        (let* ([first (car nums1)]\n               [second (car nums2)]\n               [new-result (cons (list first second) result)])\n          (cond [(< first second) (k_smallest_pairs_helper (cdr nums1) nums2 (- k 1) new-result)]\n                [(> first second) (k_smallest_pairs_helper nums1 (cdr nums2) (- k 1) new-result)]\n                [else (k_smallest_pairs_helper nums1 (cdr nums2) (- k 1) (k_smallest_pairs_helper (cdr nums1) nums2 (- k 1) new-result))]))))\n  (k_smallest_pairs_helper nums1 nums2 k '()))\n",
    "  (define (helper nums1 nums2 k result)\n    (cond [(empty? nums1) result]\n          [(empty? nums2) result]\n          [(= k 0) result]\n          [else\n           (define min-pair (list (car nums1) (car nums2)))\n           (define new-result (append result (list min-pair)))\n           (define new-nums1 (cdr nums1))\n           (define new-nums2 (cdr nums2))\n           (helper new-nums1 new-nums2 (- k 1) new-result)]))\n  (helper nums1 nums2 k '()))\n"
  ]
}