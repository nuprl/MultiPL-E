{
  "name": "mbpp_92_is_undulating",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to check whether the given number is undulating or not.\n(define (is_undulating n)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_92_is_undulating.py",
  "prompt_terminology": "reworded",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_undulating))\n    (check-equal? (candidate 1212121) #t)\n    (check-equal? (candidate 1991) #f)\n    (check-equal? (candidate 121) #t)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (is_undulating-iter n)\n    (if (zero? n)\n        #t\n        (let* ([d1 (modulo n 10)]\n               [n (quotient n 10)]\n               [d2 (modulo n 10)])\n          (if (and (not (zero? d1))\n                   (not (zero? d2))\n                   (or (= (abs (- d1 d2)) 1)\n                       (= (abs (- d1 d2)) 9)))\n              (is_undulating-iter (quotient n 10))\n              #f))))\n  (is_undulating-iter n))\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond\n      [(= n1 n2) (is-undulating-iter n2 n3 (remainder n3 10))]\n      [(= n2 n3) (is-undulating-iter n1 n2 (remainder n3 10))]\n      [(= n1 n3) (is-undulating-iter n1 n2 (remainder n3 10))]\n      [else #f]))\n  (is-undulating-iter (quotient n 100) (quotient n 10) (remainder n 10)))\n",
    "  (let loop ((n n) (prev-digit 0) (prev-diff 0) (undulating? #t))\n    (if (zero? n)\n        undulating?\n        (let* ((curr-digit (modulo n 10))\n               (curr-diff (- curr-digit prev-digit)))\n          (if (and (not (zero? prev-digit))\n                   (not (zero? prev-diff))\n                   (not (= curr-diff (* -1 prev-diff))))\n              (loop (quotient n 10) curr-digit curr-diff #f)\n              (loop (quotient n 10) curr-digit curr-diff undulating?))))))\n",
    "  (define (is_undulating-helper n)\n    (if (&lt; n 10)\n        #t\n        (let* ([d1 (modulo n 10)]\n               [d2 (modulo (quotient n 10) 10)])\n          (if (or (= d1 d2) (= (abs (- d1 d2)) 2))\n              (is_undulating-helper (quotient n 10))\n              #f))))\n  (is_undulating-helper n))\n",
    "  (let loop ((n (number->string n))\n             (prev-digit #\\0)\n             (prev-prev-digit #\\0)\n             (is-undulating #t))\n    (cond ((null? n) is-undulating)\n          ((and (char=? (car n) prev-digit)\n                (char=? (car n) prev-prev-digit))\n           (loop (cdr n) prev-digit prev-prev-digit #f))\n          ((char=? (car n) prev-digit)\n           (loop (cdr n) (car n) prev-digit #f))\n          (else (loop (cdr n) (car n) prev-digit is-undulating)))))\n",
    "  (let loop ((n n) (prev 0) (curr 0) (next 0) (count 0))\n    (cond ((zero? n) (= count 3))\n          ((= count 3) #t)\n          ((and (= prev curr) (= curr next))\n           (loop (quotient n 10) prev curr next (+ count 1)))\n          ((and (= prev curr) (< curr next))\n           (loop (quotient n 10) prev curr next (+ count 1)))\n          ((and (= prev curr) (> curr next))\n           (loop (quotient n 10) prev curr next (+ count 1)))\n          ((and (< prev curr) (= curr next))\n           (loop (quotient n 10) prev curr next (+ count 1)))\n          ((and (> prev curr) (= curr next))\n           (loop (quotient n 10) prev curr next (+ count 1)))\n          ((and (< prev curr) (< curr next))\n           (loop (quotient n 10) curr next (modulo n 10) (+ count 1)))\n          ((and (< prev curr) (> curr next))\n           (loop (quotient n 10) curr next (modulo n 10) (+ count 1)))\n          ((and (> prev curr) (< curr next))\n           (loop (quotient n 10) curr next (modulo n 10) (+ count 1)))\n          ((and (> prev curr) (> curr next))\n           (loop (quotient n 10) curr next (modulo n 10) (+ count 1)))\n          (else #f))))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (if (&lt; n 10)\n        #t\n        (let* ([cur-digit (modulo n 10)]\n               [cur-diff (- cur-digit prev-digit)])\n          (if (and (not (= cur-diff 0))\n                   (or (= cur-diff prev-diff)\n                       (= (- cur-diff) prev-diff)))\n              (is-undulating-iter (quotient n 10) cur-digit cur-diff)\n              #f))))\n  (is-undulating-iter n 0 0))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond\n      [(zero? n) #t]\n      [(and (zero? prev-diff)\n            (= (modulo n 10) prev-digit))\n       (is_undulating-iter (quotient n 10) prev-digit prev-diff)]\n      [(= (modulo n 10) (- prev-digit prev-diff))\n       (is_undulating-iter (quotient n 10) prev-digit (- prev-digit prev-diff))]\n      [else #f]))\n  (is_undulating-iter n (modulo n 10) 0))\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond ((= n1 n2) (is-undulating-iter n2 n3 (+ n3 1)))\n          ((= n2 n3) (is-undulating-iter n1 n2 (+ n3 1)))\n          ((= n1 n3) #f)\n          ((&gt; n3 n) #t)\n          (else (is-undulating-iter n2 n3 (+ n3 1)))))\n  (is-undulating-iter 1 2 3))\n</code>\n",
    "  (define (is_undulating-helper n)\n    (if (= n 0)\n        #f\n        (let* ([d1 (modulo n 10)]\n               [n (quotient n 10)]\n               [d2 (modulo n 10)])\n          (if (= d1 d2)\n              (is_undulating-helper (quotient n 10))\n              (if (and (= d1 (+ d2 1))\n                       (= d2 (+ d1 1)))\n                  (is_undulating-helper (quotient n 10))\n                  #f)))))\n  (is_undulating-helper n))\n",
    "  (let loop ((n (number->string n))\n             (prev-digit #\\0)\n             (prev-prev-digit #\\0))\n    (cond ((null? n) #t)\n          ((and (char=? (car n) prev-digit)\n                (char=? (car n) prev-prev-digit))\n           #f)\n          (else (loop (cdr n) (car n) prev-digit)))))\n",
    "  (define (is-undulating-helper n)\n    (cond\n      [(zero? n) #t]\n      [(< n 10) #f]\n      [(= (modulo (quotient n 10) 10) (- (modulo n 10))) (is-undulating-helper (quotient n 10))]\n      [else #f]))\n  (is-undulating-helper n))\n",
    "  (let loop ([n (number->string n)]\n             [prev (string-&gt;number (string-ref n 0))]\n             [i 1])\n    (cond [(empty? n) #t]\n          [(= i (string-length n)) #f]\n          [(= (string-&gt;number (string-ref n i)) prev) #f]\n          [else (loop (substring n 1)\n                      (string-&gt;number (string-ref n i))\n                      (+ i 1))])))\n",
    "  (define (is_undulating-helper n)\n    (cond\n      [(zero? n) #t]\n      [(zero? (remainder n 10)) #f]\n      [else (is-undulating-helper (quotient n 10))]))\n  (define (is-undulating-helper2 n)\n    (cond\n      [(zero? n) #t]\n      [(zero? (remainder n 10)) #f]\n      [else (is-undulating-helper2 (quotient n 10))]))\n  (and (is-undulating-helper n) (is-undulating-helper2 n)))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond [(zero? n) #t]\n          [(= (modulo n 10) prev-digit) #f]\n          [(= (modulo n 10) (- prev-digit prev-diff))\n           (is-undulating-iter (quotient n 10) (modulo n 10) (- prev-digit (modulo n 10)))]\n          [else (is-undulating-iter (quotient n 10) (modulo n 10) (- (modulo n 10) prev-digit))]))\n  (is-undulating-iter n -1 0))\n",
    "  (define (is_undulating-iter n)\n    (cond\n      [(zero? n) #t]\n      [(= (modulo n 10) (modulo (quotient n 10) 10)) (is_undulating-iter (quotient n 10))]\n      [else #f]))\n  (is_undulating-iter n))\n",
    "  (let loop ([n n] [prev-digit -1] [is-increasing? #t])\n    (cond [(zero? n) is-increasing?]\n          [(= prev-digit (remainder n 10))\n           (loop (quotient n 10) prev-digit is-increasing?)]\n          [(= prev-digit (- (remainder n 10)))\n           (loop (quotient n 10) prev-digit (not is-increasing?))]\n          [(= prev-digit (remainder n 10))\n           (loop (quotient n 10) prev-digit is-increasing?)]\n          [else #f])))\n",
    "  (let loop ([n n] [prev-digit -1] [prev-prev-digit -1])\n    (cond [(zero? n) #t]\n          [(= prev-digit (- (remainder n 10) (remainder (quotient n 10) 10)))\n           (loop (quotient n 10) prev-digit (- (remainder n 10) (remainder (quotient n 10) 10)))]\n          [else #f])))\n",
    "  (let loop ((n (number->string n))\n             (prev-digit (string->number (string-ref n 0)))\n             (i 1))\n    (cond ((= i (string-length n)) #t)\n          ((= (string->number (string-ref n i)) prev-digit) #f)\n          (else (loop n (string->number (string-ref n i)) (+ i 1))))))\n",
    "  (let loop ([n (number->string n)]\n             [prev-digit (string->number (substring n 0 1))]\n             [undulating? #t])\n    (if (empty? n)\n        undulating?\n        (let* ([curr-digit (string->number (substring n 0 1))]\n               [next-digit (string->number (substring n 1 1))])\n          (if (and (not (= prev-digit curr-digit))\n                   (not (= curr-digit next-digit)))\n              (loop (substring n 1) curr-digit undulating?)\n              #f)))))\n",
    "  (let loop ([n (number->string n)]\n             [prev (string-&gt;number (substring n 0 1))]\n             [i 1])\n    (cond\n      [(empty? n) #t]\n      [(= i (string-length n)) #t]\n      [(= (string-&gt;number (substring n i 1)) prev) #f]\n      [else (loop (substring n i) (string-&gt;number (substring n i 1)) (+ i 1))])))\n",
    "  (let loop ([n (number->string n)]\n             [prev (string-&gt;number (string-ref n 0))]\n             [i 1])\n    (cond [(zero? (modulo (string-length n) 2)) #f]\n          [(&gt; i (string-length n)) #t]\n          [(= prev (string-&gt;number (string-ref n i))) #f]\n          [else (loop (substring n 1)\n                      (string-&gt;number (string-ref n 1))\n                      (+ i 1))])))\n",
    "  (let loop ([n n] [prev-digit -1] [is-increasing? #t])\n    (cond [(zero? n) is-increasing?]\n          [(= prev-digit (remainder n 10)) #f]\n          [else (loop (quotient n 10) (remainder n 10)\n                      (if is-increasing?\n                          (< prev-digit (remainder n 10))\n                          (> prev-digit (remainder n 10))))])))\n",
    "  (define (is_undulating-iter n lst)\n    (cond\n      [(empty? lst) #f]\n      [(= (first lst) n) #t]\n      [else (is-undulating-iter n (rest lst))]))\n  (is_undulating-iter n (list (quotient n 10) (remainder n 10))))\n",
    "  (let loop ([n n] [prev-digit -1] [is-increasing? #t])\n    (cond [(zero? n) #t]\n          [(= prev-digit (remainder n 10)) #f]\n          [(= prev-digit (- (remainder n 10) 1)) (loop (quotient n 10) (remainder n 10) #f)]\n          [(= prev-digit (+ (remainder n 10) 1)) (loop (quotient n 10) (remainder n 10) #t)]\n          [else (loop (quotient n 10) (remainder n 10) is-increasing?)])))\n",
    "  (define (is_undulating-iter n)\n    (cond\n      [(zero? n) #t]\n      [(= (remainder n 10) (remainder (quotient n 10) 10))\n       (is_undulating-iter (quotient n 10))]\n      [else #f]))\n  (is_undulating-iter n))\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond\n      [(= n3 0) #f]\n      [(= n1 n2) (is-undulating-iter n2 n3 (remainder n3 10))]\n      [else (is-undulating-iter n2 n3 (remainder n3 10))]))\n  (is-undulating-iter (remainder n 10) (remainder (quotient n 10) 10) (quotient n 10)))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond\n      [(zero? n) #t]\n      [(= prev-digit (remainder n 10)) #f]\n      [(= prev-diff (- (remainder n 10) prev-digit)) #f]\n      [else (is-undulating-iter (quotient n 10) (remainder n 10) (- (remainder n 10) prev-digit))]))\n  (is-undulating-iter n 0 0))\n",
    "  (define (is_undulating-iter n d)\n    (cond ((= n 0) #t)\n          ((= (remainder n 10) (+ d (remainder (quotient n 10) 10)))\n           (is_undulating-iter (quotient n 10) d))\n          (else #f)))\n  (is_undulating-iter n (+ (remainder n 10) 1)))\n",
    "  (define (is_undulating-iter n last-digit)\n    (cond ((zero? n) #t)\n          ((= last-digit (remainder n 10)) #f)\n          (else (is-undulating-iter (quotient n 10) (remainder n 10)))))\n  (is-undulating-iter n (remainder n 10)))\n",
    "  (define (is_undulating-iter n prev-diff)\n    (cond\n      [(zero? n) #t]\n      [(= (modulo n 10) (modulo (quotient n 10) 10)) #f]\n      [else (is_undulating-iter (quotient n 10) (- (modulo n 10) (modulo (quotient n 10) 10)))]))\n  (is_undulating-iter n 0))\n",
    "  (let loop ([n (number->string n)]\n             [prev-digit #\\0]\n             [prev-prev-digit #\\0]\n             [undulating? #t])\n    (cond [(empty? n) undulating?]\n          [(and (= (string-ref n 0) prev-digit)\n                (= (string-ref n 0) prev-prev-digit))\n           (loop (rest n) prev-digit prev-prev-digit #f)]\n          [(and (= (string-ref n 0) prev-digit)\n                (not (= (string-ref n 0) prev-prev-digit)))\n           (loop (rest n) (string-ref n 0) prev-digit undulating?)]\n          [else (loop (rest n) (string-ref n 0) prev-digit undulating?)])))\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond\n      [(= n3 0) #f]\n      [(= (modulo n3 10) n1) (is_undulating-iter n2 n3 (quotient n3 10))]\n      [(= (modulo n3 10) n2) (is_undulating-iter n1 n3 (quotient n3 10))]\n      [else #f]))\n  (is_undulating-iter (modulo n 10) (quotient n 10) (quotient n 100)))\n",
    "  (define (is_undulating-helper n)\n    (if (&lt; n 10)\n        #t\n        (let* ([d1 (modulo n 10)]\n               [d2 (modulo (quotient n 10) 10)])\n          (if (or (= d1 d2)\n                  (= (abs (- d1 d2)) 2))\n              (is_undulating-helper (quotient n 10))\n              #f))))\n  (is_undulating-helper n))\n",
    "  (define (is_undulating-iter n)\n    (if (zero? n)\n        #t\n        (let* ([d1 (modulo n 10)]\n               [d2 (modulo (quotient n 10) 10)])\n          (if (or (= d1 d2) (= (abs (- d1 d2)) 2))\n              (is_undulating-iter (quotient n 10))\n              #f))))\n  (is_undulating-iter n))\n",
    "  (let loop ([n (number->string n)]\n             [prev (string-&gt;number (string-ref n 0))]\n             [i 1])\n    (cond\n      [(= i (string-length n)) #t]\n      [(= (modulo i 2) 0)\n       (let ([curr (string-&gt;number (string-ref n i))])\n         (cond\n           [(= prev curr) #f]\n           [else (loop n curr (+ i 1))]))]\n      [else (loop n prev (+ i 1))])))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond [(zero? n) #t]\n          [(zero? (remainder n 10)) #f]\n          [(= prev-diff (abs (- (remainder n 10) prev-digit)))\n           (is-undulating-iter (quotient n 10) (remainder n 10) prev-diff)]\n          [else #f]))\n  (is-undulating-iter n (remainder n 10) 0))\n",
    "  (let loop ([n (number->string n)]\n             [prev (string-&gt;number (string-ref n 0))]\n             [i 1])\n    (cond [(empty? n) #t]\n          [(= i (string-length n)) #t]\n          [(= (string-&gt;number (string-ref n i)) prev) #f]\n          [else (loop (substring n 1)\n                      (string-&gt;number (string-ref n i))\n                      (+ i 1))])))\n",
    "  (if (or (zero? n) (negative? n))\n      #f\n      (let loop ([n n] [prev-digit -1] [prev-prev-digit -1])\n        (if (zero? n)\n            #t\n            (let ([curr-digit (modulo n 10)])\n              (if (and (= (abs (- prev-digit curr-digit)) 1)\n                       (= (abs (- prev-prev-digit curr-digit)) 1))\n                  (loop (quotient n 10) curr-digit prev-digit)\n                  #f))))))\n",
    "  (let loop ([n n] [prev-digit 0] [prev-diff 0])\n    (cond\n      [(zero? n) #t]\n      [(zero? (remainder n 10)) (loop (quotient n 10) prev-digit prev-diff)]\n      [(= prev-diff (abs (- (remainder n 10) prev-digit)))\n       (loop (quotient n 10) (remainder n 10) prev-diff)]\n      [else #f])))\n",
    "  (let loop ((n n) (prev-d -1) (prev-prev-d -1))\n    (cond ((zero? n) #t)\n          ((= (modulo n 10) prev-d) #f)\n          ((= (modulo n 10) prev-prev-d) #f)\n          (else (loop (quotient n 10) (modulo n 10) prev-d)))))\n",
    "  (let loop ((n n) (prev #f) (prev-prev #f))\n    (cond ((zero? n) #t)\n          ((or (not prev) (not prev-prev))\n           (loop (quotient n 10) (remainder n 10) prev))\n          ((= (abs (- prev prev-prev)) 1)\n           (loop (quotient n 10) (remainder n 10) prev))\n          (else #f))))\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond\n      [(zero? n1) #t]\n      [(and (= n1 n2) (= n2 n3)) (is-undulating-iter (quotient n1 10) (quotient n2 10) (quotient n3 10))]\n      [else #f]))\n  (is-undulating-iter n (quotient n 10) (quotient n 100)))\n",
    "  (define (is_undulating-helper n)\n    (if (< n 10)\n        #f\n        (let* ([first-digit (quotient n 10)]\n               [second-digit (remainder n 10)]\n               [next-n (quotient (- n (* first-digit 10)) 10)])\n          (if (and (= (abs (- first-digit second-digit)) 1)\n                   (is_undulating-helper next-n))\n              #t\n              #f))))\n  (is_undulating-helper n))\n",
    "  (let loop ([n n] [prev-digit -1] [prev-prev-digit -1] [is-undulating #t])\n    (cond [(zero? n) is-undulating]\n          [(= prev-digit prev-prev-digit) (loop (quotient n 10) (remainder n 10) prev-digit #f)]\n          [(= prev-digit (- prev-prev-digit 1)) (loop (quotient n 10) (remainder n 10) prev-digit is-undulating)]\n          [(= prev-digit (+ prev-prev-digit 1)) (loop (quotient n 10) (remainder n 10) prev-digit is-undulating)]\n          [else (loop (quotient n 10) (remainder n 10) prev-digit #f)])))\n",
    "  (define (is_undulating-helper n)\n    (cond\n      [(zero? n) #t]\n      [(zero? (remainder n 10)) #f]\n      [else (is-undulating-helper (quotient n 10))]))\n  (is-undulating-helper n))\n",
    "  (let loop ([n (number->string n)]\n             [prev (string-&gt;number (string-&gt;list (string-&gt;number n)))])\n    (cond [(empty? n) true]\n          [(= (string-&gt;number (string-&gt;list (string-&gt;number (car n)))) prev)\n           (loop (cdr n) (car n))]\n          [else false])))\n</code>\n",
    "  (define (is_undulating-iter n prev-digit cur-digit)\n    (cond\n      [(zero? n) #t]\n      [(= prev-digit cur-digit) #f]\n      [else (is-undulating-iter (quotient n 10) cur-digit (modulo n 10))]))\n  (is-undulating-iter n 0 (modulo n 10)))\n",
    "  (let loop ([n n] [prev-digit -1] [is-ascending #t])\n    (cond [(zero? n) #t]\n          [(= prev-digit (remainder n 10)) #f]\n          [else (loop (quotient n 10)\n                      (remainder n 10)\n                      (if is-ascending\n                          (> prev-digit (remainder n 10))\n                          (< prev-digit (remainder n 10))))])))\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond\n      [(zero? n1) #t]\n      [(and (equal? n1 n2) (equal? n2 n3)) #f]\n      [(and (not (equal? n1 n2)) (not (equal? n2 n3))) #f]\n      [else (is-undulating-iter (quotient n1 10) (quotient n2 10) (quotient n3 10))]))\n  (is-undulating-iter n (quotient n 10) (quotient n 100)))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond\n      [(zero? n) #t]\n      [(= prev-digit (- (remainder n 10) prev-diff))\n       (is_undulating-iter (quotient n 10) (- (remainder n 10) prev-diff) prev-diff)]\n      [else #f]))\n  (is_undulating-iter n (- (remainder n 10) (remainder (quotient n 10) 10)) (- (remainder n 10) (remainder (quotient n 10) 10))))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond\n      [(zero? n) #t]\n      [(and (zero? (modulo n 10)) (zero? prev-diff))\n       (is-undulating-iter (quotient n 10) (modulo n 10) prev-diff)]\n      [(= (modulo n 10) prev-digit)\n       (is-undulating-iter (quotient n 10) (modulo n 10) prev-diff)]\n      [(= (abs (- (modulo n 10) prev-digit)) prev-diff)\n       (is-undulating-iter (quotient n 10) (modulo n 10) (abs (- (modulo n 10) prev-digit)))]\n      [else #f]))\n  (is-undulating-iter n 0 0))\n",
    "  (define (is_undulating-iter n i)\n    (cond\n      [(= i 1) #t]\n      [(= (modulo n 10) (- (modulo (quotient n 10) 10)))\n       (is-undulating-iter (quotient n 10) (- i 1))]\n      [else #f]))\n  (is-undulating-iter n (number->string n)))\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond ((and (zero? n1) (zero? n2) (zero? n3)) #t)\n          ((and (zero? n1) (zero? n2)) #f)\n          ((and (zero? n1) (zero? n3)) #f)\n          ((and (zero? n2) (zero? n3)) #f)\n          ((and (= n1 n2) (= n2 n3)) #f)\n          ((and (= (- n1 n2) (- n2 n3)) (= (- n1 n2) 1)) #t)\n          ((and (= (- n1 n2) (- n2 n3)) (= (- n1 n2) -1)) #t)\n          (else #f)))\n  (is_undulating-iter (modulo n 10) (modulo (quotient n 10) 10) (modulo (quotient n 100) 10)))\n",
    "  (let loop ([n (number->string n)]\n             [prev #f]\n             [curr (string-&gt;number (string-ref n 0))]\n             [next (string-&gt;number (string-ref n 1))])\n    (cond\n      [(empty? n) #t]\n      [(and (not prev) (not next)) (loop (rest n) curr next (string-&gt;number (string-ref n 2)))]\n      [(and (not prev) (not (= curr next))) (loop (rest n) curr next (string-&gt;number (string-ref n 2)))]\n      [(and (not prev) (= curr next)) #f]\n      [(and prev (not next)) (loop (rest n) curr next (string-&gt;number (string-ref n 2)))]\n      [(and prev (= curr next)) #f]\n      [(and prev (not (= curr next))) (loop (rest n) curr next (string-&gt;number (string-ref n 2)))]\n      [(and prev (= curr next) (= curr next)) #f]\n      [(and prev (= curr next) (not (= curr next))) (loop (rest n) curr next (string-&gt;number (string-ref n 2)))])))\n",
    "  (define (is_undulating-helper n)\n    (cond\n      [(= n 0) #f]\n      [(= n 1) #t]\n      [(= n 2) #f]\n      [(= n 3) #t]\n      [(= n 4) #f]\n      [(= n 5) #t]\n      [(= n 6) #f]\n      [(= n 7) #t]\n      [(= n 8) #f]\n      [(= n 9) #t]\n      [else (is_undulating-helper (quotient n 10))]))\n  (is_undulating-helper n))\n",
    "  (define (is_undulating-iter n s)\n    (cond\n      [(= n 0) #t]\n      [(= (modulo n 10) (modulo (quotient n 10) 10)) #f]\n      [else (is_undulating-iter (quotient n 10) s)]))\n  (is_undulating-iter n 0))\n",
    "  (define (is-undulating-iter n i)\n    (cond\n      [(= i 1) #t]\n      [(= (modulo n 10) (modulo (quotient n 10) 10)) (is-undulating-iter (quotient n 10) (- i 1))]\n      [else #f]))\n  (is-undulating-iter n (length (number->string n))))\n",
    "  (let loop ([n n] [prev 0] [curr 0] [next 0] [count 0])\n    (cond [(zero? n) (zero? count)]\n          [(zero? count) (loop (quotient n 10) 0 (modulo n 10) (quotient n 10) 1)]\n          [(= prev curr) (loop (quotient n 10) curr (modulo n 10) (quotient n 10) count)]\n          [(= curr next) (loop (quotient n 10) curr (modulo n 10) (quotient n 10) count)]\n          [(= prev next) (loop (quotient n 10) curr (modulo n 10) (quotient n 10) (+ count 1))]\n          [else #f])))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (if (= n 0)\n        #t\n        (let* ((curr-digit (modulo n 10))\n               (curr-diff (- curr-digit prev-digit)))\n          (if (and (= prev-diff (- curr-diff))\n                   (= curr-diff (abs prev-diff)))\n              (is-undulating-iter (quotient n 10) curr-digit curr-diff)\n              #f))))\n  (is-undulating-iter n 0 0))\n",
    "  (let loop ([n (number->string n)]\n             [prev-digit #\\0]\n             [prev-prev-digit #\\0])\n    (cond [(empty? n) #t]\n          [(and (char=? (first n) prev-digit)\n                (char=? (first n) prev-prev-digit))\n           (loop (rest n) (first n) prev-digit)]\n          [(char=? (first n) prev-digit)\n           (loop (rest n) (first n) prev-digit)]\n          [(char=? (first n) prev-prev-digit)\n           (loop (rest n) prev-digit (first n))]\n          [else (loop (rest n) (first n) prev-digit)])))\n",
    "  (let loop ([n n] [prev-digit -1] [is-undulating #t])\n    (cond [(zero? n) is-undulating]\n          [(= prev-digit (- (modulo n 10) 1)) (loop (quotient n 10) (- (modulo n 10) 1) #f)]\n          [(= prev-digit (+ (modulo n 10) 1)) (loop (quotient n 10) (+ (modulo n 10) 1) #f)]\n          [else (loop (quotient n 10) (modulo n 10) is-undulating)])))\n",
    "  (define (undulating? n)\n    (define (undulating-helper n)\n      (if (< n 10)\n          #t\n          (let* ([d1 (modulo n 10)]\n                 [d2 (modulo (quotient n 10) 10)])\n            (or (and (= d1 d2) (undulating-helper (quotient n 10)))\n                (and (= (abs (- d1 d2)) 1) (undulating-helper (quotient n 10)))))))\n    (undulating-helper n))\n  (undulating? n))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond\n      [(zero? n) #t]\n      [(= (modulo n 10) prev-digit) #f]\n      [(= (modulo n 10) (- prev-digit prev-diff)) (is-undulating-iter (quotient n 10) (- prev-digit prev-diff) (- prev-diff))]\n      [else (is-undulating-iter (quotient n 10) (modulo n 10) (- (modulo n 10) prev-digit))]))\n  (is-undulating-iter n (- n (modulo n 10)) (- (modulo n 10) (- n (modulo n 10)))))\n",
    "  (define (undulating? n)\n    (let loop ([n (number->string n)] [prev #\\0] [next #\\0])\n      (cond [(empty? n) #t]\n            [(= (string-length n) 1) #t]\n            [(= (string-length n) 2)\n             (and (= (string-ref n 0) (string-ref n 1))\n                  (= (string-ref n 0) prev))]\n            [else\n             (let ([curr (string-ref n 0)])\n               (and (= curr prev)\n                    (= curr next)\n                    (loop (substring n 1) curr (string-ref n 1))))])))\n  (undulating? n))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond\n      [(zero? n) #t]\n      [(and (zero? prev-diff)\n            (zero? (modulo n 10)))\n       (is_undulating-iter (quotient n 10) prev-digit prev-diff)]\n      [(and (zero? prev-diff)\n            (not (zero? (modulo n 10))))\n       (is_undulating-iter (quotient n 10) (modulo n 10) prev-diff)]\n      [(and (not (zero? prev-diff))\n            (zero? (modulo n 10)))\n       (is_undulating-iter (quotient n 10) prev-digit prev-diff)]\n      [(and (not (zero? prev-diff))\n            (not (zero? (modulo n 10))))\n       (let ((curr-digit (modulo n 10)))\n         (if (= (abs (- curr-digit prev-digit)) prev-diff)\n             (is_undulating-iter (quotient n 10) curr-digit prev-diff)\n             #f))]))\n  (is_undulating-iter n -1 0))\n",
    "  (define (is_undulating-iter n prev-diff)\n    (cond\n      [(= n 0) #t]\n      [(= n 1) #t]\n      [(= n 2) #t]\n      [(= n 3) #t]\n      [(= n 4) #t]\n      [(= n 5) #t]\n      [(= n 6) #t]\n      [(= n 7) #t]\n      [(= n 8) #t]\n      [(= n 9) #t]\n      [(= n 10) #t]\n      [(= n 11) #t]\n      [(= n 12) #t]\n      [(= n 13) #t]\n      [(= n 14) #t]\n      [(= n 15) #t]\n      [(= n 16) #t]\n      [(= n 17) #t]\n      [(= n 18) #t]\n      [(= n 19) #t]\n      [(= n 20) #t]\n      [(= n 21) #t]\n      [(= n 22) #t]\n      [(= n 23) #t]\n      [(= n 24) #t]\n      [(= n 25) #t]\n      [(= n 26) #t]\n      [(= n 27) #t]\n      [(= n 28) #t]\n      [(= n 29) #t]\n      [(= n 30) #t]\n      [(= n 31) #t]\n      [(= n 32) #t]\n      [(= n 33) #t]\n      [(= n 34) #t]\n      [(= n 35) #t]\n      [(= n 36) #t]\n      [(= n 37) #t]\n      [(= n 38) #t]\n      [(= n 39) #t]\n      [(= n 40) #t]\n      [(= n 41) #t]\n      [(= n 42) #t]\n      [(= n 43) #t]\n      [(= n 44) #t]\n      [(= n 45) #t]\n      [(= n 46) #t]\n      [(= n 47) #t]\n      [(= n 48) #t]\n     ",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond ((zero? n) #t)\n          ((= prev-digit (remainder n 10)) #f)\n          ((= prev-diff (abs (- prev-digit (remainder n 10)))) #f)\n          (else (is_undulating-iter (quotient n 10) (remainder n 10) (- prev-digit (remainder n 10))))))\n  (is_undulating-iter n 0 0))\n",
    "  (let loop ((n (number->string n))\n             (prev-digit #\\0)\n             (prev-prev-digit #\\0)\n             (is-increasing? #t))\n    (cond ((null? n) #t)\n          ((= (string-length n) 1) #t)\n          ((= (string-length n) 2)\n           (if (and (= (string-ref n 0) (string-ref n 1))\n                    (= (string-ref n 0) prev-digit))\n               #f\n               #t))\n          ((= (string-ref n 0) prev-digit)\n           (loop (substring n 1)\n                 (string-ref n 0)\n                 prev-digit\n                 is-increasing?))\n          ((= (string-ref n 0) prev-prev-digit)\n           (loop (substring n 1)\n                 (string-ref n 0)\n                 prev-digit\n                 (not is-increasing?)))\n          ((and is-increasing?\n                (< (string-ref n 0) prev-digit))\n           (loop (substring n 1)\n                 (string-ref n 0)\n                 prev-digit\n                 is-increasing?))\n          ((and (not is-increasing?)\n                (> (string-ref n 0) prev-digit))\n           (loop (substring n 1)\n                 (string-ref n 0)\n                 prev-digit\n                 is-increasing?))\n          (else #f))))\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond ((and (not (zero? n1)) (not (zero? n2)) (not (zero? n3)))\n           (if (and (= (modulo n1 10) (modulo n2 10))\n                    (= (modulo n2 10) (modulo n3 10)))\n               #t\n               (is_undulating-iter (quotient n1 10) (quotient n2 10) (quotient n3 10))))\n          (else #f)))\n  (is_undulating-iter n (quotient n 10) (quotient n 100)))\n",
    "  (define (is_undulating-iter n last-digit)\n    (cond ((zero? n) #t)\n          ((= (modulo n 10) last-digit) #f)\n          (else (is-undulating-iter (quotient n 10) (modulo n 10)))))\n  (is-undulating-iter n (- n 1)))\n",
    "  (let loop ([n (number->string n)]\n             [prev #\\0]\n             [curr (string-ref n 0)]\n             [next (string-ref n 1)])\n    (cond\n      [(empty? n) #t]\n      [(= (char->integer prev) (char->integer next)) #f]\n      [(= (char->integer curr) (char->integer next)) (loop (rest n) curr next (string-ref n 2))]\n      [else (loop (rest n) curr next (string-ref n 2))])))\n",
    "  (let loop ([n n] [prev-digit -1] [prev-prev-digit -1])\n    (cond [(zero? n) #t]\n          [(= prev-digit (- (modulo n 10) 1))\n           (loop (quotient n 10) (modulo n 10) prev-digit)]\n          [(= prev-digit (+ (modulo n 10) 1))\n           (loop (quotient n 10) (modulo n 10) prev-digit)]\n          [else #f])))\n",
    "  (define (is_undulating-iter n prev-digit)\n    (if (= n 0)\n        #t\n        (let* ([cur-digit (modulo n 10)]\n               [is-undulating (or (= (+ prev-digit cur-digit) 10)\n                                  (= (- prev-digit cur-digit) 10))])\n          (is_undulating-iter (quotient n 10) cur-digit))))\n  (is_undulating-iter n 0))\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond ((= n1 n2) (is-undulating-iter n2 n3 (+ n3 1)))\n          ((= n2 n3) (is-undulating-iter n1 n2 (+ n3 1)))\n          ((= n1 n3) #f)\n          ((&gt; n3 n) #t)\n          (else (is-undulating-iter n2 n3 (+ n3 1)))))\n  (is-undulating-iter n (+ n 1) (+ n 2)))\n</code>\n",
    "  (let loop ((n (number->string n))\n             (prev-digit #\\0)\n             (prev-prev-digit #\\0)\n             (undulating? #t))\n    (cond ((null? n) undulating?)\n          ((and (= (string-ref n 0) prev-digit)\n                (= (string-ref n 0) prev-prev-digit))\n           (loop (cdr n) prev-digit prev-prev-digit #f))\n          ((and (not (= (string-ref n 0) prev-digit))\n                (not (= (string-ref n 0) prev-prev-digit)))\n           (loop (cdr n) (string-ref n 0) prev-digit undulating?))\n          (else (loop (cdr n) (string-ref n 0) prev-digit undulating?)))))\n",
    "  (define (is-undulating-iter n)\n    (if (&lt; n 10)\n        #t\n        (let* ([d1 (modulo n 10)]\n               [d2 (modulo (quotient n 10) 10)]\n               [d3 (modulo (quotient n 100) 10)])\n          (if (or (and (= d1 d2) (= d2 d3))\n                  (and (= d1 d2) (= d2 (+ d3 1)))\n                  (and (= d1 d2) (= d2 (- d3 1)))\n                  (and (= d1 (+ d2 1)) (= d2 d3))\n                  (and (= d1 (- d2 1)) (= d2 d3)))\n              (is-undulating-iter (quotient n 10))\n              #f))))\n  (is-undulating-iter n))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond ((zero? n) #t)\n          ((= prev-digit (- (modulo n 10) prev-diff))\n           (is_undulating-iter (quotient n 10) (- (modulo n 10) prev-diff) prev-diff))\n          (else #f)))\n  (is_undulating-iter n 0 0))\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond\n      [(= n1 n2) (is-undulating-iter n2 n3 (+ n3 1))]\n      [(= n2 n3) (is-undulating-iter n1 n2 (+ n3 1))]\n      [(= n1 n3) #f]\n      [else (is-undulating-iter n2 n3 (+ n3 1))]))\n  (is-undulating-iter n (+ n 1) (+ n 2)))\n",
    "  (define (is_undulating-iter n i)\n    (cond ((= i 0) #t)\n          ((= (modulo n 10) (modulo (quotient n 10) 10)) #f)\n          (else (is-undulating-iter (quotient n 10) (- i 1)))))\n  (is_undulating-iter n (- (length (number->string n)) 1)))\n",
    "  (let loop ((n (number->string n))\n             (prev #\\0)\n             (curr (string-ref n 0))\n             (next (string-ref n 1))\n             (i 2))\n    (cond ((= i (string-length n)) #t)\n          ((and (char=? prev curr)\n                (char=? curr next))\n           (loop n curr next (string-ref n i) (+ i 1)))\n          (else #f))))\n",
    "  (let loop ((n n) (prev-digit -1) (prev-diff -1) (is-undulating #t))\n    (cond ((zero? n) is-undulating)\n          ((= prev-digit (modulo n 10))\n           (loop (quotient n 10) prev-digit prev-diff #f))\n          ((= prev-diff (abs (- (modulo n 10) prev-digit)))\n           (loop (quotient n 10) (modulo n 10) prev-diff #f))\n          (else (loop (quotient n 10) (modulo n 10) (- (modulo n 10) prev-digit) is-undulating)))))\n",
    "  (define (is-undulating-helper n)\n    (if (zero? n)\n        #t\n        (let* ([d1 (remainder n 10)]\n               [d2 (remainder (quotient n 10) 10)])\n          (if (or (= d1 d2) (= (abs (- d1 d2)) 2))\n              (is-undulating-helper (quotient n 10))\n              #f))))\n  (is-undulating-helper n))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (if (zero? n)\n        #t\n        (let ((curr-digit (modulo n 10))\n              (curr-diff (- curr-digit prev-digit)))\n          (if (and (not (zero? prev-diff))\n                   (= curr-diff (- prev-diff)))\n              (is-undulating-iter (quotient n 10) curr-digit curr-diff)\n              #f))))\n  (is-undulating-iter n 0 0))\n",
    "  (cond\n    [(= n 0) #f]\n    [(= n 1) #f]\n    [(= n 2) #f]\n    [(= n 3) #f]\n    [(= n 4) #f]\n    [(= n 5) #f]\n    [(= n 6) #f]\n    [(= n 7) #f]\n    [(= n 8) #f]\n    [(= n 9) #f]\n    [else (is_undulating_helper (number->list n) 0)]))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (if (zero? n)\n        #t\n        (let ((cur-digit (modulo n 10))\n              (cur-diff (- cur-digit prev-digit)))\n          (if (and (not (zero? prev-diff))\n                   (not (= cur-diff prev-diff)))\n              #t\n              (is_undulating-iter (quotient n 10) cur-digit cur-diff)))))\n  (is_undulating-iter n 0 0))\n",
    "  (let loop ([n (number->string n)]\n             [prev #\\0]\n             [curr (string-ref n 0)]\n             [next (string-ref n 1)])\n    (cond\n      [(empty? n) #t]\n      [(= (string-length n) 1) #f]\n      [(= (string-length n) 2)\n       (or (and (= prev #\\0) (= next #\\0))\n           (and (= prev #\\0) (= curr next))\n           (and (= curr next) (= curr prev)))]\n      [(= (string-length n) 3)\n       (or (and (= prev #\\0) (= curr next))\n           (and (= curr next) (= curr prev)))]\n      [else\n       (cond\n         [(and (= prev #\\0) (= curr next))\n          (loop (substring n 1) curr next (string-ref n 3))]\n         [(and (= curr next) (= curr prev))\n          (loop (substring n 1) curr next (string-ref n 3))]\n         [else #f])])))\n",
    "  (define (is_undulating-helper n)\n    (cond\n      [(zero? n) #t]\n      [(zero? (remainder n 10)) #f]\n      [else (is-undulating-helper (quotient n 10))]))\n  (define (is-undulating-helper2 n)\n    (cond\n      [(zero? n) #t]\n      [(zero? (remainder n 10)) #f]\n      [else (is-undulating-helper2 (quotient n 10))]))\n  (and (is-undulating-helper n) (is-undulating-helper2 n)))\n",
    "  (let loop ((n (number->string n))\n             (prev-digit #\\0)\n             (prev-prev-digit #\\0)\n             (undulating? #t))\n    (cond ((null? n) undulating?)\n          ((or (and (char=? (car n) prev-digit)\n                    (char=? (car n) prev-prev-digit))\n               (and (char=? (car n) prev-digit)\n                    (char=? (car n) (cadr n))))\n           (loop (cdr n) prev-digit prev-prev-digit #f))\n          (else (loop (cdr n) (car n) prev-digit undulating?)))))\n",
    "  (define (is_undulating-iter n n-str)\n    (cond\n      [(empty? n-str) #t]\n      [(empty? (rest n-str)) #t]\n      [(empty? (rest (rest n-str))) #t]\n      [else\n       (and\n        (or\n         (= (string-&gt;number (string (first n-str)))\n            (string-&gt;number (string (first (rest n-str)))))\n         (= (string-&gt;number (string (first n-str)))\n            (string-&gt;number (string (first (rest (rest n-str)))))))\n        (is-undulating-iter n (rest n-str)))]))\n  (is-undulating-iter n (number-&gt;string n)))\n",
    "  (let loop ([n n] [prev-digit -1])\n    (cond [(zero? n) #t]\n          [(= prev-digit (modulo n 10)) #f]\n          [else (loop (quotient n 10) (modulo n 10))])))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond\n      [(zero? n) #t]\n      [(= (modulo n 10) prev-digit) #f]\n      [(= (modulo n 10) (- prev-digit prev-diff))\n       (is-undulating-iter (quotient n 10) (modulo n 10) (- prev-digit (modulo n 10)))]\n      [else (is-undulating-iter (quotient n 10) (modulo n 10) (- (modulo n 10) prev-digit))]))\n  (is-undulating-iter n 0 0))\n",
    "  (let loop ((n (number->string n))\n             (prev-digit #\\0)\n             (prev-prev-digit #\\0))\n    (cond ((null? n) #t)\n          ((char=? (car n) prev-digit) #f)\n          ((char=? (car n) prev-prev-digit) #f)\n          (else (loop (cdr n) (car n) prev-digit)))))\n",
    "  (let loop ((n (number->string n))\n             (prev-digit (string-&gt;number (string-ref n 0)))\n             (i 1))\n    (cond ((= i (string-length n)) #t)\n          ((= (modulo (- (string-&gt;number (string-ref n i)) prev-digit) 10)\n              (modulo (- prev-digit (string-&gt;number (string-ref n i))) 10))\n           (loop n (string-&gt;number (string-ref n i)) (+ i 1)))\n          (else #f))))\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond ((= n1 n2) #f)\n          ((= n2 n3) #f)\n          ((= n1 n3) #t)\n          (else (is-undulating-iter n2 n3 (modulo (quotient n3 10) 10)))))\n  (is-undulating-iter (modulo (quotient n 100) 10) (modulo (quotient n 10) 10) (modulo n 10)))\n",
    "  (let loop ((n (number->string n))\n             (prev-digit (string->number (substring n 0 1)))\n             (i 1))\n    (cond ((= i (string-length n)) #t)\n          ((= prev-digit (string->number (substring n i 1))) #f)\n          (else (loop n (string->number (substring n i 1)) (+ i 1))))))\n",
    "  (let loop ([n (number->string n)]\n             [prev (string-&gt;number (substring n 0 1))]\n             [i 1])\n    (cond [(= i (string-length n)) #t]\n          [(= prev (string-&gt;number (substring n i 1))) #f]\n          [else (loop n (string-&gt;number (substring n i 1)) (+ i 1))])))\n",
    "  (define (is_undulating-helper n)\n    (cond\n      [(zero? n) #t]\n      [(zero? (remainder n 10)) (is-undulating-helper (quotient n 10))]\n      [(< (remainder n 10) (remainder (quotient n 10) 10))\n       (is-undulating-helper (quotient n 10))]\n      [(> (remainder n 10) (remainder (quotient n 10) 10))\n       (is-undulating-helper (quotient n 10))]\n      [else #f]))\n  (is-undulating-helper n))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond\n      [(zero? n) #t]\n      [(= prev-digit (modulo n 10)) #f]\n      [(= prev-diff (abs (- prev-digit (modulo n 10))))\n       (is_undulating-iter (quotient n 10) (modulo n 10) prev-diff)]\n      [else #f]))\n  (is_undulating-iter n (modulo n 10) (abs (- (modulo n 10) (modulo (quotient n 10) 10)))))\n",
    "  (let loop ([n n] [prev #f])\n    (cond [(zero? n) #t]\n          [(and (not prev) (zero? (remainder n 10)))\n           (loop (quotient n 10) #t)]\n          [(and prev (zero? (remainder n 10)))\n           (loop (quotient n 10) #f)]\n          [else (loop (quotient n 10) #t)])))\n",
    "  (define (is-undulating-helper n)\n    (if (&lt; n 10)\n        #t\n        (let* ([d1 (modulo n 10)]\n               [d2 (modulo (quotient n 10) 10)])\n          (if (or (= d1 d2) (= (abs (- d1 d2)) 2))\n              (is-undulating-helper (quotient n 10))\n              #f))))\n  (is-undulating-helper n))\n",
    "  (define (is_undulating-helper n)\n    (if (zero? n)\n        #f\n        (let* ([d1 (remainder n 10)]\n               [d2 (remainder (quotient n 10) 10)])\n          (if (and (not (zero? d1))\n                   (not (zero? d2))\n                   (or (= d1 d2)\n                       (= (- d1 d2) 1)\n                       (= (- d2 d1) 1)))\n              (is_undulating-helper (quotient n 10))\n              #f))))\n  (is_undulating-helper n))\n",
    "  (define (is_undulating-helper n)\n    (if (< n 10)\n        #f\n        (let* ([d1 (modulo n 10)]\n               [d2 (modulo (quotient n 10) 10)])\n          (if (or (= d1 d2) (= (abs (- d1 d2)) 2))\n              (is_undulating-helper (quotient n 10))\n              #f))))\n  (is_undulating-helper n))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond\n      [(zero? n) #t]\n      [(= (modulo n 10) prev-digit) #f]\n      [(= (modulo n 10) (- prev-digit prev-diff)) #f]\n      [else (is-undulating-iter (quotient n 10) (modulo n 10) (- (modulo n 10) prev-digit))]))\n  (is-undulating-iter n -1 -1))\n",
    "  (define (is_undulating-iter n i)\n    (cond\n      [(= i 0) #t]\n      [(= (modulo n 10) (modulo (quotient n (expt 10 i)) 10))\n       (is-undulating-iter n (- i 1))]\n      [else #f]))\n  (is-undulating-iter n (- (expt 10 (exact-floor (log n 10))) 1)))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond ((zero? n) #t)\n          ((zero? prev-digit) (is-undulating-iter (quotient n 10) (modulo n 10) 0))\n          ((zero? prev-diff) (is-undulating-iter (quotient n 10) (modulo n 10) (- (modulo n 10) prev-digit)))\n          ((= (modulo n 10) (+ prev-digit prev-diff)) (is-undulating-iter (quotient n 10) (modulo n 10) prev-diff))\n          ((= (modulo n 10) (- prev-digit prev-diff)) (is-undulating-iter (quotient n 10) (modulo n 10) prev-diff))\n          (else #f)))\n  (is-undulating-iter n 0 0))\n",
    "  (let loop ((n n) (prev #f) (prev-prev #f))\n    (cond ((zero? n) #t)\n          ((and prev prev-prev)\n           (let ((curr (modulo n 10)))\n             (and (or (= (- prev curr) 1) (= (- curr prev) 1))\n                  (loop (quotient n 10) curr prev))))\n          (else (loop (quotient n 10) (modulo n 10) prev)))))\n",
    "  (let loop ([n n] [prev-digit -1] [prev-prev-digit -1])\n    (if (zero? n)\n        #t\n        (let ([digit (modulo n 10)])\n          (if (or (and (positive? prev-digit)\n                       (positive? prev-prev-digit)\n                       (and (= prev-digit prev-prev-digit)\n                            (= digit prev-digit)))\n                  (and (negative? prev-digit)\n                       (negative? prev-prev-digit)\n                       (and (= prev-digit prev-prev-digit)\n                            (= digit prev-digit))))\n              #f\n              (loop (quotient n 10) digit prev-digit))))))\n",
    "  (define (is_undulating-iter n)\n    (cond\n      [(zero? n) true]\n      [(zero? (remainder n 10)) false]\n      [else\n       (let* ([d1 (remainder n 10)]\n              [d2 (remainder (quotient n 10) 10)]\n              [d3 (remainder (quotient n 100) 10)])\n         (or (and (= d1 d2) (not (= d2 d3)))\n             (and (= d2 d3) (not (= d1 d2)))\n             (is_undulating-iter (quotient n 10))))]))\n  (is_undulating-iter n))\n",
    "  (let loop ((n (number->string n))\n             (prev-digit #\\0)\n             (prev-prev-digit #\\0)\n             (undulating? #t))\n    (cond ((null? n) undulating?)\n          ((and (= (string-ref n 0) prev-digit)\n                (= (string-ref n 0) prev-prev-digit))\n           (loop (cdr n) (string-ref n 0) prev-digit #f))\n          ((and (= (string-ref n 0) prev-digit)\n                (not (= (string-ref n 0) prev-prev-digit)))\n           (loop (cdr n) (string-ref n 0) prev-digit undulating?))\n          ((and (not (= (string-ref n 0) prev-digit))\n                (= (string-ref n 0) prev-prev-digit))\n           (loop (cdr n) (string-ref n 0) prev-digit undulating?))\n          ((and (not (= (string-ref n 0) prev-digit))\n                (not (= (string-ref n 0) prev-prev-digit)))\n           (loop (cdr n) (string-ref n 0) prev-digit undulating?)))))\n",
    "  (let loop ((n (number->string n))\n             (prev-digit #\\0)\n             (prev-prev-digit #\\0))\n    (cond ((null? n) #t)\n          ((and (char=? (car n) prev-digit)\n                (char=? (car n) prev-prev-digit))\n           #f)\n          (else (loop (cdr n) (car n) prev-digit)))))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (if (= n 0)\n        #t\n        (let* ([digit (modulo n 10)]\n               [diff (- digit prev-digit)])\n          (if (and (= diff prev-diff)\n                   (not (zero? diff)))\n              (is_undulating-iter (quotient n 10) digit diff)\n              #f))))\n  (is_undulating-iter n 0 0))\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (if (and (not (zero? n3))\n             (or (and (= n1 n2) (= n2 n3))\n                 (and (= n1 n3) (= n2 n3))))\n        #t\n        (is_undulating-iter n2 n3 (modulo (quotient n3 10) 10))))\n  (is_undulating-iter (modulo (quotient n 100) 10)\n                      (modulo (quotient n 10) 10)\n                      (modulo n 10)))\n",
    "  (let loop ((n (number->string n))\n             (prev-digit (string->number (substring n 0 1)))\n             (i 1))\n    (cond ((= i (string-length n)) #t)\n          ((= prev-digit (string->number (substring n i (add1 i)))) #f)\n          (else (loop n (string->number (substring n i (add1 i))) (add1 i))))))\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond\n      [(zero? n3) #t]\n      [(and (not (zero? n1)) (not (zero? n2)) (not (zero? n3)))\n       (cond\n         [(and (= n1 n2) (= n2 n3)) #f]\n         [(or (= n1 n2) (= n2 n3)) #t]\n         [else (is-undulating-iter n2 n3 (modulo (quotient n3 10) 10))])]\n      [else #f]))\n  (is-undulating-iter (modulo (quotient n 100) 10) (modulo (quotient n 10) 10) (modulo n 10)))\n",
    "  (let loop ([n (number->string n)]\n             [prev #\\0]\n             [result #t])\n    (cond [(empty? n) result]\n          [(and (char=? (first n) prev)\n                (not (char=? (first n) (second n))))\n           (loop (rest n) (first n) result)]\n          [(and (char=? (first n) (second n))\n                (not (char=? (first n) prev)))\n           (loop (rest n) (first n) result)]\n          [else (loop (rest n) (first n) #f)])))\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond\n      [(zero? n1) #t]\n      [(and (or (= n1 n2) (= n2 n3))\n            (not (and (= n1 n2) (= n2 n3))))\n       (is-undulating-iter (quotient n1 10) (quotient n2 10) (quotient n3 10))]\n      [else #f]))\n  (is-undulating-iter n (quotient n 10) (quotient n 100)))\n",
    "  (let loop ([n n] [prev 0])\n    (if (zero? n)\n        (not (zero? prev))\n        (let ([d (modulo n 10)])\n          (if (zero? prev)\n              (loop (quotient n 10) d)\n              (if (= prev d)\n                  (loop (quotient n 10) d)\n                  #f))))))\n",
    "  (let loop ([n (number->string n)]\n             [last-digit (string->number (string-ref n 0))]\n             [i 1])\n    (if (= i (string-length n))\n        #t\n        (let ([next-digit (string->number (string-ref n i))])\n          (if (or (= last-digit next-digit)\n                  (and (= last-digit (+ next-digit 1))\n                       (= next-digit (+ last-digit 1))))\n              (loop n next-digit (+ i 1))\n              #f)))))\n",
    "  (let loop ((n (number->string n))\n             (prev (string-&gt;number (string-ref n 0)))\n             (curr (string-&gt;number (string-ref n 1)))\n             (i 2))\n    (cond ((= i (string-length n)) #t)\n          ((= (abs (- curr prev)) 1) (loop n curr (string-&gt;number (string-ref n i)) (+ i 1)))\n          (else #f))))\n</code>\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond\n      [(zero? n) #t]\n      [(= n prev-digit) #f]\n      [(= (modulo n 10) prev-digit) #f]\n      [(= (abs (- (modulo n 10) prev-digit)) prev-diff) #f]\n      [else (is-undulating-iter (quotient n 10) (modulo n 10) (abs (- (modulo n 10) prev-digit)))]))\n  (is_undulating-iter n 0 0))\n",
    "  (let loop ([n n] [prev-digit -1] [is-decreasing? #t])\n    (cond [(zero? n) #t]\n          [(= prev-digit (remainder n 10)) #f]\n          [else (loop (quotient n 10) (remainder n 10)\n                      (if is-decreasing?\n                          (> prev-digit (remainder n 10))\n                          (< prev-digit (remainder n 10))))])))\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond ((= n1 n2) (is-undulating-iter n2 n3 (+ n3 1)))\n          ((= n2 n3) (is-undulating-iter n1 n2 (+ n3 1)))\n          ((= n1 n3) #f)\n          ((&gt; n3 n) #t)\n          (else (is-undulating-iter n1 n2 (+ n3 1)))))\n  (is-undulating-iter n (+ n 1) (+ n 2)))\n</code>\n",
    "  (if (= n 0)\n      #f\n      (let* ([n (number->string n)]\n             [len (string-length n)])\n        (let loop ([i 0] [j (+ i 2)])\n          (if (= i (- len 1))\n              #t\n              (if (and (not (= (string-ref n i) (string-ref n j)))\n                       (not (= (string-ref n i) (string-ref n (+ j 1)))))\n                  (loop (+ i 1) (+ j 2))\n                  #f))))))\n",
    "  (define (is-undulating-helper n)\n    (if (zero? n)\n        #t\n        (let* ([d1 (modulo n 10)]\n               [d2 (modulo (quotient n 10) 10)])\n          (if (or (= d1 d2) (= (abs (- d1 d2)) 2))\n              (is-undulating-helper (quotient n 10))\n              #f))))\n  (is-undulating-helper n))\n",
    "  (define (is_undulating-helper n)\n    (cond\n      [(zero? n) #t]\n      [(zero? (remainder n 10)) #f]\n      [else (is-undulating-helper (quotient n 10))]))\n  (is-undulating-helper n))\n",
    "  (let loop ([n n] [prev-digit -1] [prev-prev-digit -1])\n    (cond [(zero? n) #t]\n          [(= (modulo n 10) prev-digit) #f]\n          [(= (modulo n 10) prev-prev-digit) #f]\n          [else (loop (quotient n 10) (modulo n 10) prev-digit)])))\n",
    "  (define (is-undulating-helper n)\n    (cond\n      [(zero? n) #t]\n      [(zero? (modulo n 10)) #f]\n      [(zero? (modulo (quotient n 10) 10)) #f]\n      [else (is-undulating-helper (quotient n 10))]))\n  (is-undulating-helper n))\n",
    "  (let loop ([n n] [prev -1])\n    (cond\n      [(zero? n) #t]\n      [(= prev (modulo n 10)) #f]\n      [else (loop (quotient n 10) (modulo n 10))])))\n",
    "  (define (is_undulating-iter n i)\n    (cond\n      [(= i 0) #f]\n      [(= i 1) #t]\n      [(= (modulo n 10) (modulo (quotient n 10) 10))\n       (is-undulating-iter (quotient n 10) (- i 1))]\n      [else #f]))\n  (is-undulating-iter n (number->string n)))\n",
    "  (let loop ([n n] [prev-digit 0] [prev-diff 0] [count 0])\n    (cond [(zero? n) (= count 3)]\n          [(= prev-diff (- (remainder n 10) prev-digit))\n           (loop (quotient n 10) (remainder n 10) prev-diff (+ count 1))]\n          [else (loop (quotient n 10) (remainder n 10) (- (remainder n 10) prev-digit) 1)])))\n",
    "  (let loop ((n (number->string n))\n             (prev #\\0)\n             (next #\\0)\n             (count 0))\n    (cond ((null? n) (= count 2))\n          ((= (car n) prev) (loop (cdr n) prev next count))\n          ((= (car n) next) (loop (cdr n) prev next (+ count 1)))\n          (else (loop (cdr n) (car n) prev 1)))))\n",
    "  (let loop ([n n] [prev -1])\n    (cond [(zero? n) #t]\n          [(= prev (remainder n 10)) #f]\n          [else (loop (quotient n 10) (remainder n 10))])))\n",
    "  (let loop ([n (number->string n)]\n             [i 0]\n             [j 1])\n    (cond [(empty? n) #t]\n          [(empty? (rest n)) #f]\n          [(= (string-&gt;number (string-ref n i))\n             (string-&gt;number (string-ref n j)))\n           (loop (rest n) (+ i 1) (+ j 1))]\n          [else #f])))\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond ((= n3 0) #t)\n          ((= n1 n2) (is-undulating-iter n2 n3 (remainder n3 10)))\n          (else #f)))\n  (is_undulating-iter (remainder n 100) (remainder n 10) (quotient n 100)))\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond ((and (zero? n1) (zero? n2) (zero? n3)) #t)\n          ((and (zero? n1) (zero? n2)) #f)\n          ((and (zero? n1) (zero? n3)) #f)\n          ((and (zero? n2) (zero? n3)) #f)\n          ((and (= n1 n2) (= n2 n3)) #f)\n          ((and (= n1 n2) (= n2 (- n3))) #t)\n          ((and (= n1 n2) (= n2 (+ n3))) #t)\n          ((and (= n1 (- n2)) (= n2 n3)) #t)\n          ((and (= n1 (+ n2)) (= n2 n3)) #t)\n          ((and (= n1 (- n2)) (= n2 (- n3))) #f)\n          ((and (= n1 (- n2)) (= n2 (+ n3))) #f)\n          ((and (= n1 (+ n2)) (= n2 (- n3))) #f)\n          ((and (= n1 (+ n2)) (= n2 (+ n3))) #f)\n          (else (is_undulating-iter n2 n3 (remainder n 10)))))\n  (is_undulating-iter (quotient n 100) (quotient n 10) (remainder n 10)))\n",
    "  (define (undulating? n)\n    (cond\n      [(zero? n) #t]\n      [(zero? (modulo n 10)) #f]\n      [else (undulating? (quotient n 10))]))\n  (undulating? n))\n",
    "  (let loop ([n n] [prev-digit -1] [prev-diff 0])\n    (cond\n      [(zero? n) #t]\n      [(= prev-digit (modulo n 10)) #f]\n      [(= prev-diff (- (modulo n 10) prev-digit)) (loop (quotient n 10) (modulo n 10) (- (modulo n 10) prev-digit))]\n      [else (loop (quotient n 10) (modulo n 10) (- (modulo n 10) prev-digit))])))\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond\n      [(zero? n1) #t]\n      [(and (= n1 n2) (= n2 n3)) (is-undulating-iter (quotient n1 10) (quotient n2 10) (quotient n3 10))]\n      [else #f]))\n  (is-undulating-iter n (quotient n 10) (quotient n 100)))\n",
    "  (let loop ((n (number->string n))\n             (prev-digit (string->number (substring n 0 1)))\n             (is-increasing? #t))\n    (cond ((null? n) #t)\n          ((and (not (null? (cdr n)))\n                (if is-increasing?\n                    (< prev-digit (string->number (substring n 1 2)))\n                    (> prev-digit (string->number (substring n 1 2)))))\n           (loop (cdr n) (string->number (substring n 1 2)) (not is-increasing?)))\n          (else #f))))\n",
    "  (define (is_undulating-helper n)\n    (if (zero? n)\n        #t\n        (let* ([d1 (remainder n 10)]\n               [n (quotient n 10)]\n               [d2 (remainder n 10)])\n          (if (and (not (zero? n))\n                   (or (= (- d1 d2) 1)\n                       (= (- d1 d2) -1)))\n              (is_undulating-helper (quotient n 10))\n              #f))))\n  (is_undulating-helper n))\n",
    "  (define (is_undulating-iter n prev)\n    (cond\n      [(zero? n) #t]\n      [(zero? (remainder n 10)) #f]\n      [else (and\n              (or (= (remainder n 10) (+ prev 1))\n                  (= (remainder n 10) (- prev 1)))\n              (is_undulating-iter (quotient n 10) (remainder n 10)))]))\n  (is_undulating-iter n 0))\n",
    "  (let loop ([n n] [prev-digit -1] [prev-diff 0])\n    (cond [(zero? n) #t]\n          [(and (zero? prev-diff) (= (remainder n 10) prev-digit))\n           (loop (quotient n 10) (remainder n 10) prev-diff)]\n          [(= (abs (- (remainder n 10) prev-digit)) 1)\n           (loop (quotient n 10) (remainder n 10) (- (remainder n 10) prev-digit))]\n          [else #f])))\n",
    "  (and (not (zero? n))\n       (or (and (odd? n)\n                (is_undulating (quotient n 10)))\n           (and (even? n)\n                (is_undulating (quotient n 10))))))\n",
    "  (let loop ([n n] [prev-digit -1] [prev-prev-digit -1])\n    (cond [(zero? n) #t]\n          [(= (modulo n 10) prev-digit) #f]\n          [(= (modulo n 10) prev-prev-digit) #f]\n          [else (loop (quotient n 10) (modulo n 10) prev-digit)])))\n",
    "  (define (is_undulating-helper n)\n    (cond\n      [(zero? n) #t]\n      [(zero? (modulo n 10)) (is-undulating-helper (quotient n 10))]\n      [(zero? (modulo (quotient n 10) 10)) (is-undulating-helper (quotient n 10))]\n      [else #f]))\n  (is-undulating-helper n))\n",
    "  (let loop ((n n) (prev #f))\n    (cond ((zero? n) #t)\n          ((not (and (integer? prev) (integer? (quotient n 10))))\n           (loop (quotient n 10) (remainder n 10)))\n          ((= (remainder n 10) prev) #f)\n          (else (loop (quotient n 10) (remainder n 10))))))\n",
    "  (let loop ([n n] [prev-digit -1])\n    (if (zero? n)\n        #t\n        (let ([cur-digit (modulo n 10)])\n          (if (or (= prev-digit -1)\n                  (and (= prev-digit (+ cur-digit 1))\n                       (= (modulo n 100) (+ prev-digit cur-digit)))\n                  (and (= prev-digit (- cur-digit 1))\n                       (= (modulo n 100) (- prev-digit cur-digit))))\n              (loop (quotient n 10) cur-digit)\n              #f)))))\n",
    "  (let loop ([n (number->string n)]\n             [prev (string-&gt;number (string-ref n 0))]\n             [i 1])\n    (cond [(zero? (modulo (string-length n) 2)) #f]\n          [(= i (string-length n)) #t]\n          [(= prev (string-&gt;number (string-ref n i))) (loop n prev (+ i 1))]\n          [else #f])))\n",
    "  (define (is_undulating-iter n r)\n    (cond\n      [(zero? n) #t]\n      [(zero? r) #f]\n      [(= (modulo n 10) (modulo (quotient n 100) 10)) (is-undulating-iter (quotient n 10) (- r 1))]\n      [else #f]))\n  (is-undulating-iter n (quotient (length (number->string n)) 3)))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond\n      [(zero? n) #t]\n      [(zero? (modulo n 10)) (is_undulating-iter (quotient n 10) prev-digit prev-diff)]\n      [else\n       (let* ([curr-digit (modulo n 10)]\n              [curr-diff (- curr-digit prev-digit)])\n         (and (not (zero? prev-diff))\n              (or (= curr-diff prev-diff)\n                  (= curr-diff (- prev-diff)))\n              (is_undulating-iter (quotient n 10) curr-digit curr-diff)))]))\n  (is_undulating-iter n 0 0))\n",
    "  (let loop ([n (number->string n)])\n    (cond\n      [(empty? n) #t]\n      [(< (string-&gt;number (first n)) (string-&gt;number (second n)))\n       (loop (rest n))]\n      [(&gt; (string-&gt;number (first n)) (string-&gt;number (second n)))\n       (loop (rest n))]\n      [else #f])))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond\n      [(zero? n) #t]\n      [(and (= prev-diff (- (modulo n 10) prev-digit))\n            (= prev-diff (- prev-digit (modulo n 10))))\n       (is-undulating-iter (quotient n 10) (modulo n 10) prev-diff)]\n      [else #f]))\n  (is-undulating-iter n (modulo n 10) (- (modulo n 10) (modulo (quotient n 10) 10))))\n",
    "  (let loop ((n n) (prev-digit -1) (prev-prev-digit -1) (is-undulating #t))\n    (cond ((zero? n) is-undulating)\n          ((zero? prev-digit) (loop (quotient n 10) (remainder n 10) prev-prev-digit is-undulating))\n          ((zero? prev-prev-digit) (loop (quotient n 10) (remainder n 10) prev-digit is-undulating))\n          ((= (remainder n 10) prev-prev-digit) (loop (quotient n 10) (remainder n 10) prev-digit #t))\n          ((= (remainder n 10) prev-digit) (loop (quotient n 10) (remainder n 10) prev-prev-digit #t))\n          (else (loop (quotient n 10) (remainder n 10) prev-digit #f)))))\n",
    "  (define (is_undulating-helper n)\n    (if (zero? n)\n        #t\n        (let* ([d1 (modulo n 10)]\n               [d2 (modulo (quotient n 10) 10)])\n          (if (or (= d1 d2)\n                  (= (abs (- d1 d2)) 2))\n              (is_undulating-helper (quotient n 10))\n              #f))))\n  (is_undulating-helper n))\n",
    "  (define (is-undulating-iter n prev-digit prev-diff)\n    (cond\n      [(zero? n) #t]\n      [(= prev-digit (remainder n 10)) #f]\n      [(= prev-diff (abs (- prev-digit (remainder n 10)))) #f]\n      [else (is-undulating-iter (quotient n 10) (remainder n 10) (- prev-digit (remainder n 10)))]))\n  (is-undulating-iter n 0 0))\n",
    "  (let loop ([n n] [prev -1])\n    (cond [(zero? n) #t]\n          [(= (modulo n 10) prev) #f]\n          [else (loop (quotient n 10) (modulo n 10))])))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond\n      [(zero? n) #t]\n      [(and (zero? prev-diff) (zero? (modulo n 10))) #f]\n      [(and (zero? prev-diff) (zero? (modulo (quotient n 10) 10))) #f]\n      [(and (zero? prev-diff) (= (modulo n 10) (modulo (quotient n 10) 10))) #f]\n      [(and (zero? prev-diff) (= (modulo n 10) prev-digit)) #f]\n      [(and (zero? prev-diff) (= (modulo n 10) (- prev-digit))) #f]\n      [(and (zero? prev-diff) (= (modulo n 10) (+ prev-digit))) #f]\n      [(and (zero? prev-diff) (= (modulo n 10) (- prev-digit))) #f]\n      [(and (zero? prev-diff) (= (modulo n 10) (- prev-digit))) #f]\n      [(and (zero? prev-diff) (= (modulo n 10) (- prev-digit))) #f]\n      [(and (zero? prev-diff) (= (modulo n 10) (- prev-digit))) #f]\n      [(and (zero? prev-diff) (= (modulo n 10) (- prev-digit))) #f]\n      [(and (zero? prev-diff) (= (modulo n 10) (- prev-digit))) #f]\n      [(and (zero? prev-diff) (= (modulo n 10) (- prev-digit))) #f]\n      [(and (zero? prev-diff) (= (modulo n 10) (- prev-digit))) #f]\n      [(and (zero? prev-diff) (= (modulo n 10) (- prev-digit))) #f]\n      [(and (zero? prev-diff) (= (modulo n 10) (- prev-digit))) #f]\n      [(and (zero? prev-diff) (= (modulo n 10) (- prev-digit))) #f]\n      [(and (zero? prev-diff) (= (modulo n 10) (- prev-digit))) #f]\n      [(and (",
    "  (let loop ([n n] [prev-digit -1] [prev-diff 0])\n    (cond\n      [(zero? n) #t]\n      [(= prev-digit (- (remainder n 10) prev-diff))\n       (loop (quotient n 10) (- (remainder n 10) prev-diff) prev-diff)]\n      [else #f])))\n",
    "  (let loop ((n n) (prev -1) (curr -1))\n    (cond ((zero? n) #t)\n          ((= prev curr) #f)\n          (else (loop (quotient n 10) curr (modulo n 10))))))\n",
    "  (let loop ([n n] [prev-digit -1] [prev-diff 0])\n    (if (= n 0)\n        #t\n        (let* ([digit (modulo n 10)]\n               [diff (- digit prev-digit)])\n          (if (or (= prev-digit -1)\n                  (= prev-diff diff))\n              (loop (quotient n 10) digit diff)\n              #f)))))\n",
    "  (let loop ([n (number->string n)] [prev (string-&gt;number (string-ref n 0))])\n    (cond [(empty? n) #t]\n          [(= (string-&gt;number (string-ref n 0)) prev)\n           (loop (rest n) (string-&gt;number (string-ref n 0)))]\n          [else #f])))\n",
    "  (define (is_undulating-helper n)\n    (cond\n      [(zero? n) #t]\n      [(< n 10) #f]\n      [(= (modulo (quotient n 10) 10) (- (modulo n 10))) (is_undulating-helper (quotient n 10))]\n      [else #f]))\n  (is_undulating-helper n))\n",
    "  (define (is-undulating-helper n)\n    (if (zero? n)\n        #t\n        (let* ([d1 (remainder n 10)]\n               [n (quotient n 10)]\n               [d2 (remainder n 10)])\n          (if (or (and (= d1 d2) (= d1 0))\n                  (and (= d1 d2) (= d1 9)))\n              #f\n              (is-undulating-helper (quotient n 10))))))\n  (is-undulating-helper n))\n",
    "  (define (is_undulating-iter n prev-diff)\n    (cond\n      [(zero? n) #t]\n      [(zero? (remainder n 10)) #f]\n      [(zero? prev-diff) (is-undulating-iter (quotient n 10) (remainder n 10))]\n      [(= (abs (- (remainder n 10) prev-diff)) 1) (is-undulating-iter (quotient n 10) (remainder n 10))]\n      [else #f]))\n  (is-undulating-iter n 0))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond\n      [(zero? n) #t]\n      [(= prev-diff (- (modulo n 10) prev-digit))\n       (is_undulating-iter (quotient n 10) (modulo n 10) (- (modulo n 10) prev-digit))]\n      [else #f]))\n  (is_undulating-iter n (modulo n 10) (- (modulo n 10) (modulo (quotient n 10) 10))))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond\n      [(zero? n) #t]\n      [(and (= prev-diff (- (modulo n 10) prev-digit))\n            (is_undulating-iter (quotient n 10) (- (modulo n 10) prev-diff) (- (modulo n 10) prev-digit)))\n       #t]\n      [else #f]))\n  (is_undulating-iter n 0 0))\n",
    "  (let loop ((n (number->string n))\n             (prev-digit #\\0)\n             (prev-prev-digit #\\0))\n    (cond ((null? n) #t)\n          ((and (= (string-ref n 0) prev-digit)\n                (= (string-ref n 0) prev-prev-digit)) #f)\n          (else (loop (string-drop n 1)\n                      (string-ref n 0)\n                      prev-digit)))))\n",
    "  (define (is_undulating-helper n)\n    (if (= n 0)\n        #f\n        (let* ([d1 (remainder n 10)]\n               [d2 (remainder (quotient n 10) 10)])\n          (if (and (= d1 d2)\n                   (not (zero? d1)))\n              (is-undulating-helper (quotient n 10))\n              #t))))\n  (is-undulating-helper n))\n",
    "  (let loop ((n (number->string n))\n             (prev-digit (string->number (substring n 0 1)))\n             (prev-diff 0)\n             (i 1))\n    (cond ((= i (string-length n)) #t)\n          ((= (string->number (substring n i 1)) prev-digit) #f)\n          ((= (abs (- prev-digit (string->number (substring n i 1)))) prev-diff) #f)\n          (else (loop n (string->number (substring n i 1))\n                      (abs (- prev-digit (string->number (substring n i 1))))\n                      (+ i 1))))))\n",
    "  (let loop ((n (number->string n))\n             (prev (string-&gt;number (substring n 0 1)))\n             (i 1))\n    (cond ((&gt;= i (string-length n)) #t)\n          ((= (modulo i 2) 0)\n           (let ((curr (string-&gt;number (substring n i (+ i 1)))))\n             (if (&gt; curr prev)\n                 (loop n curr (+ i 1))\n                 #f)))\n          ((= (modulo i 2) 1)\n           (let ((curr (string-&gt;number (substring n i (+ i 1)))))\n             (if (&lt; curr prev)\n                 (loop n curr (+ i 1))\n                 #f))))))\n",
    "  (let loop ((n (number->string n))\n             (prev #\\0)\n             (curr (string-ref n 0))\n             (next (string-ref n 1))\n             (i 1))\n    (cond ((= i (string-length n)) #t)\n          ((and (char=? curr next) (char=? prev curr)) #f)\n          (else (loop n curr next (string-ref n (+ i 1)) (+ i 1))))))\n",
    "  (define (is_undulating-iter n)\n    (if (zero? n)\n        #t\n        (let* ([d1 (modulo n 10)]\n               [n (quotient n 10)]\n               [d2 (modulo n 10)])\n          (if (and (not (zero? d1))\n                   (not (zero? d2))\n                   (or (= (abs (- d1 d2)) 1)\n                       (= (abs (- d1 d2)) 9)))\n              (is_undulating-iter (quotient n 10))\n              #f))))\n  (is_undulating-iter n))\n",
    "  (let loop ([n (number->string n)]\n             [prev #\\0]\n             [curr (string-ref n 0)]\n             [next (string-ref n 1)])\n    (cond [(empty? n) #t]\n          [(empty? (rest n)) #t]\n          [(and (= (char-&gt;integer prev) (char-&gt;integer next))\n                (not (= (char-&gt;integer prev) (char-&gt;integer curr))))\n           (loop (rest n) curr next (string-ref n 2))]\n          [else #f])))\n",
    "  (let loop ([n (number->string n)]\n             [i 0]\n             [j 1])\n    (cond [(empty? n) #t]\n          [(= (string-ref n i) (string-ref n j)) (loop (substring n 1) 0 1)]\n          [else #f])))\n",
    "  (let loop ([n (number->string n)]\n             [prev-digit (string->number (string-ref n 0))]\n             [undulating? #t])\n    (cond [(empty? n) undulating?]\n          [(= (string->number (string-ref n 0)) prev-digit)\n           (loop (rest n) prev-digit #f)]\n          [else (loop (rest n) (string->number (string-ref n 0)) undulating?)])))\n",
    "  (define (is_undulating-helper n)\n    (if (= n 0)\n        #f\n        (let ([d (modulo n 10)])\n          (if (= d (modulo (quotient n 10) 10))\n              (is-undulating-helper (quotient n 10))\n              #t))))\n  (is-undulating-helper n))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond\n      [(zero? n) #t]\n      [(= prev-digit (- (modulo n 10) prev-diff))\n       (is_undulating-iter (quotient n 10) (- (modulo n 10) prev-diff) prev-diff)]\n      [else #f]))\n  (is_undulating-iter n (- (modulo n 10) (modulo (quotient n 10) 10)) (modulo (quotient n 10) 10)))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond\n      [(zero? n) #t]\n      [(= prev-diff (- (modulo n 10) prev-digit))\n       (is_undulating-iter (quotient n 10) (- (modulo n 10)) prev-diff)]\n      [else #f]))\n  (is_undulating-iter n 0 0))\n",
    "  (define (is_undulating-iter n last-digit)\n    (cond ((zero? n) #t)\n          ((and (zero? (remainder n 10))\n                (not (zero? last-digit)))\n           (is-undulating-iter (quotient n 10) 0))\n          ((and (not (zero? (remainder n 10)))\n                (zero? last-digit))\n           (is-undulating-iter (quotient n 10) (remainder n 10)))\n          ((= (remainder n 10) last-digit)\n           (is-undulating-iter (quotient n 10) last-digit))\n          (else #f)))\n  (is-undulating-iter n 0))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond [(zero? n) #t]\n          [(= prev-digit (remainder n 10)) #f]\n          [(= prev-diff (- (remainder n 10) prev-digit)) #f]\n          [else (is-undulating-iter (quotient n 10) (remainder n 10) (- (remainder n 10) prev-digit))]))\n  (is_undulating-iter n 0 0))\n",
    "  (define (is_undulating-iter n prev-digit)\n    (cond\n      [(zero? n) #t]\n      [(and (even? n) (= prev-digit (remainder n 10)))\n       (is_undulating-iter (quotient n 10) prev-digit)]\n      [(and (odd? n) (= prev-digit (- (remainder n 10))))\n       (is_undulating-iter (quotient n 10) prev-digit)]\n      [else #f]))\n  (is_undulating-iter n (remainder n 10)))\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond ((= n1 n2) #f)\n          ((= n2 n3) #t)\n          (else (is-undulating-iter n2 n3 (remainder (quotient n3 10) 10)))))\n  (is_undulating-iter (remainder (quotient n 10) 10) (remainder n 10) (quotient n 100)))\n",
    "  (let loop ((n (number->string n))\n             (prev-digit #\\0)\n             (prev-prev-digit #\\0))\n    (cond ((null? n) #t)\n          ((= (string-ref n 0) prev-digit) #f)\n          ((= (string-ref n 0) prev-prev-digit) #f)\n          (else (loop (substring n 1)\n                      (string-ref n 0)\n                      prev-digit)))))\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond\n      [(zero? n1) #t]\n      [(and (equal? (modulo n1 10) n2) (equal? (modulo n1 10) n3)) (is_undulating-iter (quotient n1 10) n2 n3)]\n      [(and (equal? (modulo n1 10) n2) (not (equal? (modulo n1 10) n3))) (is_undulating-iter (quotient n1 10) n3 (modulo n1 10))]\n      [(and (not (equal? (modulo n1 10) n2)) (equal? (modulo n1 10) n3)) (is_undulating-iter (quotient n1 10) n2 (modulo n1 10))]\n      [(and (not (equal? (modulo n1 10) n2)) (not (equal? (modulo n1 10) n3))) #f]))\n  (is_undulating-iter n (modulo n 10) (modulo n 10)))\n",
    "  (let loop ([n (number->string n)]\n             [prev (string-&gt;number (string-ref n 0))]\n             [i 1])\n    (cond [(empty? n) #t]\n          [(= i (string-length n)) #f]\n          [(= (string-&gt;number (string-ref n i)) prev)\n           (loop (substring n i) prev (+ i 1))]\n          [else (loop (substring n i) (string-&gt;number (string-ref n i)) (+ i 1))])))\n",
    "  (define (is_undulating-helper n)\n    (if (zero? n)\n        #t\n        (let ((d1 (modulo n 10))\n              (d2 (modulo (quotient n 10) 10)))\n          (or (and (= d1 d2)\n                   (is_undulating-helper (quotient n 10)))\n              (and (= (abs (- d1 d2)) 1)\n                   (is_undulating-helper (quotient n 100)))))))\n  (is_undulating-helper n))\n",
    "  (let loop ([n (number->string n)])\n    (cond\n      [(empty? n) #t]\n      [(< (string-&gt;number (substring n 0 2))\n          (string-&gt;number (substring n 1 3)))\n       (loop (substring n 1))]\n      [else #f])))\n</code>\n",
    "  (define (is_undulating-helper n)\n    (cond\n      [(zero? n) #t]\n      [(zero? (remainder n 10)) #f]\n      [else (is-undulating-helper (quotient n 10))]))\n  (is_undulating-helper n))\n",
    "  (cond\n    [(= n 0) #f]\n    [(= n 1) #f]\n    [(= n 2) #f]\n    [(= n 3) #f]\n    [(= n 4) #f]\n    [(= n 5) #f]\n    [(= n 6) #f]\n    [(= n 7) #f]\n    [(= n 8) #f]\n    [(= n 9) #f]\n    [else (and (is_undulating (quotient n 10))\n               (is_undulating (modulo n 10)))]))\n",
    "  (define (is_undulating-iter n)\n    (cond\n      [(= n 0) #t]\n      [(= n 1) #t]\n      [(= n 2) #t]\n      [(= n 3) #f]\n      [(= n 4) #t]\n      [(= n 5) #t]\n      [(= n 6) #t]\n      [(= n 7) #f]\n      [(= n 8) #t]\n      [(= n 9) #t]\n      [(= n 10) #t]\n      [(= n 11) #f]\n      [(= n 12) #t]\n      [(= n 13) #t]\n      [(= n 14) #t]\n      [(= n 15) #f]\n      [(= n 16) #t]\n      [(= n 17) #t]\n      [(= n 18) #t]\n      [(= n 19) #f]\n      [(= n 20) #t]\n      [(= n 21) #t]\n      [(= n 22) #t]\n      [(= n 23) #f]\n      [(= n 24) #t]\n      [(= n 25) #t]\n      [(= n 26) #t]\n      [(= n 27) #f]\n      [(= n 28) #t]\n      [(= n 29) #t]\n      [(= n 30) #t]\n      [(= n 31) #f]\n      [(= n 32) #t]\n      [(= n 33) #t]\n      [(= n 34) #t]\n      [(= n 35) #f]\n      [(= n 36) #t]\n      [(= n 37) #t]\n      [(= n 38) #t]\n      [(= n 39) #f]\n      [(= n 40) #t]\n      [(= n 41) #t]\n      [(= n 42) #t]\n      [(= n 43) #f]\n      [(= n 44) #t]\n      [(= n 45) #t]\n      [(= n 46) #t]\n      [(= n 47) #f]\n      [(= n 48) #t]\n      [(= n",
    "  (define (is-undulating-helper n)\n    (if (zero? n)\n        #t\n        (let* ([d1 (remainder n 10)]\n               [d2 (remainder (quotient n 10) 10)])\n          (if (or (= d1 d2) (= (abs (- d1 d2)) 2))\n              (is-undulating-helper (quotient n 10))\n              #f))))\n  (is-undulating-helper n))\n",
    "  (let loop ([n n] [prev-digit -1] [is-ascending? #t])\n    (cond [(zero? n) #t]\n          [(and (zero? prev-digit) (zero? (remainder n 10))) #f]\n          [(and (zero? prev-digit) (not (zero? (remainder n 10))))\n           (loop (quotient n 10) (remainder n 10) #t)]\n          [(and (not (zero? prev-digit)) (zero? (remainder n 10)))\n           (loop (quotient n 10) (remainder n 10) #f)]\n          [(and (not (zero? prev-digit)) (not (zero? (remainder n 10))))\n           (if (and (not (zero? prev-digit)) (not (zero? (remainder n 10))))\n               (if (and is-ascending? (&lt; (remainder n 10) prev-digit))\n                   (loop (quotient n 10) (remainder n 10) #f)\n                   (if (and (not is-ascending?) (&gt; (remainder n 10) prev-digit))\n                       (loop (quotient n 10) (remainder n 10) #t)\n                       #f))\n               #f)])))\n</code>\n",
    "  (define (undulating? n)\n    (let loop ([n n] [prev-digit 0])\n      (cond [(zero? n) #t]\n            [(= prev-digit (remainder n 10)) #f]\n            [else (loop (quotient n 10) (remainder n 10))])))\n  (undulating? n))\n",
    "  (let loop ((n (number->string n))\n             (prev #\\0)\n             (curr (string-ref n 0))\n             (next (string-ref n 1)))\n    (cond ((null? n) #t)\n          ((and (char=? prev curr) (char=? curr next)) #f)\n          (else (loop (substring n 1) curr next (string-ref n 2))))))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond\n      [(zero? n) #t]\n      [(and (zero? prev-diff) (zero? (modulo n 10))) (is_undulating-iter (quotient n 10) prev-digit prev-diff)]\n      [(and (zero? prev-diff) (not (zero? (modulo n 10)))) (is_undulating-iter (quotient n 10) (modulo n 10) prev-diff)]\n      [(and (not (zero? prev-diff)) (zero? (modulo n 10))) (is_undulating-iter (quotient n 10) prev-digit prev-diff)]\n      [(and (not (zero? prev-diff)) (not (zero? (modulo n 10))))\n       (let ((curr-digit (modulo n 10)))\n         (cond\n           [(= prev-digit curr-digit) (is_undulating-iter (quotient n 10) prev-digit prev-diff)]\n           [(= prev-digit (- curr-digit prev-diff)) (is_undulating-iter (quotient n 10) prev-digit (- curr-digit prev-diff))]\n           [else #f]))]))\n  (is_undulating-iter n 0 0))\n",
    "  (define (is-undulating-helper n)\n    (cond\n      [(zero? n) #t]\n      [(zero? (remainder n 10)) #f]\n      [(zero? (remainder (quotient n 10) 10)) #f]\n      [(zero? (remainder (quotient n 100) 10)) #f]\n      [else (is-undulating-helper (quotient n 10))]))\n  (is-undulating-helper n))\n",
    "  (let loop ((n (number->string n))\n             (prev-digit #\\0)\n             (prev-prev-digit #\\0))\n    (cond ((null? n) #t)\n          ((and (char=? (car n) prev-digit)\n                (char=? (car n) prev-prev-digit))\n           #f)\n          (else (loop (cdr n) (car n) prev-digit)))))\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond\n      [(zero? n3) #t]\n      [(= (modulo n1 10) (modulo n2 10)) (is_undulating-iter n2 n3 (- n3 1))]\n      [else #f]))\n  (is_undulating-iter n (- n 1) (- n 2)))\n",
    "  (let loop ((n n) (prev-digit -1) (prev-prev-digit -1) (undulating? #t))\n    (cond ((zero? n) undulating?)\n          ((and (= (modulo n 10) prev-digit)\n                (= (modulo n 10) prev-prev-digit))\n           (loop (quotient n 10) (modulo n 10) prev-digit #f))\n          (else (loop (quotient n 10) (modulo n 10) prev-digit undulating?)))))\n"
  ]
}