{
  "name": "mbpp_92_is_undulating",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to check whether the given number is undulating or not.\n(define (is_undulating n)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_92_is_undulating.py",
  "prompt_terminology": "reworded",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_undulating))\n    (check-equal? (candidate 1212121) #t)\n    (check-equal? (candidate 1991) #f)\n    (check-equal? (candidate 121) #t)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (is_undulating-iter n)\n    (if (zero? n)\n        #t\n        (let* ([d1 (modulo n 10)]\n               [n (quotient n 10)]\n               [d2 (modulo n 10)])\n          (if (and (not (zero? d1))\n                   (not (zero? d2))\n                   (or (= (abs (- d1 d2)) 1)\n                       (= (abs (- d1 d2)) 9)))\n              (is_undulating-iter (quotient n 10))\n              #f))))\n  (is_undulating-iter n))\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond\n      [(= n1 n2) (is-undulating-iter n2 n3 (remainder n3 10))]\n      [(= n2 n3) (is-undulating-iter n1 n2 (remainder n3 10))]\n      [(= n1 n3) (is-undulating-iter n1 n2 (remainder n3 10))]\n      [else #f]))\n  (is-undulating-iter (quotient n 100) (quotient n 10) (remainder n 10)))\n",
    "  (let loop ((n n) (prev-digit 0) (prev-diff 0) (undulating? #t))\n    (if (zero? n)\n        undulating?\n        (let* ((curr-digit (modulo n 10))\n               (curr-diff (- curr-digit prev-digit)))\n          (if (and (not (zero? prev-digit))\n                   (not (zero? prev-diff))\n                   (not (= curr-diff (* -1 prev-diff))))\n              (loop (quotient n 10) curr-digit curr-diff #f)\n              (loop (quotient n 10) curr-digit curr-diff undulating?))))))\n",
    "  (define (is_undulating-helper n)\n    (if (&lt; n 10)\n        #t\n        (let* ([d1 (modulo n 10)]\n               [d2 (modulo (quotient n 10) 10)])\n          (if (or (= d1 d2) (= (abs (- d1 d2)) 2))\n              (is_undulating-helper (quotient n 10))\n              #f))))\n  (is_undulating-helper n))\n",
    "  (let loop ((n (number->string n))\n             (prev-digit #\\0)\n             (prev-prev-digit #\\0)\n             (is-undulating #t))\n    (cond ((null? n) is-undulating)\n          ((and (char=? (car n) prev-digit)\n                (char=? (car n) prev-prev-digit))\n           (loop (cdr n) prev-digit prev-prev-digit #f))\n          ((char=? (car n) prev-digit)\n           (loop (cdr n) (car n) prev-digit #f))\n          (else (loop (cdr n) (car n) prev-digit is-undulating)))))\n",
    "  (let loop ((n n) (prev 0) (curr 0) (next 0) (count 0))\n    (cond ((zero? n) (= count 3))\n          ((= count 3) #t)\n          ((and (= prev curr) (= curr next))\n           (loop (quotient n 10) prev curr next (+ count 1)))\n          ((and (= prev curr) (< curr next))\n           (loop (quotient n 10) prev curr next (+ count 1)))\n          ((and (= prev curr) (> curr next))\n           (loop (quotient n 10) prev curr next (+ count 1)))\n          ((and (< prev curr) (= curr next))\n           (loop (quotient n 10) prev curr next (+ count 1)))\n          ((and (> prev curr) (= curr next))\n           (loop (quotient n 10) prev curr next (+ count 1)))\n          ((and (< prev curr) (< curr next))\n           (loop (quotient n 10) curr next (modulo n 10) (+ count 1)))\n          ((and (< prev curr) (> curr next))\n           (loop (quotient n 10) curr next (modulo n 10) (+ count 1)))\n          ((and (> prev curr) (< curr next))\n           (loop (quotient n 10) curr next (modulo n 10) (+ count 1)))\n          ((and (> prev curr) (> curr next))\n           (loop (quotient n 10) curr next (modulo n 10) (+ count 1)))\n          (else #f))))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (if (&lt; n 10)\n        #t\n        (let* ([cur-digit (modulo n 10)]\n               [cur-diff (- cur-digit prev-digit)])\n          (if (and (not (= cur-diff 0))\n                   (or (= cur-diff prev-diff)\n                       (= (- cur-diff) prev-diff)))\n              (is-undulating-iter (quotient n 10) cur-digit cur-diff)\n              #f))))\n  (is-undulating-iter n 0 0))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond\n      [(zero? n) #t]\n      [(and (zero? prev-diff)\n            (= (modulo n 10) prev-digit))\n       (is_undulating-iter (quotient n 10) prev-digit prev-diff)]\n      [(= (modulo n 10) (- prev-digit prev-diff))\n       (is_undulating-iter (quotient n 10) prev-digit (- prev-digit prev-diff))]\n      [else #f]))\n  (is_undulating-iter n (modulo n 10) 0))\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond ((= n1 n2) (is-undulating-iter n2 n3 (+ n3 1)))\n          ((= n2 n3) (is-undulating-iter n1 n2 (+ n3 1)))\n          ((= n1 n3) #f)\n          ((&gt; n3 n) #t)\n          (else (is-undulating-iter n2 n3 (+ n3 1)))))\n  (is-undulating-iter 1 2 3))\n</code>\n",
    "  (define (is_undulating-helper n)\n    (if (= n 0)\n        #f\n        (let* ([d1 (modulo n 10)]\n               [n (quotient n 10)]\n               [d2 (modulo n 10)])\n          (if (= d1 d2)\n              (is_undulating-helper (quotient n 10))\n              (if (and (= d1 (+ d2 1))\n                       (= d2 (+ d1 1)))\n                  (is_undulating-helper (quotient n 10))\n                  #f)))))\n  (is_undulating-helper n))\n",
    "  (let loop ((n (number->string n))\n             (prev-digit #\\0)\n             (prev-prev-digit #\\0))\n    (cond ((null? n) #t)\n          ((and (char=? (car n) prev-digit)\n                (char=? (car n) prev-prev-digit))\n           #f)\n          (else (loop (cdr n) (car n) prev-digit)))))\n",
    "  (define (is-undulating-helper n)\n    (cond\n      [(zero? n) #t]\n      [(< n 10) #f]\n      [(= (modulo (quotient n 10) 10) (- (modulo n 10))) (is-undulating-helper (quotient n 10))]\n      [else #f]))\n  (is-undulating-helper n))\n",
    "  (let loop ([n (number->string n)]\n             [prev (string-&gt;number (string-ref n 0))]\n             [i 1])\n    (cond [(empty? n) #t]\n          [(= i (string-length n)) #f]\n          [(= (string-&gt;number (string-ref n i)) prev) #f]\n          [else (loop (substring n 1)\n                      (string-&gt;number (string-ref n i))\n                      (+ i 1))])))\n",
    "  (define (is_undulating-helper n)\n    (cond\n      [(zero? n) #t]\n      [(zero? (remainder n 10)) #f]\n      [else (is-undulating-helper (quotient n 10))]))\n  (define (is-undulating-helper2 n)\n    (cond\n      [(zero? n) #t]\n      [(zero? (remainder n 10)) #f]\n      [else (is-undulating-helper2 (quotient n 10))]))\n  (and (is-undulating-helper n) (is-undulating-helper2 n)))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond [(zero? n) #t]\n          [(= (modulo n 10) prev-digit) #f]\n          [(= (modulo n 10) (- prev-digit prev-diff))\n           (is-undulating-iter (quotient n 10) (modulo n 10) (- prev-digit (modulo n 10)))]\n          [else (is-undulating-iter (quotient n 10) (modulo n 10) (- (modulo n 10) prev-digit))]))\n  (is-undulating-iter n -1 0))\n",
    "  (define (is_undulating-iter n)\n    (cond\n      [(zero? n) #t]\n      [(= (modulo n 10) (modulo (quotient n 10) 10)) (is_undulating-iter (quotient n 10))]\n      [else #f]))\n  (is_undulating-iter n))\n",
    "  (let loop ([n n] [prev-digit -1] [is-increasing? #t])\n    (cond [(zero? n) is-increasing?]\n          [(= prev-digit (remainder n 10))\n           (loop (quotient n 10) prev-digit is-increasing?)]\n          [(= prev-digit (- (remainder n 10)))\n           (loop (quotient n 10) prev-digit (not is-increasing?))]\n          [(= prev-digit (remainder n 10))\n           (loop (quotient n 10) prev-digit is-increasing?)]\n          [else #f])))\n",
    "  (let loop ([n n] [prev-digit -1] [prev-prev-digit -1])\n    (cond [(zero? n) #t]\n          [(= prev-digit (- (remainder n 10) (remainder (quotient n 10) 10)))\n           (loop (quotient n 10) prev-digit (- (remainder n 10) (remainder (quotient n 10) 10)))]\n          [else #f])))\n",
    "  (let loop ((n (number->string n))\n             (prev-digit (string->number (string-ref n 0)))\n             (i 1))\n    (cond ((= i (string-length n)) #t)\n          ((= (string->number (string-ref n i)) prev-digit) #f)\n          (else (loop n (string->number (string-ref n i)) (+ i 1))))))\n",
    "  (let loop ([n (number->string n)]\n             [prev-digit (string->number (substring n 0 1))]\n             [undulating? #t])\n    (if (empty? n)\n        undulating?\n        (let* ([curr-digit (string->number (substring n 0 1))]\n               [next-digit (string->number (substring n 1 1))])\n          (if (and (not (= prev-digit curr-digit))\n                   (not (= curr-digit next-digit)))\n              (loop (substring n 1) curr-digit undulating?)\n              #f)))))\n"
  ]
}