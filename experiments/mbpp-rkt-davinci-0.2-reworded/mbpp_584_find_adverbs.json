{
  "name": "mbpp_584_find_adverbs",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to find the first adverb ending with ly and its positions in a given string.\n(define (find_adverbs text)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_584_find_adverbs.py",
  "prompt_terminology": "reworded",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate find_adverbs))\n    (check-equal? (candidate \"Clearly, he has no excuse for such behavior.\") \"0-7: Clearly\")\n    (check-equal? (candidate \"Please handle the situation carefuly\") \"28-36: carefuly\")\n    (check-equal? (candidate \"Complete the task quickly\") \"18-25: quickly\")\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (let loop ([text text] [pos 0])\n    (cond\n      [(empty? text) '()]\n      [(regexp-match #rx\"ly$\" (first text)) (list (first text) pos)]\n      [else (loop (rest text) (+ 1 pos))])))\n",
    "  (let loop ([text text] [pos 0])\n    (cond [(empty? text) '()]\n          [(string-suffix? \"ly\" (first text))\n           (list (first text) pos)]\n          [else (loop (rest text) (+ 1 pos))])))\n",
    "  (regexp-match* #rx\"\\w+ly\" text))\n",
    "  (regexp-match* #rx\"\\w+ly\" text))\n",
    "  (regexp-match* #rx\"\\w+ly\" text))\n",
    "  (regexp-match* #rx\"\\w+ly\" text))\n",
    "  (regexp-match* #rx\"\\w+ly\" text))\n",
    "  (define (is_adverb word)\n    (and (string-suffix? \"ly\" word)\n         (not (string-suffix? \"ally\" word))\n         (not (string-suffix? \"ily\" word))))\n  (define (find_adverb words)\n    (cond ((null? words) '())\n          ((is_adverb (car words)) (list (car words) (list (string-index text (car words)))))\n          (else (find_adverb (cdr words)))))\n  (find_adverb (string-split text)))\n",
    "  (regexp-match* #rx\"\\w+ly\" text))\n",
    "  (regexp-match* #rx\"\\w+ly\" text))\n",
    "  (define (find_adverbs_helper text pos)\n    (cond\n      [(empty? text) '()]\n      [(regexp-match #rx\"ly$\" text) (cons (list (substring text 0 (regexp-match-end 0)) pos) (find_adverbs_helper (substring text (regexp-match-end 0)) (+ pos (regexp-match-end 0))))]\n      [else (find_adverbs_helper (substring text 1) (+ pos 1))]))\n  (find_adverbs_helper text 0))\n",
    "  (regexp-match* #rx\"\\w+ly\" text))\n",
    "  (define (is_adverb word)\n    (and (string-suffix? \"ly\" word)\n         (member word (string-tokenize text #\\space))))\n  (define (find_adverb text)\n    (cond ((is_adverb text) text)\n          ((string-empty? text) \"\")\n          (else (find_adverb (substring text 1)))))\n  (define (find_adverb_positions text)\n    (cond ((is_adverb text) (list 0))\n          ((string-empty? text) '())\n          (else (cons (+ (find_adverb_positions (substring text 1)) 1)\n                      (find_adverb_positions (substring text 1))))))\n  (list (find_adverb text) (find_adverb_positions text)))\n",
    "  (define (is-adverb? word)\n    (and (string-suffix? \"ly\" word)\n         (not (string-suffix? \"ally\" word))\n         (not (string-suffix? \"ally\" (substring word 0 (- (string-length word) 2))))))\n  (define (find-adverb-helper text adverbs)\n    (cond ((string-empty? text) adverbs)\n          ((is-adverb? text) (cons (list (substring text 0 (- (string-length text) 2)) 0) adverbs))\n          (else (find-adverb-helper (substring text 1)\n                                    (cond ((is-adverb? (substring text 0 (- (string-length text) 2)))\n                                           (cons (list (substring text 0 (- (string-length text) 2)) (- (string-length text) 2)) adverbs))\n                                          (else adverbs))))))\n  (find-adverb-helper text '()))\n</code>\nI'm not sure if this is the most efficient way to do it, but it works.\n",
    "  (let ([adverbs (regexp-match* #rx\"\\w+ly\" text)])\n    (for/list ([adverb (in-list adverbs)]\n               [pos (in-list (regexp-match-positions #rx\"\\w+ly\" text))])\n      (list adverb pos))))\n",
    "  (regexp-match* #rx\"\\w+ly\" text))\n",
    "  (regexp-match* #rx\"\\w+ly\" text))\n",
    "  (define (is_adverb? word)\n    (and (string-suffix? \"ly\" word)\n         (string-suffix? \"ly\" (string-downcase word))))\n  (define (find_adverb-helper text pos)\n    (cond ((string-empty? text) '())\n          ((is_adverb? text) (list pos))\n          (else (find-adverb-helper (string-tail text) (+ pos 1)))))\n  (find-adverb-helper text 0))\n",
    "  (define (is_adverb? word)\n    (and (string-suffix? \"ly\" word)\n         (string-suffix? \"ly\" (string-downcase word))))\n  (define (find_adverb text)\n    (cond ((null? text) '())\n          ((is_adverb? (car text)) (list (car text) (list (string-index text (car text)))))\n          (else (find_adverb (cdr text)))))\n  (find_adverb (string-split text)))\n",
    "  (let loop ([text text] [pos 0] [result '()])\n    (cond\n      [(empty? text) result]\n      [(regexp-match #rx\"ly$\" (first text))\n       (loop (rest text) (+ pos 1) (cons (list (first text) pos) result))]\n      [else (loop (rest text) (+ pos 1) result)])))\n"
  ]
}