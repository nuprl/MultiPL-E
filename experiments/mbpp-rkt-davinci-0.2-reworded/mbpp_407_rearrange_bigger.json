{
  "name": "mbpp_407_rearrange_bigger",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to create the next bigger number by rearranging the digits of a given number.\n(define (rearrange_bigger n)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_407_rearrange_bigger.py",
  "prompt_terminology": "reworded",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate rearrange_bigger))\n    (check-equal? (candidate 12) 21)\n    (check-equal? (candidate 10) #f)\n    (check-equal? (candidate 102) 120)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (rearrange-bigger-helper n)\n    (if (= n 0)\n        0\n        (let ([d (modulo n 10)])\n          (if (= d 0)\n              (rearrange-bigger-helper (quotient n 10))\n              (let ([n2 (quotient n 10)])\n                (if (= n2 0)\n                    (cons d n2)\n                    (let ([n3 (rearrange-bigger-helper n2)])\n                      (if (and (pair? n3)\n                               (< (car n3) d))\n                          (cons d (cons (car n3) (cdr n3)))\n                          (cons d n3)))))))))\n  (if (= n 0)\n      0\n      (let ([n2 (rearrange-bigger-helper n)])\n        (if (pair? n2)\n            (apply + (map (lambda (x) (* x (expt 10 (- (length n2) 1)))) n2))\n            n2))))\n",
    "  (let ([n-str (number->string n)])\n    (define (rearrange-bigger-helper n-str)\n      (let ([n-str-len (string-length n-str)])\n        (if (= n-str-len 1)\n            (string->number n-str)\n            (let ([n-str-last-char (string-ref n-str (- n-str-len 1))])\n              (let ([n-str-last-char-num (string->number n-str-last-char)])\n                (let ([n-str-last-char-num-1 (sub1 n-str-last-char-num)])\n                  (let ([n-str-last-char-num-1-str (number->string n-str-last-char-num-1)])\n                    (let ([n-str-last-char-num-1-str-len (string-length n-str-last-char-num-1-str)])\n                      (let ([n-str-last-char-num-1-str-len-1 (sub1 n-str-last-char-num-1-str-len)])\n                        (if (= n-str-last-char-num-1-str-len-1 0)\n                            (string->number n-str-last-char-num-1-str)\n                            (let ([n-str-last-char-num-1-str-last-char (string-ref n-str-last-char-num-1-str n-str-last-char-num-1-str-len-1)])\n                              (let ([n-str-last-char-num-1-str-last-char-num (string->number n-str-last-char-num-1-str-last-char)])\n                                (let ([n-str-last-char-num-1-str-last-char-num-1 (sub1 n-str-last-char-num-1-str-last-char-num)])\n                                  (let ([n-str-last-char-num-1-str-last-char-num-1-str (number->string n",
    "  (define (rearrange_bigger_helper n lst)\n    (cond\n      [(empty? lst) (error \"No bigger number\")]\n      [(> (first lst) n) (first lst)]\n      [else (rearrange_bigger_helper n (rest lst))]))\n  (rearrange_bigger_helper n (permutations (number->list n))))\n",
    "  (define (rearrange_bigger-iter n i)\n    (cond [(= i 0) n]\n          [else (let* ([d (modulo n (expt 10 i))]\n                       [n (quotient n (expt 10 i))])\n                  (if (and (not (= d 0))\n                           (&gt; d (modulo n (expt 10 (- i 1)))))\n                      (let ([n (+ (* n (expt 10 i))\n                                  (modulo n (expt 10 (- i 1)))\n                                  (* (- d (modulo n (expt 10 (- i 1))))\n                                     (expt 10 (- i 1))))])\n                        (rearrange_bigger-iter n (- i 1)))\n                      (rearrange_bigger-iter n (- i 1))))]))\n  (rearrange_bigger-iter n (exact-floor (log n 10))))\n",
    "  (define (rearrange-helper n i)\n    (if (= i (- (string-length n) 1))\n        (string-append n \"0\")\n        (let* ([n-i (string-ref n i)]\n               [n-i+1 (string-ref n (+ i 1))]\n               [n-i-1 (string-ref n (- i 1))]\n               [n-i-2 (string-ref n (- i 2))])\n          (if (and (char&gt;=? n-i-1 n-i)\n                   (char&gt;=? n-i+1 n-i))\n              (rearrange-helper n (+ i 1))\n              (let* ([n-i-1-index (string-index n n-i-1)]\n                     [n-i-2-index (string-index n n-i-2)]\n                     [n-i-1-index-new (+ n-i-1-index 1)]\n                     [n-i-2-index-new (+ n-i-2-index 1)]\n                     [n-i-1-new (string-ref n n-i-1-index-new)]\n                     [n-i-2-new (string-ref n n-i-2-index-new)]\n                     [n-i-1-new-index (string-index n n-i-1-new)]\n                     [n-i-2-new-index (string-index n n-i-2-new)])\n                (let ([n-i-1-new-index-new (+ n-i-1-new-index 1)]\n                      [n-i-2-new-index-new (+ n-i-2-new-index 1)])\n                  (string-append (substring n 0 n-i-1-index)\n                                 (string n-i-1-new)\n                                 (substring n n-i-1-index-new n-i-2-index)\n                                 (string n-i-2-new)\n                                 (substring n n-i-2-index-new))))))))\n  (rearrange-helper n 0))\n</code>\n",
    "  (define (swap lst i j)\n    (define (swap-helper lst i j)\n      (cond ((= i j) lst)\n            ((= i 0) (cons (list-ref lst j) (swap-helper (append (list-tail lst j) (list (list-ref lst i))) i (- j 1))))\n            (else (cons (list-ref lst i) (swap-helper (append (list-tail lst j) (list (list-ref lst i))) (- i 1) (- j 1))))))\n    (swap-helper lst (- (length lst) 1) (- j 1)))\n  (define (find-index lst i)\n    (cond ((= i 0) -1)\n          ((< (list-ref lst i) (list-ref lst (- i 1))) i)\n          (else (find-index lst (- i 1)))))\n  (define (find-swap-index lst i j)\n    (cond ((= j 0) -1)\n          ((> (list-ref lst i) (list-ref lst j)) j)\n          (else (find-swap-index lst i (- j 1)))))\n  (define (rearrange-bigger-helper lst i j)\n    (cond ((= i -1) -1)\n          ((= j -1) (rearrange-bigger-helper lst (- i 1) (- i 1)))\n          ((= (find-swap-index lst i j) -1) (rearrange-bigger-helper lst (- i 1) (- i 1)))\n          (else (swap lst i (find-swap-index lst i j)))))\n  (rearrange-bigger-helper (number->list n) (- (length (number->list n)) 1) (- (length (number->list n)) 1)))\n",
    "  (let loop ([n n] [i 0])\n    (if (= i (sub1 (string-length n)))\n        n\n        (let ([n (string->number (string-append (string-drop n i) (string-take n i)))])\n          (if (&lt; n (string->number n))\n              n\n              (loop n (add1 i)))))))\n</code>\n",
    "  (define (rearrange_bigger_helper n)\n    (if (zero? (modulo n 10))\n        (rearrange_bigger_helper (quotient n 10))\n        (list (modulo n 10) (quotient n 10))))\n  (define (rearrange_bigger_helper2 n)\n    (if (zero? (modulo n 10))\n        (rearrange_bigger_helper2 (quotient n 10))\n        (list (modulo n 10) (quotient n 10))))\n  (define (rearrange_bigger_helper3 n)\n    (if (zero? (modulo n 10))\n        (rearrange_bigger_helper3 (quotient n 10))\n        (list (modulo n 10) (quotient n 10))))\n  (define (rearrange_bigger_helper4 n)\n    (if (zero? (modulo n 10))\n        (rearrange_bigger_helper4 (quotient n 10))\n        (list (modulo n 10) (quotient n 10))))\n  (define (rearrange_bigger_helper5 n)\n    (if (zero? (modulo n 10))\n        (rearrange_bigger_helper5 (quotient n 10))\n        (list (modulo n 10) (quotient n 10))))\n  (define (rearrange_bigger_helper6 n)\n    (if (zero? (modulo n 10))\n        (rearrange_bigger_helper6 (quotient n 10))\n        (list (modulo n 10) (quotient n 10))))\n  (define (rearrange_bigger_helper7 n)\n    (if (zero? (modulo n 10))\n        (rearrange_bigger_helper7 (quotient n 10))\n        (list (modulo n 10) (quotient n 10))))\n  (define (rearrange_bigger_helper8 n)\n    (if (zero? (modulo n 10))\n        (rearrange_bigger_helper8 (qu",
    "  (let loop ([n n] [i (number->string n)] [j (number->string n)])\n    (if (not (string-ci=? i j))\n        (string->number j)\n        (loop n (number->string (add1 n)) (number->string (add1 n))))))\n",
    "  (define (rearrange_bigger_iter n i)\n    (if (= i (sub1 (string-length n)))\n        (string-append n (string (char-downcase (string-ref n 0))))\n        (let* ((digit (string-ref n i))\n               (next-digit (string-ref n (add1 i)))\n               (next-digit-upcase (char-upcase next-digit)))\n          (if (and (char-numeric? digit)\n                   (char-numeric? next-digit)\n                   (&gt; digit next-digit))\n              (string-append (substring n 0 i)\n                             (string next-digit-upcase)\n                             (string digit)\n                             (substring n (add1 (add1 i))))\n              (rearrange_bigger_iter n (add1 i))))))\n  (rearrange_bigger_iter n 0))\n",
    "  (define (rearrange_bigger_helper n)\n    (if (zero? n)\n        '(0)\n        (cons (modulo n 10) (rearrange_bigger_helper (quotient n 10)))))\n  (define (rearrange_bigger_helper2 n)\n    (if (zero? n)\n        '(0)\n        (cons (modulo n 10) (rearrange_bigger_helper2 (quotient n 10)))))\n  (define (rearrange_bigger_helper3 n)\n    (if (zero? n)\n        '(0)\n        (cons (modulo n 10) (rearrange_bigger_helper3 (quotient n 10)))))\n  (define (rearrange_bigger_helper4 n)\n    (if (zero? n)\n        '(0)\n        (cons (modulo n 10) (rearrange_bigger_helper4 (quotient n 10)))))\n  (define (rearrange_bigger_helper5 n)\n    (if (zero? n)\n        '(0)\n        (cons (modulo n 10) (rearrange_bigger_helper5 (quotient n 10)))))\n  (define (rearrange_bigger_helper6 n)\n    (if (zero? n)\n        '(0)\n        (cons (modulo n 10) (rearrange_bigger_helper6 (quotient n 10)))))\n  (define (rearrange_bigger_helper7 n)\n    (if (zero? n)\n        '(0)\n        (cons (modulo n 10) (rearrange_bigger_helper7 (quotient n 10)))))\n  (define (rearrange_bigger_helper8 n)\n    (if (zero? n)\n        '(0)\n        (cons (modulo n 10) (rearrange_bigger_helper8 (quotient n 10)))))\n  (define (rearrange_bigger_helper9 n)\n    (if (zero? n)\n        '(0)\n        (",
    "  (define (rearrange-bigger-helper n i)\n    (if (= i (sub1 (length n)))\n        (list->number n)\n        (let ([n-i (list-ref n i)])\n          (for/first ([j (in-range (add1 i) (length n))]\n                      #:when (and (< n-i (list-ref n j))\n                                  (not (zero? (modulo (list->number (sublist n i)) 10))))\n                      #:break (list->number (append (sublist n 0 i)\n                                                    (list (list-ref n j))\n                                                    (sort (append (list n-i)\n                                                                  (sublist n (add1 i) j)\n                                                                  (sublist n (add1 j))))\n                                                          <)))]\n            j))))\n  (rearrange-bigger-helper (number->list n) 0))\n",
    "  (let loop ([n n] [i (number->string n)])\n    (cond [(empty? i) n]\n          [else (let* ([i (string->list i)]\n                       [j (last i)]\n                       [i (butlast i)]\n                       [k (find-first-bigger j i)]\n                       [i (insert-at k j i)])\n                  (loop (string->number (list->string i)) i))])))\n",
    "  (define (rearrange-bigger-helper n d)\n    (if (zero? d)\n        n\n        (let* ([d (modulo n 10)]\n               [n (quotient n 10)]\n               [n (rearrange-bigger-helper n d)])\n          (if (zero? n)\n              d\n              (let* ([n (modulo n 10)]\n                     [n (quotient n 10)])\n                (if (&lt; d n)\n                    (let* ([n (+ (* n 10) d)]\n                           [n (+ (* n 10) n)])\n                      (rearrange-bigger-helper n d))\n                    (rearrange-bigger-helper (+ (* n 10) d) d)))))))\n  (rearrange-bigger-helper n (modulo n 10)))\n</code>\n",
    "  (define (rearrange_bigger_helper n i)\n    (cond\n      [(= i 0) n]\n      [(> (quotient n (expt 10 i)) (quotient n (expt 10 (+ i 1))))\n       (rearrange_bigger_helper (+ n (* (- (quotient n (expt 10 i)) (quotient n (expt 10 (+ i 1)))) (expt 10 (+ i 1)))) (- i 1))]\n      [else (rearrange_bigger_helper n (- i 1))]))\n  (rearrange_bigger_helper n (- (number->string n) 1)))\n",
    "  (define (rearrange_bigger_helper n i)\n    (if (= i (- (string-length n) 1))\n        n\n        (let* ((n-i (string-ref n i))\n               (n-i+1 (string-ref n (+ i 1)))\n               (n-i+1-index (+ i 1)))\n          (if (&gt; n-i n-i+1)\n              (let* ((n-i+1-index (+ i 1))\n                     (n-i+1-index-char (string-ref n n-i+1-index))\n                     (n-i-index i)\n                     (n-i-index-char (string-ref n n-i-index))\n                     (n-i+1-index-char-index (string-index n n-i+1-index-char))\n                     (n-i-index-char-index (string-index n n-i-index-char)))\n                (string-set! n n-i-index-char-index n-i+1-index-char)\n                (string-set! n n-i+1-index-char-index n-i-index-char)\n                (rearrange_bigger_helper n (+ i 1)))\n              (rearrange_bigger_helper n (+ i 1))))))\n  (rearrange_bigger_helper (number-&gt;string n) 0))\n",
    "  (define (rearrange_bigger-helper n i)\n    (cond ((= i 0) n)\n          ((&gt; (modulo n (expt 10 i)) (modulo n (expt 10 (- i 1))))\n           (rearrange_bigger-helper (modulo n (expt 10 (- i 1))) (- i 1)))\n          (else (rearrange_bigger-helper (modulo n (expt 10 (- i 1))) (- i 1)))))\n  (rearrange_bigger-helper n (floor (log n 10))))\n</code>\n",
    "  (let loop ([n n] [digits (string->list (number->string n))] [i (length digits)])\n    (cond [(= i 1) n]\n          [(< (list-ref digits (- i 1)) (list-ref digits (- i 2)))\n           (loop (string->number (list->string (sort (reverse (list-ref digits (- i 1)) (sublist digits 0 (- i 1)))))\n                    (sublist digits 0 (- i 1)) (- i 1)))]\n          [else (loop n (sublist digits 0 (- i 1)) (- i 1))])))\n",
    "  (define (rearrange_bigger_helper n)\n    (cond\n      [(empty? n) empty]\n      [(= (first n) 9) (cons (first n) (rearrange_bigger_helper (rest n)))]\n      [else (cons (first n) (rearrange_bigger_helper (rest n)))]))\n  (rearrange_bigger_helper (list->string n)))\n",
    "  (define (rearrange_bigger_helper n i)\n    (if (= i 0)\n        n\n        (let* ([n-str (number->string n)]\n               [n-str-len (string-length n-str)]\n               [n-str-i (string-ref n-str (- n-str-len i))]\n               [n-str-i-1 (string-ref n-str (- n-str-len (+ i 1)))])\n          (if (> n-str-i n-str-i-1)\n              (let* ([n-str-i-1-index (- n-str-len (+ i 1))]\n                     [n-str-i-index (- n-str-len i)]\n                     [n-str-i-1-index-char (string-ref n-str n-str-i-1-index)]\n                     [n-str-i-index-char (string-ref n-str n-str-i-index)]\n                     [n-str-i-1-index-char-num (string->number n-str-i-1-index-char)]\n                     [n-str-i-index-char-num (string->number n-str-i-index-char)]\n                     [n-str-i-1-index-char-num-swapped (- n-str-i-index-char-num n-str-i-1-index-char-num)]\n                     [n-str-i-index-char-num-swapped (- n-str-i-1-index-char-num n-str-i-1-index-char-num-swapped)]\n                     [n-str-i-1-index-char-num-swapped-str (number->string n-str-i-1-index-char-num-swapped)]\n                     [n-str-i-index-char-num-swapped-str (number->string n-str-i-index-char-num-swapped)]\n                     [n-str-i-1-index-char-num-swapped-str-len (string-length n-str-i-1-index-char-num-swapped-str)]\n                    ",
    "  (define (rearrange_bigger-helper n i)\n    (cond\n      [(= i (- (string-length n) 1)) #f]\n      [(< (string-ref n i) (string-ref n (+ i 1)))\n       (string-append (substring n 0 i)\n                      (substring n (+ i 1) (+ i 2))\n                      (substring n i (+ i 1))\n                      (substring n (+ i 2)))]\n      [else (rearrange_bigger-helper n (+ i 1))]))\n  (rearrange_bigger-helper n 0))\n",
    "  (define (rearrange-helper n i)\n    (if (= i 0)\n        (list n)\n        (let* ([d (modulo n 10)]\n               [n (quotient n 10)]\n               [m (rearrange-helper n (- i 1))])\n          (if (and (not (null? m))\n                   (&gt; d (car m)))\n              (cons d m)\n              (cons (car m) (cons d (cdr m)))))))\n  (define (digits n)\n    (if (= n 0)\n        0\n        (+ (digits (quotient n 10)) 1)))\n  (define (rearrange-to-number l)\n    (if (null? l)\n        0\n        (+ (* (car l) (expt 10 (length l)))\n           (rearrange-to-number (cdr l)))))\n  (rearrange-to-number (rearrange-helper n (digits n))))\n",
    "  (define (rearrange-bigger-helper n)\n    (let loop ([n (number->string n)] [i (sub1 (string-length n))])\n      (if (= i 0)\n          (string->number (string-append (substring n 0 1) (substring n 1)))\n          (if (< (string-ref n i) (string-ref n (sub1 i)))\n              (string->number (string-append (substring n 0 i) (substring n (add1 i)) (string-ref n i) (substring n (add1 i))))\n              (loop n (sub1 i))))))\n  (if (= n (rearrange-bigger-helper n))\n      -1\n      (rearrange-bigger-helper n)))\n",
    "  (let loop ((n (number->string n))\n             (i (sub1 (string-length n))))\n    (cond ((= i 0) (string->number n))\n          ((< (string-ref n i) (string-ref n (sub1 i)))\n           (let ((j (sub1 i)))\n             (do ((j j (- j 1)))\n                 ((>= j 0) (void))\n               (when (>= (string-ref n j) (string-ref n i))\n                 (set! j (sub1 j))))\n             (let ((tmp (string-ref n i)))\n               (string-set! n i (string-ref n j))\n               (string-set! n j tmp))\n             (let ((tmp (substring n (+ i 1))))\n               (string-set! n (+ i 1) #\\0)\n               (string-append n (string-sort tmp string<?))))))\n          (else (loop n (sub1 i))))))\n",
    "  (define (rearrange-helper n i)\n    (if (= i (sub1 (string-length n)))\n        (string-append n \"0\")\n        (let ((next-digit (add1 (string-ref n i))))\n          (if (or (= next-digit #\\0)\n                  (= next-digit #\\9))\n              (rearrange-helper n (add1 i))\n              (string-append (substring n 0 i)\n                             (string next-digit)\n                             (substring n (add1 i)))))))\n  (rearrange-helper n 0))\n</code>\n",
    "  (cond\n    [(= n 0) #f]\n    [(= n 1) #f]\n    [(= n 2) #f]\n    [(= n 3) #f]\n    [(= n 4) #f]\n    [(= n 5) #f]\n    [(= n 6) #f]\n    [(= n 7) #f]\n    [(= n 8) #f]\n    [(= n 9) #f]\n    [else (rearrange_bigger (quotient n 10))]))\n",
    "  (define (rearrange_bigger_iter n i)\n    (if (= i (sub1 (string-length n)))\n        n\n        (let* ([n (string->number n)]\n               [n-i (string-ref n i)]\n               [n-i+1 (string-ref n (add1 i))])\n          (if (&gt; n-i n-i+1)\n              (let* ([n-i+1 (number-&gt;string n-i+1)]\n                     [n-i (number-&gt;string n-i)]\n                     [n (number-&gt;string n)])\n                (string-append (substring n 0 i) n-i+1 n-i (substring n (+ i 2))))\n              (rearrange_bigger_iter n (add1 i))))))\n  (rearrange_bigger_iter (number-&gt;string n) 0))\n</code>\n",
    "  (define (rearrange_bigger_helper n i)\n    (if (zero? i)\n        n\n        (let* ([i (sub1 i)]\n               [n (integer->list n)]\n               [i-th (list-ref n i)]\n               [j (find-next-bigger-index n i)])\n          (if (zero? j)\n              (rearrange_bigger_helper n i)\n              (let* ([j-th (list-ref n j)]\n                     [n (swap n i j)])\n                (rearrange_bigger_helper (list->integer n) i))))))\n  (rearrange_bigger_helper n (sub1 (integer-length n))))\n",
    "  (define (rearrange_bigger_helper n i)\n    (cond\n      [(= i (- (string-length n) 1)) n]\n      [(< (string-ref n i) (string-ref n (+ i 1)))\n       (string-append (substring n 0 i)\n                      (string-append (string-append (string-ref n (+ i 1)) (string-ref n i))\n                                     (substring n (+ i 2) (string-length n))))]\n      [else (rearrange_bigger_helper n (+ i 1))]))\n  (rearrange_bigger_helper (number->string n) 0))\n",
    "  (define (rearrange_bigger_helper n acc)\n    (if (zero? n)\n        acc\n        (rearrange_bigger_helper (quotient n 10) (cons (remainder n 10) acc))))\n  (define (rearrange_bigger_helper2 n acc)\n    (if (zero? n)\n        acc\n        (rearrange_bigger_helper2 (quotient n 10) (cons (remainder n 10) acc))))\n  (define (rearrange_bigger_helper3 n acc)\n    (if (zero? n)\n        acc\n        (rearrange_bigger_helper3 (quotient n 10) (cons (remainder n 10) acc))))\n  (define (rearrange_bigger_helper4 n acc)\n    (if (zero? n)\n        acc\n        (rearrange_bigger_helper4 (quotient n 10) (cons (remainder n 10) acc))))\n  (define (rearrange_bigger_helper5 n acc)\n    (if (zero? n)\n        acc\n        (rearrange_bigger_helper5 (quotient n 10) (cons (remainder n 10) acc))))\n  (define (rearrange_bigger_helper6 n acc)\n    (if (zero? n)\n        acc\n        (rearrange_bigger_helper6 (quotient n 10) (cons (remainder n 10) acc))))\n  (define (rearrange_bigger_helper7 n acc)\n    (if (zero? n)\n        acc\n        (rearrange_bigger_helper7 (quotient n 10) (cons (remainder n 10) acc))))\n  (define (rearrange_bigger_helper8 n acc)\n    (if (zero? n)\n        acc\n        (rearrange_bigger_helper8 (quotient n 10) (cons (remainder n 10) acc))))\n  (define (rearrange_bigger_helper9 n acc)\n    (if (zero? n",
    "  (define (rearrange-bigger-helper n)\n    (define (rearrange-bigger-helper-helper n)\n      (define (rearrange-bigger-helper-helper-helper n)\n        (define (rearrange-bigger-helper-helper-helper-helper n)\n          (define (rearrange-bigger-helper-helper-helper-helper-helper n)\n            (define (rearrange-bigger-helper-helper-helper-helper-helper-helper n)\n              (define (rearrange-bigger-helper-helper-helper-helper-helper-helper-helper n)\n                (define (rearrange-bigger-helper-helper-helper-helper-helper-helper-helper-helper n)\n                  (define (rearrange-bigger-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                    (define (rearrange-bigger-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                      (define (rearrange-bigger-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                        (define (rearrange-bigger-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                          (define (rearrange-bigger-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                            (define (rearrange-bigger-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                              (define (rearrange-bigger-",
    "  (define (rearrange_bigger-helper n i)\n    (if (= i 0)\n        (rearrange_bigger-helper n (- i 1))\n        (let* ([n-str (number->string n)]\n               [n-str-len (string-length n-str)]\n               [n-str-i (string-ref n-str i)]\n               [n-str-i-1 (string-ref n-str (- i 1))]\n               [n-str-i-1-int (string-&gt;number n-str-i-1)]\n               [n-str-i-int (string-&gt;number n-str-i)])\n          (if (&lt; n-str-i-1-int n-str-i-int)\n              (let* ([n-str-i-1-int-str (number-&gt;string n-str-i-1-int)]\n                     [n-str-i-int-str (number-&gt;string n-str-i-int)]\n                     [n-str-i-1-int-str-len (string-length n-str-i-1-int-str)]\n                     [n-str-i-int-str-len (string-length n-str-i-int-str)]\n                     [n-str-i-1-int-str-len-1 (- n-str-i-1-int-str-len 1)]\n                     [n-str-i-int-str-len-1 (- n-str-i-int-str-len 1)]\n                     [n-str-i-1-int-str-len-1-str (number-&gt;string n-str-i-1-int-str-len-1)]\n                     [n-str-i-int-str-len-1-str (number-&gt;string n-str-i-int-str-len-1-str)]\n                     [n-str-i-1-int-str-len-1-str-int (string-&gt;number n-str-i-1-int-str-len-1-str)]\n                     [n-str-i-",
    "  (let* ([n-str (number->string n)]\n         [n-str-len (string-length n-str)]\n         [n-str-rev (reverse n-str)]\n         [n-str-rev-len (string-length n-str-rev)]\n         [n-str-rev-lst (string->list n-str-rev)]\n         [n-str-rev-lst-len (length n-str-rev-lst)]\n         [n-str-rev-lst-rev (reverse n-str-rev-lst)]\n         [n-str-rev-lst-rev-len (length n-str-rev-lst-rev)])\n    (let loop ([i 0] [j 0])\n      (cond\n        [(= i (- n-str-rev-lst-len 1)) (string->number (list->string n-str-rev-lst-rev))]\n        [(> (list-ref n-str-rev-lst-rev i) (list-ref n-str-rev-lst-rev (+ i 1)))\n         (let* ([tmp (list-ref n-str-rev-lst-rev i)]\n                [tmp2 (list-ref n-str-rev-lst-rev (+ i 1))]\n                [tmp3 (list-ref n-str-rev-lst-rev (+ i 2))]\n                [tmp4 (list-ref n-str-rev-lst-rev (+ i 3))])\n           (set! (list-ref n-str-rev-lst-rev i) tmp2)\n           (set! (list-ref n-str-rev-lst-rev (+ i 1)) tmp)\n           (set! (list-ref n-str-rev-lst-rev (+ i 2)) tmp3)\n           (set! (list-ref n-str-rev-lst-rev (+ i 3)) tmp4)\n           (string->number (list->string n-str-rev-lst-rev)))]\n        [else (loop (+ i 1) (+ j 1))]))))\n",
    "  (define (next-bigger-number n)\n    (if (zero? n)\n        0\n        (let* ([d (remainder n 10)]\n               [n (quotient n 10)]\n               [n (next-bigger-number n)])\n          (if (zero? n)\n              (if (zero? d)\n                  0\n                  (* 10 d))\n              (let* ([d2 (remainder n 10)]\n                     [n (quotient n 10)])\n                (if (&lt; d d2)\n                    (+ (* 10 d) (+ (* 100 d2) n))\n                    (+ (* 10 d2) (+ (* 100 d) n)))))))))\n  (let ([n (next-bigger-number n)])\n    (if (zero? n)\n        -1\n        n)))\n",
    "  (define (rearrange_bigger-helper n i)\n    (if (= i (- (string-length n) 1))\n        (string-append n (string (char-upcase (string-ref n 0))))\n        (let ((next-char (string-ref n (+ i 1))))\n          (if (char-numeric? next-char)\n              (if (&gt; (char-&gt;integer next-char) (char-&gt;integer (string-ref n i)))\n                  (string-append (substring n 0 i) (string (char-upcase next-char)) (substring n (+ i 2) (string-length n)))\n                  (rearrange_bigger-helper n (+ i 1)))\n              (if (&gt; (char-&gt;integer (char-upcase next-char)) (char-&gt;integer (string-ref n i)))\n                  (string-append (substring n 0 i) (string (char-upcase next-char)) (substring n (+ i 2) (string-length n)))\n                  (rearrange_bigger-helper n (+ i 1)))))))\n  (rearrange_bigger-helper n 0))\n",
    "  (define (rearrange_bigger_iter n acc)\n    (if (zero? n)\n        (reverse acc)\n        (let* ([d (modulo n 10)]\n               [n (quotient n 10)])\n          (rearrange_bigger_iter n (cons d acc)))))\n  (rearrange_bigger_iter n '()))\n",
    "  (define (rearrange-helper n lst)\n    (if (null? lst)\n        n\n        (let* ([i (car lst)]\n               [rest (cdr lst)]\n               [j (car rest)]\n               [rest2 (cdr rest)])\n          (if (and (not (null? j))\n                   (&lt; i j))\n              (rearrange-helper (string-append (substring n 0 (- (string-length n) (length rest)))\n                                                (number-&gt;string j)\n                                                (number-&gt;string i)\n                                                (string-append rest2))\n                                rest2)\n              (rearrange-helper n rest)))))\n  (rearrange-helper n (string-&gt;list (number-&gt;string n))))\n",
    "  (define (rearrange_bigger-helper n i)\n    (if (= i 0)\n        n\n        (let* ([d (modulo n (expt 10 i))]\n               [n (quotient n (expt 10 i))]\n               [n (if (= d 0) n (add1 n))]\n               [n (if (= n 10) (add1 (rearrange_bigger-helper n (sub1 i))) n)])\n          (if (= n 10)\n              -1\n              (add (multiply d (expt 10 i)) (rearrange_bigger-helper n (sub1 i)))))))\n  (rearrange_bigger-helper n (number->string n |> string-length)))\n",
    "  (let ([n (number->string n)]\n        [n (string->list n)])\n    (let loop ([n n]\n               [i (sub1 (length n))])\n      (cond [(= i 0) #f]\n            [(> (list-ref n i) (list-ref n (sub1 i)))\n             (let ([j (sub1 i)])\n               (let loop ([j j])\n                 (cond [(> (list-ref n j) (list-ref n i))\n                        (let ([tmp (list-ref n j)])\n                          (set-car! (list-ref n j) (list-ref n i))\n                          (set-car! (list-ref n i) tmp))\n                        (let ([tmp (list-ref n i)])\n                          (set-car! (list-ref n i) (list-ref n (sub1 i)))\n                          (set-car! (list-ref n (sub1 i)) tmp))\n                        (let ([tmp (list-ref n (sub1 i))])\n                          (set-car! (list-ref n (sub1 i)) (list-ref n j))\n                          (set-car! (list-ref n j) tmp))\n                        (let ([tmp (list-ref n j)])\n                          (set-car! (list-ref n j) (list-ref n i))\n                          (set-car! (list-ref n i) tmp))\n                        (let ([tmp (list-ref n i)])\n                          (set-car! (list-ref n i) (list-ref n (sub1 i)))\n                          (set-car! (list-ref n (sub1 i)) tmp))\n                        (let ([tmp (list-ref n (sub1 i))])\n                          (set-car! (list-ref n (sub1 i)) (list-ref n j))\n                          (set-car! (list-ref n j) tmp))\n                        (let ([tmp (list-ref n j)])\n                          (set-car! (list-ref n j) (list-ref n i))\n                          (set-car! (list-ref n i) tmp",
    "  (define (rearrange_bigger_helper n i)\n    (cond\n      [(= i (- (string-length n) 1)) #f]\n      [(> (string-ref n i) (string-ref n (+ i 1)))\n       (string-append (substring n 0 i)\n                      (string-append (list (string-ref n (+ i 1)))\n                                     (list (string-ref n i)))\n                      (substring n (+ i 2)))]\n      [else (rearrange_bigger_helper n (+ i 1))]))\n  (rearrange_bigger_helper (number->string n) 0))\n",
    "  (let ([digits (string->list (number->string n))])\n    (if (null? (cdr digits))\n        n\n        (let ([i (find-first-decreasing-index digits)])\n          (if (negative? i)\n              n\n              (let ([j (find-first-larger-index digits i)])\n                (let ([tmp (list-ref digits i)])\n                  (set-car! (list-ref digits i) (list-ref digits j))\n                  (set-car! (list-ref digits j) tmp))\n                (let ([sorted-tail (sort (sublist digits (+ i 1)) <)])\n                  (set-cdr! (list-ref digits i) sorted-tail)\n                  (string->number (list->string digits))))))))))\n",
    "  (define (rearrange-bigger-helper n i)\n    (if (= i (sub1 (string-length n)))\n        (string-&gt;number n)\n        (let* ([n (string-&gt;number n)]\n               [n-str (number-&gt;string n)]\n               [i-str (string (string-ref n-str i))]\n               [i-num (string-&gt;number i-str)]\n               [j-num (rearrange-bigger-helper n (add1 i))])\n          (if (&lt; i-num j-num)\n              (string-&gt;number (string-append (substring n-str 0 i)\n                                              (number-&gt;string j-num)\n                                              (number-&gt;string i-num)\n                                              (substring n-str (add1 i))))\n              (rearrange-bigger-helper n (add1 i))))))\n  (rearrange-bigger-helper (number-&gt;string n) 0))\n</code>\n",
    "  (define (rearrange-bigger-helper n i)\n    (if (= i 0)\n        n\n        (let* ([n-str (number->string n)]\n               [n-str-len (string-length n-str)]\n               [n-str-i (string-ref n-str i)]\n               [n-str-i-1 (string-ref n-str (- i 1))])\n          (if (< n-str-i n-str-i-1)\n              (let* ([n-str-i-1-index (string-index n-str n-str-i-1)]\n                     [n-str-i-1-index-1 (string-index n-str n-str-i-1 (- n-str-i-1-index))]\n                     [n-str-i-1-index-1-index (string-index n-str n-str-i-1-index-1 (- n-str-i-1-index-1))]\n                     [n-str-i-1-index-1-index-1 (string-index n-str n-str-i-1-index-1-index (- n-str-i-1-index-1-index))]\n                     [n-str-i-1-index-1-index-1-index (string-index n-str n-str-i-1-index-1-index-1 (- n-str-i-1-index-1-index-1))]\n                     [n-str-i-1-index-1-index-1-index-1 (string-index n-str n-str-i-1-index-1-index-1-index (- n-str-i-1-index-1-index-1-index))]\n                     [n-str-i-1-index-1-index-1-index-1-index (string-index n-str n-str-i-1-index-1-index-1-index-1 (- n-str-i-1-index-1-index-1-index-1))]\n                     [n-str-i-1-index-1-index-1-index-1-index-1",
    "  (let loop ([n (number->string n)]\n             [i (sub1 (string-length n))])\n    (cond [(= i 0) #f]\n          [(> (string-ref n i) (string-ref n (sub1 i)))\n           (let ([j (sub1 i)])\n             (let loop ([j j])\n               (cond [(> (string-ref n j) (string-ref n i))\n                      (let ([tmp (string-ref n j)])\n                        (string-set! n j (string-ref n i))\n                        (string-set! n i tmp))\n                      (let loop ([k (add1 i)])\n                        (cond [(> k j) (string->number n)]\n                              [else (let ([tmp (string-ref n k)])\n                                      (string-set! n k (string-ref n j))\n                                      (string-set! n j tmp)\n                                      (loop (add1 k)))]))]\n                     [else (loop (sub1 j))]))]\n          [else (loop n (sub1 i))]))))\n",
    "  (define (rearrange_bigger_helper n i)\n    (if (= i (- (string-length n) 1))\n        n\n        (let* ([n-i (string-ref n i)]\n               [n-i+1 (string-ref n (+ i 1))])\n          (if (&lt; n-i n-i+1)\n              (let* ([n-i+1-index (string-index n n-i+1)]\n                     [n-i-index i]\n                     [n-i+1-index-char (string-ref n n-i+1-index)]\n                     [n-i-index-char (string-ref n n-i-index)])\n                (string-set! n n-i-index-char n-i+1-index-char)\n                (string-set! n n-i+1-index-char n-i-index-char)\n                (string-append (substring n 0 (+ i 1))\n                               (sort (substring n (+ i 1)) &lt;)\n                               (substring n (+ i 1))))\n              (rearrange_bigger_helper n (+ i 1)))))))\n  (rearrange_bigger_helper (number-&gt;string n) 0))\n",
    "  (define (rearrange_bigger_helper n l)\n    (if (null? l)\n        n\n        (let ([m (car l)])\n          (if (&gt; m n)\n              m\n              (rearrange_bigger_helper n (cdr l))))))\n  (rearrange_bigger_helper n (sort (string-&gt;list (number-&gt;string n)) &lt;)))\n</code>\n",
    "  (define (rearrange-bigger-helper n)\n    (if (zero? n)\n        '()\n        (cons (modulo n 10) (rearrange-bigger-helper (quotient n 10)))))\n  (define (rearrange-bigger-helper2 lst)\n    (if (null? lst)\n        0\n        (+ (* (car lst) (expt 10 (length lst))) (rearrange-bigger-helper2 (cdr lst)))))\n  (rearrange-bigger-helper2 (sort (rearrange-bigger-helper n) >)))\n",
    "  (define (rearrange_bigger_helper n l)\n    (if (null? l)\n        n\n        (let* ([n (number->string n)]\n               [n (string->list n)]\n               [n (sort n <)]\n               [n (list->string n)]\n               [n (string->number n)])\n          (if (< n l)\n              (rearrange_bigger_helper n (next-permutation n))\n              n))))\n  (rearrange_bigger_helper n n))\n",
    "  (let ([digits (string->list (number->string n))])\n    (let ([next-bigger (find-next-bigger digits)])\n      (if next-bigger\n          (string->number (list->string next-bigger))\n          -1))))\n",
    "  (define (rearrange-bigger-helper n i)\n    (if (&lt; i (sub1 (string-length n)))\n        (let* ([n (string-&gt;number n)]\n               [i (string-&gt;number (string-append (string-&gt;list (substring n i (add1 i))) (string-&gt;list (substring n (add1 i) (add2 i)))))]\n               [j (string-&gt;number (string-append (string-&gt;list (substring n (add1 i) (add2 i))) (string-&gt;list (substring n i (add1 i)))))]\n               [k (string-&gt;number (string-append (string-&gt;list (substring n (add2 i) (add3 i))) (string-&gt;list (substring n i (add2 i)))))]\n               [l (string-&gt;number (string-append (string-&gt;list (substring n (add3 i) (add4 i))) (string-&gt;list (substring n i (add3 i)))))]\n               [m (string-&gt;number (string-append (string-&gt;list (substring n (add4 i) (add5 i))) (string-&gt;list (substring n i (add4 i)))))]\n               [o (string-&gt;number (string-append (string-&gt;list (substring n (add5 i) (add6 i))) (string-&gt;list (substring n i (add5 i)))))]\n               [p (string-&gt;number (string-append (string-&gt;list (substring n (add6 i) (add7 i))) (string-&gt;list (substring n i (add6 i)))))]\n               [q (string-&gt;number (string-append (string-&gt;list (substring n (add7 i) (add8 i))) (string-&gt;list (substring n i (add7 i)))))]\n               [r (string-&gt;number (string-append (string-&gt;list (substring n (add8 i",
    "  (define (rearrange-bigger-helper n)\n    (define (rearrange-bigger-helper-helper n)\n      (define (rearrange-bigger-helper-helper-helper n)\n        (define (rearrange-bigger-helper-helper-helper-helper n)\n          (define (rearrange-bigger-helper-helper-helper-helper-helper n)\n            (define (rearrange-bigger-helper-helper-helper-helper-helper-helper n)\n              (define (rearrange-bigger-helper-helper-helper-helper-helper-helper-helper n)\n                (define (rearrange-bigger-helper-helper-helper-helper-helper-helper-helper-helper n)\n                  (define (rearrange-bigger-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                    (define (rearrange-bigger-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                      (define (rearrange-bigger-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                        (define (rearrange-bigger-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                          (define (rearrange-bigger-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                            (define (rearrange-bigger-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                              (define (rearrange-bigger-",
    "  (define (rearrange_bigger_helper n i)\n    (if (= i 0)\n        n\n        (let* ([n-i (modulo n (expt 10 i))]\n               [n-i-1 (modulo n (expt 10 (- i 1)))])\n          (if (&gt; n-i-1 n-i)\n              (let* ([n-i-1-1 (modulo n (expt 10 (- i 2)))]\n                     [n-i-1-1-1 (modulo n (expt 10 (- i 3)))]\n                     [n-i-1-1-1-1 (modulo n (expt 10 (- i 4)))]\n                     [n-i-1-1-1-1-1 (modulo n (expt 10 (- i 5)))]\n                     [n-i-1-1-1-1-1-1 (modulo n (expt 10 (- i 6)))]\n                     [n-i-1-1-1-1-1-1-1 (modulo n (expt 10 (- i 7)))]\n                     [n-i-1-1-1-1-1-1-1-1 (modulo n (expt 10 (- i 8)))]\n                     [n-i-1-1-1-1-1-1-1-1-1 (modulo n (expt 10 (- i 9)))]\n                     [n-i-1-1-1-1-1-1-1-1-1-1 (modulo n (expt 10 (- i 10)))]\n                     [n-i-1-1-1-1-1-1-1-1-1-1-1 (modulo n (expt 10 (- i 11)))]\n                     [n-i-1-1-1-1-1-1-1-1-1-1-1-1 (modulo n (expt 10 (- i 12)))]\n                     [n-i-1-1-1-1-1-1-1-1-1-1-1-1-1 (modulo n (expt 10 (- i 13)))]\n                     [n-i-1-1-1-1-1",
    "  (define (rearrange_bigger_helper n)\n    (define (rearrange_bigger_helper_helper n)\n      (define (rearrange_bigger_helper_helper_helper n)\n        (define (rearrange_bigger_helper_helper_helper_helper n)\n          (define (rearrange_bigger_helper_helper_helper_helper_helper n)\n            (define (rearrange_bigger_helper_helper_helper_helper_helper_helper n)\n              (define (rearrange_bigger_helper_helper_helper_helper_helper_helper_helper n)\n                (define (rearrange_bigger_helper_helper_helper_helper_helper_helper_helper_helper n)\n                  (define (rearrange_bigger_helper_helper_helper_helper_helper_helper_helper_helper_helper n)\n                    (define (rearrange_bigger_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper n)\n                      (define (rearrange_bigger_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper n)\n                        (define (rearrange_bigger_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper n)\n                          (define (rearrange_bigger_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper n)\n                            (define (rearrange_bigger_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper n)\n                              (define (rearrange_bigger_",
    "  (define (rearrange_bigger_helper n)\n    (if (zero? n)\n        '()\n        (cons (modulo n 10) (rearrange_bigger_helper (quotient n 10)))))\n  (define (rearrange_bigger_helper2 n)\n    (if (zero? n)\n        '()\n        (cons (modulo n 10) (rearrange_bigger_helper2 (quotient n 10)))))\n  (define (rearrange_bigger_helper3 n)\n    (if (zero? n)\n        '()\n        (cons (modulo n 10) (rearrange_bigger_helper3 (quotient n 10)))))\n  (define (rearrange_bigger_helper4 n)\n    (if (zero? n)\n        '()\n        (cons (modulo n 10) (rearrange_bigger_helper4 (quotient n 10)))))\n  (define (rearrange_bigger_helper5 n)\n    (if (zero? n)\n        '()\n        (cons (modulo n 10) (rearrange_bigger_helper5 (quotient n 10)))))\n  (define (rearrange_bigger_helper6 n)\n    (if (zero? n)\n        '()\n        (cons (modulo n 10) (rearrange_bigger_helper6 (quotient n 10)))))\n  (define (rearrange_bigger_helper7 n)\n    (if (zero? n)\n        '()\n        (cons (modulo n 10) (rearrange_bigger_helper7 (quotient n 10)))))\n  (define (rearrange_bigger_helper8 n)\n    (if (zero? n)\n        '()\n        (cons (modulo n 10) (rearrange_bigger_helper8 (quotient n 10)))))\n  (define (rearrange_bigger_helper9 n)\n    (if (zero? n)\n        '()\n        (cons (modulo n 10) (re",
    "  (define (rearrange_bigger_helper n i)\n    (cond [(< i (sub1 (string-length n)))\n           (let* ([n-i (string-ref n i)]\n                  [n-i+1 (string-ref n (add1 i))])\n             (if (> n-i n-i+1)\n                 (let ([n-i+1-i (string-ref n-i+1 i)])\n                   (string-set! n-i+1 i n-i)\n                   (string-set! n i n-i+1-i)\n                   (string->number n))\n                 (rearrange_bigger_helper n (add1 i))))]\n          [else false]))\n  (rearrange_bigger_helper (number->string n) 0))\n",
    "  (define (rearrange_bigger-helper n i)\n    (if (= i (sub1 (length n)))\n        (list->number (reverse n))\n        (let* ([n (string->list n)]\n               [i (sub1 i)]\n               [j (find-next-bigger-index n i)])\n          (if (not j)\n              (rearrange_bigger-helper n (add1 i))\n              (let* ([n (swap n i j)]\n                     [n (reverse-sublist n i (add1 i))])\n                (list->number n))))))\n  (rearrange_bigger-helper (number->string n) 0))\n",
    "  (define (rearrange_bigger_helper n i)\n    (if (= i (sub1 (string-length n)))\n        n\n        (let* ([n-i (string-ref n i)]\n               [n-i+1 (string-ref n (add1 i))])\n          (if (&gt; n-i n-i+1)\n              (string-append (substring n 0 i)\n                             (string n-i+1)\n                             (string n-i)\n                             (substring n (add1 (add1 i))))\n              (rearrange_bigger_helper n (add1 i))))))\n  (rearrange_bigger_helper n 0))\n",
    "  (let ([n-str (number->string n)])\n    (if (string=? n-str (sort n-str string<?))\n        -1\n        (string->number (sort n-str string>)))))\n",
    "  (define (rearrange-bigger-helper n i)\n    (if (= i 0)\n        (list n)\n        (let* ([d (modulo n (expt 10 i))]\n               [n (- n d)]\n               [n (quotient n (expt 10 i))]\n               [d (- d (* (quotient d (expt 10 (- i 1))) (expt 10 (- i 1))))]\n               [d (+ d (* (quotient n (expt 10 (- i 1))) (expt 10 i)))]\n               [n (- n (* (quotient n (expt 10 (- i 1))) (expt 10 (- i 1))))])\n          (cons d (rearrange-bigger-helper n (- i 1))))))\n  (apply + (rearrange-bigger-helper n (exact-floor (log n 10)))))\n",
    "  (define (rearrange_bigger_helper n i)\n    (if (= i (sub1 (string-length n)))\n        n\n        (let* ((n-i (string-ref n i))\n               (n-i+1 (string-ref n (add1 i)))\n               (n-i+1-i (string-append (string n-i+1) (string n-i))))\n          (if (< n-i+1-i (string-append (string n-i) (string n-i+1)))\n              (string-append (substring n 0 i) n-i+1-i (substring n (add1 (add1 i))))\n              (rearrange_bigger_helper n (add1 i))))))\n  (rearrange_bigger_helper n 0))\n",
    "  (define (rearrange-bigger-helper n i)\n    (let ((n-str (number->string n))\n          (n-len (string-length n-str)))\n      (if (= i n-len)\n          n\n          (let ((i-char (string-ref n-str i))\n                (i-char-int (string->number i-char)))\n            (if (and (< i-char-int (string->number (string-ref n-str (- i 1))))\n                     (< i-char-int (string->number (string-ref n-str (- i 2)))))\n                (let ((i-char-int-str (number->string i-char-int)))\n                  (string-append (substring n-str 0 (- i 2))\n                                 i-char-int-str\n                                 (substring n-str (- i 2) (- i 1))\n                                 (substring n-str (- i 1) i)\n                                 (substring n-str i)))\n                (rearrange-bigger-helper n (+ i 1))))))))\n  (rearrange-bigger-helper n 1))\n",
    "  (define (rearrange_bigger_helper n)\n    (if (= n 0)\n        0\n        (let* ([d (modulo n 10)]\n               [r (quotient n 10)]\n               [r-bigger (rearrange_bigger_helper r)])\n          (if (= r-bigger 0)\n              0\n              (let* ([r-bigger-d (modulo r-bigger 10)]\n                     [r-bigger-r (quotient r-bigger 10)])\n                (if (&gt; d r-bigger-d)\n                    (let* ([r-bigger-r-d (modulo r-bigger-r 10)]\n                           [r-bigger-r-r (quotient r-bigger-r 10)])\n                      (if (&gt; d r-bigger-r-d)\n                          (if (= r-bigger-r-r 0)\n                              (+ (* r-bigger-r-d 10) d)\n                              (+ (* r-bigger-r-r 10) d))\n                          (+ (* r-bigger-r-r 10) d r-bigger-r-d)))\n                    (+ (* r-bigger-r 10) d r-bigger-d)))))))\n  (rearrange_bigger_helper n))\n",
    "  (define (rearrange-bigger-helper n)\n    (cond\n      [(= n 0) (list 0)]\n      [(= n 1) (list 1)]\n      [(= n 2) (list 2)]\n      [(= n 3) (list 3)]\n      [(= n 4) (list 4)]\n      [(= n 5) (list 5)]\n      [(= n 6) (list 6)]\n      [(= n 7) (list 7)]\n      [(= n 8) (list 8)]\n      [(= n 9) (list 9)]\n      [else (append (rearrange-bigger-helper (quotient n 10)) (list (remainder n 10)))]))\n  (define (rearrange-bigger-helper2 lst)\n    (cond\n      [(= (length lst) 1) (list (car lst))]\n      [(= (length lst) 2) (list (car lst) (cadr lst))]\n      [(= (length lst) 3) (list (car lst) (cadr lst) (caddr lst))]\n      [(= (length lst) 4) (list (car lst) (cadr lst) (caddr lst) (cadddr lst))]\n      [(= (length lst) 5) (list (car lst) (cadr lst) (caddr lst) (cadddr lst) (caddddr lst))]\n      [(= (length lst) 6) (list (car lst) (cadr lst) (caddr lst) (cadddr lst) (caddddr lst) (cadddddr lst))]\n      [(= (length lst) 7) (list (car lst) (cadr lst) (caddr lst) (cadddr lst) (caddddr lst) (cadddddr lst) (caddddddr lst))]\n      [(= (length lst) 8) (list (car lst) (cadr lst) (caddr lst) (cadddr lst) (caddddr l",
    "  (define (rearrange-bigger-helper n)\n    (if (zero? n)\n        n\n        (let* ([d (modulo n 10)]\n               [r (quotient n 10)]\n               [r-bigger (rearrange-bigger-helper r)])\n          (if (and (not (zero? r-bigger))\n                   (&gt; d (modulo r-bigger 10)))\n              (let* ([r-bigger-d (modulo r-bigger 10)]\n                     [r-bigger-r (quotient r-bigger 10)])\n                (if (zero? r-bigger-r)\n                    (+ (* 10 d) r-bigger-d)\n                    (+ (* 100 d) (+ (* 10 r-bigger-d) r-bigger-r))))\n              (if (zero? r)\n                  n\n                  (+ (* 10 d) r-bigger))))))\n  (rearrange-bigger-helper n))\n",
    "  (define (rearrange_bigger_helper n i)\n    (cond\n      [(zero? i) #f]\n      [(> (modulo n (expt 10 i)) (modulo n (expt 10 (- i 1))))\n       (+ (modulo n (expt 10 (- i 1))) (modulo n (expt 10 i)) (modulo n (expt 10 (- i 2))))]\n      [else (rearrange_bigger_helper n (- i 1))]))\n  (rearrange_bigger_helper n (length (number->string n))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (cond\n      [(null? digits) n]\n      [(null? (cdr digits)) n]\n      [else (let ([last (last digits)])\n              (cond\n                [(null? last) n]\n                [else (let ([rest (butlast digits)])\n                        (cond\n                          [(null? rest) n]\n                          [else (let ([next (first (filter (lambda (x) (&gt; x (car last))) rest))])\n                                  (cond\n                                    [(null? next) n]\n                                    [else (string-&gt;number (list-&gt;string (append (reverse (cons next (sort (cons (car last) (cdr last)))))) (sort (remove next rest))))]))]))]))])))\n",
    "  (define (rearrange-bigger-helper n i)\n    (if (= i (sub1 (string-length n)))\n        n\n        (let* ([n-i (string-ref n i)]\n               [n-i+1 (string-ref n (add1 i))])\n          (if (&gt; n-i n-i+1)\n              (string-append (substring n 0 i)\n                             (string n-i+1)\n                             (string n-i)\n                             (substring n (add1 (add1 i))))\n              (rearrange-bigger-helper n (add1 i))))))\n  (rearrange-bigger-helper n 0))\n",
    "  (define (rearrange_bigger_helper n)\n    (if (= n 0)\n        (list)\n        (cons (modulo n 10) (rearrange_bigger_helper (quotient n 10)))))\n  (define (rearrange_bigger_helper2 lst)\n    (if (null? lst)\n        0\n        (+ (* (car lst) (expt 10 (length lst))) (rearrange_bigger_helper2 (cdr lst)))))\n  (rearrange_bigger_helper2 (sort < (rearrange_bigger_helper n))))\n",
    "  (define (rearrange-bigger-helper n i)\n    (cond\n      [(zero? i) #f]\n      [(< (modulo n (expt 10 i)) (modulo n (expt 10 (- i 1))))\n       (+ (modulo n (expt 10 (- i 1)))\n          (modulo n (expt 10 i))\n          (modulo n (expt 10 (- i 2)))\n          (modulo n (expt 10 (- i 3)))\n          (modulo n (expt 10 (- i 4)))\n          (modulo n (expt 10 (- i 5)))\n          (modulo n (expt 10 (- i 6)))\n          (modulo n (expt 10 (- i 7)))\n          (modulo n (expt 10 (- i 8)))\n          (modulo n (expt 10 (- i 9))))]\n      [else (rearrange-bigger-helper n (- i 1))]))\n  (rearrange-bigger-helper n 9))\n",
    "  (define (rearrange_bigger_helper n i)\n    (if (= i (sub1 (string-length n)))\n        (string->number n)\n        (let* ([n (string->number n)]\n               [n (number->string n)]\n               [i (number->string i)]\n               [j (string-ref n i)]\n               [k (string-ref n (sub1 i))]\n               [n (string-replace n i k)]\n               [n (string-replace n (sub1 i) j)])\n          (rearrange_bigger_helper n (add1 i)))))\n  (rearrange_bigger_helper n 0))\n",
    "  (define (rearrange_bigger_helper n i)\n    (cond [(= i (- (string-length (number->string n)) 1)) (number->string n)]\n          [else (define (swap-digits n i j)\n                  (define (swap-digits-helper n i j)\n                    (cond [(= i j) (number->string n)]\n                          [else (string-append (substring (number->string n) 0 i)\n                                               (string (string-ref (number->string n) j))\n                                               (substring (number->string n) (+ i 1) j)\n                                               (string (string-ref (number->string n) i))\n                                               (substring (number->string n) (+ j 1)))\n                          ]))\n                (swap-digits-helper n i j))\n          ]))\n  (rearrange_bigger_helper n 0))\n",
    "  (define (rearrange-bigger-helper n i)\n    (if (= i (sub1 (string-length n)))\n        n\n        (let* ([n-i (string-ref n i)]\n               [n-i+1 (string-ref n (add1 i))])\n          (if (&gt; n-i n-i+1)\n              (string-append (substring n 0 i)\n                             (string n-i+1)\n                             (string n-i)\n                             (substring n (add1 (add1 i))))\n              (rearrange-bigger-helper n (add1 i))))))\n  (rearrange-bigger-helper n 0))\n",
    "  (define (rearrange_bigger_iter n i)\n    (cond\n      [(= i (- (string-length n) 1)) #f]\n      [(> (string-ref n i) (string-ref n (+ i 1)))\n       (string-append (substring n 0 i)\n                      (string-append (string (string-ref n (+ i 1)))\n                                     (string (string-ref n i)))\n                      (substring n (+ i 2)))]\n      [else (rearrange_bigger_iter n (+ i 1))]))\n  (rearrange_bigger_iter n 0))\n",
    "  (define (rearrange_bigger_helper n)\n    (define (rearrange_bigger_helper_helper n)\n      (define (rearrange_bigger_helper_helper_helper n)\n        (define (rearrange_bigger_helper_helper_helper_helper n)\n          (define (rearrange_bigger_helper_helper_helper_helper_helper n)\n            (define (rearrange_bigger_helper_helper_helper_helper_helper_helper n)\n              (define (rearrange_bigger_helper_helper_helper_helper_helper_helper_helper n)\n                (define (rearrange_bigger_helper_helper_helper_helper_helper_helper_helper_helper n)\n                  (define (rearrange_bigger_helper_helper_helper_helper_helper_helper_helper_helper_helper n)\n                    (define (rearrange_bigger_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper n)\n                      (define (rearrange_bigger_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper n)\n                        (define (rearrange_bigger_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper n)\n                          (define (rearrange_bigger_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper n)\n                            (define (rearrange_bigger_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper n)\n                              (define (rearrange_bigger_",
    "  (define (rearrange-helper n)\n    (let ([n (number->string n)])\n      (if (string=? n (sort n <))\n          #f\n          (rearrange-helper (string->number (sort n <))))))\n  (rearrange-helper n))\n",
    "  (define (rearrange_bigger-helper n i)\n    (cond\n      [(= i (sub1 (string-length n))) #f]\n      [(> (string-&gt;number (string-append (substring n i) (substring n (add1 i))))\n          (string-&gt;number (string-append (substring n (add1 i)) (substring n i))))\n       (string-append (substring n 0 i) (substring n (add1 i)) (substring n i (add1 i)) (substring n (add1 (add1 i))))]\n      [else (rearrange_bigger-helper n (add1 i))]))\n  (rearrange_bigger-helper n 0))\n",
    "  (define (rearrange_bigger-helper n-str)\n    (define (swap-last-two n-str)\n      (string-append (substring n-str 0 (- (string-length n-str) 2))\n                     (string (string-ref n-str (- (string-length n-str) 1)))\n                     (string (string-ref n-str (- (string-length n-str) 2)))))\n    (cond\n      [(= (string-length n-str) 2) (swap-last-two n-str)]\n      [(< (string->number (swap-last-two n-str)) n) (rearrange_bigger-helper (swap-last-two n-str))]\n      [else (swap-last-two n-str)]))\n  (rearrange_bigger-helper (number->string n)))\n",
    "  (let ([digits (string->list (number->string n))])\n    (let ([i (find-first-decreasing-digit digits)])\n      (if i\n          (let ([j (find-first-larger-digit digits i)])\n            (let ([temp (list-ref digits i)])\n              (set-car! (list-ref digits i) (list-ref digits j))\n              (set-car! (list-ref digits j) temp))\n            (let ([sub-digits (sublist digits (+ i 1) (length digits))])\n              (set-cdr! (list-ref digits i) (sort sub-digits <))\n              (string->number (list->string digits))))\n          -1))))\n",
    "  (define (rearrange-bigger-helper n i)\n    (if (= i 0)\n        n\n        (let* ([n-str (number->string n)]\n               [n-str-len (string-length n-str)]\n               [n-str-i (string-ref n-str (- n-str-len i))]\n               [n-str-i-1 (string-ref n-str (- n-str-len (+ i 1)))])\n          (if (> n-str-i-1 n-str-i)\n              (let* ([n-str-i-1-index (- n-str-len (+ i 1))]\n                     [n-str-i-index (- n-str-len i)]\n                     [n-str-i-1-index-val (string-ref n-str-i-1-index)]\n                     [n-str-i-index-val (string-ref n-str-i-index)])\n                (string-set! n-str-i-1-index n-str-i-index-val)\n                (string-set! n-str-i-index n-str-i-1-index-val)\n                (string->number n-str))\n              (rearrange-bigger-helper n (- i 1))))))\n  (rearrange-bigger-helper n (- (string-length (number->string n)) 1)))\n",
    "  (define (rearrange_bigger_iter n acc)\n    (if (zero? n)\n        acc\n        (let* ([d (remainder n 10)]\n               [n (quotient n 10)]\n               [acc (+ (* d (expt 10 (length acc))) acc)])\n          (rearrange_bigger_iter n acc))))\n  (rearrange_bigger_iter n '()))\n",
    "  (define (rearrange_bigger_helper n i)\n    (if (< i (sub1 (string-length n)))\n        (let ((next-digit (string-ref n (add1 i))))\n          (if (< (string-ref n i) next-digit)\n              (let ((new-n (string-append (substring n 0 i)\n                                          (string next-digit)\n                                          (string (string-ref n i))\n                                          (substring n (add1 i)))))\n                (rearrange_bigger_helper new-n 0))\n              (rearrange_bigger_helper n (add1 i))))\n        n))\n  (rearrange_bigger_helper n 0))\n",
    "  (define (rearrange-bigger-helper n i)\n    (cond\n      [(= i (- (string-length n) 1)) #f]\n      [(> (string-ref n i) (string-ref n (+ i 1)))\n       (string-append (substring n 0 i)\n                      (string-append (string (string-ref n (+ i 1)))\n                                     (string (string-ref n i)))\n                      (substring n (+ i 2) (string-length n)))]\n      [else (rearrange-bigger-helper n (+ i 1))]))\n  (rearrange-bigger-helper n 0))\n",
    "  (let ([digits (string->list (number->string n))])\n    (let loop ([i (sub1 (length digits))])\n      (if (negative? i)\n          (error \"no bigger number\")\n          (let ([j (sub1 (length digits))])\n            (if (negative? j)\n                (error \"no bigger number\")\n                (if (< (list-ref digits i) (list-ref digits j))\n                    (let ([tmp (list-ref digits i)])\n                      (set-car! (list-ref digits i) (list-ref digits j))\n                      (set-car! (list-ref digits j) tmp)\n                      (string->number (list->string (sort digits <))))\n                    (loop (sub1 i)))))))))\n",
    "  (define (rearrange_bigger_helper n)\n    (if (= n 0)\n        (list 0)\n        (append (rearrange_bigger_helper (quotient n 10)) (list (remainder n 10)))))\n  (define (rearrange_bigger_helper2 lst)\n    (if (null? lst)\n        0\n        (+ (* (car lst) (expt 10 (length lst))) (rearrange_bigger_helper2 (cdr lst)))))\n  (rearrange_bigger_helper2 (sort < (rearrange_bigger_helper n))))\n",
    "  (let ([digits (number->list n)]\n        [len (length digits)])\n    (cond\n      [(= len 1) (list n)]\n      [(= len 2) (list (list-ref digits 1) (list-ref digits 0))]\n      [else (let ([i (find-index-of-first-smaller-digit digits len)])\n              (cond\n                [(= i -1) (list n)]\n                [else (let ([j (find-index-of-first-bigger-digit digits i)])\n                        (let ([temp (list-ref digits i)])\n                          (set-car! (list-ref digits i) (list-ref digits j))\n                          (set-car! (list-ref digits j) temp)\n                          (reverse (sort (sublist digits (+ i 1) len) <) (sublist digits 0 (+ i 1))))))]))])))\n",
    "  (define (rearrange_bigger_helper n i)\n    (if (= i (- (string-length n) 1))\n        n\n        (let* ([n (string->number n)]\n               [n-i (string-ref n i)]\n               [n-i+1 (string-ref n (+ i 1))])\n          (if (< n-i n-i+1)\n              (let* ([n-i (number->string n-i)]\n                     [n-i+1 (number->string n-i+1)]\n                     [n (string-append (substring n 0 i) n-i+1 (substring n (+ i 1)) n-i)])\n                (rearrange_bigger_helper n (+ i 1)))\n              (rearrange_bigger_helper n (+ i 1))))))\n  (rearrange_bigger_helper (number->string n) 0))\n",
    "  (define (rearrange_bigger_iter n acc)\n    (if (zero? n)\n        acc\n        (let* ([d (modulo n 10)]\n               [n (quotient n 10)]\n               [acc (+ (* acc 10) d)])\n          (rearrange_bigger_iter n acc))))\n  (rearrange_bigger_iter n 0))\n",
    "  (define (rearrange-bigger-helper n)\n    (if (= n (apply * (digits n)))\n        (error \"No bigger number\")\n        (let* ([d (digits n)]\n               [i (find-first-decreasing-digit d)]\n               [j (find-first-bigger-digit d i)])\n          (apply +\n                 (append (sublist d 0 i)\n                         (list (list-ref d j))\n                         (sort (sublist d (+ i 1) j) <)\n                         (list (list-ref d i))\n                         (sublist d (+ j 1)))))))\n  (rearrange-bigger-helper n))\n",
    "  (define (rearrange-digits n)\n    (define (rearrange-digits-iter n ds)\n      (if (zero? n)\n          ds\n          (rearrange-digits-iter (quotient n 10) (cons (modulo n 10) ds))))\n    (rearrange-digits-iter n '()))\n  (define (rearrange-digits-to-number ds)\n    (define (rearrange-digits-to-number-iter ds n)\n      (if (null? ds)\n          n\n          (rearrange-digits-to-number-iter (cdr ds) (+ (* n 10) (car ds)))))\n    (rearrange-digits-to-number-iter ds 0))\n  (define (rearrange-digits-next ds)\n    (if (null? ds)\n        '()\n        (let ((ds-sorted (sort (lambda (x y) (< x y)) ds)))\n          (let ((ds-sorted-reversed (reverse ds-sorted)))\n            (let ((ds-sorted-reversed-tail (cdr ds-sorted-reversed)))\n              (let ((ds-sorted-reversed-tail-sorted (sort (lambda (x y) (< x y)) ds-sorted-reversed-tail)))\n                (let ((ds-sorted-reversed-tail-sorted-reversed (reverse ds-sorted-reversed-tail-sorted)))\n                  (let ((ds-sorted-reversed-tail-sorted-reversed-tail (cdr ds-sorted-reversed-tail-sorted-reversed)))\n                    (let ((ds-sorted-reversed-tail-sorted-reversed-tail-sorted (sort (lambda (x y) (< x y)) ds-sorted-reversed-tail-sorted-reversed-tail)))\n                      (let ((ds-sorted-reversed-tail-sorted-reversed-tail-sorted-reversed (",
    "  (define (rearrange_bigger-helper n i)\n    (if (= i (- (string-length n) 1))\n        (string-append n \"0\")\n        (let ((n-i (string-ref n i))\n              (n-i+1 (string-ref n (+ i 1))))\n          (if (&lt; n-i n-i+1)\n              (string-append (substring n 0 i)\n                             (string n-i+1)\n                             (string n-i)\n                             (substring n (+ i 2)))\n              (rearrange_bigger-helper n (+ i 1))))))\n  (rearrange_bigger-helper n 0))\n",
    "  (define (rearrange_bigger_helper n i)\n    (if (= i (- (string-length n) 1))\n        #f\n        (let* ([n (string->number n)]\n               [n-1 (string->number (substring n 0 (- i 1)))])\n          (if (> (- n n-1) (string->number (substring n i)))\n              (let* ([n-2 (string->number (substring n 0 i))]\n                     [n-3 (string->number (substring n (+ i 1)))])\n                (if (> (- n n-2) (string->number (substring n (+ i 1))))\n                    (string->number (string-append (number->string n-2)\n                                                   (number->string n-3)\n                                                   (number->string n-1)))\n                    (string->number (string-append (number->string n-1)\n                                                   (number->string n-2)\n                                                   (number->string n-3)))))\n              (rearrange_bigger_helper n (+ i 1))))))\n  (rearrange_bigger_helper (number->string n) 1))\n",
    "  (define (find-next-bigger-digit-index n i)\n    (if (= i (- (string-length n) 1))\n        #f\n        (if (< (string-ref n i) (string-ref n (+ i 1)))\n            (+ i 1)\n            (find-next-bigger-digit-index n (+ i 1)))))\n  (define (swap n i j)\n    (string-append (substring n 0 i)\n                   (string (string-ref n j))\n                   (substring n (+ i 1) j)\n                   (string (string-ref n i))\n                   (substring n (+ j 1))))\n  (define (sort-right n i)\n    (string-append (substring n 0 i)\n                   (sort (substring n i) string<?)))\n  (define (rearrange-bigger n)\n    (let ([i (find-next-bigger-digit-index n 0)])\n      (if i\n          (sort-right (swap n i (find-next-bigger-digit-index n i)) i)\n          #f)))\n  (rearrange-bigger (number->string n)))\n",
    "  (define (rearrange_bigger_helper n)\n    (let ([n-str (number->string n)])\n      (let ([n-str-len (string-length n-str)])\n        (let ([n-str-list (string->list n-str)])\n          (let ([n-str-list-rev (reverse n-str-list)])\n            (let ([n-str-list-rev-len (length n-str-list-rev)])\n              (let ([n-str-list-rev-len-1 (- n-str-list-rev-len 1)])\n                (let ([n-str-list-rev-len-2 (- n-str-list-rev-len 2)])\n                  (let ([n-str-list-rev-len-3 (- n-str-list-rev-len 3)])\n                    (let ([n-str-list-rev-len-4 (- n-str-list-rev-len 4)])\n                      (let ([n-str-list-rev-len-5 (- n-str-list-rev-len 5)])\n                        (let ([n-str-list-rev-len-6 (- n-str-list-rev-len 6)])\n                          (let ([n-str-list-rev-len-7 (- n-str-list-rev-len 7)])\n                            (let ([n-str-list-rev-len-8 (- n-str-list-rev-len 8)])\n                              (let ([n-str-list-rev-len-9 (- n-str-list-rev-len 9)])\n                                (let ([n-str-list-rev-len-10 (- n-str-list-rev-len 10)])\n                                  (let ([n-str-list-rev-len-11 (- n-str-list-rev-len 11)])\n                                    (let ([n-str-list-rev-len-12 (- n-str-list-rev-len 12)])\n                                      (let ([n-str-list-rev-len-13 (- n-str-list-rev-len 13)])\n                                        (let ([n-str-list-rev",
    "  (define (rearrange_bigger-helper n i)\n    (if (= i 0)\n        (list n)\n        (let ((d (modulo n (expt 10 i))))\n          (if (and (&gt; d 0) (&gt; d (modulo n (expt 10 (- i 1)))))\n              (cons (modulo n (expt 10 (- i 1)))\n                    (rearrange_bigger-helper (- n d) (- i 1)))\n              (rearrange_bigger-helper n (- i 1))))))\n  (apply + (rearrange_bigger-helper n (exact-floor (log n 10)))))\n",
    "  (define (rearrange_bigger_helper n)\n    (define (rearrange_bigger_helper_helper n)\n      (if (zero? n)\n          '()\n          (cons (modulo n 10) (rearrange_bigger_helper_helper (quotient n 10)))))\n    (sort (rearrange_bigger_helper_helper n) <))\n  (define (rearrange_bigger_helper_helper2 n)\n    (if (zero? n)\n        0\n        (+ (* (modulo n 10) (expt 10 (quotient n 10))) (rearrange_bigger_helper_helper2 (quotient n 10)))))\n  (rearrange_bigger_helper_helper2 (rearrange_bigger_helper n)))\n",
    "  (define (rearrange_bigger_helper n i)\n    (cond\n      [(= i 0) n]\n      [(> (modulo n 10) (modulo (quotient n 10) 10)) (rearrange_bigger_helper (quotient n 10) (- i 1))]\n      [else (rearrange_bigger_helper (quotient n 10) (- i 1))]))\n  (rearrange_bigger_helper n (length n)))\n",
    "  (let ([n-str (number->string n)])\n    (if (string=? n-str (string-sort n-str))\n        -1\n        (string->number (string-sort n-str)))))\n",
    "  (define (rearrange-bigger-helper n i)\n    (if (= i 0)\n        (list n)\n        (let* ([n-i (modulo n (expt 10 i))]\n               [n-i-1 (modulo n (expt 10 (- i 1)))]\n               [n-i-1-1 (modulo n (expt 10 (- i 2)))]\n               [n-i-1-1-1 (modulo n (expt 10 (- i 3)))]\n               [n-i-1-1-1-1 (modulo n (expt 10 (- i 4)))]\n               [n-i-1-1-1-1-1 (modulo n (expt 10 (- i 5)))]\n               [n-i-1-1-1-1-1-1 (modulo n (expt 10 (- i 6)))]\n               [n-i-1-1-1-1-1-1-1 (modulo n (expt 10 (- i 7)))]\n               [n-i-1-1-1-1-1-1-1-1 (modulo n (expt 10 (- i 8)))]\n               [n-i-1-1-1-1-1-1-1-1-1 (modulo n (expt 10 (- i 9)))]\n               [n-i-1-1-1-1-1-1-1-1-1-1 (modulo n (expt 10 (- i 10)))]\n               [n-i-1-1-1-1-1-1-1-1-1-1-1 (modulo n (expt 10 (- i 11)))]\n               [n-i-1-1-1-1-1-1-1-1-1-1-1-1 (modulo n (expt 10 (- i 12)))]\n               [n-i-1-1-1-1-1-1-1-1-1-1-1-1-1 (modulo n (expt 10 (- i 13)))]\n               [n-i-1-1-1-1-1-1-1-1-1-1-1-1-1",
    "  (define (rearrange_bigger_helper n i)\n    (cond\n      [(= i (- (string-length n) 1)) #f]\n      [(> (string-ref n i) (string-ref n (+ i 1)))\n       (string-append (substring n 0 i)\n                      (string (string-ref n (+ i 1)))\n                      (string (string-ref n i))\n                      (substring n (+ i 2) (string-length n)))]\n      [else (rearrange_bigger_helper n (+ i 1))]))\n  (rearrange_bigger_helper n 0))\n",
    "  (define (rearrange_bigger_iter n i)\n    (if (= i (- (string-length n) 1))\n        n\n        (let* ([n-i (string-ref n i)]\n               [n-i+1 (string-ref n (+ i 1))])\n          (if (&gt; n-i n-i+1)\n              (let ([n-i+1-index (string-index n n-i+1)])\n                (string-append (substring n 0 i)\n                               (string-append (substring n (+ i 1) n-i+1-index)\n                                              (string n-i))\n                               (substring n n-i+1-index (+ n-i+1-index 1))))\n              (rearrange_bigger_iter n (+ i 1))))))\n  (rearrange_bigger_iter n 0))\n",
    "  (define (rearrange_bigger_helper n)\n    (cond [(= n 0) (list 0)]\n          [(= n 1) (list 1)]\n          [(= n 2) (list 2 1)]\n          [(= n 3) (list 3 1 2)]\n          [(= n 4) (list 4 1 2 3)]\n          [(= n 5) (list 5 1 2 3 4)]\n          [(= n 6) (list 6 1 2 3 4 5)]\n          [(= n 7) (list 7 1 2 3 4 5 6)]\n          [(= n 8) (list 8 1 2 3 4 5 6 7)]\n          [(= n 9) (list 9 1 2 3 4 5 6 7 8)]\n          [else (error \"Invalid input\")]))\n  (define (rearrange_bigger_helper2 n)\n    (cond [(= n 0) (list 0)]\n          [(= n 1) (list 1)]\n          [(= n 2) (list 2 1)]\n          [(= n 3) (list 3 2 1)]\n          [(= n 4) (list 4 3 2 1)]\n          [(= n 5) (list 5 4 3 2 1)]\n          [(= n 6) (list 6 5 4 3 2 1)]\n          [(= n 7) (list 7 6 5 4 3 2 1)]\n          [(= n 8) (list 8 7 6 5 4 3 2 1)]\n          [(= n 9) (list 9 8 7 6 5 4 3 2 1)]\n          [else (error \"Invalid input\")]))\n  (define (rearrange_bigger_helper3 n)\n    (cond [(= n 0) (list 0)]\n          [(= n 1) (list 1)]\n          [(= n 2) (list 2 1)]\n          [(= n 3) (list 3 2 1)]\n          [(= n 4) (list 4 3 2 1)]\n          [(= n 5) (list 5 4 3 2 1)]\n          [(= n 6) (list 6 5 4 3 2 1)]\n          [(= n 7) (list 7 6 5 4 3 2 1)]\n          [(= n 8) (list 8 7 6 5 4 3 2 1)]\n          [(= n 9) (list 9 8 7 6",
    "  (let ((digits (string->list (number->string n))))\n    (let loop ((i (sub1 (length digits))))\n      (cond\n        [(zero? i) (error \"no bigger number\")]\n        [(> (list-ref digits i) (list-ref digits (sub1 i)))\n         (let ((j (sub1 i)))\n           (let loop ((k (sub1 i)))\n             (cond\n               [(zero? k) (error \"no bigger number\")]\n               [(> (list-ref digits k) (list-ref digits j))\n                (list-set digits j (list-ref digits k))\n                (list-set digits k (list-ref digits j))\n                (list->string (sort (lambda (x y) (< x y)) digits))]\n               [else (loop (sub1 k))])))]\n        [else (loop (sub1 i))]))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (let loop ([i (sub1 (length digits))])\n      (cond [(zero? i) n]\n            [(< (list-ref digits i) (list-ref digits (sub1 i)))\n             (let ([j (sub1 (length digits))])\n               (let loop ([j (sub1 j)])\n                 (cond [(< (list-ref digits i) (list-ref digits j))\n                        (let ([tmp (list-ref digits i)])\n                          (set-car! (list-ref digits i) (list-ref digits j))\n                          (set-car! (list-ref digits j) tmp))\n                        (list->string (append (sublist digits 0 i)\n                                              (sort (sublist digits i) <)))]\n                       [else (loop (sub1 j))])))]\n            [else (loop (sub1 i))]))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (cond\n      [(null? digits) n]\n      [(null? (cdr digits)) n]\n      [else\n       (let ([bigger (rearrange_bigger (string->number (list->string (cdr digits))))])\n         (if (&gt; bigger n) bigger\n             (let ([swap-index (find-swap-index digits)])\n               (if swap-index\n                   (let ([swap-digit (list-ref digits swap-index)])\n                     (let ([swap-index-2 (find-swap-index-2 digits swap-index swap-digit)])\n                       (let ([new-digits (swap-digits digits swap-index swap-index-2)])\n                         (string->number (list->string new-digits))))))\n               n))))])))\n",
    "  (define (swap lst i j)\n    (define (swap-helper lst i j)\n      (if (zero? i)\n          (cons (list-ref lst j) (list-ref lst i))\n          (cons (list-ref lst i) (swap-helper (rest lst) (- i 1) (- j 1)))))\n    (swap-helper lst i j))\n  (define (next-bigger-helper n)\n    (define (next-bigger-helper-helper n i)\n      (if (zero? i)\n          (list n)\n          (if (< (list-ref n i) (list-ref n (- i 1)))\n              (swap n i (- i 1))\n              (next-bigger-helper-helper n (- i 1)))))\n    (next-bigger-helper-helper n (- (length n) 1)))\n  (next-bigger-helper (string->list (number->string n))))\n",
    "  (cond\n    [(= n 0) #f]\n    [(= n 1) #f]\n    [(= n 2) #f]\n    [(= n 3) #f]\n    [(= n 4) #f]\n    [(= n 5) #f]\n    [(= n 6) #f]\n    [(= n 7) #f]\n    [(= n 8) #f]\n    [(= n 9) #f]\n    [else (rearrange_bigger (quotient n 10))]))\n",
    "  (let ([digits (string->list (number->string n))])\n    (let ([next-perm (next-permutation digits)])\n      (if next-perm\n          (string->number (list->string next-perm))\n          -1))))\n",
    "  (define (rearrange-bigger-helper n)\n    (define (rearrange-bigger-helper-helper n)\n      (if (zero? n)\n          '()\n          (cons (modulo n 10) (rearrange-bigger-helper-helper (quotient n 10)))))\n    (define (rearrange-bigger-helper-helper2 n)\n      (if (null? n)\n          '()\n          (cons (car n) (rearrange-bigger-helper-helper2 (cdr n)))))\n    (define (rearrange-bigger-helper-helper3 n)\n      (if (null? n)\n          '()\n          (cons (car n) (rearrange-bigger-helper-helper3 (cdr n)))))\n    (define (rearrange-bigger-helper-helper4 n)\n      (if (null? n)\n          '()\n          (cons (car n) (rearrange-bigger-helper-helper4 (cdr n)))))\n    (define (rearrange-bigger-helper-helper5 n)\n      (if (null? n)\n          '()\n          (cons (car n) (rearrange-bigger-helper-helper5 (cdr n)))))\n    (define (rearrange-bigger-helper-helper6 n)\n      (if (null? n)\n          '()\n          (cons (car n) (rearrange-bigger-helper-helper6 (cdr n)))))\n    (define (rearrange-bigger-helper-helper7 n)\n      (if (null? n)\n          '()\n          (cons (car n) (rearrange-bigger-helper-helper7 (cdr n)))))\n    (define (rearrange-bigger-helper-helper8 n)\n      (if (null? n)\n          '()\n          (cons (car n) (rearrange-bigger-helper-helper8 (cdr n)))))\n    (define (re",
    "  (define (rearrange_bigger_helper n i)\n    (if (= i 0)\n        (list n)\n        (let ((n-i (modulo n (expt 10 i))))\n          (if (&gt; n-i (modulo n (expt 10 (- i 1))))\n              (cons n-i (rearrange_bigger_helper (- n n-i) (- i 1)))\n              (rearrange_bigger_helper n (- i 1))))))\n  (let ((len (number-&gt;string n)))\n    (apply + (rearrange_bigger_helper n (string-length len)))))\n",
    "  (define (rearrange_bigger_iter n lst)\n    (if (null? lst)\n        n\n        (let ([lst (sort < lst)])\n          (if (and (not (null? (cdr lst)))\n                   (not (null? (cddr lst)))\n                   (> (car lst) (cadr lst))\n                   (> (cadr lst) (caddr lst)))\n              (rearrange_bigger_iter (string->number (string-append (number->string (car lst))\n                                                                    (number->string (cadr lst))\n                                                                    (number->string (caddr lst))))\n                                      (append (list (car lst))\n                                              (cdddr lst)))\n              (rearrange_bigger_iter (string->number (string-append (number->string (car lst))\n                                                                    (number->string (cadr lst))))\n                                      (append (list (cadr lst))\n                                              (list (car lst))\n                                              (cddr lst)))))))\n  (rearrange_bigger_iter n (string->list (number->string n))))\n",
    "  (define (rearrange_bigger_helper n)\n    (let ([digits (string->list (number->string n))])\n      (let loop ([i (sub1 (length digits))])\n        (cond\n          [(zero? i) #f]\n          [(< (list-ref digits i) (list-ref digits (sub1 i)))\n           (let ([j (sub1 i)])\n             (let loop ([j (sub1 j)])\n               (cond\n                 [(zero? j) (list (list-ref digits i) (sub1 i))]\n                 [(> (list-ref digits i) (list-ref digits j))\n                  (list (list-ref digits i) (sub1 i))]\n                 [else (loop j)])))]\n          [else (loop (sub1 i))])))))\n  (let ([result (rearrange_bigger_helper n)])\n    (if result\n        (let ([i (cadr result)]\n              [j (car result)])\n          (let ([digits (string->list (number->string n))])\n            (let ([temp (list-ref digits i)])\n              (set-car! (list-ref digits i) j)\n              (set-car! (list-ref digits (sub1 i)) temp))\n            (string->number (list->string digits))))\n        #f)))\n",
    "  (define (rearrange_bigger_iter n i)\n    (if (= i (- (string-length n) 1))\n        n\n        (let* ([n-i (string-ref n i)]\n               [n-i+1 (string-ref n (+ i 1))])\n          (if (&lt; n-i n-i+1)\n              (string-append (substring n 0 i)\n                             (string n-i+1)\n                             (string n-i)\n                             (substring n (+ i 2) (string-length n)))\n              (rearrange_bigger_iter n (+ i 1))))))\n  (rearrange_bigger_iter n 0))\n",
    "  (define (rearrange_bigger-helper n i)\n    (if (= i (- (string-length n) 1))\n        n\n        (let* ([n-i (string-ref n i)]\n               [n-i+1 (string-ref n (+ i 1))])\n          (if (> n-i n-i+1)\n              (string-append (substring n 0 i)\n                             (string n-i+1)\n                             (string n-i)\n                             (substring n (+ i 2) (string-length n)))\n              (rearrange_bigger-helper n (+ i 1))))))\n  (rearrange_bigger-helper n 0))\n",
    "  (define (rearrange_bigger_helper n i)\n    (cond\n      [(= i (sub1 (string-length n))) #f]\n      [(> (string-&gt;number (string-ref n i)) (string-&gt;number (string-ref n (add1 i))))\n       (string-&gt;number (string-append (substring n 0 i) (substring n (add1 i) (add1 i)) (substring n i (add1 i)) (substring n (add1 i))))]\n      [else (rearrange_bigger_helper n (add1 i))]))\n  (rearrange_bigger_helper n 0))\n",
    "  (define (rearrange-bigger-helper n i)\n    (cond [(zero? i) n]\n          [(< (modulo n (expt 10 i)) (modulo n (expt 10 (- i 1))))\n           (rearrange-bigger-helper n (- i 1))]\n          [else\n           (let* ([d (modulo n (expt 10 i))]\n                  [n (- n d)]\n                  [d-1 (modulo n (expt 10 (- i 1)))]\n                  [n (- n d-1)]\n                  [n (+ n (* d (expt 10 (- i 1))))]\n                  [n (+ n (* d-1 (expt 10 i)))]\n                  [n (rearrange-bigger-helper n (- i 1))])\n             n)]))\n  (rearrange-bigger-helper n (exact-floor (log n 10))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (let loop ([i (sub1 (length digits))])\n      (cond\n        [(= i 0) #f]\n        [(< (list-ref digits i) (list-ref digits (sub1 i)))\n         (let ([j (sub1 i)])\n           (let loop ([k (add1 i)])\n             (cond\n               [(> (list-ref digits k) (list-ref digits j))\n                (let ([tmp (list-ref digits k)])\n                  (set-car! (list-ref digits k) (list-ref digits j))\n                  (set-car! (list-ref digits j) tmp)\n                  (list->string (reverse (append (sublist digits 0 j)\n                                                  (sort (sublist digits j) <)))))\n                ]\n               [else (loop (add1 k))])))]\n        [else (loop (sub1 i))]))))\n",
    "  (define (rearrange_bigger-helper n i)\n    (cond [(= i 0) (list n)]\n          [(> (modulo n (expt 10 i)) (modulo n (expt 10 (- i 1))))\n           (cons (modulo n (expt 10 i))\n                 (rearrange_bigger-helper (modulo n (expt 10 (- i 1))) (- i 1)))]\n          [else (rearrange_bigger-helper n (- i 1))]))\n  (define (rearrange_bigger-helper2 n i)\n    (cond [(= i 0) n]\n          [else (+ (rearrange_bigger-helper2 n (- i 1))\n                   (expt 10 (- i 1)))]))\n  (rearrange_bigger-helper2 (rearrange_bigger-helper n (length (number->string n))) (length (number->string n))))\n",
    "  (define (rearrange-bigger-helper n)\n    (let ([n-str (number->string n)]\n          [n-str-len (string-length n-str)])\n      (let loop ([i (- n-str-len 2)]\n                 [j (- n-str-len 1)])\n        (cond\n          [(< i 0) #f]\n          [(> (string-ref n-str i) (string-ref n-str j))\n           (let ([n-str-i (string-ref n-str i)]\n                 [n-str-j (string-ref n-str j)])\n             (string-set! n-str i n-str-j)\n             (string-set! n-str j n-str-i)\n             (string->number n-str))]\n          [else (loop (- i 1) (- j 1))]))))\n  (rearrange-bigger-helper n))\n",
    "  (define (rearrange_bigger-helper n i)\n    (cond [(= i 0) n]\n          [(< (modulo n (expt 10 i)) (modulo n (expt 10 (- i 1))))\n           (rearrange_bigger-helper (modulo (+ n (* (- (modulo n (expt 10 i)) (modulo n (expt 10 (- i 1)))) (expt 10 i))) (expt 10 i)) (- i 1))]\n          [else (rearrange_bigger-helper n (- i 1))]))\n  (rearrange_bigger-helper n (exact-floor (log n 10))))\n",
    "  (define (rearrange_bigger_helper n i)\n    (if (= i 0)\n        n\n        (let* ([i-1 (- i 1)]\n               [n-i (modulo n (expt 10 i))]\n               [n-i-1 (modulo n (expt 10 i-1))])\n          (if (> n-i n-i-1)\n              (let* ([n-i-1-1 (modulo n (expt 10 (- i-1 1))))\n                     [n-i-1-1-1 (modulo n (expt 10 (- i-1 2))))\n                     [n-i-1-1-1-1 (modulo n (expt 10 (- i-1 3))))]\n                (if (and (= n-i-1-1-1-1 0) (= n-i-1-1-1 0))\n                    (rearrange_bigger_helper (+ n-i-1-1-1-1 n-i-1-1-1 n-i-1-1 n-i-1 n-i) (- i 1))\n                    (rearrange_bigger_helper (+ n-i-1-1-1 n-i-1-1 n-i-1 n-i) (- i 1))))\n              (rearrange_bigger_helper n (- i 1))))))\n  (rearrange_bigger_helper n (number->string n (length (number->string n)))))\n",
    "  (define (rearrange-bigger-helper n)\n    (define (rearrange-bigger-helper-helper n)\n      (define (rearrange-bigger-helper-helper-helper n)\n        (define (rearrange-bigger-helper-helper-helper-helper n)\n          (define (rearrange-bigger-helper-helper-helper-helper-helper n)\n            (define (rearrange-bigger-helper-helper-helper-helper-helper-helper n)\n              (define (rearrange-bigger-helper-helper-helper-helper-helper-helper-helper n)\n                (define (rearrange-bigger-helper-helper-helper-helper-helper-helper-helper-helper n)\n                  (define (rearrange-bigger-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                    (define (rearrange-bigger-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                      (define (rearrange-bigger-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                        (define (rearrange-bigger-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                          (define (rearrange-bigger-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                            (define (rearrange-bigger-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                              (define (rearrange-bigger-",
    "  (define (rearrange-bigger-helper n i)\n    (cond\n      [(= i 0) (list n)]\n      [(= (modulo n 10) 0) (rearrange-bigger-helper (quotient n 10) (- i 1))]\n      [else (cons (modulo n 10) (rearrange-bigger-helper (quotient n 10) (- i 1)))]))\n  (define (rearrange-bigger-helper2 n i)\n    (cond\n      [(= i 0) n]\n      [(= (modulo n 10) 0) (rearrange-bigger-helper2 (quotient n 10) (- i 1))]\n      [else (cons (modulo n 10) (rearrange-bigger-helper2 (quotient n 10) (- i 1)))]))\n  (define (rearrange-bigger-helper3 n i)\n    (cond\n      [(= i 0) n]\n      [(= (modulo n 10) 0) (rearrange-bigger-helper3 (quotient n 10) (- i 1))]\n      [else (cons (modulo n 10) (rearrange-bigger-helper3 (quotient n 10) (- i 1)))]))\n  (define (rearrange-bigger-helper4 n i)\n    (cond\n      [(= i 0) n]\n      [(= (modulo n 10) 0) (rearrange-bigger-helper4 (quotient n 10) (- i 1))]\n      [else (cons (modulo n 10) (rearrange-bigger-helper4 (quotient n 10) (- i 1)))]))\n  (define (rearrange-bigger-helper5 n i)\n    (cond\n      [(= i 0) n]\n      [(= (modulo n 10) 0) (rearrange-bigger-helper5 (quotient n 10) (- i 1))]\n      [else (cons (modulo n 10) (rearrange-bigger-helper5 (quotient n 10) (- i 1)))]))\n  (",
    "  (define (rearrange_bigger_helper n i)\n    (cond\n      [(= i (sub1 (string-length n))) #f]\n      [(> (string-&gt;number (substring n i (add1 i))) (string-&gt;number (substring n (add1 i) (add1 (add1 i)))))\n       (string-&gt;number (string-append (substring n 0 i) (substring n (add1 i) (add1 (add1 i))) (substring n i (add1 i)) (substring n (add1 (add1 i)) (string-length n))))]\n      [else (rearrange_bigger_helper n (add1 i))]))\n  (rearrange_bigger_helper n 0))\n",
    "  (define (rearrange_bigger-helper n i)\n    (if (= i 0)\n        n\n        (let* ([n-str (number->string n)]\n               [n-str-rev (reverse n-str)]\n               [n-str-rev-i (string-ref n-str-rev i)]\n               [n-str-rev-i-1 (string-ref n-str-rev (- i 1))])\n          (if (> n-str-rev-i n-str-rev-i-1)\n              (string->number (string-append (reverse (string-replace n-str-rev-i-1 n-str-rev-i))\n                                             (string-replace n-str-rev-i n-str-rev-i-1)))\n              (rearrange_bigger-helper n (- i 1))))))\n  (rearrange_bigger-helper n (- (string-length (number->string n)) 1)))\n",
    "  (define (rearrange_bigger_helper n i)\n    (if (= i 0)\n        (list n)\n        (let ([d (modulo n (expt 10 i))])\n          (if (and (&gt; d 0) (&gt; d (modulo n (expt 10 (- i 1)))))\n              (list (modulo n (expt 10 (- i 1)))\n                    (modulo n (expt 10 i))\n                    (modulo n (expt 10 (- i 2))))\n              (rearrange_bigger_helper n (- i 1))))))\n  (apply + (rearrange_bigger_helper n (expt 10 (floor (log n 10)))))\n)\n</code>\n",
    "  (define (rearrange_bigger-helper n i)\n    (if (= i (sub1 (string-length n)))\n        (string-append n (string (char-downcase (string-ref n i))))\n        (let ((j (rearrange-bigger-helper-2 n i)))\n          (if (= j i)\n              (rearrange-bigger-helper n (add1 i))\n              (let ((n-list (string->list n)))\n                (list-set n-list i (list-ref n-list j))\n                (list-set n-list j (list-ref n-list i))\n                (string-append (list->string (sublist n-list 0 j))\n                               (list->string (sort (sublist n-list j) char<?))\n                               (list->string (sublist n-list (add1 j)))))))))\n  (rearrange-bigger-helper n 0))\n",
    "  (define (rearrange_bigger-iter n i)\n    (if (= i (sub1 (string-length n)))\n        n\n        (let ((n-i (string-ref n i)))\n          (let ((n-i+1 (string-ref n (add1 i))))\n            (if (&lt; n-i n-i+1)\n                (string-append (substring n 0 i) (string-append n-i+1 (string-append n-i (substring n (add1 (add1 i))))))\n                (rearrange_bigger-iter n (add1 i)))))))\n  (rearrange_bigger-iter n 0))\n</code>\nI'm not sure if this is the most efficient way to do it, but it works.\n",
    "  (define (rearrange_bigger_helper n)\n    (define (rearrange_bigger_helper_helper n)\n      (define (rearrange_bigger_helper_helper_helper n)\n        (define (rearrange_bigger_helper_helper_helper_helper n)\n          (define (rearrange_bigger_helper_helper_helper_helper_helper n)\n            (define (rearrange_bigger_helper_helper_helper_helper_helper_helper n)\n              (define (rearrange_bigger_helper_helper_helper_helper_helper_helper_helper n)\n                (define (rearrange_bigger_helper_helper_helper_helper_helper_helper_helper_helper n)\n                  (define (rearrange_bigger_helper_helper_helper_helper_helper_helper_helper_helper_helper n)\n                    (define (rearrange_bigger_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper n)\n                      (define (rearrange_bigger_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper n)\n                        (define (rearrange_bigger_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper n)\n                          (define (rearrange_bigger_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper n)\n                            (define (rearrange_bigger_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper n)\n                              (define (rearrange_bigger_",
    "  (define (rearrange-bigger-helper n)\n    (if (zero? n)\n        0\n        (let* ([d (modulo n 10)]\n               [r (quotient n 10)]\n               [r-bigger (rearrange-bigger-helper r)])\n          (if (and (not (zero? r-bigger))\n                   (&gt; d (modulo r-bigger 10)))\n              (let* ([r-bigger-d (modulo r-bigger 10)]\n                     [r-bigger-r (quotient r-bigger 10)])\n                (+ (* r-bigger-r 10)\n                   d\n                   (* r-bigger-d 100)))\n              (+ (* r-bigger 10)\n                 d)))))\n  (let* ([n-bigger (rearrange-bigger-helper n)])\n    (if (zero? n-bigger)\n        n\n        n-bigger)))\n",
    "  (define (rearrange_bigger_helper n)\n    (if (zero? n)\n        (list)\n        (cons (modulo n 10) (rearrange_bigger_helper (quotient n 10)))))\n  (define (rearrange_bigger_helper2 n)\n    (if (zero? n)\n        (list)\n        (cons (modulo n 10) (rearrange_bigger_helper2 (quotient n 10)))))\n  (define (rearrange_bigger_helper3 n)\n    (if (zero? n)\n        (list)\n        (cons (modulo n 10) (rearrange_bigger_helper3 (quotient n 10)))))\n  (define (rearrange_bigger_helper4 n)\n    (if (zero? n)\n        (list)\n        (cons (modulo n 10) (rearrange_bigger_helper4 (quotient n 10)))))\n  (define (rearrange_bigger_helper5 n)\n    (if (zero? n)\n        (list)\n        (cons (modulo n 10) (rearrange_bigger_helper5 (quotient n 10)))))\n  (define (rearrange_bigger_helper6 n)\n    (if (zero? n)\n        (list)\n        (cons (modulo n 10) (rearrange_bigger_helper6 (quotient n 10)))))\n  (define (rearrange_bigger_helper7 n)\n    (if (zero? n)\n        (list)\n        (cons (modulo n 10) (rearrange_bigger_helper7 (quotient n 10)))))\n  (define (rearrange_bigger_helper8 n)\n    (if (zero? n)\n        (list)\n        (cons (modulo n 10) (rearrange_bigger_helper8 (quotient n 10)))))\n  (define (rearrange_bigger_helper9 n)\n    (if (zero? n)\n        (list)\n        (",
    "  (define (rearrange_bigger-helper n)\n    (cond\n      [(= n 0) (list 0)]\n      [else (cons (modulo n 10) (rearrange_bigger-helper (quotient n 10)))]))\n  (define (rearrange-helper n)\n    (cond\n      [(= n 0) (list 0)]\n      [else (cons (modulo n 10) (rearrange-helper (quotient n 10)))]))\n  (define (rearrange n)\n    (cond\n      [(= n 0) (list 0)]\n      [else (cons (modulo n 10) (rearrange (quotient n 10)))]))\n  (define (rearrange-bigger n)\n    (cond\n      [(= n 0) (list 0)]\n      [else (cons (modulo n 10) (rearrange-bigger (quotient n 10)))]))\n  (define (rearrange-bigger-helper n)\n    (cond\n      [(= n 0) (list 0)]\n      [else (cons (modulo n 10) (rearrange-bigger-helper (quotient n 10)))]))\n  (define (rearrange-bigger-helper-helper n)\n    (cond\n      [(= n 0) (list 0)]\n      [else (cons (modulo n 10) (rearrange-bigger-helper-helper (quotient n 10)))]))\n  (define (rearrange-bigger-helper-helper-helper n)\n    (cond\n      [(= n 0) (list 0)]\n      [else (cons (modulo n 10) (rearrange-bigger-helper-helper-helper (quotient n 10)))]))\n  (define (rearrange-bigger-helper-helper-helper-helper n)\n    (cond\n      [(= n 0) (list 0)]\n      [else (cons (modulo n 10) (rearrange-bigger-helper-helper-helper-helper (quotient n 10)))]))\n  (define",
    "  (let ([digits (number->list n)])\n    (let ([i (find-index-of-first-decreasing-digit digits)])\n      (if (negative? i)\n          -1\n          (let ([j (find-index-of-first-digit-larger-than-i digits i)])\n            (if (negative? j)\n                -1\n                (let ([digits (swap-digits digits i j)])\n                  (let ([digits (reverse-digits digits (+ i 1) (length digits))])\n                    (list->number digits)))))))))\n",
    "  (define (rearrange_bigger_helper n)\n    (let* ([n-str (number->string n)]\n           [n-str-len (string-length n-str)]\n           [n-str-rev (reverse n-str)]\n           [n-str-rev-len (string-length n-str-rev)]\n           [n-str-rev-list (string-&gt;list n-str-rev)]\n           [n-str-rev-list-len (length n-str-rev-list)]\n           [n-str-rev-list-sorted (sort n-str-rev-list &lt;)]\n           [n-str-rev-list-sorted-len (length n-str-rev-list-sorted)]\n           [n-str-rev-list-sorted-str (list-&gt;string n-str-rev-list-sorted)]\n           [n-str-rev-list-sorted-str-len (string-length n-str-rev-list-sorted-str)]\n           [n-str-rev-list-sorted-str-rev (reverse n-str-rev-list-sorted-str)]\n           [n-str-rev-list-sorted-str-rev-len (string-length n-str-rev-list-sorted-str-rev)]\n           [n-str-rev-list-sorted-str-rev-num (string-&gt;number n-str-rev-list-sorted-str-rev)])\n      (cond [(= n-str-rev-list-sorted-str-rev-num n) -1]\n            [else n-str-rev-list-sorted-str-rev-num])))\n  (rearrange_bigger_helper n))\n",
    "  (define (rearrange_bigger_helper n)\n    (let* ([digits (number->string n)]\n           [len (string-length digits)]\n           [last-index (- len 1)])\n      (let loop ([i (- len 2)]\n                 [next-index last-index])\n        (cond\n          [(= i -1) #f]\n          [(> (string-ref digits i) (string-ref digits next-index))\n           (list i next-index)]\n          [else (loop (- i 1) (- next-index 1))]))))\n  (let* ([digits (number->string n)]\n         [len (string-length digits)]\n         [last-index (- len 1)])\n    (let ([swap-indexes (rearrange_bigger_helper n)])\n      (if swap-indexes\n          (let* ([i (car swap-indexes)]\n                 [j (cadr swap-indexes)]\n                 [swap-char (string-ref digits i)]\n                 [swap-char-index (string-index digits swap-char i)]\n                 [swap-char-index-next (if (= swap-char-index i)\n                                           (- swap-char-index 1)\n                                           swap-char-index)]\n                 [swap-char-index-next-char (string-ref digits swap-char-index-next)]\n                 [swap-char-index-next-char-index (string-index digits swap-char-index-next-char swap-char-index-next)])\n            (let ([swapped-digits (string-replace* digits (string swap-char-index-next-char) swap-char-index-next-char-index)])\n              (string-&gt;number (string-append (substring swapped-digits 0 i)\n                                              (substring swapped-digits (+ i 1) j)\n                                              (substring swapped-digits i (+ i 1))\n                                              (substring swapped-digits (+ j 1) last-index)\n                                              (substring swapped-digits j (+ j 1))))))\n          #f))))\n",
    "  (let loop ([n n] [digits (number->string n)] [i (sub1 (string-length digits))])\n    (cond\n      [(= i 0) n]\n      [(< (string-ref digits i) (string-ref digits (sub1 i)))\n       (let ([j (sub1 i)])\n         (for ([k (in-range i (sub1 (string-length digits)))])\n           (when (> (string-ref digits k) (string-ref digits j))\n             (set! j k)))\n         (let ([tmp (string-ref digits j)])\n           (string-set! digits j (string-ref digits i))\n           (string-set! digits i tmp))\n         (let ([tmp (string-copy digits)])\n           (string-set! tmp i (string-ref digits (sub1 i)))\n           (string-set! tmp (sub1 i) (string-ref digits i))\n           (string->number tmp)))]\n      [else (loop n digits (sub1 i))])))\n",
    "  (define (rearrange_bigger_helper n i)\n    (if (= i (- (string-length n) 1))\n        n\n        (let* ([n (string->number n)]\n               [n1 (number->string (+ n 1))]\n               [n2 (number->string (+ n 2))])\n          (if (and (string=? (string-take n1 i) (string-take n2 i))\n                   (string<? (string-drop n1 i) (string-drop n2 i)))\n              (string-append (string-take n1 i) (string-drop n2 i))\n              (rearrange_bigger_helper n (+ i 1))))))\n  (rearrange_bigger_helper n 0))\n",
    "  (let ([s (number->string n)])\n    (for/first ([i (in-range (sub1 (string-length s)))])\n      (let ([j (in-range (add1 i))])\n        (for/first ([k (in-range (string-length s))])\n          (when (and (not (equal? i k))\n                     (not (equal? j k))\n                     (not (equal? i j))\n                     (and (< (string-ref s i) (string-ref s k))\n                          (> (string-ref s i) (string-ref s j))))\n            (string-append (substring s 0 i)\n                           (substring s k (add1 k))\n                           (substring s i (add1 i))\n                           (substring s j (add1 j))\n                           (substring s (add1 k) (add1 j))\n                           (substring s (add1 i) (add1 k)))))))))\n",
    "  (define (rearrange_bigger_helper n i)\n    (if (= i 0)\n        n\n        (let* ([d (modulo n (expt 10 i))]\n               [d-1 (modulo n (expt 10 (- i 1)))]\n               [d-2 (modulo n (expt 10 (- i 2)))]\n               [d-3 (modulo n (expt 10 (- i 3)))]\n               [d-4 (modulo n (expt 10 (- i 4)))]\n               [d-5 (modulo n (expt 10 (- i 5)))]\n               [d-6 (modulo n (expt 10 (- i 6)))]\n               [d-7 (modulo n (expt 10 (- i 7)))]\n               [d-8 (modulo n (expt 10 (- i 8)))]\n               [d-9 (modulo n (expt 10 (- i 9)))])\n          (cond\n            [(and (= d-1 d-2) (= d-2 d-3) (= d-3 d-4) (= d-4 d-5) (= d-5 d-6) (= d-6 d-7) (= d-7 d-8) (= d-8 d-9))\n             (rearrange_bigger_helper n (- i 1))]\n            [(and (= d-1 d-2) (= d-2 d-3) (= d-3 d-4) (= d-4 d-5) (= d-5 d-6) (= d-6 d-7) (= d-7 d-8))\n             (rearrange_bigger_helper n (- i 1))]\n            [(and (= d-1 d-2) (= d-2 d-3) (= d-3 d-4) (= d-4 d-5) (= d-5 d-6) (= d-6 d-7))\n             (rearrange_bigger_helper n (- i 1))]\n            [(and (= d-1 d-2) (= d-2 d-3) (= d-3 d-4) (= d-4 d-5) (= d-5 d-6))\n             (rearrange_bigger_helper n",
    "  (define (rearrange-bigger-helper n i)\n    (if (= i 0)\n        (list n)\n        (let* ([d (modulo n (expt 10 i))]\n               [m (quotient n (expt 10 i))]\n               [r (rearrange-bigger-helper m (- i 1))])\n          (if (and (not (null? r))\n                   (&gt; (car r) d))\n              (cons d r)\n              (cons m (cons d (cdr r)))))))\n  (let* ([s (number-&gt;string n)]\n         [l (string-length s)]\n         [r (rearrange-bigger-helper n l)])\n    (if (null? r)\n        -1\n        (apply string-&gt;number (map number-&gt;string r)))))\n",
    "  (define (rearrange-bigger-helper n)\n    (define (rearrange-bigger-helper-helper n)\n      (define (rearrange-bigger-helper-helper-helper n)\n        (define (rearrange-bigger-helper-helper-helper-helper n)\n          (define (rearrange-bigger-helper-helper-helper-helper-helper n)\n            (define (rearrange-bigger-helper-helper-helper-helper-helper-helper n)\n              (define (rearrange-bigger-helper-helper-helper-helper-helper-helper-helper n)\n                (define (rearrange-bigger-helper-helper-helper-helper-helper-helper-helper-helper n)\n                  (define (rearrange-bigger-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                    (define (rearrange-bigger-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                      (define (rearrange-bigger-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                        (define (rearrange-bigger-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                          (define (rearrange-bigger-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                            (define (rearrange-bigger-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                              (define (rearrange-bigger-",
    "  (let ([digits (string->list (number->string n))])\n    (if (null? (cdr digits))\n        n\n        (let ([next-bigger (rearrange_bigger (string->number (list->string (cdr digits))))])\n          (if (< next-bigger (string->number (list->string digits)))\n              next-bigger\n              (let ([last-digit (car (reverse digits))])\n                (if (null? (cdr (reverse digits)))\n                    n\n                    (let ([last-but-one (car (reverse (cdr (reverse digits))))])\n                      (if (< last-digit last-but-one)\n                          (let ([last-but-one-index (position last-but-one digits)])\n                            (let ([last-digit-index (position last-digit digits)])\n                              (let ([new-digits (swap-elements digits last-digit-index last-but-one-index)])\n                                (let ([new-digits (sort (cdr new-digits) <)])\n                                  (string->number (list->string (cons last-digit new-digits)))))))\n                          (let ([last-digit-index (position last-digit digits)])\n                            (let ([new-digits (swap-elements digits last-digit-index (sub1 last-digit-index))])\n                              (let ([new-digits (sort (cdr new-digits) <)])\n                                (string->number (list->string (cons last-digit new-digits)))))))))))))))\n",
    "  (define (rearrange-bigger-helper n i)\n    (if (= i (- (string-length n) 1))\n        n\n        (let* ((n-i (string-ref n i))\n               (n-i+1 (string-ref n (+ i 1)))\n               (n-i+1-index (+ i 1)))\n          (if (< n-i n-i+1)\n              (let* ((n-i-index i)\n                     (n-i-index-char (string-ref n n-i-index))\n                     (n-i+1-index-char (string-ref n n-i+1-index))\n                     (n-i-index-char-index (string-index n n-i-index-char))\n                     (n-i+1-index-char-index (string-index n n-i+1-index-char))\n                     (n-i-index-char-index-char (string-ref n n-i-index-char-index))\n                     (n-i+1-index-char-index-char (string-ref n n-i+1-index-char-index))\n                     (n-i-index-char-index-char-index (string-index n n-i-index-char-index-char))\n                     (n-i+1-index-char-index-char-index (string-index n n-i+1-index-char-index-char))\n                     (n-i-index-char-index-char-index-char (string-ref n n-i-index-char-index-char-index))\n                     (n-i+1-index-char-index-char-index-char (string-ref n n-i+1-index-char-index-char-index))\n                     (n-i-index-char-index-char-index-char-index (string-index n n-i-index-char-index-char-index-char))\n                     (n-i+1-index-char-index-char-index-char-index (string-index n n-i+1-index-char-index-char-index-char))\n                     (n-i-",
    "  (define (rearrange_bigger_helper n i)\n    (if (= i 0)\n        (if (and (zero? (modulo n 10))\n                 (zero? (modulo (quotient n 10) 10)))\n            (rearrange_bigger_helper (quotient n 10) (- i 1))\n            (cons (modulo n 10) (rearrange_bigger_helper (quotient n 10) (- i 1))))\n        (if (and (zero? (modulo n 10))\n                 (zero? (modulo (quotient n 10) 10)))\n            (rearrange_bigger_helper (quotient n 10) (- i 1))\n            (if (&gt; (modulo n 10) (modulo (quotient n 10) 10))\n                (cons (modulo n 10) (rearrange_bigger_helper (quotient n 10) (- i 1)))\n                (cons (modulo (quotient n 10) 10) (rearrange_bigger_helper (quotient n 10) (- i 1)))))))\n  (define (rearrange_bigger_helper2 n i)\n    (if (= i 0)\n        (cons (modulo n 10) (rearrange_bigger_helper (quotient n 10) (- i 1)))\n        (if (&gt; (modulo n 10) (modulo (quotient n 10) 10))\n            (cons (modulo n 10) (rearrange_bigger_helper (quotient n 10) (- i 1)))\n            (cons (modulo (quotient n 10) 10) (rearrange_bigger_helper (quotient n 10) (- i 1))))))\n  (define (rearrange_bigger_helper3 n i)\n    (if (= i 0)\n        (cons (modulo n 10) (rearrange_bigger_helper (quotient n 10) (- i 1)))\n        (cons (modulo (quotient n 10) 10) (rearrange_bigger_helper (quotient n 10) (- i 1)))))\n  (define (re",
    "  (define (next-bigger-number n)\n    (if (zero? n)\n        0\n        (+ (* (remainder n 10) (expt 10 (integer-length n)))\n           (next-bigger-number (quotient n 10)))))\n  (let loop ([n (next-bigger-number n)])\n    (if (not (equal? n (next-bigger-number n)))\n        n\n        (loop (next-bigger-number n)))))\n",
    "  (define (rearrange_bigger_helper n)\n    (let ([digits (string->list (number->string n))])\n      (let loop ([i (length digits)] [j (length digits)])\n        (cond\n          [(= i 0) (error \"no bigger number\")]\n          [(= i j) (loop (- i 1) (- j 1))]\n          [(< (list-ref digits i) (list-ref digits j))\n           (let ([tmp (list-ref digits i)])\n             (set-car! (list-ref digits i) (list-ref digits j))\n             (set-car! (list-ref digits j) tmp)\n             (list->string (reverse (list-ref digits (+ i 1)))))\n           ]\n          [else (loop i (- j 1))]))))\n  (rearrange_bigger_helper n))\n",
    "  (let ([digits (string->list (number->string n))])\n    (let loop ([i (sub1 (length digits))])\n      (cond\n        [(zero? i) (error 'rearrange_bigger \"no bigger number\")]\n        [(> (list-ref digits i) (list-ref digits (sub1 i)))\n         (let ([j (sub1 i)])\n           (let loop ([k (sub1 i)])\n             (cond\n               [(> (list-ref digits k) (list-ref digits j)) (loop (sub1 k))]\n               [else (list j k)])))]\n        [else (loop (sub1 i))]))))\n",
    "  (define (rearrange_bigger_helper n i)\n    (if (= i (- (string-length (number->string n)) 1))\n        n\n        (let* ([n-str (number->string n)]\n               [n-str-len (string-length n-str)]\n               [n-str-i (string-ref n-str i)]\n               [n-str-i+1 (string-ref n-str (+ i 1))]\n               [n-str-i+1-index (+ i 1)])\n          (if (and (< n-str-i n-str-i+1)\n                   (not (zero? (modulo n-str-i+1-index 2))))\n              (let* ([n-str-i-index i]\n                     [n-str-i-index-char (string-ref n-str-i-index)]\n                     [n-str-i-index-char-index (string-index n-str-i-index-char n-str)])\n                (string-set! n-str-i-index-char-index n-str-i+1)\n                (string-set! n-str-i+1-index n-str-i-index-char)\n                (string->number n-str))\n              (rearrange_bigger_helper n (+ i 1))))))\n  (rearrange_bigger_helper n 0))\n",
    "  (define (rearrange_bigger_helper n i)\n    (if (= i (sub1 (string-length n)))\n        (string-append n (string (char-downcase (string-ref n 0))))\n        (let ((next-char (string-ref n (add1 i))))\n          (if (&gt; (char-downcase next-char) (char-downcase (string-ref n i)))\n              (string-append (substring n 0 i) (string-append next-char (string-append (string-ref n i) (substring n (add1 i)))))\n              (rearrange_bigger_helper n (add1 i))))))\n  (rearrange_bigger_helper n 0))\n</code>\n",
    "  (define (rearrange_bigger-helper n i)\n    (if (= i 0)\n        n\n        (let* ([d (modulo n (expt 10 i))]\n               [n (- n d)]\n               [d (/ d (expt 10 (- i 1)))]\n               [n (+ n (* d (expt 10 (- i 1))))])\n          (if (&gt; d (modulo n (expt 10 (- i 1))))\n              (rearrange_bigger-helper n (- i 1))\n              (let* ([n (- n (* d (expt 10 (- i 1))))]\n                     [n (+ n (* (modulo n (expt 10 (- i 1))) (expt 10 (- i 1))))]\n                     [n (+ n (* d (expt 10 (- i 2))))])\n                (rearrange_bigger-helper n (- i 2))))))))\n  (rearrange_bigger-helper n (exact-floor (log n 10))))\n</code>\n",
    "  (define (rearrange-bigger-helper n i)\n    (if (= i (- (string-length n) 1))\n        n\n        (let* ([n-i (string-ref n i)]\n               [n-i+1 (string-ref n (+ i 1))])\n          (if (&gt; n-i n-i+1)\n              (let* ([n-i-str (number-&gt;string n-i)]\n                     [n-i+1-str (number-&gt;string n-i+1)]\n                     [n-i-str-len (string-length n-i-str)]\n                     [n-i+1-str-len (string-length n-i+1-str)]\n                     [n-i-str-len-1 (- n-i-str-len 1)]\n                     [n-i+1-str-len-1 (- n-i+1-str-len 1)]\n                     [n-i-str-last-char (string-ref n-i-str n-i-str-len-1)]\n                     [n-i+1-str-last-char (string-ref n-i+1-str n-i+1-str-len-1)]\n                     [n-i-str-last-char-num (string-&gt;number n-i-str-last-char)]\n                     [n-i+1-str-last-char-num (string-&gt;number n-i+1-str-last-char)]\n                     [n-i-str-last-char-num-1 (- n-i-str-last-char-num 1)]\n                     [n-i+1-str-last-char-num-1 (- n-i+1-str-last-char-num 1)]\n                     [n-i-str-last-char-num-1-str (number-&gt;string n-i-str-last-char-num-1)]\n                     [n-i+1-str-last-char-num-1-str (number-&gt;string n-i+1-str-last-char-num-1)]\n                     [n-i-str-last",
    "  (define (rearrange_bigger_helper n i)\n    (cond [(= i (- (string-length n) 1)) #f]\n          [(> (string-ref n i) (string-ref n (+ i 1))) (string-append (substring n 0 i) (string-append (string-ref n (+ i 1)) (string-ref n i)) (substring n (+ i 2) (string-length n))))\n          [else (rearrange_bigger_helper n (+ i 1))]))\n  (rearrange_bigger_helper n 0))\n",
    "  (define (rearrange_bigger_helper n i)\n    (cond [(= i (sub1 (string-length n))) #f]\n          [(> (string->number (substring n i (add1 i))) (string->number (substring n (sub1 i) i)))\n           (string->number (string-append (substring n 0 i) (substring n (add1 i) (string-length n)) (substring n i (add1 i))))]\n          [else (rearrange_bigger_helper n (add1 i))]))\n  (rearrange_bigger_helper n 1))\n",
    "  (let ([digits (string->list (number->string n))])\n    (let ([i (find-first-decreasing-digit digits)])\n      (if i\n          (let ([j (find-first-bigger-digit (list-ref digits i) (cdr (drop digits i)))])\n            (if j\n                (let ([swap-i (list-ref digits i)])\n                  (set-car! (drop digits i) (list-ref (drop digits i) j))\n                  (set-car! (drop digits (+ i j)) swap-i)\n                  (string->number (list->string (sort (drop digits (+ i 1)) <))))\n                (error \"no bigger number\")))\n          (error \"no bigger number\")))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (let loop ([i (sub1 (length digits))])\n      (cond\n        [(= i 0) #f]\n        [(< (list-ref digits i) (list-ref digits (sub1 i)))\n         (let ([j (sub1 (sub1 i))])\n           (let loop ([j j])\n             (cond\n               [(< (list-ref digits j) (list-ref digits i))\n                (let ([tmp (list-ref digits i)])\n                  (set-car! (list-ref digits i) (list-ref digits j))\n                  (set-car! (list-ref digits j) tmp))\n                (let ([tmp (list-ref digits (sub1 i))])\n                  (set-car! (list-ref digits (sub1 i)) (list-ref digits (sub1 j)))\n                  (set-car! (list-ref digits (sub1 j)) tmp))\n                (let loop ([k (sub1 (sub1 i))])\n                  (cond\n                    [(> k j) (string->number (list->string (reverse digits)))]\n                    [else\n                     (let ([tmp (list-ref digits k)])\n                       (set-car! (list-ref digits k) (list-ref digits (sub1 k)))\n                       (set-car! (list-ref digits (sub1 k)) tmp))\n                     (loop (sub1 k))])))]\n               [else (loop (sub1 j))])))]\n        [else (loop (sub1 i))]))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (let ([i (find-next-bigger-digit digits)])\n      (if i\n          (let ([j (find-next-bigger-digit (reverse (sublist digits i)))])\n            (if j\n                (let ([j (+ i (- (length digits) j))])\n                  (let ([tmp (list-ref digits i)])\n                    (set-car! (list-ref digits i) (list-ref digits j))\n                    (set-car! (list-ref digits j) tmp))\n                  (apply string->number (append (sublist digits 0 i) (reverse (sublist digits (+ i 1)))))\n                  )\n                #f))\n          #f))))\n",
    "  (let loop ([n n] [digits (number->digits n)] [i (sub1 (length digits))])\n    (cond\n      [(zero? i) n]\n      [(> (list-ref digits i) (list-ref digits (sub1 i)))\n       (let ([j (sub1 i)])\n         (for ([k (in-range (sub1 i) -1 -1)])\n           (when (> (list-ref digits k) (list-ref digits j))\n             (set! j k)))\n         (list-swap! digits i j)\n         (list-sort! digits < (add1 i) (length digits))\n         (digits->number digits))]\n      [else (loop n digits (sub1 i))])))\n",
    "  (define (rearrange-bigger-helper n)\n    (let loop ([n n] [i 0])\n      (if (= i (sub1 (string-length n)))\n          (list n #f)\n          (let* ([n-i (string-ref n i)]\n                 [n-i+1 (string-ref n (add1 i))])\n            (if (&lt; n-i n-i+1)\n                (list (string-append (substring n 0 i)\n                                     (string n-i+1)\n                                     (string n-i)\n                                     (substring n (add1 (add1 i))))\n                      #t)\n                (loop n (add1 i)))))))\n  (let-values ([(n found?) (rearrange-bigger-helper n)])\n    (if found?\n        (string-&gt;number n)\n        #f)))\n",
    "  (define (next-bigger n)\n    (cond\n      [(= n 0) #f]\n      [(= n 1) #f]\n      [(= n 2) #f]\n      [(= n 3) #f]\n      [(= n 4) #f]\n      [(= n 5) #f]\n      [(= n 6) #f]\n      [(= n 7) #f]\n      [(= n 8) #f]\n      [(= n 9) #f]\n      [else (next-bigger (quotient n 10))]))\n  (next-bigger n))\n",
    "  (define (rearrange_bigger-helper n i)\n    (if (= i 0)\n        n\n        (let* ([d (modulo n (expt 10 i))]\n               [d-1 (modulo n (expt 10 (- i 1)))]\n               [d-2 (modulo n (expt 10 (- i 2)))]\n               [d-1-swapped (modulo (+ (* d-2 (expt 10 (- i 1)))\n                                       (* d (expt 10 (- i 2))))\n                                    (expt 10 i))])\n          (if (and (< d-1 d-1-swapped)\n                   (< d-1-swapped d))\n              (rearrange_bigger-helper (+ (- n d) d-1-swapped) (- i 1))\n              (rearrange_bigger-helper n (- i 1))))))\n  (rearrange_bigger-helper n (exact-floor (log n 10))))\n",
    "  (define (rearrange-helper n i)\n    (cond\n      [(= i 0) #f]\n      [(> (modulo n 10) (modulo (quotient n (expt 10 i)) 10))\n       (let ([j (quotient n (expt 10 i))])\n         (+ (modulo n (expt 10 i))\n            (* j (expt 10 (- i 1)))\n            (* (modulo n 10) (expt 10 i))))]\n      [else (rearrange-helper n (- i 1))]))\n  (rearrange-helper n (quotient (expt 10 (number->string n)) 10)))\n",
    "  (let ([n-str (number->string n)])\n    (if (string-&gt;number (string-append (list-&gt;string (reverse (sort (string-&gt;list n-str))))))\n        (string-&gt;number (string-append (list-&gt;string (reverse (sort (string-&gt;list n-str))))))\n        -1)))\n",
    "  (let* ([digits (string->list (number->string n))]\n         [reversed (reverse digits)]\n         [sorted (sort < reversed)])\n    (if (equal? reversed sorted)\n        -1\n        (string->number (list->string (reverse (sort > sorted)))))))\n",
    "  (define (rearrange_bigger-helper n i)\n    (if (= i 0)\n        (list n)\n        (let* ([d (remainder n 10)]\n               [n (quotient n 10)]\n               [n (rearrange_bigger-helper n (- i 1))])\n          (if (and (not (empty? n))\n                   (&gt; d (car n)))\n              (cons d n)\n              (cons (car n) (cons d (cdr n)))))))\n  (rearrange_bigger-helper n (exact-floor (log n 10))))\n</code>\n",
    "  (define (rearrange_bigger_helper n i)\n    (if (= i (- (string-length n) 1))\n        (string-append n (string (char-upcase (string-ref n 0))))\n        (let* ((c (string-ref n i))\n               (c_up (char-upcase c))\n               (c_down (char-downcase c)))\n          (if (and (&lt; c_down (string-ref n (+ i 1)))\n                   (&lt; c_up (string-ref n (+ i 1))))\n              (string-append (substring n 0 i)\n                             (string c_up)\n                             (substring n (+ i 1) (- (string-length n) i))\n                             (string c_down)\n                             (substring n (- (string-length n) i)))\n              (rearrange_bigger_helper n (+ i 1))))))\n  (rearrange_bigger_helper n 0))\n",
    "  (define (rearrange_bigger-helper n i)\n    (cond\n      [(= i (- (string-length n) 1)) #f]\n      [(< (string-ref n i) (string-ref n (+ i 1)))\n       (string-append (substring n 0 i)\n                      (string (string-ref n (+ i 1)))\n                      (string (string-ref n i))\n                      (substring n (+ i 2) (string-length n)))]\n      [else (rearrange_bigger-helper n (+ i 1))]))\n  (rearrange_bigger-helper n 0))\n",
    "  (let ([digits (string->list (number->string n))])\n    (let loop ([i (sub1 (length digits))])\n      (if (or (= i -1)\n              (and (< (list-ref digits i) (list-ref digits (sub1 i)))\n                   (not (zero? (modulo (list-ref digits i) (list-ref digits (sub1 i)))))))\n          (let ([j (sub1 i)])\n            (let loop ([k (sub1 (length digits))])\n              (if (or (= k -1)\n                      (and (< (list-ref digits k) (list-ref digits j))\n                           (not (zero? (modulo (list-ref digits k) (list-ref digits j))))))\n                  (let ([tmp (list-ref digits j)])\n                    (set-car! (list-ref digits j) (list-ref digits k))\n                    (set-car! (list-ref digits k) tmp)\n                    (let ([tmp (list-ref digits j)])\n                      (set-car! (list-ref digits j) (list-ref digits (sub1 j)))\n                      (set-car! (list-ref digits (sub1 j)) tmp))\n                    (string->number (list->string (append (sublist digits 0 j)\n                                                          (reverse (sublist digits (add1 j)))))))\n                  (loop (sub1 k))))))\n          (loop (sub1 i))))))\n",
    "  (let loop ([n n] [i (number->string n)] [j (number->string n)])\n    (if (and (not (empty? i)) (not (empty? j)))\n        (if (&gt; (string-&gt;number (string-append (list (first i)) (list (first j)))) n)\n            (string-&gt;number (string-append (list (first i)) (list (first j))))\n            (loop n (rest i) (rest j)))\n        n)))\n",
    "  (define (rearrange-bigger-helper n i)\n    (cond\n      [(= i 0) n]\n      [(> (modulo n (expt 10 i)) (modulo n (expt 10 (- i 1))))\n       (rearrange-bigger-helper (+ n (* (- (modulo n (expt 10 i)) (modulo n (expt 10 (- i 1)))) (expt 10 (- i 1)))) (- i 1))]\n      [else (rearrange-bigger-helper n (- i 1))]))\n  (rearrange-bigger-helper n (- (number->string n) 1)))\n",
    "  (let* ([s (number->string n)]\n         [l (string-length s)]\n         [i (find-first-decreasing-digit s)])\n    (cond [(= i -1) -1]\n          [(= i (sub1 l)) -1]\n          [else (let* ([j (find-first-larger-digit s i)]\n                       [t (string-ref s i)]\n                       [s (string-set s i (string-ref s j))]\n                       [s (string-set s j t)])\n                  (string->number (string-append (substring s 0 i)\n                                                 (sort (substring s i) string<?))))])))\n",
    "  (define (rearrange_bigger_helper n i)\n    (if (= i (- (length n) 1))\n        (string-&gt;number n)\n        (let* ([n (string-&gt;number n)]\n               [n (number-&gt;string n)]\n               [n (string-&gt;list n)]\n               [n (sort n &lt;)]\n               [n (list-&gt;string n)])\n          (if (&lt; (string-&gt;number (string-append (list-ref n i) (list-ref n (+ i 1))))\n                 (string-&gt;number (string-append (list-ref n (+ i 1)) (list-ref n i))))\n              (string-&gt;number (string-append (list-ref n i) (list-ref n (+ i 1))))\n              (rearrange_bigger_helper n (+ i 1))))))\n  (rearrange_bigger_helper n 0))\n</code>\nI'm not sure if this is the most efficient way to do this, but it works.\n",
    "  (define (next-bigger-number n)\n    (define (next-bigger-number-helper n)\n      (define (next-bigger-number-helper-helper n)\n        (define (next-bigger-number-helper-helper-helper n)\n          (define (next-bigger-number-helper-helper-helper-helper n)\n            (define (next-bigger-number-helper-helper-helper-helper-helper n)\n              (define (next-bigger-number-helper-helper-helper-helper-helper-helper n)\n                (define (next-bigger-number-helper-helper-helper-helper-helper-helper-helper n)\n                  (define (next-bigger-number-helper-helper-helper-helper-helper-helper-helper-helper n)\n                    (define (next-bigger-number-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                      (define (next-bigger-number-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                        (define (next-bigger-number-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                          (define (next-bigger-number-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                            (define (next-bigger-number-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                              (define (next-bigger-number-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper n",
    "  (define (rearrange_bigger_helper n i)\n    (if (= i 0)\n        n\n        (let* ([d (modulo n (expt 10 i))]\n               [n (quotient n (expt 10 i))]\n               [d (if (= d 0)\n                      (rearrange_bigger_helper n (- i 1))\n                      d)])\n          (if (= d 0)\n              0\n              (let* ([n (quotient n 10)]\n                     [n (if (= n 0)\n                            (rearrange_bigger_helper n (- i 1))\n                            n)])\n                (if (= n 0)\n                    0\n                    (let* ([n (quotient n 10)]\n                           [n (if (= n 0)\n                                  (rearrange_bigger_helper n (- i 1))\n                                  n)])\n                      (if (= n 0)\n                          0\n                          (let* ([n (quotient n 10)]\n                                 [n (if (= n 0)\n                                        (rearrange_bigger_helper n (- i 1))\n                                        n)])\n                            (if (= n 0)\n                                0\n                                (let* ([n (quotient n 10)]\n                                       [n (if (= n 0)\n                                              (rearrange_bigger_helper n (- i 1))\n                                              n)])\n                                  (if (= n 0)\n                                      0\n                                      (let* ([n (quotient n 10)]\n                                             [n (if (= n 0)\n                                                    (rearrange_bigger_helper n (- i 1))\n                                                    n)])\n                                        (if (= n 0)\n                                            0\n                                            (let* ([n (quotient n 10)]\n                                                   [n (if (= n 0)\n                                                          (rearrange_bigger_helper n (- i 1))\n                                                          n)])\n                                              (if (= n 0)\n                                                  0\n                                                  (let* ([n (quotient n 10)]\n                                                         [",
    "  (define (rearrange_bigger_helper n i)\n    (if (= i 1)\n        (list n)\n        (let* ([n-str (number->string n)]\n               [n-str-len (string-length n-str)]\n               [n-str-rev (reverse n-str)]\n               [n-str-rev-len (string-length n-str-rev)]\n               [n-str-rev-i (substring n-str-rev 0 i)]\n               [n-str-rev-i-len (string-length n-str-rev-i)]\n               [n-str-rev-i-rev (reverse n-str-rev-i)]\n               [n-str-rev-i-rev-len (string-length n-str-rev-i-rev)]\n               [n-str-rev-i-rev-1 (substring n-str-rev-i-rev 0 1)]\n               [n-str-rev-i-rev-1-len (string-length n-str-rev-i-rev-1)]\n               [n-str-rev-i-rev-1-num (string->number n-str-rev-i-rev-1)]\n               [n-str-rev-i-rev-1-num-plus-1 (+ n-str-rev-i-rev-1-num 1)]\n               [n-str-rev-i-rev-1-num-plus-1-str (number->string n-str-rev-i-rev-1-num-plus-1)]\n               [n-str-rev-i-rev-1-num-plus-1-str-len (string-length n-str-rev-i-rev-1-num-plus-1-str)]\n               [n-str-rev-i-rev-1-num-plus-1-str-1 (substring n-str-rev-i-rev-1-num-plus-1-str 0 1)]\n               [n-str-rev-i-rev-1-num-plus-1-str-1-len (string-length n-str-rev-i-rev-1-num-plus-1-str-1",
    "  (define (rearrange-bigger-helper n s)\n    (cond\n      [(empty? s) #f]\n      [(> n (apply string->number (reverse s))) (apply string->number (reverse s))]\n      [else (rearrange-bigger-helper n (rest s))]))\n  (rearrange-bigger-helper n (permutations (number->string n))))\n",
    "  (define (rearrange_bigger_helper n i)\n    (if (= i (- (string-length n) 1))\n        (string-append n \"0\")\n        (let* ([n-i (string-ref n i)]\n               [n-i-1 (string-ref n (- i 1))])\n          (if (< n-i-1 n-i)\n              (string-append (substring n 0 i)\n                             (string n-i)\n                             (string n-i-1)\n                             (substring n (+ i 2) (string-length n)))\n              (rearrange_bigger_helper n (+ i 1))))))\n  (rearrange_bigger_helper n 0))\n",
    "  (define (rearrange_bigger-helper n i)\n    (cond [(= i (sub1 (string-length n))) #f]\n          [(< (string-ref n i) (string-ref n (add1 i)))\n           (string-append (substring n 0 i)\n                          (string (string-ref n (add1 i)))\n                          (string (string-ref n i))\n                          (substring n (add1 (add1 i))))]\n          [else (rearrange_bigger-helper n (add1 i))]))\n  (rearrange_bigger-helper n 0))\n",
    "  (define (rearrange-bigger-helper n i)\n    (cond [(= i 0) n]\n          [(< (modulo n (expt 10 i)) (modulo n (expt 10 (- i 1))))\n           (rearrange-bigger-helper (+ n (* (- (modulo n (expt 10 i)) (modulo n (expt 10 (- i 1)))) (expt 10 (- i 1)))) (- i 1))]\n          [else (rearrange-bigger-helper n (- i 1))]))\n  (rearrange-bigger-helper n (number->string n)))\n",
    "  (let* ([digits (string->list (number->string n))]\n         [len (length digits)]\n         [i (find-first-decreasing-digit digits len)])\n    (if (negative? i)\n        n\n        (let* ([j (find-first-larger-digit digits i len)]\n               [tmp (list-ref digits i)]\n               [digits (set-list-ref digits i (list-ref digits j))]\n               [digits (set-list-ref digits j tmp)])\n          (let* ([sub-digits (sublist digits (+ i 1) len)]\n                 [sub-digits (sort sub-digits <)])\n            (list->number (append (sublist digits 0 (+ i 1)) sub-digits)))))))\n",
    "  (define (rearrange_bigger_helper n i)\n    (if (= i (- (string-length n) 1))\n        n\n        (let* ([n (string->number n)]\n               [n-i (string-ref n i)]\n               [n-i+1 (string-ref n (+ i 1))])\n          (if (&gt; n-i+1 n-i)\n              (let* ([n-i+1-index (string-index n n-i+1)]\n                     [n-i-index i]\n                     [n-i+1-index-char (string-ref n n-i+1-index)]\n                     [n-i-index-char (string-ref n n-i-index)]\n                     [n (string-replace n n-i-index-char n-i+1-index-char)]\n                     [n (string-replace n n-i+1-index-char n-i-index-char)])\n                (number->string n))\n              (rearrange_bigger_helper n (+ i 1))))))\n  (rearrange_bigger_helper n 0))\n",
    "  (let ([digits (string->list (number->string n))])\n    (cond\n      [(empty? digits) n]\n      [(= (length digits) 1) n]\n      [else\n       (let ([next-bigger (rearrange-bigger-helper (reverse digits))])\n         (if next-bigger\n             (string->number (list->string (reverse next-bigger)))\n             n))])))\n",
    "  (let ((digits (string->list (number->string n))))\n    (let loop ((i (- (length digits) 2))\n               (digits digits))\n      (cond ((< i 0) (error \"no bigger number\"))\n            ((> (list-ref digits i) (list-ref digits (+ i 1)))\n             (let ((j (loop (- i 1) digits)))\n               (let ((tmp (list-ref digits j)))\n                 (set-car! (list-ref digits j) (list-ref digits (+ j 1)))\n                 (set-car! (list-ref digits (+ j 1)) tmp)\n                 (string->number (list->string (append (take digits j)\n                                                       (reverse (drop digits (+ j 1)))))))))\n            (else (loop (- i 1) digits))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (let ([i (find-index-from-right (lambda (x y) (< x y)) digits)])\n      (if (not i)\n          n\n          (let ([j (find-index-from-right (lambda (x y) (> x y)) (sublist digits i))])\n            (let ([temp (list-ref digits j)])\n              (list-set digits j (list-ref digits i))\n              (list-set digits i temp)\n              (let ([sublist (sublist digits (+ i 1))])\n                (set! sublist (sort sublist <))\n                (set! digits (append (sublist digits 0 (+ i 1)) sublist))\n                (string->number (list->string digits)))))))))\n",
    "  (define (rearrange_bigger-helper n i)\n    (cond\n      [(= i (sub1 (string-length n))) #f]\n      [(> (string-&gt;number (substring n i (add1 i)))\n          (string-&gt;number (substring n (add1 i) (add1 (add1 i)))))\n       (rearrange_bigger-helper n (add1 i))]\n      [else\n       (string-&gt;number (string-append\n                         (substring n 0 i)\n                         (substring n (add1 i) (add1 (add1 i)))\n                         (substring n i (add1 i))\n                         (substring n (add1 (add1 i)) (string-length n))))]))\n  (rearrange_bigger-helper (number-&gt;string n) 0))\n",
    "  (let ([digits (string->list (number->string n))])\n    (let loop ([i (sub1 (length digits))])\n      (cond\n        [(zero? i) #f]\n        [(> (list-ref digits i) (list-ref digits (sub1 i)))\n         (let ([j (sub1 i)])\n           (while (and (> j 0)\n                       (> (list-ref digits j) (list-ref digits (sub1 j))))\n             (set! j (sub1 j)))\n           (let ([tmp (list-ref digits j)])\n             (set-list-ref! digits j (list-ref digits (sub1 i)))\n             (set-list-ref! digits (sub1 i) tmp))\n           (let ([tmp (list-ref digits i)])\n             (set-list-ref! digits i (list-ref digits (sub1 i)))\n             (set-list-ref! digits (sub1 i) tmp))\n           (string->number (list->string (sort digits <))))]\n        [else (loop (sub1 i))]))))\n",
    "  (define (rearrange_bigger_helper n i)\n    (if (= i 0)\n        (list n)\n        (let* ([d (modulo n (expt 10 i))]\n               [n (quotient n (expt 10 i))]\n               [d (modulo d (expt 10 (- i 1)))]\n               [n (quotient n (expt 10 (- i 1)))])\n          (if (and (= d 0) (= n 0))\n              (rearrange_bigger_helper n (- i 1))\n              (rearrange_bigger_helper (+ (* n (expt 10 i)) d) (- i 1))))))\n  (rearrange_bigger_helper n (exact-floor (log n 10))))\n",
    "  (define (rearrange_bigger_helper n i)\n    (if (= i 0)\n        (if (zero? (modulo n 10))\n            (rearrange_bigger_helper (quotient n 10) (- i 1))\n            (list (quotient n 10) (modulo n 10)))\n        (if (= (modulo n 10) 0)\n            (rearrange_bigger_helper (quotient n 10) (- i 1))\n            (cons (modulo n 10) (rearrange_bigger_helper (quotient n 10) (- i 1))))))\n  (define (rearrange_bigger_helper2 n i)\n    (if (= i 0)\n        (list (quotient n 10) (modulo n 10))\n        (cons (modulo n 10) (rearrange_bigger_helper2 (quotient n 10) (- i 1)))))\n  (define (rearrange_bigger_helper3 n i)\n    (if (= i 0)\n        (list (quotient n 10) (modulo n 10))\n        (cons (modulo n 10) (rearrange_bigger_helper3 (quotient n 10) (- i 1)))))\n  (define (rearrange_bigger_helper4 n i)\n    (if (= i 0)\n        (list (quotient n 10) (modulo n 10))\n        (cons (modulo n 10) (rearrange_bigger_helper4 (quotient n 10) (- i 1)))))\n  (define (rearrange_bigger_helper5 n i)\n    (if (= i 0)\n        (list (quotient n 10) (modulo n 10))\n        (cons (modulo n 10) (rearrange_bigger_helper5 (quotient n 10) (- i 1)))))\n  (define (rearrange_bigger_helper6 n i)\n    (if (= i 0)\n        (list (quotient n 10) (modulo n 10))\n        (cons (modulo n 10) (rearrange_bigger_hel",
    "  (define (rearrange_bigger_helper n acc)\n    (if (zero? n)\n        acc\n        (rearrange_bigger_helper (quotient n 10) (cons (remainder n 10) acc))))\n  (define (rearrange_bigger_helper2 lst acc)\n    (if (null? lst)\n        acc\n        (rearrange_bigger_helper2 (cdr lst) (cons (car lst) acc))))\n  (define (rearrange_bigger_helper3 lst acc)\n    (if (null? lst)\n        acc\n        (rearrange_bigger_helper3 (cdr lst) (cons (car lst) acc))))\n  (define (rearrange_bigger_helper4 lst acc)\n    (if (null? lst)\n        acc\n        (rearrange_bigger_helper4 (cdr lst) (cons (car lst) acc))))\n  (define (rearrange_bigger_helper5 lst acc)\n    (if (null? lst)\n        acc\n        (rearrange_bigger_helper5 (cdr lst) (cons (car lst) acc))))\n  (define (rearrange_bigger_helper6 lst acc)\n    (if (null? lst)\n        acc\n        (rearrange_bigger_helper6 (cdr lst) (cons (car lst) acc))))\n  (define (rearrange_bigger_helper7 lst acc)\n    (if (null? lst)\n        acc\n        (rearrange_bigger_helper7 (cdr lst) (cons (car lst) acc))))\n  (define (rearrange_bigger_helper8 lst acc)\n    (if (null? lst)\n        acc\n        (rearrange_bigger_helper8 (cdr lst) (cons (car lst) acc))))\n  (define (rearrange_bigger_helper9 lst acc)\n    (if (null? lst)\n        acc\n",
    "  (let loop ([n n] [i 0])\n    (if (= i (- (number->string n) 1))\n        n\n        (let* ([n-str (number->string n)]\n               [n-str-len (string-length n-str)]\n               [n-str-i (string-ref n-str i)]\n               [n-str-i+1 (string-ref n-str (+ i 1))])\n          (if (< n-str-i n-str-i+1)\n              (string->number (string-append (substring n-str 0 i)\n                                             (string n-str-i+1)\n                                             (string n-str-i)\n                                             (substring n-str (+ i 2) n-str-len)))\n              (loop n (+ i 1)))))))\n",
    "  (define (rearrange-bigger-helper n)\n    (if (= n 0)\n        0\n        (let* ([d (modulo n 10)]\n               [r (quotient n 10)])\n          (if (= d 0)\n              (rearrange-bigger-helper (+ r 1))\n              (if (= r 0)\n                  (rearrange-bigger-helper (+ n 1))\n                  (let* ([d2 (modulo r 10)]\n                         [r2 (quotient r 10)])\n                    (if (&lt; d d2)\n                        (+ (* d2 10) d)\n                        (rearrange-bigger-helper (+ (* r2 10) d)))))))))\n  (rearrange-bigger-helper n))\n",
    "  (define (rearrange_bigger_helper n i)\n    (if (= i 0)\n        (list n)\n        (let ([d (modulo n (expt 10 i))])\n          (if (and (< d (modulo n (expt 10 (- i 1))))\n                   (< (modulo n (expt 10 (- i 1))) (modulo n (expt 10 (- i 2)))))\n              (list (+ n (* (- (modulo n (expt 10 (- i 1))) d) (expt 10 (- i 2))))\n                    (- n (modulo n (expt 10 (- i 1))) d))\n              (rearrange_bigger_helper n (- i 1))))))\n  (rearrange_bigger_helper n (floor (log n 10))))\n",
    "  (define (rearrange_bigger_helper n i)\n    (if (= i (- (string-length n) 1))\n        (string-append n (string (char-upcase (string-ref n 0))))\n        (let ((next-char (string-ref n (+ i 1))))\n          (if (&gt; (char-&gt;integer next-char) (char-&gt;integer (string-ref n i)))\n              (string-append (substring n 0 i) (string (char-upcase (string-ref n i))) (substring n (+ i 1) (string-length n)))\n              (rearrange_bigger_helper n (+ i 1))))))\n  (rearrange_bigger_helper n 0))\n",
    "  (define (rearrange_bigger_helper n i)\n    (cond\n      [(= i (- (string-length n) 1)) #f]\n      [(< (string-ref n i) (string-ref n (+ i 1)))\n       (string-append (substring n 0 i)\n                      (list (string-ref n (+ i 1)))\n                      (list (string-ref n i))\n                      (substring n (+ i 2) (string-length n)))]\n      [else (rearrange_bigger_helper n (+ i 1))]))\n  (rearrange_bigger_helper n 0))\n",
    "  (define (rearrange_bigger_helper n)\n    (let* ([n-str (number->string n)]\n           [n-str-len (string-length n-str)]\n           [n-str-chars (string->list n-str)]\n           [n-str-chars-sorted (sort n-str-chars <)])\n      (if (equal? n-str-chars n-str-chars-sorted)\n          -1\n          (let* ([n-str-chars-sorted-reversed (reverse n-str-chars-sorted)]\n                 [n-str-chars-sorted-reversed-str (list->string n-str-chars-sorted-reversed)]\n                 [n-str-chars-sorted-reversed-str-num (string->number n-str-chars-sorted-reversed-str)])\n            (if (> n-str-chars-sorted-reversed-str-num n)\n                (rearrange_bigger_helper n-str-chars-sorted-reversed-str-num)\n                n-str-chars-sorted-reversed-str-num)))))\n  (rearrange_bigger_helper n))\n",
    "  (let ([digits (string->list (number->string n))])\n    (let ([next-bigger (next-permutation digits)])\n      (if next-bigger\n          (string->number (list->string next-bigger))\n          -1))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (let ([i (find-next-bigger-digit digits)])\n      (if i\n          (let ([j (find-next-bigger-digit (reverse (sublist digits i)) i)])\n            (if j\n                (let ([temp (list-ref digits j)])\n                  (set-car! (list-ref digits j) (list-ref digits i))\n                  (set-car! (list-ref digits i) temp)\n                  (string->number (list->string (append (reverse (sublist digits (+ i 1))) (sublist digits 0 i)))))\n                (let ([temp (list-ref digits i)])\n                  (set-car! (list-ref digits i) (list-ref digits (- (length digits) 1)))\n                  (set-car! (list-ref digits (- (length digits) 1)) temp)\n                  (string->number (list->string (append (reverse (sublist digits (+ i 1))) (sublist digits 0 i)))))))\n          (error \"No bigger number possible\"))))))\n",
    "  (define (rearrange_bigger_helper n)\n    (define (rearrange_bigger_helper_helper n)\n      (define (rearrange_bigger_helper_helper_helper n)\n        (define (rearrange_bigger_helper_helper_helper_helper n)\n          (define (rearrange_bigger_helper_helper_helper_helper_helper n)\n            (define (rearrange_bigger_helper_helper_helper_helper_helper_helper n)\n              (define (rearrange_bigger_helper_helper_helper_helper_helper_helper_helper n)\n                (define (rearrange_bigger_helper_helper_helper_helper_helper_helper_helper_helper n)\n                  (define (rearrange_bigger_helper_helper_helper_helper_helper_helper_helper_helper_helper n)\n                    (define (rearrange_bigger_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper n)\n                      (define (rearrange_bigger_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper n)\n                        (define (rearrange_bigger_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper n)\n                          (define (rearrange_bigger_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper n)\n                            (define (rearrange_bigger_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper n)\n                              (define (rearrange_bigger_",
    "  (define (rearrange-bigger-helper n i)\n    (if (= i (sub1 (string-length n)))\n        n\n        (let* ([n-i (string-ref n i)]\n               [n-i+1 (string-ref n (add1 i))]\n               [n-i+1-bigger? (string<? n-i n-i+1)])\n          (if n-i+1-bigger?\n              (rearrange-bigger-helper (string-append (substring n 0 i)\n                                                      (string n-i+1)\n                                                      (string n-i)\n                                                      (substring n (add1 (add1 i))))\n                                       (add1 i))\n              (rearrange-bigger-helper n (add1 i))))))\n  (rearrange-bigger-helper (number->string n) 0))\n",
    "  (let ([d (string->list (number->string n))])\n    (for/first ([i (in-range (sub1 (length d)) -1 -1)]\n                [j (in-range (add1 i) (length d))])\n      (when (< (list-ref d i) (list-ref d j))\n        (list-swap! d i j)\n        (list-sort! d < (range i (length d)))\n        (string->number (list->string d))))))\n",
    "  (define (rearrange_bigger-helper n i)\n    (if (= i (sub1 (string-length n)))\n        n\n        (let* ([n-i (string-ref n i)]\n               [n-i+1 (string-ref n (add1 i))])\n          (if (&lt; n-i+1 n-i)\n              (string-append (substring n 0 i)\n                             (string n-i+1)\n                             (string n-i)\n                             (substring n (add1 (add1 i))))\n              (rearrange_bigger-helper n (add1 i))))))\n  (rearrange_bigger-helper n 0))\n",
    "  (let ([digits (string->list (number->string n))])\n    (let ([i (find-index (lambda (x) (< x (cadr x))) digits)])\n      (if i\n          (let ([j (find-index (lambda (x) (> x (cadr x))) (reverse (sublist digits i)))])\n            (string->number (list->string (append (sublist digits 0 i)\n                                                  (list (list-ref digits (+ i j)))\n                                                  (list (list-ref digits (+ i 1)))\n                                                  (reverse (sublist digits (+ i 2) (+ i j)))\n                                                  (reverse (sublist digits (+ i j) (length digits)))))))\n          -1))))\n"
  ]
}