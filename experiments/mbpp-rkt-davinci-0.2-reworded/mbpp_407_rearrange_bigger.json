{
  "name": "mbpp_407_rearrange_bigger",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to create the next bigger number by rearranging the digits of a given number.\n(define (rearrange_bigger n)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_407_rearrange_bigger.py",
  "prompt_terminology": "reworded",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate rearrange_bigger))\n    (check-equal? (candidate 12) 21)\n    (check-equal? (candidate 10) #f)\n    (check-equal? (candidate 102) 120)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (rearrange-bigger-helper n)\n    (if (= n 0)\n        0\n        (let ([d (modulo n 10)])\n          (if (= d 0)\n              (rearrange-bigger-helper (quotient n 10))\n              (let ([n2 (quotient n 10)])\n                (if (= n2 0)\n                    (cons d n2)\n                    (let ([n3 (rearrange-bigger-helper n2)])\n                      (if (and (pair? n3)\n                               (< (car n3) d))\n                          (cons d (cons (car n3) (cdr n3)))\n                          (cons d n3)))))))))\n  (if (= n 0)\n      0\n      (let ([n2 (rearrange-bigger-helper n)])\n        (if (pair? n2)\n            (apply + (map (lambda (x) (* x (expt 10 (- (length n2) 1)))) n2))\n            n2))))\n",
    "  (let ([n-str (number->string n)])\n    (define (rearrange-bigger-helper n-str)\n      (let ([n-str-len (string-length n-str)])\n        (if (= n-str-len 1)\n            (string->number n-str)\n            (let ([n-str-last-char (string-ref n-str (- n-str-len 1))])\n              (let ([n-str-last-char-num (string->number n-str-last-char)])\n                (let ([n-str-last-char-num-1 (sub1 n-str-last-char-num)])\n                  (let ([n-str-last-char-num-1-str (number->string n-str-last-char-num-1)])\n                    (let ([n-str-last-char-num-1-str-len (string-length n-str-last-char-num-1-str)])\n                      (let ([n-str-last-char-num-1-str-len-1 (sub1 n-str-last-char-num-1-str-len)])\n                        (if (= n-str-last-char-num-1-str-len-1 0)\n                            (string->number n-str-last-char-num-1-str)\n                            (let ([n-str-last-char-num-1-str-last-char (string-ref n-str-last-char-num-1-str n-str-last-char-num-1-str-len-1)])\n                              (let ([n-str-last-char-num-1-str-last-char-num (string->number n-str-last-char-num-1-str-last-char)])\n                                (let ([n-str-last-char-num-1-str-last-char-num-1 (sub1 n-str-last-char-num-1-str-last-char-num)])\n                                  (let ([n-str-last-char-num-1-str-last-char-num-1-str (number->string n",
    "  (define (rearrange_bigger_helper n lst)\n    (cond\n      [(empty? lst) (error \"No bigger number\")]\n      [(> (first lst) n) (first lst)]\n      [else (rearrange_bigger_helper n (rest lst))]))\n  (rearrange_bigger_helper n (permutations (number->list n))))\n",
    "  (define (rearrange_bigger-iter n i)\n    (cond [(= i 0) n]\n          [else (let* ([d (modulo n (expt 10 i))]\n                       [n (quotient n (expt 10 i))])\n                  (if (and (not (= d 0))\n                           (&gt; d (modulo n (expt 10 (- i 1)))))\n                      (let ([n (+ (* n (expt 10 i))\n                                  (modulo n (expt 10 (- i 1)))\n                                  (* (- d (modulo n (expt 10 (- i 1))))\n                                     (expt 10 (- i 1))))])\n                        (rearrange_bigger-iter n (- i 1)))\n                      (rearrange_bigger-iter n (- i 1))))]))\n  (rearrange_bigger-iter n (exact-floor (log n 10))))\n",
    "  (define (rearrange-helper n i)\n    (if (= i (- (string-length n) 1))\n        (string-append n \"0\")\n        (let* ([n-i (string-ref n i)]\n               [n-i+1 (string-ref n (+ i 1))]\n               [n-i-1 (string-ref n (- i 1))]\n               [n-i-2 (string-ref n (- i 2))])\n          (if (and (char&gt;=? n-i-1 n-i)\n                   (char&gt;=? n-i+1 n-i))\n              (rearrange-helper n (+ i 1))\n              (let* ([n-i-1-index (string-index n n-i-1)]\n                     [n-i-2-index (string-index n n-i-2)]\n                     [n-i-1-index-new (+ n-i-1-index 1)]\n                     [n-i-2-index-new (+ n-i-2-index 1)]\n                     [n-i-1-new (string-ref n n-i-1-index-new)]\n                     [n-i-2-new (string-ref n n-i-2-index-new)]\n                     [n-i-1-new-index (string-index n n-i-1-new)]\n                     [n-i-2-new-index (string-index n n-i-2-new)])\n                (let ([n-i-1-new-index-new (+ n-i-1-new-index 1)]\n                      [n-i-2-new-index-new (+ n-i-2-new-index 1)])\n                  (string-append (substring n 0 n-i-1-index)\n                                 (string n-i-1-new)\n                                 (substring n n-i-1-index-new n-i-2-index)\n                                 (string n-i-2-new)\n                                 (substring n n-i-2-index-new))))))))\n  (rearrange-helper n 0))\n</code>\n",
    "  (define (swap lst i j)\n    (define (swap-helper lst i j)\n      (cond ((= i j) lst)\n            ((= i 0) (cons (list-ref lst j) (swap-helper (append (list-tail lst j) (list (list-ref lst i))) i (- j 1))))\n            (else (cons (list-ref lst i) (swap-helper (append (list-tail lst j) (list (list-ref lst i))) (- i 1) (- j 1))))))\n    (swap-helper lst (- (length lst) 1) (- j 1)))\n  (define (find-index lst i)\n    (cond ((= i 0) -1)\n          ((< (list-ref lst i) (list-ref lst (- i 1))) i)\n          (else (find-index lst (- i 1)))))\n  (define (find-swap-index lst i j)\n    (cond ((= j 0) -1)\n          ((> (list-ref lst i) (list-ref lst j)) j)\n          (else (find-swap-index lst i (- j 1)))))\n  (define (rearrange-bigger-helper lst i j)\n    (cond ((= i -1) -1)\n          ((= j -1) (rearrange-bigger-helper lst (- i 1) (- i 1)))\n          ((= (find-swap-index lst i j) -1) (rearrange-bigger-helper lst (- i 1) (- i 1)))\n          (else (swap lst i (find-swap-index lst i j)))))\n  (rearrange-bigger-helper (number->list n) (- (length (number->list n)) 1) (- (length (number->list n)) 1)))\n",
    "  (let loop ([n n] [i 0])\n    (if (= i (sub1 (string-length n)))\n        n\n        (let ([n (string->number (string-append (string-drop n i) (string-take n i)))])\n          (if (&lt; n (string->number n))\n              n\n              (loop n (add1 i)))))))\n</code>\n",
    "  (define (rearrange_bigger_helper n)\n    (if (zero? (modulo n 10))\n        (rearrange_bigger_helper (quotient n 10))\n        (list (modulo n 10) (quotient n 10))))\n  (define (rearrange_bigger_helper2 n)\n    (if (zero? (modulo n 10))\n        (rearrange_bigger_helper2 (quotient n 10))\n        (list (modulo n 10) (quotient n 10))))\n  (define (rearrange_bigger_helper3 n)\n    (if (zero? (modulo n 10))\n        (rearrange_bigger_helper3 (quotient n 10))\n        (list (modulo n 10) (quotient n 10))))\n  (define (rearrange_bigger_helper4 n)\n    (if (zero? (modulo n 10))\n        (rearrange_bigger_helper4 (quotient n 10))\n        (list (modulo n 10) (quotient n 10))))\n  (define (rearrange_bigger_helper5 n)\n    (if (zero? (modulo n 10))\n        (rearrange_bigger_helper5 (quotient n 10))\n        (list (modulo n 10) (quotient n 10))))\n  (define (rearrange_bigger_helper6 n)\n    (if (zero? (modulo n 10))\n        (rearrange_bigger_helper6 (quotient n 10))\n        (list (modulo n 10) (quotient n 10))))\n  (define (rearrange_bigger_helper7 n)\n    (if (zero? (modulo n 10))\n        (rearrange_bigger_helper7 (quotient n 10))\n        (list (modulo n 10) (quotient n 10))))\n  (define (rearrange_bigger_helper8 n)\n    (if (zero? (modulo n 10))\n        (rearrange_bigger_helper8 (qu",
    "  (let loop ([n n] [i (number->string n)] [j (number->string n)])\n    (if (not (string-ci=? i j))\n        (string->number j)\n        (loop n (number->string (add1 n)) (number->string (add1 n))))))\n",
    "  (define (rearrange_bigger_iter n i)\n    (if (= i (sub1 (string-length n)))\n        (string-append n (string (char-downcase (string-ref n 0))))\n        (let* ((digit (string-ref n i))\n               (next-digit (string-ref n (add1 i)))\n               (next-digit-upcase (char-upcase next-digit)))\n          (if (and (char-numeric? digit)\n                   (char-numeric? next-digit)\n                   (&gt; digit next-digit))\n              (string-append (substring n 0 i)\n                             (string next-digit-upcase)\n                             (string digit)\n                             (substring n (add1 (add1 i))))\n              (rearrange_bigger_iter n (add1 i))))))\n  (rearrange_bigger_iter n 0))\n",
    "  (define (rearrange_bigger_helper n)\n    (if (zero? n)\n        '(0)\n        (cons (modulo n 10) (rearrange_bigger_helper (quotient n 10)))))\n  (define (rearrange_bigger_helper2 n)\n    (if (zero? n)\n        '(0)\n        (cons (modulo n 10) (rearrange_bigger_helper2 (quotient n 10)))))\n  (define (rearrange_bigger_helper3 n)\n    (if (zero? n)\n        '(0)\n        (cons (modulo n 10) (rearrange_bigger_helper3 (quotient n 10)))))\n  (define (rearrange_bigger_helper4 n)\n    (if (zero? n)\n        '(0)\n        (cons (modulo n 10) (rearrange_bigger_helper4 (quotient n 10)))))\n  (define (rearrange_bigger_helper5 n)\n    (if (zero? n)\n        '(0)\n        (cons (modulo n 10) (rearrange_bigger_helper5 (quotient n 10)))))\n  (define (rearrange_bigger_helper6 n)\n    (if (zero? n)\n        '(0)\n        (cons (modulo n 10) (rearrange_bigger_helper6 (quotient n 10)))))\n  (define (rearrange_bigger_helper7 n)\n    (if (zero? n)\n        '(0)\n        (cons (modulo n 10) (rearrange_bigger_helper7 (quotient n 10)))))\n  (define (rearrange_bigger_helper8 n)\n    (if (zero? n)\n        '(0)\n        (cons (modulo n 10) (rearrange_bigger_helper8 (quotient n 10)))))\n  (define (rearrange_bigger_helper9 n)\n    (if (zero? n)\n        '(0)\n        (",
    "  (define (rearrange-bigger-helper n i)\n    (if (= i (sub1 (length n)))\n        (list->number n)\n        (let ([n-i (list-ref n i)])\n          (for/first ([j (in-range (add1 i) (length n))]\n                      #:when (and (< n-i (list-ref n j))\n                                  (not (zero? (modulo (list->number (sublist n i)) 10))))\n                      #:break (list->number (append (sublist n 0 i)\n                                                    (list (list-ref n j))\n                                                    (sort (append (list n-i)\n                                                                  (sublist n (add1 i) j)\n                                                                  (sublist n (add1 j))))\n                                                          <)))]\n            j))))\n  (rearrange-bigger-helper (number->list n) 0))\n",
    "  (let loop ([n n] [i (number->string n)])\n    (cond [(empty? i) n]\n          [else (let* ([i (string->list i)]\n                       [j (last i)]\n                       [i (butlast i)]\n                       [k (find-first-bigger j i)]\n                       [i (insert-at k j i)])\n                  (loop (string->number (list->string i)) i))])))\n",
    "  (define (rearrange-bigger-helper n d)\n    (if (zero? d)\n        n\n        (let* ([d (modulo n 10)]\n               [n (quotient n 10)]\n               [n (rearrange-bigger-helper n d)])\n          (if (zero? n)\n              d\n              (let* ([n (modulo n 10)]\n                     [n (quotient n 10)])\n                (if (&lt; d n)\n                    (let* ([n (+ (* n 10) d)]\n                           [n (+ (* n 10) n)])\n                      (rearrange-bigger-helper n d))\n                    (rearrange-bigger-helper (+ (* n 10) d) d)))))))\n  (rearrange-bigger-helper n (modulo n 10)))\n</code>\n",
    "  (define (rearrange_bigger_helper n i)\n    (cond\n      [(= i 0) n]\n      [(> (quotient n (expt 10 i)) (quotient n (expt 10 (+ i 1))))\n       (rearrange_bigger_helper (+ n (* (- (quotient n (expt 10 i)) (quotient n (expt 10 (+ i 1)))) (expt 10 (+ i 1)))) (- i 1))]\n      [else (rearrange_bigger_helper n (- i 1))]))\n  (rearrange_bigger_helper n (- (number->string n) 1)))\n",
    "  (define (rearrange_bigger_helper n i)\n    (if (= i (- (string-length n) 1))\n        n\n        (let* ((n-i (string-ref n i))\n               (n-i+1 (string-ref n (+ i 1)))\n               (n-i+1-index (+ i 1)))\n          (if (&gt; n-i n-i+1)\n              (let* ((n-i+1-index (+ i 1))\n                     (n-i+1-index-char (string-ref n n-i+1-index))\n                     (n-i-index i)\n                     (n-i-index-char (string-ref n n-i-index))\n                     (n-i+1-index-char-index (string-index n n-i+1-index-char))\n                     (n-i-index-char-index (string-index n n-i-index-char)))\n                (string-set! n n-i-index-char-index n-i+1-index-char)\n                (string-set! n n-i+1-index-char-index n-i-index-char)\n                (rearrange_bigger_helper n (+ i 1)))\n              (rearrange_bigger_helper n (+ i 1))))))\n  (rearrange_bigger_helper (number-&gt;string n) 0))\n",
    "  (define (rearrange_bigger-helper n i)\n    (cond ((= i 0) n)\n          ((&gt; (modulo n (expt 10 i)) (modulo n (expt 10 (- i 1))))\n           (rearrange_bigger-helper (modulo n (expt 10 (- i 1))) (- i 1)))\n          (else (rearrange_bigger-helper (modulo n (expt 10 (- i 1))) (- i 1)))))\n  (rearrange_bigger-helper n (floor (log n 10))))\n</code>\n",
    "  (let loop ([n n] [digits (string->list (number->string n))] [i (length digits)])\n    (cond [(= i 1) n]\n          [(< (list-ref digits (- i 1)) (list-ref digits (- i 2)))\n           (loop (string->number (list->string (sort (reverse (list-ref digits (- i 1)) (sublist digits 0 (- i 1)))))\n                    (sublist digits 0 (- i 1)) (- i 1)))]\n          [else (loop n (sublist digits 0 (- i 1)) (- i 1))])))\n",
    "  (define (rearrange_bigger_helper n)\n    (cond\n      [(empty? n) empty]\n      [(= (first n) 9) (cons (first n) (rearrange_bigger_helper (rest n)))]\n      [else (cons (first n) (rearrange_bigger_helper (rest n)))]))\n  (rearrange_bigger_helper (list->string n)))\n",
    "  (define (rearrange_bigger_helper n i)\n    (if (= i 0)\n        n\n        (let* ([n-str (number->string n)]\n               [n-str-len (string-length n-str)]\n               [n-str-i (string-ref n-str (- n-str-len i))]\n               [n-str-i-1 (string-ref n-str (- n-str-len (+ i 1)))])\n          (if (> n-str-i n-str-i-1)\n              (let* ([n-str-i-1-index (- n-str-len (+ i 1))]\n                     [n-str-i-index (- n-str-len i)]\n                     [n-str-i-1-index-char (string-ref n-str n-str-i-1-index)]\n                     [n-str-i-index-char (string-ref n-str n-str-i-index)]\n                     [n-str-i-1-index-char-num (string->number n-str-i-1-index-char)]\n                     [n-str-i-index-char-num (string->number n-str-i-index-char)]\n                     [n-str-i-1-index-char-num-swapped (- n-str-i-index-char-num n-str-i-1-index-char-num)]\n                     [n-str-i-index-char-num-swapped (- n-str-i-1-index-char-num n-str-i-1-index-char-num-swapped)]\n                     [n-str-i-1-index-char-num-swapped-str (number->string n-str-i-1-index-char-num-swapped)]\n                     [n-str-i-index-char-num-swapped-str (number->string n-str-i-index-char-num-swapped)]\n                     [n-str-i-1-index-char-num-swapped-str-len (string-length n-str-i-1-index-char-num-swapped-str)]\n                    "
  ]
}