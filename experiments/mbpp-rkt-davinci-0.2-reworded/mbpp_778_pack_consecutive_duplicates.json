{
  "name": "mbpp_778_pack_consecutive_duplicates",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to pack consecutive duplicates of a given list elements into sublists.\n(define (pack_consecutive_duplicates list1)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_778_pack_consecutive_duplicates.py",
  "prompt_terminology": "reworded",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate pack_consecutive_duplicates))\n    (check-equal? (candidate (list 0 0 1 2 3 4 4 5 6 6 6 7 8 9 4 4)) (list (list 0 0) (list 1) (list 2) (list 3) (list 4 4) (list 5) (list 6 6 6) (list 7) (list 8) (list 9) (list 4 4)))\n    (check-equal? (candidate (list 10 10 15 19 18 18 17 26 26 17 18 10)) (list (list 10 10) (list 15) (list 19) (list 18 18) (list 17) (list 26 26) (list 17) (list 18) (list 10)))\n    (check-equal? (candidate (list \"a\" \"a\" \"b\" \"c\" \"d\" \"d\")) (list (list \"a\" \"a\") (list \"b\") (list \"c\") (list \"d\" \"d\")))\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (cond\n    [(null? list1) '()]\n    [else (cons (list (car list1))\n                (pack_consecutive_duplicates (cdr list1)))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons (list (first list1))\n           (pack_consecutive_duplicates (filter (lambda (x) (not (= x (first list1)))) (rest list1))))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else (cons (list (first list1))\n                (pack_consecutive_duplicates (filter (lambda (x) (not (= x (first list1)))) (rest list1))))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (if (null? list1)\n        result\n        (let ((first (car list1))\n              (rest (cdr list1)))\n          (if (null? rest)\n              (cons (list first) result)\n              (if (equal? first (car rest))\n                  (pack_consecutive_duplicates_iter rest (cons (cons first (car result)) (cdr result)))\n                  (pack_consecutive_duplicates_iter rest (cons (list first) result)))))))\n  (pack_consecutive_duplicates_iter list1 (list)))\n",
    "  (cond\n    [(null? list1) '()]\n    [else (cons (list (car list1))\n                (pack_consecutive_duplicates (cdr list1)))]))\n",
    "  (cond [(empty? list1) empty]\n        [else (cons (list (first list1))\n                    (pack_consecutive_duplicates (remove (first list1) list1)))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond\n      [(empty? list1) result]\n      [(empty? result) (pack_consecutive_duplicates_iter (rest list1) (list (list (first list1))))]\n      [(equal? (first (first result)) (first list1)) (pack_consecutive_duplicates_iter (rest list1) (cons (cons (first list1) (first result)) (rest result)))]\n      [else (pack_consecutive_duplicates_iter (rest list1) (cons (list (first list1)) result))]))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons (list (first list1))\n           (pack_consecutive_duplicates (remove (first list1) (rest list1))))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else (cons (list (first list1))\n                (pack_consecutive_duplicates (filter (lambda (x) (not (= x (first list1)))) (rest list1))))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [(empty? (rest list1)) (list list1)]\n    [else\n     (if (equal? (first list1) (first (rest list1)))\n         (cons (list (first list1)) (pack_consecutive_duplicates (rest list1)))\n         (cons (list (first list1)) (pack_consecutive_duplicates (rest list1))))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons\n      (list (first list1))\n      (pack_consecutive_duplicates (rest list1)))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons\n      (cons (first list1)\n            (filter (lambda (x) (equal? x (first list1))) list1))\n      (pack_consecutive_duplicates (filter (lambda (x) (not (equal? x (first list1)))) list1)))]))\n",
    "  (cond\n    [(null? list1) '()]\n    [else\n     (let ([sublist (list (car list1))])\n       (for ([elem (cdr list1)])\n         (if (equal? elem (car sublist))\n             (set! sublist (append sublist (list elem)))\n             (set! list1 (append (list sublist) (list elem))\n                   sublist (list elem))))\n       list1)]))\n",
    "  (cond [(empty? list1) empty]\n        [else (cons (list (first list1))\n                    (pack_consecutive_duplicates (filter (lambda (x) (not (= x (first list1)))) (rest list1))))]))\n",
    "  (let loop ((list1 list1)\n             (acc '()))\n    (cond ((null? list1) acc)\n          ((null? (cdr list1)) (cons (list (car list1)) acc))\n          ((equal? (car list1) (cadr list1))\n           (loop (cdr list1) (cons (cons (car list1) (cadr list1)) acc)))\n          (else (loop (cdr list1) (cons (list (car list1)) acc))))))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond\n      [(empty? list1) result]\n      [else\n       (let* ([first (first list1)]\n              [rest (rest list1)]\n              [first_rest (cons first rest)]\n              [first_rest_duplicates (filter (lambda (x) (equal? x first)) first_rest)]\n              [rest_duplicates (filter (lambda (x) (not (equal? x first))) first_rest)])\n         (pack_consecutive_duplicates_iter rest_duplicates (cons first_rest_duplicates result)))]))\n  (pack_consecutive_duplicates_iter list1 '()))\n",
    "  (let loop ((list1 list1)\n             (list2 '()))\n    (cond ((null? list1) (reverse list2))\n          ((null? (cdr list1)) (reverse (cons (list (car list1)) list2)))\n          ((equal? (car list1) (cadr list1))\n           (loop (cdr list1) (cons (cons (car list1) (car list2)) (cdr list2))))\n          (else (loop (cdr list1) (cons (list (car list1)) list2))))))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons (list (first list1))\n           (pack_consecutive_duplicates (rest list1)))]))\n",
    "  (cond ((null? list1) '())\n        ((null? (cdr list1)) (list list1))\n        ((equal? (car list1) (cadr list1))\n         (cons (list (car list1) (cadr list1))\n               (pack_consecutive_duplicates (cdr list1))))\n        (else (cons (list (car list1))\n                    (pack_consecutive_duplicates (cdr list1))))))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons (list (car list1))\n           (pack_consecutive_duplicates (cdr list1)))]))\n",
    "  (cond\n    [(null? list1) '()]\n    [else (cons (list (car list1))\n                (pack_consecutive_duplicates (cdr list1)))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 acc)\n    (cond\n      [(empty? list1) acc]\n      [(empty? acc) (pack_consecutive_duplicates_iter (rest list1) (list (list (first list1))))]\n      [(equal? (first (first acc)) (first list1)) (pack_consecutive_duplicates_iter (rest list1) (cons (cons (first list1) (first acc)) (rest acc)))]\n      [else (pack_consecutive_duplicates_iter (rest list1) (cons (list (first list1)) acc))]))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (define (pack_consecutive_duplicates_iter list1 list2)\n    (cond ((null? list1) list2)\n          ((null? list2) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (car list1) (caar list2)) (pack_consecutive_duplicates_iter (cdr list1) (cons (cons (car list1) (car list2)) (cdr list2))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) list2)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (let loop ([list1 list1]\n             [result '()])\n    (cond [(empty? list1) (reverse result)]\n          [else (let ([first (first list1)])\n                  (loop (drop-right list1 (length (take-while (lambda (x) (= x first)) list1)))\n                        (cons (take-while (lambda (x) (= x first)) list1) result)))])))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (if (null? list1)\n        result\n        (let ((first (car list1))\n              (rest (cdr list1)))\n          (if (null? rest)\n              (cons (list first) result)\n              (let ((second (car rest)))\n                (if (= first second)\n                    (pack_consecutive_duplicates_iter rest (cons (cons first (car result)) (cdr result)))\n                    (pack_consecutive_duplicates_iter rest (cons (list first) result))))))))\n  (pack_consecutive_duplicates_iter list1 '()))\n",
    "  (define (pack_consecutive_duplicates_iter list1 list2)\n    (cond ((null? list1) list2)\n          ((null? list2) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (car (car list2)) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (append (list (append (car list2) (list (car list1)))) (cdr list2))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (append (list (list (car list1))) list2)))))\n  (pack_consecutive_duplicates_iter list1 '()))\n",
    "  (let loop ([list1 list1]\n             [list2 '()])\n    (if (null? list1)\n        list2\n        (if (null? (cdr list1))\n            (append list2 (list list1))\n            (if (equal? (car list1) (cadr list1))\n                (loop (cdr list1) list2)\n                (loop (cdr list1) (append list2 (list (list (car list1))))))))))\n",
    "  (if (null? list1)\n      '()\n      (let ((sublist (list (car list1))))\n        (if (null? (cdr list1))\n            (list sublist)\n            (if (equal? (car list1) (cadr list1))\n                (cons (append sublist (list (cadr list1))) (pack_consecutive_duplicates (cdr (cdr list1))))\n                (cons sublist (pack_consecutive_duplicates (cdr list1))))))))\n",
    "  (if (null? list1)\n      '()\n      (let ((first (car list1))\n            (rest (cdr list1)))\n        (cons (cons first (take-while (lambda (x) (= x first)) rest))\n              (pack_consecutive_duplicates (drop-while (lambda (x) (= x first)) rest))))))\n",
    "  (define (pack_consecutive_duplicates_helper list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_helper (cdr list1) (list (list (car list1)))))\n          ((equal? (caar result) (car list1)) (pack_consecutive_duplicates_helper (cdr list1) (cons (cons (car list1) (car result)) (cdr result))))\n          (else (pack_consecutive_duplicates_helper (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_helper list1 '())))\n",
    "  (if (null? list1)\n      '()\n      (let ((first (car list1))\n            (rest (cdr list1)))\n        (if (null? rest)\n            (list (list first))\n            (let ((next (car rest)))\n              (if (= first next)\n                  (cons (cons first (car (pack_consecutive_duplicates rest)))\n                        (pack_consecutive_duplicates (cdr (pack_consecutive_duplicates rest))))\n                  (cons (list first) (pack_consecutive_duplicates rest))))))))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let* ([first (first list1)]\n            [rest (rest list1)]\n            [first-rest (cons first rest)]\n            [first-rest-duplicates (filter (lambda (x) (equal? x first)) first-rest)])\n       (cons first-rest-duplicates (pack_consecutive_duplicates (filter (lambda (x) (not (equal? x first))) first-rest))))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (caar result) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (cons (append (car result) (list (car list1))) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let* ([first (first list1)]\n            [rest (rest list1)]\n            [first-rest (cons first rest)]\n            [first-rest-duplicates (filter (lambda (x) (equal? x first)) first-rest)]\n            [rest-duplicates (filter (lambda (x) (not (equal? x first))) first-rest)])\n       (cons first-rest-duplicates (pack_consecutive_duplicates rest-duplicates)))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else (cons (list (first list1)) (pack_consecutive_duplicates (rest list1)))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let* ([first (first list1)]\n            [rest (rest list1)]\n            [rest-packed (pack_consecutive_duplicates rest)])\n       (if (equal? first (first rest))\n           (cons (cons first (first rest-packed)) (rest rest-packed))\n           (cons (list first) rest-packed)))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons\n      (list (first list1))\n      (pack_consecutive_duplicates (rest list1)))]))\n",
    "  (let loop ((list1 list1) (result '()))\n    (cond ((null? list1) result)\n          ((null? (cdr list1)) (cons (list (car list1)) result))\n          ((equal? (car list1) (cadr list1))\n           (loop (cdr list1) (cons (cons (car list1) (car result)) (cdr result))))\n          (else (loop (cdr list1) (cons (list (car list1)) result))))))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond\n      [(null? list1) result]\n      [(null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1))))]\n      [(equal? (car list1) (caar result)) (pack_consecutive_duplicates_iter (cdr list1) (cons (cons (car list1) (car result)) (cdr result)))]\n      [else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) result))]))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (define (pack_consecutive_duplicates_helper list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_helper (cdr list1) (list (list (car list1)))))\n          ((equal? (caar result) (car list1)) (pack_consecutive_duplicates_helper (cdr list1) (cons (append (car result) (list (car list1))) (cdr result))))\n          (else (pack_consecutive_duplicates_helper (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_helper list1 '())))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons (list (first list1))\n           (pack_consecutive_duplicates (filter (lambda (x) (not (= x (first list1)))) (rest list1))))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (if (null? list1)\n        result\n        (let ((first (car list1))\n              (rest (cdr list1)))\n          (if (null? rest)\n              (cons (list first) result)\n              (let ((first_rest (car rest))\n                    (rest_rest (cdr rest)))\n                (if (equal? first first_rest)\n                    (pack_consecutive_duplicates_iter rest_rest (cons (cons first result) '()))\n                    (pack_consecutive_duplicates_iter rest_rest (cons (list first) result))))))))\n  (pack_consecutive_duplicates_iter list1 '()))\n",
    "  (if (null? list1)\n      '()\n      (let ((first (car list1))\n            (rest (cdr list1)))\n        (if (null? rest)\n            (list (list first))\n            (if (equal? first (car rest))\n                (cons (cons first (car (pack_consecutive_duplicates rest))) (cdr (pack_consecutive_duplicates rest)))\n                (cons (list first) (pack_consecutive_duplicates rest)))))))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let* ([first (first list1)]\n            [rest (rest list1)]\n            [first-duplicates (filter (lambda (x) (= x first)) rest)]\n            [rest-duplicates (filter (lambda (x) (not (= x first))) rest)])\n       (cons (cons first first-duplicates)\n             (pack_consecutive_duplicates rest-duplicates)))]))\n",
    "  (cond\n    [(null? list1) '()]\n    [else\n     (let ([first (car list1)]\n           [rest (cdr list1)])\n       (if (null? rest)\n           (list first)\n           (if (equal? first (car rest))\n               (cons first (pack_consecutive_duplicates rest))\n               (list first (pack_consecutive_duplicates rest)))))]))\n",
    "  (cond\n    [(null? list1) '()]\n    [else\n     (let* ([first (car list1)]\n            [rest (cdr list1)]\n            [first-sublist (list first)])\n       (if (null? rest)\n           (list first-sublist)\n           (if (= first (car rest))\n               (cons first-sublist (pack_consecutive_duplicates rest))\n               (cons first-sublist (pack_consecutive_duplicates rest)))))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons (list (first list1))\n           (pack_consecutive_duplicates (filter (lambda (x) (not (= x (first list1)))) (rest list1))))]))\n",
    "  (define (pack_consecutive_duplicates_helper list1 list2)\n    (cond\n      [(empty? list1) list2]\n      [(empty? (cdr list1)) (cons (cons (car list1) (list (car list1))) list2)]\n      [(equal? (car list1) (cadr list1))\n       (pack_consecutive_duplicates_helper (cdr list1) (cons (cons (car list1) (cons (car list1) (car list2))) (cdr list2)))]\n      [else (pack_consecutive_duplicates_helper (cdr list1) (cons (list (car list1)) list2))]))\n  (reverse (pack_consecutive_duplicates_helper list1 '())))\n",
    "  (cond ((null? list1) '())\n        ((null? (cdr list1)) (list list1))\n        (else (let ((first (car list1))\n                     (rest (cdr list1)))\n                 (if (equal? first (car rest))\n                     (cons (cons first (pack_consecutive_duplicates rest))\n                           (pack_consecutive_duplicates (cdr rest)))\n                     (cons (list first)\n                           (pack_consecutive_duplicates rest)))))))\n",
    "  (cond\n    [(null? list1) '()]\n    [(null? (cdr list1)) (list list1)]\n    [else (cons (list (car list1)) (pack_consecutive_duplicates (cdr list1)))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond\n      [(empty? list1) result]\n      [(empty? result) (pack_consecutive_duplicates_iter (rest list1) (list (list (first list1))))]\n      [else\n       (if (equal? (first (first result)) (first list1))\n           (pack_consecutive_duplicates_iter (rest list1) (cons (cons (first list1) (first result)) (rest result)))\n           (pack_consecutive_duplicates_iter (rest list1) (cons (list (first list1)) result)))]))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons\n      (list (first list1))\n      (pack_consecutive_duplicates (rest list1)))]))\n",
    "  (if (null? list1)\n      '()\n      (let ((first (car list1))\n            (rest (cdr list1)))\n        (if (null? rest)\n            (list (list first))\n            (let ((rest-result (pack_consecutive_duplicates rest)))\n              (if (equal? first (caar rest-result))\n                  (cons (cons first (car rest-result)) (cdr rest-result))\n                  (cons (list first) rest-result)))))))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let ([first-element (first list1)]\n           [rest-of-list (rest list1)])\n       (cons\n        (cons first-element\n              (filter (lambda (x) (equal? x first-element)) rest-of-list))\n        (pack_consecutive_duplicates (filter (lambda (x) (not (equal? x first-element))) rest-of-list))))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else (cons (list (first list1))\n                (pack_consecutive_duplicates (filter (lambda (x) (not (= x (first list1)))) (rest list1))))]))\n",
    "  (let loop ((list1 list1)\n             (result '()))\n    (cond ((null? list1) (reverse result))\n          (else\n           (let ((sublist (list (car list1))))\n             (loop (cdr list1)\n                   (cons (loop (cdr list1)\n                               (if (equal? (car list1) (car (cdr list1)))\n                                   (cons (car (cdr list1)) sublist)\n                                   (cons (car list1) sublist)))\n                         result)))))))\n",
    "  (cond\n    [(empty? list1) empty]\n    [(empty? (rest list1)) (list (list (first list1)))]\n    [(equal? (first list1) (second list1))\n     (cons (cons (first list1) (cons (second list1) empty))\n           (pack_consecutive_duplicates (rest (rest list1))))]\n    [else (cons (list (first list1)) (pack_consecutive_duplicates (rest list1)))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (car list1) (caar result)) (pack_consecutive_duplicates_iter (cdr list1) (cons (cons (car list1) (car result)) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons (list (first list1))\n           (pack_consecutive_duplicates (remove (first list1) list1)))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [(empty? (rest list1)) (list (list (first list1)))]\n    [else (cons (list (first list1)) (pack_consecutive_duplicates (rest list1)))]))\n",
    "  (cond\n    [(null? list1) '()]\n    [(null? (cdr list1)) (list list1)]\n    [(equal? (car list1) (cadr list1))\n     (cons (cons (car list1) (pack_consecutive_duplicates (cdr list1)))\n           (pack_consecutive_duplicates (cdr list1)))]\n    [else (cons (list (car list1)) (pack_consecutive_duplicates (cdr list1)))]))\n",
    "  (define (pack_consecutive_duplicates_helper list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_helper (cdr list1) (list (list (car list1)))))\n          ((equal? (car (car result)) (car list1)) (pack_consecutive_duplicates_helper (cdr list1) (cons (cons (car list1) (car result)) (cdr result))))\n          (else (pack_consecutive_duplicates_helper (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_helper list1 '())))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let* ([first (first list1)]\n            [rest (rest list1)]\n            [first-sublist (list first)])\n       (cond\n         [(empty? rest) (list first-sublist)]\n         [(equal? first (first rest))\n          (cons first-sublist (pack_consecutive_duplicates rest))]\n         [else\n          (cons first-sublist (pack_consecutive_duplicates rest))]))]))\n",
    "  (cond\n    [(null? list1) '()]\n    [else\n     (let ([first (car list1)]\n           [rest (cdr list1)])\n       (if (null? rest)\n           (list (list first))\n           (let ([next (car rest)])\n             (if (equal? first next)\n                 (cons (cons first (car (pack_consecutive_duplicates rest)))\n                       (cdr (pack_consecutive_duplicates rest)))\n                 (cons (list first) (pack_consecutive_duplicates rest))))))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons\n      (list (first list1))\n      (pack_consecutive_duplicates (rest list1)))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons (cons (first list1) (take-while (lambda (x) (= x (first list1))) (rest list1)))\n           (pack_consecutive_duplicates (drop-while (lambda (x) (= x (first list1))) (rest list1))))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons (list (first list1))\n           (pack_consecutive_duplicates (remove (first list1) (rest list1))))]))\n",
    "  (letrec ([pack (lambda (list1 acc)\n                   (cond [(empty? list1) acc]\n                         [(empty? acc) (pack (rest list1) (list (list (first list1))))]\n                         [(equal? (first (first acc)) (first list1))\n                          (pack (rest list1) (cons (cons (first list1) (first acc)) (rest acc)))]\n                         [else (pack (rest list1) (cons (list (first list1)) acc))]))])\n    (pack list1 '())))\n",
    "  (cond\n    [(null? list1) '()]\n    [(null? (cdr list1)) (list list1)]\n    [else (cons (list (car list1)) (pack_consecutive_duplicates (cdr list1)))]))\n</code>\nI'm getting the following error:\n<code>application: not a procedure;\n expected a procedure that can be applied to arguments\n  given: '(a a a a b c c a a d e e e e)\n  arguments...:\n   'a\n</code>\nI'm not sure what I'm doing wrong.\n\n\nA:\n\nYou're not using the <code>cdr</code> of the list, you're using the whole list.\n<code>(define (pack_consecutive_duplicates list1)\n  (cond\n    [(null? list1) '()]\n    [(null? (cdr list1)) (list list1)]\n    [else (cons (list (car list1)) (pack_consecutive_duplicates (cdr list1)))]))\n</code>\n",
    "  (define (pack_consecutive_duplicates_helper list1 result)\n    (if (null? list1)\n        result\n        (let ((first (car list1))\n              (rest (cdr list1)))\n          (if (null? rest)\n              (cons (list first) result)\n              (if (equal? first (car rest))\n                  (pack_consecutive_duplicates_helper rest (cons (cons first (car result)) (cdr result)))\n                  (pack_consecutive_duplicates_helper rest (cons (list first) result)))))))\n  (pack_consecutive_duplicates_helper list1 (list)))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (car (car result)) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (append (list (append (car result) (list (car list1)))) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (append (list (list (car list1))) result)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (if (null? list1)\n      '()\n      (letrec ([first (car list1)]\n               [rest (cdr list1)]\n               [first-rest (cons first rest)]\n               [first-rest-duplicates (filter (lambda (x) (equal? first x)) first-rest)])\n        (cons first-rest-duplicates (pack_consecutive_duplicates (filter (lambda (x) (not (equal? first x))) first-rest))))))\n",
    "  (define (pack_consecutive_duplicates_helper list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_helper (cdr list1) (list (list (car list1)))))\n          ((equal? (car (car result)) (car list1)) (pack_consecutive_duplicates_helper (cdr list1) (cons (append (car result) (list (car list1))) (cdr result))))\n          (else (pack_consecutive_duplicates_helper (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_helper list1 '())))\n",
    "  (cond\n    [(null? list1) '()]\n    [else (cons (list (car list1))\n                (pack_consecutive_duplicates (cdr list1)))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond\n      [(null? list1) result]\n      [else\n       (let* ([head (car list1)]\n              [tail (cdr list1)]\n              [sublist (list head)])\n         (cond\n           [(null? tail) (append result (list sublist))]\n           [(equal? head (car tail))\n            (pack_consecutive_duplicates_iter tail result (append sublist (list (car tail))))]\n           [else (pack_consecutive_duplicates_iter tail (append result (list sublist)))]))]))\n  (pack_consecutive_duplicates_iter list1 '()))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let ([first (first list1)]\n           [rest (rest list1)])\n       (if (equal? first (first rest))\n           (cons (cons first (pack_consecutive_duplicates rest))\n                 (pack_consecutive_duplicates rest))\n           (cons (list first)\n                 (pack_consecutive_duplicates rest))))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [(empty? (rest list1)) (list (list (first list1)))]\n    [else\n     (let* ([first-element (first list1)]\n            [rest-of-list (rest list1)]\n            [first-element-of-rest (first rest-of-list)]\n            [rest-of-rest-of-list (rest rest-of-list)])\n       (cond\n         [(equal? first-element first-element-of-rest)\n          (cons (cons first-element (pack_consecutive_duplicates rest-of-list))\n                (pack_consecutive_duplicates rest-of-rest-of-list))]\n         [else\n          (cons (list first-element)\n                (pack_consecutive_duplicates rest-of-list))]))]))\n",
    "  (define (pack_consecutive_duplicates_helper list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_helper (cdr list1) (list (list (car list1)))))\n          ((equal? (caar result) (car list1)) (pack_consecutive_duplicates_helper (cdr list1) (cons (append (car result) (list (car list1))) (cdr result))))\n          (else (pack_consecutive_duplicates_helper (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_helper list1 '())))\n",
    "  (cond\n    [(null? list1) '()]\n    [else\n     (let ([first (car list1)]\n           [rest (cdr list1)])\n       (cons\n        (cons first (take-while (lambda (x) (eq? x first)) rest))\n        (pack_consecutive_duplicates (drop-while (lambda (x) (eq? x first)) rest))))]))\n",
    "  (if (null? list1)\n      '()\n      (let ((first (car list1))\n            (rest (cdr list1)))\n        (if (null? rest)\n            (list (list first))\n            (let ((next (car rest))\n                  (rest-rest (cdr rest)))\n              (if (equal? first next)\n                  (cons (cons first (car (pack_consecutive_duplicates rest)))\n                        (pack_consecutive_duplicates rest-rest))\n                  (cons (list first)\n                        (pack_consecutive_duplicates rest))))))))\n",
    "  (define (pack_consecutive_duplicates_helper list1 list2)\n    (cond ((null? list1) list2)\n          ((null? list2) (pack_consecutive_duplicates_helper (cdr list1) (list (car list1))))\n          ((equal? (car list1) (car (car list2))) (pack_consecutive_duplicates_helper (cdr list1) (append (list (append (car list2) (list (car list1)))) (cdr list2))))\n          (else (pack_consecutive_duplicates_helper (cdr list1) (append (list (car list1)) list2)))))\n  (pack_consecutive_duplicates_helper list1 '()))\n",
    "  (cond\n    [(null? list1) '()]\n    [(null? (cdr list1)) (list list1)]\n    [else (cons (list (car list1)) (pack_consecutive_duplicates (cdr list1)))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (caar result) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (cons (append (car result) (list (car list1))) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (if (null? list1)\n        result\n        (let ((first (car list1))\n              (rest (cdr list1)))\n          (if (null? rest)\n              (cons (list first) result)\n              (if (= first (car rest))\n                  (pack_consecutive_duplicates_iter rest (cons (cons first (car result)) (cdr result)))\n                  (pack_consecutive_duplicates_iter rest (cons (list first) result)))))))\n  (pack_consecutive_duplicates_iter list1 '()))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (if (null? list1)\n        result\n        (let ((first (car list1))\n              (rest (cdr list1)))\n          (if (null? rest)\n              (cons (list first) result)\n              (if (equal? first (car rest))\n                  (pack_consecutive_duplicates_iter rest (cons (cons first (car result)) (cdr result)))\n                  (pack_consecutive_duplicates_iter rest (cons (list first) result)))))))\n  (pack_consecutive_duplicates_iter list1 (list)))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (car (car result)) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (cons (append (car result) (list (car list1))) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (let loop ((list1 list1)\n             (result '()))\n    (if (null? list1)\n        (reverse result)\n        (let ((sublist (list (car list1))))\n          (loop (cdr list1)\n                (let loop ((list1 (cdr list1))\n                           (sublist sublist))\n                  (if (null? list1)\n                      (cons sublist result)\n                      (if (equal? (car list1) (car sublist))\n                          (loop (cdr list1)\n                                (cons (car list1) sublist))\n                          (cons sublist result)))))))))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else (cons (list (first list1)) (pack_consecutive_duplicates (rest list1)))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond\n      [(empty? list1) result]\n      [(empty? result) (pack_consecutive_duplicates_iter (rest list1) (list (list (first list1))))]\n      [(equal? (first (last result)) (first list1)) (pack_consecutive_duplicates_iter (rest list1) (append result (list (list (first list1))))) ]\n      [else (pack_consecutive_duplicates_iter (rest list1) (append result (list (list (first list1)))))]))\n  (pack_consecutive_duplicates_iter list1 empty))\n",
    "  (cond\n    [(null? list1) '()]\n    [(null? (cdr list1)) (list list1)]\n    [else (cons (list (car list1)) (pack_consecutive_duplicates (cdr list1)))]))\n</code>\nI am not sure how to make it so that it will pack consecutive duplicates into sublists. I am not sure how to make it so that it will check if the next element is the same as the current element.\n\n\nA:\n\nYou can use <code>split-at</code> to split the list at the first element that is not equal to the first element of the list.\n<code>(define (pack-consecutive-duplicates lst)\n  (if (null? lst)\n      '()\n      (let* ([(first-duplicates . rest) (split-at lst (complement (curry = (car lst))))]\n             [first-duplicates (cons (car lst) first-duplicates)])\n        (cons first-duplicates (pack-consecutive-duplicates rest)))))\n</code>\n",
    "  (cond\n    [(null? list1) '()]\n    [else (cons (list (car list1)) (pack_consecutive_duplicates (cdr list1)))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [(empty? (rest list1)) (list (list (first list1)))]\n    [else\n     (let ([sublist (list (first list1))])\n       (for/fold ([acc (list sublist)])\n                 ([x (in-list (rest list1))])\n         (if (equal? (first sublist) x)\n             (set! sublist (cons x sublist))\n             (begin\n               (set! acc (cons sublist acc))\n               (set! sublist (list x))))\n         acc))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (caar result) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (cons (cons (car list1) (car result)) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let ([first (first list1)]\n           [rest (rest list1)])\n       (if (equal? first (first rest))\n           (cons (cons first (pack_consecutive_duplicates rest)) (pack_consecutive_duplicates rest))\n           (cons (list first) (pack_consecutive_duplicates rest))))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond\n      [(empty? list1) result]\n      [(empty? result) (pack_consecutive_duplicates_iter (rest list1) (list (list (first list1))))]\n      [(equal? (first (first result)) (first list1)) (pack_consecutive_duplicates_iter (rest list1) (cons (append (first result) (list (first list1))) (rest result)))]\n      [else (pack_consecutive_duplicates_iter (rest list1) (cons (list (first list1)) result))]))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (cond\n    [(empty? list1) empty]\n    [(empty? (rest list1)) (list list1)]\n    [(equal? (first list1) (second list1))\n     (cons (list (first list1) (second list1))\n           (pack_consecutive_duplicates (rest (rest list1))))]\n    [else\n     (cons (list (first list1))\n           (pack_consecutive_duplicates (rest list1)))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [(empty? (cdr list1)) (list list1)]\n    [(equal? (car list1) (cadr list1))\n     (cons (list (car list1) (cadr list1))\n           (pack_consecutive_duplicates (cddr list1)))]\n    [else\n     (cons (list (car list1))\n           (pack_consecutive_duplicates (cdr list1)))]))\n",
    "  (if (null? list1)\n      '()\n      (let ((first (car list1))\n            (rest (cdr list1)))\n        (cons (list first)\n              (pack_consecutive_duplicates rest)))))\n",
    "  (define (iter list1 result)\n    (cond\n      [(empty? list1) result]\n      [(empty? result) (iter (rest list1) (list (list (first list1))))]\n      [(equal? (first (first result)) (first list1))\n       (iter (rest list1) (cons (cons (first list1) (first result)) (rest result)))]\n      [else (iter (rest list1) (cons (list (first list1)) result))]))\n  (reverse (iter list1 '())))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (caar result) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (cons (append (car result) (list (car list1))) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (cond\n    [(null? list1) '()]\n    [(null? (cdr list1)) (list list1)]\n    [(equal? (car list1) (cadr list1))\n     (cons (cons (car list1) (pack_consecutive_duplicates (cdr list1)))\n           (pack_consecutive_duplicates (cdr list1)))]\n    [else (cons (list (car list1)) (pack_consecutive_duplicates (cdr list1)))]))\n",
    "  (define (pack_consecutive_duplicates_helper list1 list2)\n    (cond ((null? list1) list2)\n          ((null? list2) (pack_consecutive_duplicates_helper (cdr list1) (list (list (car list1)))))\n          ((equal? (car (car list2)) (car list1)) (pack_consecutive_duplicates_helper (cdr list1) (append (list (append (car list2) (list (car list1)))) (cdr list2))))\n          (else (pack_consecutive_duplicates_helper (cdr list1) (append (list (list (car list1))) list2)))))\n  (pack_consecutive_duplicates_helper list1 '()))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (caar result) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (cons (append (car result) (list (car list1))) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else (cons (list (first list1)) (pack_consecutive_duplicates (rest list1)))]))\n",
    "  (define (pack_consecutive_duplicates_helper list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_helper (cdr list1) (list (list (car list1)))))\n          ((equal? (caar result) (car list1)) (pack_consecutive_duplicates_helper (cdr list1) (cons (append (car result) (list (car list1))) (cdr result))))\n          (else (pack_consecutive_duplicates_helper (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_helper list1 '())))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons\n      (cons (first list1) (take-while (lambda (x) (equal? x (first list1))) (rest list1)))\n      (pack_consecutive_duplicates (drop-while (lambda (x) (equal? x (first list1))) (rest list1))))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let* ([first (first list1)]\n            [rest (rest list1)]\n            [first-rest (cons first rest)]\n            [first-rest-duplicates (filter (lambda (x) (equal? x first)) first-rest)])\n       (cons first-rest-duplicates (pack_consecutive_duplicates (filter (lambda (x) (not (equal? x first))) first-rest))))]))\n",
    "  (define (pack_consecutive_duplicates_helper list1 result)\n    (cond\n      [(empty? list1) result]\n      [(empty? result) (pack_consecutive_duplicates_helper (rest list1) (list (list (first list1))))]\n      [(equal? (first (first result)) (first list1)) (pack_consecutive_duplicates_helper (rest list1) (cons (append (first result) (list (first list1))) (rest result)))]\n      [else (pack_consecutive_duplicates_helper (rest list1) (cons (list (first list1)) result))]))\n  (reverse (pack_consecutive_duplicates_helper list1 '())))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let* ([first (first list1)]\n            [rest (rest list1)]\n            [first-rest (cons first rest)]\n            [first-rest-same? (equal? first-rest (take (length first-rest) list1))])\n       (if first-rest-same?\n           (cons first-rest (pack_consecutive_duplicates (drop (length first-rest) list1)))\n           (cons (list first) (pack_consecutive_duplicates rest))))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else (cons (list (first list1)) (pack_consecutive_duplicates (rest list1)))]))\n",
    "  (cond\n    [(null? list1) '()]\n    [(null? (cdr list1)) (list list1)]\n    [else (cons (list (car list1))\n                (pack_consecutive_duplicates (cdr list1)))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [(empty? (rest list1)) (list (list (first list1)))]\n    [else\n     (let ([first-element (first list1)])\n       (cond\n         [(equal? first-element (first (rest list1)))\n          (cons (cons first-element (first (pack_consecutive_duplicates (rest list1))))\n                (rest (pack_consecutive_duplicates (rest list1))))]\n         [else\n          (cons (list first-element)\n                (pack_consecutive_duplicates (rest list1)))]))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let* ([first (first list1)]\n            [rest (rest list1)]\n            [first-of-rest (first rest)]\n            [rest-of-rest (rest rest)])\n       (if (equal? first first-of-rest)\n           (cons (cons first (pack_consecutive_duplicates rest))\n                 (pack_consecutive_duplicates rest-of-rest))\n           (cons (list first) (pack_consecutive_duplicates rest))))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let* ([first (first list1)]\n            [rest (rest list1)]\n            [first-rest (cons first rest)]\n            [rest-list (pack_consecutive_duplicates rest)])\n       (if (equal? first (first rest-list))\n           (cons first-rest (rest rest-list))\n           (cons first-rest rest-list)))]))\n",
    "  (letrec ([pack (lambda (list1 list2)\n                   (if (null? list1)\n                       list2\n                       (if (null? list2)\n                           (pack (cdr list1) (list (list (car list1))))\n                           (if (equal? (car list1) (caar list2))\n                               (pack (cdr list1) (cons (cons (car list1) (car list2)) (cdr list2)))\n                               (pack (cdr list1) (cons (list (car list1)) list2))))))])\n    (reverse (pack list1 '()))))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond\n      [(null? list1) result]\n      [(null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1))))]\n      [(equal? (car (car result)) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (append (list (append (car result) (list (car list1)))) (cdr result)))]\n      [else (pack_consecutive_duplicates_iter (cdr list1) (append (list (list (car list1))) result))]))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (caar result) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (cons (cons (car list1) (car result)) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond\n      [(empty? list1) result]\n      [else\n       (define (get_duplicates list1 element)\n         (cond\n           [(empty? list1) (list element)]\n           [(equal? (first list1) element) (cons element (get_duplicates (rest list1) element))]\n           [else (list element)]))\n       (define duplicates (get_duplicates list1 (first list1)))\n       (pack_consecutive_duplicates_iter (drop (length duplicates) list1) (append result (list duplicates)))]))\n  (pack_consecutive_duplicates_iter list1 '()))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let ([first (first list1)]\n           [rest (rest list1)])\n       (let ([first-sublist (list first)])\n         (let loop ([rest rest]\n                    [sublist first-sublist])\n           (cond\n             [(empty? rest) (list sublist)]\n             [(equal? first (first rest))\n              (loop (rest rest) (append sublist (list (first rest))))]\n             [else\n              (cons sublist (pack_consecutive_duplicates rest))]))))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (car (car result)) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (cons (cons (car list1) (car result)) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (define (pack_consecutive_duplicates_iter list2 result)\n    (cond\n      [(empty? list2) result]\n      [(empty? result) (pack_consecutive_duplicates_iter (rest list2) (list (list (first list2))))]\n      [(equal? (first (first result)) (first list2)) (pack_consecutive_duplicates_iter (rest list2) (cons (cons (first list2) (first result)) (rest result)))]\n      [else (pack_consecutive_duplicates_iter (rest list2) (cons (list (first list2)) result))]))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (let loop ((list1 list1)\n             (result '()))\n    (cond ((null? list1) (reverse result))\n          ((null? (cdr list1)) (reverse (cons (list (car list1)) result)))\n          (else (if (equal? (car list1) (cadr list1))\n                   (loop (cdr list1) (cons (cons (car list1) (car result)) (cdr result)))\n                   (loop (cdr list1) (cons (list (car list1)) result)))))))\n",
    "  (cond ((null? list1) '())\n        ((null? (cdr list1)) (list list1))\n        ((equal? (car list1) (cadr list1)) (cons (list (car list1) (cadr list1)) (pack_consecutive_duplicates (cddr list1))))\n        (else (cons (list (car list1)) (pack_consecutive_duplicates (cdr list1))))))\n",
    "  (cond\n    [(empty? list1) empty]\n    [(empty? (cdr list1)) (list list1)]\n    [else (cons (list (car list1)) (pack_consecutive_duplicates (cdr list1)))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let* ([first (first list1)]\n            [rest (rest list1)]\n            [first-rest (cons first rest)]\n            [first-rest-duplicates (filter (lambda (x) (equal? x first)) first-rest)])\n       (cons first-rest-duplicates (pack_consecutive_duplicates (remove first first-rest))))]))\n",
    "  (cond [(null? list1) '()]\n        [else (cons (list (car list1))\n                    (pack_consecutive_duplicates (cdr list1)))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (car list1) (caar result)) (pack_consecutive_duplicates_iter (cdr list1) (cons (cons (car list1) (car result)) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (let loop ((list1 list1)\n             (acc '()))\n    (cond\n      [(empty? list1) (reverse acc)]\n      [else (let ((first (first list1))\n                   (rest (rest list1)))\n              (loop (drop-while (lambda (x) (equal? x first)) rest)\n                    (cons (cons first (take-while (lambda (x) (equal? x first)) rest)) acc)))])))\n",
    "  (let loop ((list1 list1) (list2 '()) (list3 '()))\n    (cond ((null? list1) (reverse list2))\n          ((null? list2) (loop (cdr list1) (list (list (car list1))) list3))\n          ((equal? (car list1) (caar list2)) (loop (cdr list1) (cons (cons (car list1) (car list2)) (cdr list2)) list3))\n          (else (loop (cdr list1) (list (list (car list1))) list3)))))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (if (null? list1)\n        result\n        (let ((first (car list1))\n              (rest (cdr list1)))\n          (if (null? rest)\n              (cons (list first) result)\n              (let ((second (car rest)))\n                (if (= first second)\n                    (pack_consecutive_duplicates_iter rest (cons (cons first (car result)) (cdr result)))\n                    (pack_consecutive_duplicates_iter rest (cons (list first) result))))))))\n  (pack_consecutive_duplicates_iter list1 '()))\n",
    "  (define (pack_consecutive_duplicates_iter list1 list2)\n    (if (null? list1)\n        list2\n        (if (null? list2)\n            (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1))))\n            (if (equal? (car list1) (caar list2))\n                (pack_consecutive_duplicates_iter (cdr list1) (cons (cons (car list1) (car list2)) (cdr list2)))\n                (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) list2))))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (car (car result)) (car list1))\n           (pack_consecutive_duplicates_iter (cdr list1) (cons (append (car result) (list (car list1))) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (let loop ((list1 list1)\n             (acc '()))\n    (cond ((null? list1) (reverse acc))\n          ((null? (cdr list1)) (reverse (cons (list (car list1)) acc)))\n          ((equal? (car list1) (cadr list1))\n           (loop (cdr list1) (cons (cons (car list1) (car acc)) (cdr acc))))\n          (else (loop (cdr list1) (cons (list (car list1)) acc))))))\n",
    "  (define (pack_consecutive_duplicates_helper list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_helper (cdr list1) (list (list (car list1)))))\n          ((equal? (car (car result)) (car list1)) (pack_consecutive_duplicates_helper (cdr list1) (cons (append (car result) (list (car list1))) (cdr result))))\n          (else (pack_consecutive_duplicates_helper (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_helper list1 '())))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let ([first (first list1)]\n           [rest (rest list1)])\n       (if (equal? first (first rest))\n           (cons (cons first (pack_consecutive_duplicates rest))\n                 (pack_consecutive_duplicates rest))\n           (cons (list first)\n                 (pack_consecutive_duplicates rest))))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond\n      [(empty? list1) result]\n      [(empty? result) (pack_consecutive_duplicates_iter (rest list1) (list (list (first list1))))]\n      [(equal? (first (first result)) (first list1)) (pack_consecutive_duplicates_iter (rest list1) (cons (cons (first list1) (first result)) (rest result)))]\n      [else (pack_consecutive_duplicates_iter (rest list1) (cons (list (first list1)) result))]))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let* ([first (first list1)]\n            [rest (rest list1)]\n            [first-rest (cons first rest)]\n            [first-rest-duplicates (filter (lambda (x) (equal? x first)) first-rest)])\n       (cons first-rest-duplicates (pack_consecutive_duplicates (remove first-rest-duplicates first-rest))))]))\n",
    "  (if (null? list1)\n      '()\n      (let ((first (car list1))\n            (rest (cdr list1)))\n        (if (null? rest)\n            (list (list first))\n            (let ((next (car rest)))\n              (if (equal? first next)\n                  (cons (cons first (car (pack_consecutive_duplicates rest)))\n                        (pack_consecutive_duplicates (cdr (pack_consecutive_duplicates rest))))\n                  (cons (list first) (pack_consecutive_duplicates rest))))))))\n",
    "  (define (pack_consecutive_duplicates_helper list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_helper (cdr list1) (list (list (car list1)))))\n          ((equal? (caar result) (car list1)) (pack_consecutive_duplicates_helper (cdr list1) (cons (cons (car list1) (car result)) (cdr result))))\n          (else (pack_consecutive_duplicates_helper (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_helper list1 '())))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((= (car (car result)) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (cons (cons (car list1) (car result)) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (if (null? list1)\n      '()\n      (let loop ((list1 list1) (list2 '()) (list3 '()))\n        (if (null? list1)\n            (reverse (cons list2 list3))\n            (if (equal? (car list1) (car list2))\n                (loop (cdr list1) (cons (car list1) list2) list3)\n                (loop (cdr list1) (list (car list1)) (cons list2 list3)))))))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let* ([first (first list1)]\n            [rest (rest list1)]\n            [first-rest (cons first rest)]\n            [first-rest-duplicates (filter (lambda (x) (equal? x first)) first-rest)])\n       (cons first-rest-duplicates (pack_consecutive_duplicates (filter (lambda (x) (not (equal? x first))) first-rest))))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let* ([first (first list1)]\n            [rest (rest list1)]\n            [first-dups (filter (lambda (x) (equal? x first)) rest)]\n            [rest-dups (filter (lambda (x) (not (equal? x first))) rest)])\n       (cons (cons first first-dups) (pack_consecutive_duplicates rest-dups)))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let* ([first (first list1)]\n            [rest (rest list1)]\n            [first-rest (cons first rest)]\n            [first-rest-duplicates (filter (lambda (x) (equal? x first)) first-rest)]\n            [rest-duplicates (filter (lambda (x) (not (equal? x first))) first-rest)])\n       (cons first-rest-duplicates (pack_consecutive_duplicates rest-duplicates)))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let* ([first (first list1)]\n            [rest (rest list1)]\n            [first-sublist (cons first empty)]\n            [rest-sublists (pack_consecutive_duplicates rest)])\n       (if (equal? first (first rest))\n           (cons (cons first first-sublist) rest-sublists)\n           (cons first-sublist rest-sublists)))]))\n",
    "  (let loop ((list1 list1)\n             (result '()))\n    (cond ((null? list1) result)\n          ((null? (cdr list1)) (cons (list (car list1)) result))\n          ((equal? (car list1) (cadr list1))\n           (loop (cdr list1) (cons (cons (car list1) (car result)) (cdr result))))\n          (else (loop (cdr list1) (cons (list (car list1)) result))))))\n",
    "  (define (pack_consecutive_duplicates_iter list1 list2)\n    (cond ((null? list1) list2)\n          ((null? list2) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (caar list2) (car list1))\n           (pack_consecutive_duplicates_iter (cdr list1) (cons (cons (car list1) (car list2)) (cdr list2))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) list2)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons (list (first list1))\n           (pack_consecutive_duplicates (filter (lambda (x) (not (equal? x (first list1)))) (rest list1))))]))\n",
    "  (cond\n    [(null? list1) '()]\n    [else\n     (let* ([first (car list1)]\n            [rest (cdr list1)]\n            [first-rest (cons first rest)]\n            [first-rest-duplicates (filter (lambda (x) (equal? x first)) first-rest)]\n            [rest-duplicates (filter (lambda (x) (not (equal? x first))) first-rest)])\n       (cons first-rest-duplicates (pack_consecutive_duplicates rest-duplicates)))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else (cons (list (first list1))\n                (pack_consecutive_duplicates (filter (lambda (x) (not (= x (first list1)))) (rest list1))))]))\n",
    "  (cond\n    [(null? list1) '()]\n    [(null? (cdr list1)) (list list1)]\n    [else (cons (list (car list1)) (pack_consecutive_duplicates (cdr list1)))]))\n</code>\nI'm not sure what I'm doing wrong.\n\n\nA:\n\nYou're not doing anything wrong, but you're not doing anything right either.\nThe problem is that you're not using the <code>cdr</code> of the list to compare with the <code>car</code>, and you're not recursing on the <code>cdr</code> of the list.\n<code>(define (pack_consecutive_duplicates list1)\n  (cond\n    [(null? list1) '()]\n    [(null? (cdr list1)) (list list1)]\n    [else (cons (list (car list1)) (pack_consecutive_duplicates (cdr list1)))]))\n</code>\nYou're just recursing on the <code>cdr</code> of the list, and you're not using the <code>cdr</code> of the list to compare with the <code>car</code>.\nThe solution is to use the <code>cdr</code> of the list to compare with the <code>car</code>, and to recurse on the <code>cdr</code> of the list.\n<code>(define (pack_consecutive_duplicates list1)\n  (cond\n    [(null? list1) '()]\n    [(null? (cdr list1)) (list list1)]\n    [(equal? (car list1) (cadr list1)) (cons (list (car list1)) (pack_consecutive_duplicates (cdr list1)))]\n    [else (cons (list (car list1)) (pack_consecutive_duplicates (cdr list1)))]))\n</code>\n",
    "  (cond\n    [(empty? list1) empty]\n    [(empty? (rest list1)) (list (list (first list1)))]\n    [else (cons (list (first list1)) (pack_consecutive_duplicates (rest list1)))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond\n      [(empty? list1) result]\n      [(empty? result) (pack_consecutive_duplicates_iter (rest list1) (list (list (first list1))))]\n      [else (if (equal? (first (last result)) (first list1))\n                (pack_consecutive_duplicates_iter (rest list1) (append (butlast result) (list (append (last result) (list (first list1))))))\n                (pack_consecutive_duplicates_iter (rest list1) (append result (list (list (first list1))))))]))\n  (pack_consecutive_duplicates_iter list1 '()))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (if (null? list1)\n        result\n        (let ((first (car list1))\n              (rest (cdr list1)))\n          (if (null? rest)\n              (append result (list (list first)))\n              (let ((second (car rest)))\n                (if (equal? first second)\n                    (pack_consecutive_duplicates_iter rest (append result (list (list first second))))\n                    (pack_consecutive_duplicates_iter rest (append result (list (list first)))))))))\n  (pack_consecutive_duplicates_iter list1 '()))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons (list (first list1))\n           (pack_consecutive_duplicates (remove (first list1) list1)))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond\n      [(empty? list1) result]\n      [(empty? result) (pack_consecutive_duplicates_iter (rest list1) (list (list (first list1))))]\n      [(equal? (first (last result)) (first list1)) (pack_consecutive_duplicates_iter (rest list1) (append result (list (first list1))))]\n      [else (pack_consecutive_duplicates_iter (rest list1) (append result (list (list (first list1)))))]))\n  (pack_consecutive_duplicates_iter list1 empty))\n",
    "  (cond\n    [(empty? list1) empty]\n    [(empty? (rest list1)) (list (list (first list1)))]\n    [else\n     (let ([first-element (first list1)]\n           [rest-list (rest list1)])\n       (cond\n         [(equal? first-element (first rest-list))\n          (cons (cons first-element (first (pack_consecutive_duplicates rest-list)))\n                (pack_consecutive_duplicates (rest (pack_consecutive_duplicates rest-list))))]\n         [else\n          (cons (list first-element) (pack_consecutive_duplicates rest-list))]))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (car list1) (caar result)) (pack_consecutive_duplicates_iter (cdr list1) (cons (cons (car list1) (car result)) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (cond\n    [(empty? list1) empty]\n    [(empty? (cdr list1)) (list (list (car list1)))]\n    [(equal? (car list1) (cadr list1))\n     (cons (cons (car list1) (pack_consecutive_duplicates (cdr list1)))\n           (pack_consecutive_duplicates (cdr list1)))]\n    [else (cons (list (car list1)) (pack_consecutive_duplicates (cdr list1)))]))\n",
    "  (cond\n    [(null? list1) '()]\n    [else\n     (cons (list (car list1))\n           (pack_consecutive_duplicates (cdr list1)))]))\n",
    "  (define (pack_consecutive_duplicates_helper list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_helper (cdr list1) (list (list (car list1)))))\n          ((equal? (car (car result)) (car list1)) (pack_consecutive_duplicates_helper (cdr list1) (cons (append (car result) (list (car list1))) (cdr result))))\n          (else (pack_consecutive_duplicates_helper (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_helper list1 '())))\n",
    "  (define (pack_consecutive_duplicates_iter list1 list2)\n    (if (null? list1)\n        list2\n        (if (null? list2)\n            (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1))))\n            (if (equal? (car (car list2)) (car list1))\n                (pack_consecutive_duplicates_iter (cdr list1) (cons (append (car list2) (list (car list1))) (cdr list2)))\n                (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) list2))))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (if (null? list1)\n      '()\n      (let ((sublist (list (car list1))))\n        (if (null? (cdr list1))\n            (list sublist)\n            (if (equal? (car list1) (cadr list1))\n                (cons (append sublist (list (cadr list1)))\n                      (pack_consecutive_duplicates (cdr list1)))\n                (cons sublist (pack_consecutive_duplicates (cdr list1))))))))\n",
    "  (let loop ((list1 list1) (list2 '()))\n    (cond ((null? list1) list2)\n          ((null? (cdr list1)) (cons (list (car list1)) list2))\n          ((equal? (car list1) (cadr list1))\n           (loop (cdr list1) (cons (cons (car list1) (car list2)) (cdr list2))))\n          (else (loop (cdr list1) (cons (list (car list1)) list2))))))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (caar result) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (cons (cons (car list1) (car result)) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (if (null? list1)\n      '()\n      (let ((sublist (list (car list1))))\n        (if (null? (cdr list1))\n            (list sublist)\n            (if (equal? (car list1) (cadr list1))\n                (append (pack_consecutive_duplicates (cdr list1)) (list sublist))\n                (cons sublist (pack_consecutive_duplicates (cdr list1))))))))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons (list (first list1))\n           (pack_consecutive_duplicates (remove (first list1) (rest list1))))]))\n",
    "  (let loop ([list1 list1]\n             [result '()])\n    (cond [(empty? list1) (reverse result)]\n          [(empty? result) (loop (cdr list1) (list (list (car list1))))]\n          [(equal? (caar result) (car list1))\n           (loop (cdr list1) (cons (cons (car list1) (car result)) (cdr result)))]\n          [else (loop (cdr list1) (cons (list (car list1)) result))])))\n",
    "  (let loop ((list1 list1)\n             (acc '()))\n    (cond ((null? list1) (reverse acc))\n          ((null? (cdr list1)) (reverse (cons (list (car list1)) acc)))\n          ((equal? (car list1) (cadr list1))\n           (loop (cdr list1) (cons (cons (car list1) (car acc)) (cdr acc))))\n          (else (loop (cdr list1) (cons (list (car list1)) acc))))))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else (cons (list (first list1)) (pack_consecutive_duplicates (rest list1)))]))\n",
    "  (cond\n    [(null? list1) '()]\n    [(null? (cdr list1)) (list list1)]\n    [else\n     (let* ([first (car list1)]\n            [rest (cdr list1)]\n            [first-rest (car rest)]\n            [rest-rest (cdr rest)])\n       (if (= first first-rest)\n           (cons (cons first (pack_consecutive_duplicates rest))\n                 (pack_consecutive_duplicates rest-rest))\n           (cons (list first)\n                 (pack_consecutive_duplicates rest))))]))\n",
    "  (cond\n    [(null? list1) '()]\n    [else\n     (let* ([first (car list1)]\n            [rest (cdr list1)]\n            [first-rest (cons first rest)]\n            [first-rest-duplicates (filter (lambda (x) (equal? x first)) first-rest)])\n       (cons first-rest-duplicates (pack_consecutive_duplicates (filter (lambda (x) (not (equal? x first))) first-rest))))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (if (null? list1)\n        result\n        (let ((first (car list1))\n              (rest (cdr list1)))\n          (if (null? rest)\n              (cons (list first) result)\n              (let ((next (car rest)))\n                (if (= first next)\n                    (pack_consecutive_duplicates_iter rest (cons (cons first (car result)) (cdr result)))\n                    (pack_consecutive_duplicates_iter rest (cons (list first) result))))))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (caar result) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (cons (append (car result) (list (car list1))) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (caar result) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (append (list (append (car result) (list (car list1)))) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (append (list (list (car list1))) result)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (if (null? list1)\n      '()\n      (let ((first (car list1))\n            (rest (cdr list1)))\n        (cons (cons first (filter (lambda (x) (equal? x first)) rest))\n              (pack_consecutive_duplicates (filter (lambda (x) (not (equal? x first))) rest))))))\n",
    "  (define (pack_consecutive_duplicates_helper list1 result)\n    (if (null? list1)\n        result\n        (let ((first (car list1))\n              (rest (cdr list1)))\n          (if (null? rest)\n              (cons (list first) result)\n              (if (equal? first (car rest))\n                  (pack_consecutive_duplicates_helper rest (cons (cons first (car result)) (cdr result)))\n                  (pack_consecutive_duplicates_helper rest (cons (list first) result)))))))\n  (pack_consecutive_duplicates_helper list1 (list)))\n",
    "  (cond\n    [(empty? list1) empty]\n    [(empty? (rest list1)) (list list1)]\n    [else (cons (list (first list1)) (pack_consecutive_duplicates (rest list1)))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (if (null? list1)\n        result\n        (let ((first (car list1))\n              (rest (cdr list1)))\n          (if (null? rest)\n              (cons (list first) result)\n              (let ((second (car rest)))\n                (if (= first second)\n                    (pack_consecutive_duplicates_iter rest (cons (cons first (car result)) (cdr result)))\n                    (pack_consecutive_duplicates_iter rest (cons (list first) result))))))))\n  (pack_consecutive_duplicates_iter list1 '()))\n",
    "  (cond [(empty? list1) empty]\n        [else\n         (let* ([first (first list1)]\n                [rest (rest list1)]\n                [packed (pack_consecutive_duplicates rest)]\n                [first-packed (first packed)]\n                [rest-packed (rest packed)])\n           (cond [(empty? rest) (list first)]\n                 [(equal? first first-packed) (cons first first-packed)]\n                 [else (cons (list first) packed)]))]))\n",
    "  (define (pack_consecutive_duplicates_helper list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_helper (cdr list1) (list (list (car list1)))))\n          ((equal? (car (car result)) (car list1)) (pack_consecutive_duplicates_helper (cdr list1) (cons (cons (car list1) (car result)) (cdr result))))\n          (else (pack_consecutive_duplicates_helper (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_helper list1 '())))\n",
    "  (if (null? list1)\n      '()\n      (let ((sublist (list (car list1))))\n        (if (null? (cdr list1))\n            (list sublist)\n            (if (equal? (car list1) (cadr list1))\n                (append (pack_consecutive_duplicates (cdr list1)) (list sublist))\n                (cons sublist (pack_consecutive_duplicates (cdr list1))))))))\n",
    "  (if (null? list1)\n      '()\n      (let ((sublist (list (car list1))))\n        (if (null? (cdr list1))\n            (list sublist)\n            (if (equal? (car list1) (cadr list1))\n                (append (pack_consecutive_duplicates (cdr list1)) (list sublist))\n                (cons sublist (pack_consecutive_duplicates (cdr list1))))))))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (caar result) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (cons (cons (car list1) (car result)) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons (list (first list1))\n           (pack_consecutive_duplicates (remove (first list1) (rest list1))))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let* ([first (first list1)]\n            [rest (rest list1)]\n            [first-rest (cons first rest)]\n            [first-rest-same? (lambda (lst) (equal? first (first lst)))]\n            [same-as-first (take-while first-rest-same? rest)]\n            [rest-of-rest (drop-while first-rest-same? rest)])\n       (cons (cons first same-as-first)\n             (pack_consecutive_duplicates rest-of-rest)))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons (list (first list1))\n           (pack_consecutive_duplicates (filter (lambda (x) (not (= x (first list1)))) (rest list1))))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let ([first (first list1)])\n       (cons (cons first (filter (lambda (x) (equal? x first)) list1))\n             (pack_consecutive_duplicates (remove (lambda (x) (equal? x first)) list1))))]))\n",
    "  (define (pack_consecutive_duplicates_helper list1 result)\n    (if (null? list1)\n        result\n        (let ((first (car list1))\n              (rest (cdr list1)))\n          (if (null? rest)\n              (cons (list first) result)\n              (let ((second (car rest)))\n                (if (= first second)\n                    (pack_consecutive_duplicates_helper rest (cons (cons first (car result)) (cdr result)))\n                    (pack_consecutive_duplicates_helper rest (cons (list first) result))))))))\n  (pack_consecutive_duplicates_helper list1 (list)))\n",
    "  (if (null? list1)\n      '()\n      (let ((first (car list1))\n            (rest (cdr list1)))\n        (if (null? rest)\n            (list list1)\n            (if (equal? first (car rest))\n                (cons (cons first (pack_consecutive_duplicates rest))\n                      (pack_consecutive_duplicates rest))\n                (cons (list first)\n                      (pack_consecutive_duplicates rest)))))))\n",
    "  (if (null? list1)\n      '()\n      (let ((sublist (list (car list1))))\n        (if (null? (cdr list1))\n            (list sublist)\n            (if (equal? (car list1) (cadr list1))\n                (cons (append sublist (list (cadr list1))) (pack_consecutive_duplicates (cddr list1)))\n                (cons sublist (pack_consecutive_duplicates (cdr list1))))))))\n",
    "  (if (null? list1)\n      list1\n      (let ((sublist (list (car list1))))\n        (if (null? (cdr list1))\n            (list sublist)\n            (if (equal? (car list1) (cadr list1))\n                (append (list (append sublist (list (cadr list1)))) (pack_consecutive_duplicates (cdr (cdr list1))))\n                (append (list sublist) (pack_consecutive_duplicates (cdr list1))))))))\n",
    "  (cond\n    [(null? list1) '()]\n    [else\n     (let* ([first (car list1)]\n            [rest (cdr list1)]\n            [first-rest (cons first rest)]\n            [first-rest-duplicates (filter (lambda (x) (equal? x first)) first-rest)]\n            [rest-duplicates (filter (lambda (x) (not (equal? x first))) first-rest)])\n       (cons first-rest-duplicates (pack_consecutive_duplicates rest-duplicates)))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (car (car result)) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (append (list (append (car result) (list (car list1)))) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (append (list (list (car list1))) result)))))\n  (pack_consecutive_duplicates_iter list1 '()))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else (cons (list (first list1)) (pack_consecutive_duplicates (rest list1)))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond\n      [(empty? list1) result]\n      [(empty? result) (pack_consecutive_duplicates_iter (rest list1) (list (list (first list1))))]\n      [(equal? (first (first result)) (first list1)) (pack_consecutive_duplicates_iter (rest list1) (cons (append (first result) (list (first list1))) (rest result)))]\n      [else (pack_consecutive_duplicates_iter (rest list1) (cons (list (first list1)) result))]))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (if (null? list1)\n      '()\n      (let ((sublist (list (car list1))))\n        (if (null? (cdr list1))\n            (list sublist)\n            (if (equal? (car list1) (cadr list1))\n                (cons (cons (car list1) (pack_consecutive_duplicates (cdr list1)))\n                      (cddr list1))\n                (cons sublist (pack_consecutive_duplicates (cdr list1))))))))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond\n      [(empty? list1) result]\n      [(empty? result) (pack_consecutive_duplicates_iter (rest list1) (list (list (first list1))))]\n      [(equal? (first (first result)) (first list1)) (pack_consecutive_duplicates_iter (rest list1) (cons (cons (first list1) (first result)) (rest result)))]\n      [else (pack_consecutive_duplicates_iter (rest list1) (cons (list (first list1)) result))]))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (cond\n    [(empty? list1) empty]\n    [(empty? (rest list1)) (list (list (first list1)))]\n    [else (cons (list (first list1)) (pack_consecutive_duplicates (rest list1)))]))\n",
    "  (define (pack_consecutive_duplicates_helper list1 list2)\n    (cond\n      [(null? list1) list2]\n      [(null? list2) (pack_consecutive_duplicates_helper (cdr list1) (list (list (car list1))))]\n      [(equal? (car list1) (caar list2)) (pack_consecutive_duplicates_helper (cdr list1) (cons (cons (car list1) (car list2)) (cdr list2)))]\n      [else (pack_consecutive_duplicates_helper (cdr list1) (cons (list (car list1)) list2))]))\n  (reverse (pack_consecutive_duplicates_helper list1 '())))\n"
  ]
}