{
  "name": "mbpp_283_validate",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a rktthon function takes in an integer and check whether the frequency of each digit in the integer is less than or equal to the digit itself.\n(define (validate n)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_283_validate.py",
  "prompt_terminology": "reworded",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate validate))\n    (check-equal? (candidate 1234) #t)\n    (check-equal? (candidate 51241) #f)\n    (check-equal? (candidate 321) #t)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (helper n)\n    (if (= n 0)\n        '()\n        (cons (modulo n 10) (helper (quotient n 10)))))\n  (define (count-digit n lst)\n    (if (null? lst)\n        0\n        (+ (if (= n (car lst)) 1 0) (count-digit n (cdr lst)))))\n  (define (check-digit n lst)\n    (if (null? lst)\n        #t\n        (and (<= (count-digit n lst) n) (check-digit n (cdr lst)))))\n  (check-digit n (helper n)))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (let loop ([ds (sort digits <)])\n      (cond [(empty? ds) #t]\n            [(<= (length (filter (lambda (d) (equal? d (first ds))) ds)) (string->number (number->string (first ds))))\n             (loop (rest ds))]\n            [else #f]))))\n",
    "  (define (validate-helper n)\n    (cond\n      [(zero? n) #t]\n      [(< (count-digit (remainder n 10) n) (remainder n 10)) #f]\n      [else (validate-helper (quotient n 10))]))\n  (validate-helper n))\n",
    "  (let loop ([n n] [digits (list)] [freq (list)])\n    (cond [(zero? n) (andmap (lambda (d f) (<= f d)) digits freq)]\n          [else (loop (quotient n 10)\n                      (cons (remainder n 10) digits)\n                      (cons (count (remainder n 10) digits) freq))])))\n",
    "  (let ([digits (string->list (number->string n))])\n    (let loop ([digits digits] [freq (make-hash)])\n      (cond [(empty? digits)\n             (let loop ([freq freq])\n               (cond [(empty? freq) #t]\n               [(<= (hash-ref freq (car (hash-keys freq))) (car (hash-keys freq)))\n                (loop (hash-remove freq (car (hash-keys freq))))]\n               [else #f]))]\n            [else\n             (let ([d (car digits)])\n               (if (hash-has-key? freq d)\n                   (loop (cdr digits) (hash-update freq d add1))\n                   (loop (cdr digits) (hash-set freq d 1))))]))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (define (count-digit n d)\n    (if (zero? n)\n        0\n        (+ (if (= (remainder n 10) d) 1 0)\n           (count-digit (quotient n 10) d))))\n  (define (helper n)\n    (if (zero? n)\n        #t\n        (and (<= (count-digit n (remainder n 10)) (remainder n 10))\n             (helper (quotient n 10)))))\n  (helper n))\n",
    "  (let ([s (number->string n)])\n    (for/and ([d (in-range 10)])\n      (<= (count (string-contains s (number->string d)) s) d))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (let loop ([digits digits] [counts (make-hash)])\n      (cond [(empty? digits)\n             (for/and ([(d . c) (in-hash counts)])\n               (<= c (string->number (number->string d))))]\n            [else\n             (let ([d (first digits)])\n               (hash-update! counts d add1 0)\n               (loop (rest digits) counts))]))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (let loop ([digits digits])\n      (cond\n        [(empty? digits) #t]\n        [(<= (count (first digits) digits) (string->number (string (first digits))))\n         (loop (rest digits))]\n        [else #f]))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (d) (count d digits)) digits))])\n      (<= f d))))\n",
    "  (define (count-digit n d)\n    (cond\n      [(zero? n) 0]\n      [(= (remainder n 10) d) (+ 1 (count-digit (quotient n 10) d))]\n      [else (count-digit (quotient n 10) d)]))\n  (define (check-digit n d)\n    (cond\n      [(zero? n) true]\n      [(= (remainder n 10) d) (and (<= (count-digit n d) d) (check-digit (quotient n 10) d))]\n      [else (check-digit (quotient n 10) d)]))\n  (check-digit n 9))\n",
    "  (let ([s (number->string n)])\n    (for/and ([c (in-string s)])\n      (<= (count c s) (string->number c)))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([s (number->string n)])\n    (for/and ([d (in-range 10)])\n      (<= (count (string-contains s (number->string d)) s) d))))\n",
    "  (cond\n    [(= n 0) #t]\n    [(< (count-digit n (modulo n 10)) (modulo n 10)) #f]\n    [else (validate (quotient n 10))]))\n",
    "  (define (helper n)\n    (cond\n      [(zero? n) #t]\n      [(<= (count-digits n (remainder n 10)) (remainder n 10)) (helper (quotient n 10))]\n      [else #f]))\n  (helper n))\n",
    "  (define (validate-helper n count)\n    (if (zero? n)\n        (if (zero? count)\n            #t\n            #f)\n        (validate-helper (quotient n 10) (+ count 1))))\n  (validate-helper n 0))\n",
    "  (let ([s (number->string n)])\n    (for/and ([d (in-list (string->list s))])\n      (<= (count (string->list s) d) (string->number (string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (define (validate-helper n)\n    (if (zero? n)\n        #t\n        (let* ([d (remainder n 10)]\n               [f (count-digit n d)]\n               [n (quotient n 10)])\n          (and (<= f d) (validate-helper n)))))\n  (validate-helper n))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([digit (in-list digits)])\n      (<= (count digit digits) (string->number (number->string digit))))))\n",
    "  (define (helper n)\n    (cond\n      [(zero? n) empty]\n      [else (cons (remainder n 10) (helper (quotient n 10)))]))\n  (define (count-digit lst)\n    (cond\n      [(empty? lst) empty]\n      [else (cons (count (first lst) lst) (count-digit (remove (first lst) lst)))]))\n  (define (check-valid lst)\n    (cond\n      [(empty? lst) true]\n      [(> (first lst) (first (rest lst))) false]\n      [else (check-valid (rest lst))]))\n  (check-valid (count-digit (helper n))))\n",
    "  (define (count-digit n d)\n    (cond\n      [(zero? n) 0]\n      [(= (remainder n 10) d) (+ 1 (count-digit (quotient n 10) d))]\n      [else (count-digit (quotient n 10) d)]))\n  (define (validate-helper n)\n    (cond\n      [(zero? n) #t]\n      [(<= (count-digit n (remainder n 10)) (remainder n 10)) (validate-helper (quotient n 10))]\n      [else #f]))\n  (validate-helper n))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (letrec ([digits (string->list (number->string n))]\n           [counts (map (lambda (d) (count (lambda (x) (=? x d)) digits)) digits)])\n    (andmap (lambda (c d) (<= c d)) counts digits)))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (x) (count x digits)) digits))])\n      (<= f d))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (letrec ([digits (string->list (number->string n))]\n           [count (lambda (digit)\n                    (count-occurrences digit digits))])\n    (andmap (lambda (digit)\n              (<= (count digit) (string->number (char->string digit))))\n            digits)))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (x) (count x digits)) digits))])\n      (<= f d))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (letrec ([digits (string->list (number->string n))]\n           [count (lambda (d) (length (filter (lambda (x) (= x d)) digits)))]\n           [valid? (lambda (d) (<= (count d) d))])\n    (andmap valid? digits)))\n",
    "  (let ([s (number->string n)])\n    (for/and ([d (in-range 0 9)])\n      (<= (count (\u03bb (c) (char=? c (integer->char d))) s) d))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (x) (count x digits)) digits))])\n      (<= f d))))\n",
    "  (define (helper n)\n    (if (zero? n)\n        '()\n        (cons (remainder n 10) (helper (quotient n 10)))))\n  (define (freq x lst)\n    (if (null? lst)\n        0\n        (if (= x (car lst))\n            (+ 1 (freq x (cdr lst)))\n            (freq x (cdr lst)))))\n  (define (check lst)\n    (if (null? lst)\n        #t\n        (if (<= (freq (car lst) lst) (car lst))\n            (check (cdr lst))\n            #f)))\n  (check (helper n)))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number d)))))\n",
    "  (define (count-digit n d)\n    (cond [(= n 0) 0]\n          [(= (remainder n 10) d) (+ 1 (count-digit (quotient n 10) d))]\n          [else (count-digit (quotient n 10) d)]))\n  (define (validate-helper n)\n    (cond [(= n 0) #t]\n          [(<= (count-digit n (remainder n 10)) (remainder n 10)) (validate-helper (quotient n 10))]\n          [else #f]))\n  (validate-helper n))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (define (count-digit d n)\n    (cond\n      [(zero? n) 0]\n      [(= d (remainder n 10)) (+ 1 (count-digit d (quotient n 10)))]\n      [else (count-digit d (quotient n 10))]))\n  (define (check-digit d n)\n    (cond\n      [(zero? n) #t]\n      [(>= (count-digit d n) d) #f]\n      [else (check-digit d (quotient n 10))]))\n  (define (helper n)\n    (cond\n      [(zero? n) #t]\n      [(check-digit (remainder n 10) n) (helper (quotient n 10))]\n      [else #f]))\n  (helper n))\n",
    "  (define (count-digit n d)\n    (cond\n      [(zero? n) 0]\n      [(= (remainder n 10) d) (+ 1 (count-digit (quotient n 10) d))]\n      [else (count-digit (quotient n 10) d)]))\n  (define (validate-helper n)\n    (cond\n      [(zero? n) #t]\n      [(<= (count-digit n (remainder n 10)) (remainder n 10)) (validate-helper (quotient n 10))]\n      [else #f]))\n  (validate-helper n))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (define (validate-helper n freq)\n    (cond\n      [(zero? n) (freq)]\n      [(<= (modulo n 10) (list-ref freq (modulo n 10))) (validate-helper (quotient n 10) freq)]\n      [else (validate-helper (quotient n 10) (list-set freq (modulo n 10) (+ 1 (list-ref freq (modulo n 10)))))]))\n  (validate-helper n (make-list 10 0)))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (d) (count d digits)) digits))])\n      (<= f d))))\n",
    "  (letrec ([digits (string->list (number->string n))]\n           [freq (for/fold ([freq (make-hash)]) ([d digits])\n                   (hash-update! freq d add1 0))])\n    (for/and ([d digits])\n      (<= (hash-ref freq d 0) (string->number (number->string d))))))\n",
    "  (define (count-digit n d)\n    (cond\n      [(zero? n) 0]\n      [(= (remainder n 10) d) (+ 1 (count-digit (quotient n 10) d))]\n      [else (count-digit (quotient n 10) d)]))\n  (define (helper n)\n    (cond\n      [(zero? n) #t]\n      [(<= (count-digit n (remainder n 10)) (remainder n 10)) (helper (quotient n 10))]\n      [else #f]))\n  (helper n))\n",
    "  (define (count-digit n d)\n    (cond\n      [(zero? n) 0]\n      [(= (remainder n 10) d) (+ 1 (count-digit (quotient n 10) d))]\n      [else (count-digit (quotient n 10) d)]))\n  (define (check-digit n d)\n    (cond\n      [(zero? n) true]\n      [(= (remainder n 10) d) (and (>= (count-digit n d) d) (check-digit (quotient n 10) d))]\n      [else (check-digit (quotient n 10) d)]))\n  (define (loop n)\n    (cond\n      [(zero? n) true]\n      [else (and (check-digit n (remainder n 10)) (loop (quotient n 10)))]))\n  (loop n))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([digit (in-list digits)])\n      (<= (count digit digits) (string->number (number->string digit))))))\n",
    "  (define (count-digit n d)\n    (if (= n 0)\n        0\n        (+ (if (= (remainder n 10) d) 1 0)\n           (count-digit (quotient n 10) d))))\n  (define (helper n)\n    (if (= n 0)\n        #t\n        (and (not (> (count-digit n (remainder n 10)) (remainder n 10)))\n             (helper (quotient n 10)))))\n  (helper n))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([digit (in-list digits)])\n      (<= (count (lambda (x) (= x digit)) digits) digit))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (let loop ([digits digits] [freq (make-hash)])\n      (cond [(empty? digits)\n             (for/and ([(d . f) (in-hash freq)])\n               (<= f (string->number (number->string d))))]\n            [else\n             (let ([d (car digits)])\n               (hash-update! freq d add1 0)\n               (loop (cdr digits) freq))]))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (define (count-digit n d)\n    (cond [(zero? n) 0]\n          [(= (remainder n 10) d) (+ 1 (count-digit (quotient n 10) d))]\n          [else (count-digit (quotient n 10) d)]))\n  (define (helper n)\n    (cond [(zero? n) true]\n          [(<= (count-digit n (remainder n 10)) (remainder n 10)) (helper (quotient n 10))]\n          [else false]))\n  (helper n))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([d (string->list (number->string n))])\n    (for/and ([i (in-range 10)])\n      (<= (count (\u03bb (x) (= x i)) d) i))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (define (count-digit n d)\n    (cond\n      [(zero? n) 0]\n      [(= (remainder n 10) d) (+ 1 (count-digit (quotient n 10) d))]\n      [else (count-digit (quotient n 10) d)]))\n  (define (helper n)\n    (cond\n      [(zero? n) #t]\n      [(<= (count-digit n (remainder n 10)) (remainder n 10)) (helper (quotient n 10))]\n      [else #f]))\n  (helper n))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number d)))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (d) (count d digits)) digits))])\n      (<= f d))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (let loop ([digits digits] [result #t])\n      (cond [(empty? digits) result]\n            [(>= (count (first digits) digits) (string->number (first digits))) #f]\n            [else (loop (rest digits) result)]))))\n",
    "  (define (count-digit n d)\n    (if (zero? n)\n        0\n        (+ (if (= (remainder n 10) d) 1 0)\n           (count-digit (quotient n 10) d))))\n  (define (check-digit n d)\n    (if (zero? n)\n        #t\n        (and (check-digit (quotient n 10) d)\n             (<= (count-digit n d) d))))\n  (check-digit n 9))\n",
    "  (define (validate-helper n)\n    (if (zero? n)\n        '()\n        (cons (remainder n 10) (validate-helper (quotient n 10)))))\n  (define (count-digit n lst)\n    (if (null? lst)\n        0\n        (if (= n (car lst))\n            (+ 1 (count-digit n (cdr lst)))\n            (count-digit n (cdr lst)))))\n  (define (check-freq n lst)\n    (if (null? lst)\n        #t\n        (if (<= (count-digit n lst) n)\n            (check-freq n (cdr lst))\n            #f)))\n  (check-freq n (validate-helper n)))\n",
    "  (define (freq-of-digit d n)\n    (cond\n      [(zero? n) 0]\n      [(= d (remainder n 10)) (+ 1 (freq-of-digit d (quotient n 10)))]\n      [else (freq-of-digit d (quotient n 10))]))\n  (define (validate-helper n)\n    (cond\n      [(zero? n) #t]\n      [(<= (freq-of-digit (remainder n 10) n) (remainder n 10)) (validate-helper (quotient n 10))]\n      [else #f]))\n  (validate-helper n))\n",
    "  (define (count-digit n d)\n    (cond\n      [(zero? n) 0]\n      [(= (remainder n 10) d) (+ 1 (count-digit (quotient n 10) d))]\n      [else (count-digit (quotient n 10) d)]))\n  (define (helper n)\n    (cond\n      [(zero? n) true]\n      [(<= (count-digit n (remainder n 10)) (remainder n 10)) (helper (quotient n 10))]\n      [else false]))\n  (helper n))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (d) (count d digits)) digits))])\n      (<= f d))))\n",
    "  (define (helper n)\n    (cond ((= n 0) '())\n          (else (cons (remainder n 10) (helper (quotient n 10))))))\n  (define (freq lst)\n    (cond ((null? lst) '())\n          (else (cons (list (car lst) (count (car lst) lst)) (freq (remove (car lst) lst))))))\n  (define (valid? lst)\n    (cond ((null? lst) #t)\n          ((>= (cadr (car lst)) (car (car lst))) (valid? (cdr lst)))\n          (else #f)))\n  (valid? (freq (helper n))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (define (validate-helper n lst)\n    (if (null? lst)\n        #t\n        (if (>= (count (car lst) (number->string n)) (car lst))\n            (validate-helper n (cdr lst))\n            #f)))\n  (validate-helper n (string->list (number->string n))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (string d))))))\n",
    "  (define (freq-of-digit n d)\n    (cond\n      [(zero? n) 0]\n      [(= (remainder n 10) d) (+ 1 (freq-of-digit (quotient n 10) d))]\n      [else (freq-of-digit (quotient n 10) d)]))\n  (define (validate-helper n)\n    (cond\n      [(zero? n) #t]\n      [(<= (freq-of-digit n (remainder n 10)) (remainder n 10)) (validate-helper (quotient n 10))]\n      [else #f]))\n  (validate-helper n))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([digit (in-list digits)])\n      (<= (count digit digits) (string->number (number->string digit))))))\n",
    "  (define (validate-helper n)\n    (cond\n      [(zero? n) #t]\n      [(<= (count-digit n (remainder n 10)) (remainder n 10)) (validate-helper (quotient n 10))]\n      [else #f]))\n  (validate-helper n))\n",
    "  (define (helper n)\n    (if (zero? n)\n        '()\n        (cons (remainder n 10) (helper (quotient n 10)))))\n  (define (count-digit n lst)\n    (if (null? lst)\n        0\n        (if (= n (car lst))\n            (+ 1 (count-digit n (cdr lst)))\n            (count-digit n (cdr lst)))))\n  (define (check-freq lst)\n    (if (null? lst)\n        #t\n        (if (<= (count-digit (car lst) lst) (car lst))\n            (check-freq (cdr lst))\n            #f)))\n  (check-freq (helper n)))\n",
    "  (let ([s (number->string n)])\n    (for/and ([d (in-list (string->list s))])\n      (<= (count d s) (string->number (string d))))))\n",
    "  (define (validate-helper n freq)\n    (cond\n      [(zero? n) #t]\n      [(= (remainder n 10) freq) (validate-helper (quotient n 10) freq)]\n      [(> (remainder n 10) freq) #f]\n      [else (validate-helper (quotient n 10) (add1 freq))]))\n  (validate-helper n 0))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (x) (count x digits)) digits))])\n      (<= f d))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (define (count-digit n d)\n    (cond\n      [(zero? n) 0]\n      [(= (remainder n 10) d) (+ 1 (count-digit (quotient n 10) d))]\n      [else (count-digit (quotient n 10) d)]))\n  (define (loop n)\n    (cond\n      [(zero? n) #t]\n      [(<= (count-digit n (remainder n 10)) (remainder n 10)) (loop (quotient n 10))]\n      [else #f]))\n  (loop n))\n",
    "  (let ([digits (string->list (number->string n))])\n    (andmap (lambda (d) (<= (count d digits) (string->number (char->string d)))) digits)))\n",
    "  (define (count-digit n d)\n    (cond\n      [(zero? n) 0]\n      [else\n       (cond\n         [(= d (remainder n 10)) (+ 1 (count-digit (quotient n 10) d))]\n         [else (count-digit (quotient n 10) d)])]))\n  (define (helper n)\n    (cond\n      [(zero? n) #t]\n      [else\n       (cond\n         [(<= (count-digit n (remainder n 10)) (remainder n 10)) (helper (quotient n 10))]\n         [else #f])]))\n  (helper n))\n",
    "  (define (count-digit n d)\n    (cond\n      [(zero? n) 0]\n      [(= (remainder n 10) d) (+ 1 (count-digit (quotient n 10) d))]\n      [else (count-digit (quotient n 10) d)]))\n  (define (validate-helper n)\n    (cond\n      [(zero? n) #t]\n      [(<= (count-digit n (remainder n 10)) (remainder n 10)) (validate-helper (quotient n 10))]\n      [else #f]))\n  (validate-helper n))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (x) (count x digits)) digits))])\n      (<= f d))))\n",
    "  (define (validate-helper n)\n    (if (zero? n)\n        '()\n        (cons (remainder n 10) (validate-helper (quotient n 10)))))\n  (define (count-digit n lst)\n    (if (null? lst)\n        0\n        (if (= n (car lst))\n            (+ 1 (count-digit n (cdr lst)))\n            (count-digit n (cdr lst)))))\n  (define (validate-helper2 lst)\n    (if (null? lst)\n        #t\n        (if (<= (count-digit (car lst) lst) (car lst))\n            (validate-helper2 (cdr lst))\n            #f)))\n  (validate-helper2 (validate-helper n)))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (define (helper n lst)\n    (if (zero? n)\n        lst\n        (helper (quotient n 10) (cons (remainder n 10) lst))))\n  (define (count n lst)\n    (if (null? lst)\n        0\n        (if (= n (car lst))\n            (+ 1 (count n (cdr lst)))\n            (count n (cdr lst)))))\n  (define (check lst)\n    (if (null? lst)\n        #t\n        (if (&gt;= (count (car lst) lst) (car lst))\n            (check (cdr lst))\n            #f)))\n  (check (helper n '())))\n</code>\nI'm not sure if this is the most efficient way to do it, but it works.\n",
    "  (define (count-digit n d)\n    (cond\n      [(zero? n) 0]\n      [(= (remainder n 10) d) (+ 1 (count-digit (quotient n 10) d))]\n      [else (count-digit (quotient n 10) d)]))\n  (define (iter n)\n    (cond\n      [(zero? n) #t]\n      [(< (count-digit n (remainder n 10)) (remainder n 10)) #f]\n      [else (iter (quotient n 10))]))\n  (iter n))\n",
    "  (define (validate-helper n lst)\n    (cond\n      [(empty? lst) #t]\n      [(<= (count (first lst) (number->string n)) (first lst)) (validate-helper n (rest lst))]\n      [else #f]))\n  (validate-helper n (string->list (number->string n))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (count-list digits d))])\n      (<= f d))))\n",
    "  (define (validate-helper n)\n    (cond\n      [(zero? n) #t]\n      [(< (count-digit n (modulo n 10)) (modulo n 10)) #f]\n      [else (validate-helper (quotient n 10))]))\n  (validate-helper n))\n",
    "  (define (validate-helper n)\n    (cond\n      [(zero? n) #t]\n      [(<= (count-digit (remainder n 10) n) (remainder n 10)) (validate-helper (quotient n 10))]\n      [else #f]))\n  (validate-helper n))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (define (validate-helper n)\n    (cond\n      [(zero? n) #t]\n      [(<= (count-digit (remainder n 10) n) (remainder n 10)) (validate-helper (quotient n 10))]\n      [else #f]))\n  (validate-helper n))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (define (helper n)\n    (if (= n 0)\n        '()\n        (cons (modulo n 10) (helper (quotient n 10)))))\n  (define (check-freq lst)\n    (if (null? lst)\n        #t\n        (if (>= (count (car lst) lst) (car lst))\n            #f\n            (check-freq (remove (car lst) lst)))))\n  (check-freq (helper n)))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let loop ([n n] [digits '()])\n    (cond [(zero? n) (for/and ([d (in-list digits)])\n                              (let ([count (count (lambda (x) (=? x d)) digits)])\n                                (and (<= count d)\n                                     (<= d 9))))]\n          [else (loop (quotient n 10) (cons (remainder n 10) digits))])))\n",
    "  (define (count-digit d n)\n    (cond [(zero? n) 0]\n          [(= d (remainder n 10)) (+ 1 (count-digit d (quotient n 10)))]\n          [else (count-digit d (quotient n 10))]))\n  (define (helper n)\n    (cond [(zero? n) #t]\n          [(>= (count-digit (remainder n 10) n) (remainder n 10)) #f]\n          [else (helper (quotient n 10))]))\n  (helper n))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (define (count-digit n d)\n    (if (zero? n)\n        0\n        (+ (if (= (remainder n 10) d) 1 0)\n           (count-digit (quotient n 10) d))))\n  (define (helper n)\n    (if (zero? n)\n        #t\n        (and (<= (count-digit n (remainder n 10)) (remainder n 10))\n             (helper (quotient n 10)))))\n  (helper n))\n",
    "  (let ([digits (string->list (number->string n))])\n    (let loop ([ds digits])\n      (cond\n        [(empty? ds) #t]\n        [(<= (count (first ds) digits) (string->number (first ds))) (loop (rest ds))]\n        [else #f]))))\n",
    "  (letrec ([digits (string->list (number->string n))]\n           [freq (for/fold ([freq (make-hash)]) ([d digits])\n                   (hash-update! freq d add1 0))])\n    (for/and ([d digits])\n      (<= (hash-ref freq d 0) (string->number (number->string d))))))\n",
    "  (define (validate-helper n)\n    (if (zero? n)\n        '()\n        (cons (remainder n 10)\n              (validate-helper (quotient n 10)))))\n  (define (count-helper lst)\n    (if (null? lst)\n        '()\n        (cons (count (car lst) lst)\n              (count-helper (cdr lst)))))\n  (define (validate-helper2 lst)\n    (if (null? lst)\n        #t\n        (and (<= (car lst) (car (count-helper (validate-helper n))))\n             (validate-helper2 (cdr lst)))))\n  (validate-helper2 (validate-helper n)))\n",
    "  (let ([digits (string->list (number->string n))])\n    (let loop ([ds (sort digits <)])\n      (cond [(empty? ds) #t]\n            [(>= (count (first ds) digits) (string->number (list->string (first ds)))) #f]\n            [else (loop (rest ds))]))))\n",
    "  (define (count-digit n d)\n    (cond\n      [(zero? n) 0]\n      [(= (remainder n 10) d) (+ 1 (count-digit (quotient n 10) d))]\n      [else (count-digit (quotient n 10) d)]))\n  (define (validate-helper n)\n    (cond\n      [(zero? n) #t]\n      [(<= (count-digit n (remainder n 10)) (remainder n 10)) (validate-helper (quotient n 10))]\n      [else #f]))\n  (validate-helper n))\n",
    "  (define (count-digit d n)\n    (cond\n      [(zero? n) 0]\n      [(= d (remainder n 10)) (+ 1 (count-digit d (quotient n 10)))]\n      [else (count-digit d (quotient n 10))]))\n  (define (helper n)\n    (cond\n      [(zero? n) #t]\n      [(<= (count-digit (remainder n 10) n) (remainder n 10)) (helper (quotient n 10))]\n      [else #f]))\n  (helper n))\n",
    "  (let ([digits (string->list (number->string n))])\n    (andmap (lambda (d) (<= (count (lambda (x) (= x d)) digits) (string->number (number->string d)))) digits)))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (define (validate-helper n)\n    (cond\n      [(zero? n) #t]\n      [(<= (count-digit (remainder n 10) n) (remainder n 10)) (validate-helper (quotient n 10))]\n      [else #f]))\n  (validate-helper n))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (x) (count x digits)) digits))])\n      (<= f d))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count (in-list digits) d) (string->number (number->string d))))))\n",
    "  (let ([counts (count-digits n)])\n    (for/and ([(digit . freq) counts])\n      (<= freq digit))))\n",
    "  (if (zero? n)\n      #t\n      (let* ([d (remainder n 10)]\n             [f (frequency n)]\n             [f-d (frequency d)])\n        (and (validate (quotient n 10))\n             (or (zero? f-d)\n                 (<= f-d d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (let loop ([ds digits] [freq (make-hash)])\n      (cond [(empty? ds)\n             (for/and ([(d . f) (in-hash freq)])\n               (<= f (string->number (number->string d))))]\n            [else\n             (let ([d (car ds)])\n               (hash-update! freq d add1 0)\n               (loop (cdr ds) freq))]))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (d) (count d digits)) digits))])\n      (<= f d))))\n",
    "  (letrec ([digits (string->list (number->string n))]\n           [freq (for/fold ([freq (make-hash)]) ([d digits])\n                   (hash-update freq d add1 0))])\n    (every? (lambda (d)\n              (<= (hash-ref freq d) (string->number (symbol->string d))))\n            digits)))\n",
    "  (define (validate-helper n freq-list)\n    (cond\n      [(= n 0) (andmap (lambda (x y) (<= x y)) freq-list (range 1 10))]\n      [(= (modulo n 10) 0) (validate-helper (quotient n 10) freq-list)]\n      [else (validate-helper (quotient n 10) (cons (add1 (list-ref freq-list (modulo n 10))) freq-list))]))\n  (validate-helper n (build-list 10 (lambda (x) 0))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (define (count-digit n digit)\n    (cond\n      [(= n 0) 0]\n      [(= (remainder n 10) digit) (+ 1 (count-digit (quotient n 10) digit))]\n      [else (count-digit (quotient n 10) digit)]))\n  (define (check-digit n)\n    (cond\n      [(= n 0) #t]\n      [(<= (count-digit n (remainder n 10)) (remainder n 10)) (check-digit (quotient n 10))]\n      [else #f]))\n  (check-digit n))\n",
    "  (define (count-digit n d)\n    (cond\n      [(zero? n) 0]\n      [(= (remainder n 10) d) (+ 1 (count-digit (quotient n 10) d))]\n      [else (count-digit (quotient n 10) d)]))\n  (define (helper n)\n    (cond\n      [(zero? n) #t]\n      [(>= (count-digit n (remainder n 10)) (remainder n 10)) #f]\n      [else (helper (quotient n 10))]))\n  (helper n))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (x) (count x digits)) digits))])\n      (<= f d))))\n",
    "  (define (count-digit n d)\n    (cond\n      [(zero? n) 0]\n      [(= (remainder n 10) d) (+ 1 (count-digit (quotient n 10) d))]\n      [else (count-digit (quotient n 10) d)]))\n  (define (check-digit n d)\n    (cond\n      [(zero? n) #t]\n      [(<= (count-digit n d) d) (check-digit (quotient n 10) d)]\n      [else #f]))\n  (check-digit n 9))\n",
    "  (let ([digits (list->string (number->list n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number d)))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (define (count-digit n d)\n    (if (zero? n)\n        0\n        (+ (if (= (remainder n 10) d) 1 0)\n           (count-digit (quotient n 10) d))))\n  (define (helper n)\n    (if (zero? n)\n        #t\n        (and (<= (count-digit n (remainder n 10)) (remainder n 10))\n             (helper (quotient n 10)))))\n  (helper n))\n",
    "  (define (count-digit n d)\n    (cond\n      [(zero? n) 0]\n      [(= (remainder n 10) d) (+ 1 (count-digit (quotient n 10) d))]\n      [else (count-digit (quotient n 10) d)]))\n  (define (loop n)\n    (cond\n      [(zero? n) #t]\n      [(< (count-digit n (remainder n 10)) (remainder n 10)) #f]\n      [else (loop (quotient n 10))]))\n  (loop n))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (define (helper n)\n    (cond\n      [(zero? n) '()]\n      [else (cons (remainder n 10) (helper (quotient n 10)))]))\n  (define (count-digit lst digit)\n    (cond\n      [(empty? lst) 0]\n      [(= digit (first lst)) (+ 1 (count-digit (rest lst) digit))]\n      [else (count-digit (rest lst) digit)]))\n  (define (check-digit lst digit)\n    (cond\n      [(empty? lst) #t]\n      [(= digit (first lst)) (check-digit (rest lst) digit)]\n      [(< (count-digit lst digit) digit) #f]\n      [else (check-digit (rest lst) digit)]))\n  (check-digit (helper n) (first (helper n))))\n",
    "  (define (validate-helper n)\n    (if (zero? n)\n        #t\n        (let* ([d (remainder n 10)]\n               [f (frequency d n)]\n               [n (quotient n 10)])\n          (and (<= f d)\n               (validate-helper n)))))\n  (validate-helper n))\n",
    "  (define (validate-helper n)\n    (cond\n      [(zero? n) #t]\n      [(<= (count-digit (remainder n 10) n) (remainder n 10)) (validate-helper (quotient n 10))]\n      [else #f]))\n  (validate-helper n))\n",
    "  (let ([s (number->string n)])\n    (for/and ([c (in-string s)])\n      (<= (count c s) (string->number c)))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (x) (count x digits)) digits))])\n      (<= f d))))\n",
    "  (define (count-digit n d)\n    (cond\n      [(zero? n) 0]\n      [(= (remainder n 10) d) (+ 1 (count-digit (quotient n 10) d))]\n      [else (count-digit (quotient n 10) d)]))\n  (define (helper n)\n    (cond\n      [(zero? n) #t]\n      [(<= (count-digit n (remainder n 10)) (remainder n 10)) (helper (quotient n 10))]\n      [else #f]))\n  (helper n))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (x) (count x digits)) digits))])\n      (<= f d))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([digit (in-list digits)]\n              [count (in-list (map (\u03bb (x) (count x digits)) digits))])\n      (<= count digit))))\n",
    "  (let ([s (number->string n)])\n    (for/and ([d (in-range 10)])\n      (<= (count (string-contains s (number->string d)) s) d))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([s (number->string n)]\n        [l (string-length s)])\n    (for/and ([i (in-range l)])\n      (<= (count (string-ref s i) s) (string->number (string (string-ref s i)))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (define (count-digit n d)\n    (cond\n      [(zero? n) 0]\n      [(= (remainder n 10) d) (+ 1 (count-digit (quotient n 10) d))]\n      [else (count-digit (quotient n 10) d)]))\n  (define (iter n)\n    (cond\n      [(zero? n) true]\n      [(< (count-digit n (remainder n 10)) (remainder n 10)) (iter (quotient n 10))]\n      [else false]))\n  (iter n))\n",
    "  (define (count-digit n d)\n    (if (zero? n)\n        0\n        (+ (if (= (remainder n 10) d) 1 0)\n           (count-digit (quotient n 10) d))))\n  (define (helper n)\n    (if (zero? n)\n        #t\n        (and (<= (count-digit n (remainder n 10)) (remainder n 10))\n             (helper (quotient n 10)))))\n  (helper n))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (lambda (x) (count x digits)) digits))])\n      (<= f d))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (d) (count d digits)) digits))])\n      (<= f d))))\n",
    "  (define (helper n)\n    (if (zero? n)\n        '()\n        (cons (remainder n 10) (helper (quotient n 10)))))\n  (define (freq lst)\n    (if (null? lst)\n        '()\n        (cons (list (car lst) (count (car lst) lst)) (freq (remove (car lst) lst)))))\n  (define (check lst)\n    (if (null? lst)\n        #t\n        (if (<= (cadr (car lst)) (car (car lst)))\n            (check (cdr lst))\n            #f)))\n  (check (freq (helper n))))\n",
    "  (define (validate-helper n)\n    (cond\n      [(zero? n) #t]\n      [(<= (count-digit (remainder n 10) n) (remainder n 10)) (validate-helper (quotient n 10))]\n      [else #f]))\n  (validate-helper n))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([d (string->list (number->string n))])\n    (andmap (lambda (x) (<= (count x d) (string->number x))) d)))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (x) (count x digits)) digits))])\n      (<= f d))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ((digits (string->list (number->string n))))\n    (let loop ((digits digits) (freq (make-hash)))\n      (cond [(empty? digits)\n             (for/and ([(k v)] (hash-for-each freq))\n               (and (<= v (string->number (symbol->string k)))))]\n            [(hash-ref freq (car digits) (lambda () 0))\n             (loop (cdr digits) (hash-set! freq (car digits) (+ 1 (hash-ref freq (car digits)))))]\n            [else (loop (cdr digits) (hash-set! freq (car digits) 1))]))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (andmap (lambda (d)\n              (let ([count (count (lambda (x) (=? x d)) digits)])\n                (<=? count (string->number (char->string d)))))\n            digits)))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (define (freq-of-digit d n)\n    (if (= n 0)\n        0\n        (+ (if (= (remainder n 10) d) 1 0)\n           (freq-of-digit d (quotient n 10)))))\n  (define (validate-helper n)\n    (if (= n 0)\n        #t\n        (and (<= (freq-of-digit (remainder n 10) n) (remainder n 10))\n             (validate-helper (quotient n 10)))))\n  (validate-helper n))\n",
    "  (define (validate-helper n)\n    (if (zero? n)\n        #t\n        (let ([d (remainder n 10)]\n              [f (count-digits n d)])\n          (and (<= f d)\n               (validate-helper (quotient n 10))))))\n  (validate-helper n))\n",
    "  (define (validate-helper n)\n    (if (zero? n)\n        '()\n        (cons (remainder n 10)\n              (validate-helper (quotient n 10)))))\n  (define (count-digit n lst)\n    (if (null? lst)\n        0\n        (if (= n (car lst))\n            (+ 1 (count-digit n (cdr lst)))\n            (count-digit n (cdr lst)))))\n  (define (validate-digit n lst)\n    (if (null? lst)\n        #t\n        (if (<= (count-digit n lst) n)\n            (validate-digit n (cdr lst))\n            #f)))\n  (validate-digit n (validate-helper n)))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (x) (count x digits)) digits))])\n      (<= f d))))\n",
    "  (define (count-digit n d)\n    (cond\n      [(zero? n) 0]\n      [(= (remainder n 10) d) (+ 1 (count-digit (quotient n 10) d))]\n      [else (count-digit (quotient n 10) d)]))\n  (define (helper n)\n    (cond\n      [(zero? n) true]\n      [(<= (count-digit n (remainder n 10)) (remainder n 10)) (helper (quotient n 10))]\n      [else false]))\n  (helper n))\n",
    "  (define (helper n)\n    (if (zero? n)\n        '()\n        (cons (remainder n 10) (helper (quotient n 10)))))\n  (define (freq lst)\n    (if (null? lst)\n        '()\n        (cons (list (car lst) (count (car lst) lst)) (freq (remove (car lst) lst)))))\n  (define (check lst)\n    (if (null? lst)\n        #t\n        (if (&lt;= (cadr (car lst)) (car (car lst)))\n            (check (cdr lst))\n            #f)))\n  (check (freq (helper n))))\n</code>\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (d) (count d digits)) digits))])\n      (<= f d))))\n",
    "  (define (count-digit n d)\n    (cond\n      [(zero? n) 0]\n      [(= (remainder n 10) d) (+ 1 (count-digit (quotient n 10) d))]\n      [else (count-digit (quotient n 10) d)]))\n  (define (check-digit n d)\n    (cond\n      [(zero? n) true]\n      [(<= (count-digit n d) d) (check-digit (quotient n 10) (+ 1 d))]\n      [else false]))\n  (check-digit n 0))\n",
    "  (define (count-digits n)\n    (if (zero? n)\n        0\n        (+ 1 (count-digits (quotient n 10)))))\n  (define (count-digit d n)\n    (if (zero? n)\n        0\n        (+ (if (= d (remainder n 10)) 1 0)\n           (count-digit d (quotient n 10)))))\n  (define (validate-helper n)\n    (if (zero? n)\n        #t\n        (and (<= (count-digit (remainder n 10) n) (remainder n 10))\n             (validate-helper (quotient n 10)))))\n  (validate-helper n))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (d) (count d digits)) digits))])\n      (<= f d))))\n",
    "  (let ([d (string->list (number->string n))])\n    (for/and ([d (in-list d)])\n      (<= (count (lambda (x) (equal? x d)) d) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (x) (count x digits)) digits))])\n      (<= f d))))\n",
    "  (let ([digits (string-&gt;list (number-&gt;string n))])\n    (for/and ([d (in-list digits)])\n      (&lt;= (count (in-list digits) d) (string-&gt;number (number-&gt;string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (string d))))))\n",
    "  (define (count-digit n d)\n    (if (= n 0)\n        0\n        (+ (if (= (remainder n 10) d) 1 0)\n           (count-digit (quotient n 10) d))))\n  (define (helper n)\n    (if (= n 0)\n        #t\n        (if (<= (count-digit n (remainder n 10)) (remainder n 10))\n            (helper (quotient n 10))\n            #f)))\n  (helper n))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (lambda (x) (count x digits)) digits))])\n      (<= f d))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (andmap (lambda (d) (<= (count d digits) (string->number (char->string d)))) digits)))\n",
    "  (define (validate-helper n freq)\n    (cond\n      [(zero? n) (andmap (lambda (x) (<= x (freq x))) (list 0 1 2 3 4 5 6 7 8 9))]\n      [(<= (freq (remainder n 10)) (remainder n 10)) (validate-helper (quotient n 10) freq)]\n      [else #f]))\n  (define (freq n)\n    (cond\n      [(zero? n) 0]\n      [(= (remainder n 10) 0) (+ 1 (freq (quotient n 10)))]\n      [else (freq (quotient n 10))]))\n  (validate-helper n freq))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (lambda (x) (count x digits)) digits))])\n      (<= f d))))\n",
    "  (letrec ([digits (string->list (number->string n))]\n           [count (lambda (d) (length (filter (lambda (x) (= x d)) digits)))]\n           [valid? (lambda (d) (<= (count d) d))])\n    (andmap valid? digits)))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (string d))))))\n",
    "  (define (count-digit d n)\n    (if (= n 0)\n        0\n        (+ (if (= (remainder n 10) d) 1 0)\n           (count-digit d (quotient n 10)))))\n  (define (validate-helper n)\n    (if (= n 0)\n        #t\n        (and (validate-helper (quotient n 10))\n             (<= (count-digit (remainder n 10) n) (remainder n 10)))))\n  (validate-helper n))\n",
    "  (let ([s (number->string n)])\n    (for/and ([d (in-range 10)])\n      (<= (count (string-contains s (number->string d)) s) d))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (define (count-digit n d)\n    (cond\n      [(zero? n) 0]\n      [(= (remainder n 10) d) (+ 1 (count-digit (quotient n 10) d))]\n      [else (count-digit (quotient n 10) d)]))\n  (define (helper n)\n    (cond\n      [(zero? n) #t]\n      [(<= (count-digit n (remainder n 10)) (remainder n 10)) (helper (quotient n 10))]\n      [else #f]))\n  (helper n))\n"
  ]
}