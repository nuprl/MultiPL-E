{
  "name": "mbpp_283_validate",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a rktthon function takes in an integer and check whether the frequency of each digit in the integer is less than or equal to the digit itself.\n(define (validate n)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_283_validate.py",
  "prompt_terminology": "reworded",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate validate))\n    (check-equal? (candidate 1234) #t)\n    (check-equal? (candidate 51241) #f)\n    (check-equal? (candidate 321) #t)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (helper n)\n    (if (= n 0)\n        '()\n        (cons (modulo n 10) (helper (quotient n 10)))))\n  (define (count-digit n lst)\n    (if (null? lst)\n        0\n        (+ (if (= n (car lst)) 1 0) (count-digit n (cdr lst)))))\n  (define (check-digit n lst)\n    (if (null? lst)\n        #t\n        (and (<= (count-digit n lst) n) (check-digit n (cdr lst)))))\n  (check-digit n (helper n)))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (let loop ([ds (sort digits <)])\n      (cond [(empty? ds) #t]\n            [(<= (length (filter (lambda (d) (equal? d (first ds))) ds)) (string->number (number->string (first ds))))\n             (loop (rest ds))]\n            [else #f]))))\n",
    "  (define (validate-helper n)\n    (cond\n      [(zero? n) #t]\n      [(< (count-digit (remainder n 10) n) (remainder n 10)) #f]\n      [else (validate-helper (quotient n 10))]))\n  (validate-helper n))\n",
    "  (let loop ([n n] [digits (list)] [freq (list)])\n    (cond [(zero? n) (andmap (lambda (d f) (<= f d)) digits freq)]\n          [else (loop (quotient n 10)\n                      (cons (remainder n 10) digits)\n                      (cons (count (remainder n 10) digits) freq))])))\n",
    "  (let ([digits (string->list (number->string n))])\n    (let loop ([digits digits] [freq (make-hash)])\n      (cond [(empty? digits)\n             (let loop ([freq freq])\n               (cond [(empty? freq) #t]\n               [(<= (hash-ref freq (car (hash-keys freq))) (car (hash-keys freq)))\n                (loop (hash-remove freq (car (hash-keys freq))))]\n               [else #f]))]\n            [else\n             (let ([d (car digits)])\n               (if (hash-has-key? freq d)\n                   (loop (cdr digits) (hash-update freq d add1))\n                   (loop (cdr digits) (hash-set freq d 1))))]))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (define (count-digit n d)\n    (if (zero? n)\n        0\n        (+ (if (= (remainder n 10) d) 1 0)\n           (count-digit (quotient n 10) d))))\n  (define (helper n)\n    (if (zero? n)\n        #t\n        (and (<= (count-digit n (remainder n 10)) (remainder n 10))\n             (helper (quotient n 10)))))\n  (helper n))\n",
    "  (let ([s (number->string n)])\n    (for/and ([d (in-range 10)])\n      (<= (count (string-contains s (number->string d)) s) d))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (let loop ([digits digits] [counts (make-hash)])\n      (cond [(empty? digits)\n             (for/and ([(d . c) (in-hash counts)])\n               (<= c (string->number (number->string d))))]\n            [else\n             (let ([d (first digits)])\n               (hash-update! counts d add1 0)\n               (loop (rest digits) counts))]))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (let loop ([digits digits])\n      (cond\n        [(empty? digits) #t]\n        [(<= (count (first digits) digits) (string->number (string (first digits))))\n         (loop (rest digits))]\n        [else #f]))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (d) (count d digits)) digits))])\n      (<= f d))))\n",
    "  (define (count-digit n d)\n    (cond\n      [(zero? n) 0]\n      [(= (remainder n 10) d) (+ 1 (count-digit (quotient n 10) d))]\n      [else (count-digit (quotient n 10) d)]))\n  (define (check-digit n d)\n    (cond\n      [(zero? n) true]\n      [(= (remainder n 10) d) (and (<= (count-digit n d) d) (check-digit (quotient n 10) d))]\n      [else (check-digit (quotient n 10) d)]))\n  (check-digit n 9))\n",
    "  (let ([s (number->string n)])\n    (for/and ([c (in-string s)])\n      (<= (count c s) (string->number c)))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n"
  ]
}