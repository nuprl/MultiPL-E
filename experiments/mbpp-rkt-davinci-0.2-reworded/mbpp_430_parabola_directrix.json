{
  "name": "mbpp_430_parabola_directrix",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to find the directrix of a parabola.\n(define (parabola_directrix a b c)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_430_parabola_directrix.py",
  "prompt_terminology": "reworded",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parabola_directrix))\n    (check-equal? (candidate 5 3 2) -198)\n    (check-equal? (candidate 9 8 4) -2336)\n    (check-equal? (candidate 2 4 6) -130)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (directrix x)\n    (define (parabola y)\n      (+ (* a y) (* b y y) (* c y y y)))\n    (define (derivative y)\n      (+ (* b 2) (* c 3 y)))\n    (define (newton-raphson y)\n      (define (close-enough? v1 v2)\n        (< (abs (- v1 v2)) 0.001))\n    (define (try guess)\n      (let ((next (newton-guess guess)))\n        (if (close-enough? guess next)\n            next\n            (try next))))\n    (define (newton-guess x)\n      (- x (/ (parabola x) (derivative x))))\n    (try x))\n  directrix)\n",
    "  (define (directrix x)\n    (+ (/ b 2) (* a x) (* b x) c))\n  directrix)\n",
    "  (let ((discriminant (- (* b b) (* 4 a c))))\n    (cond ((< discriminant 0) #f)\n          ((= discriminant 0) (/ (- b) (* 2 a)))\n          (else (/ (- b) (* 2 a))))))\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (g x)\n    (- (f x) (* 2 a x)))\n  (define (h x)\n    (- (g x) (* 2 b x)))\n  (define (i x)\n    (- (h x) (* 2 b)))\n  (define (j x)\n    (- (i x) (* 2 a)))\n  (define (k x)\n    (- (j x) (* 2 a)))\n  (define (l x)\n    (- (k x) (* 2 b)))\n  (define (m x)\n    (- (l x) (* 2 b)))\n  (define (n x)\n    (- (m x) (* 2 a)))\n  (define (o x)\n    (- (n x) (* 2 a)))\n  (define (p x)\n    (- (o x) (* 2 b)))\n  (define (q x)\n    (- (p x) (* 2 b)))\n  (define (r x)\n    (- (q x) (* 2 a)))\n  (define (s x)\n    (- (r x) (* 2 a)))\n  (define (t x)\n    (- (s x) (* 2 b)))\n  (define (u x)\n    (- (t x) (* 2 b)))\n  (define (v x)\n    (- (u x) (* 2 a)))\n  (define (w x)\n    (- (v x) (* 2 a)))\n  (define (x x)\n    (- (w x) (* 2 b)))\n  (define (y x)\n    (- (x x) (* 2 b)))\n  (define (z x)\n    (- (y x) (* 2 a)))\n  (define (aa x)\n    (- (z x) (* 2 a)))\n  (define (bb x)\n    (- (aa x) (* 2 b)))\n  (define (cc x)\n    (- (bb x) (* 2 b)))\n  (define (dd x)\n    (- (cc x) (* 2 a)))\n  (define (ee x)\n    (- (dd x) (* 2 a)))\n  (define (ff x)\n    (- (ee",
    "  (let ([x (/ (- b) (* 2 a))])\n    (if (zero? a)\n        (error \"a cannot be zero\")\n        (- (/ c) x))))\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (/ (- c) b))\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a))\n       (/ (+ (* x x) (* b x) c) (* 2 a))))\n  directrix)\n",
    "  (let ([x (/ (- b) (* 2 a))])\n    (+ c (* a (sqr x)))))\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (df x)\n    (+ (* a 1) (* b 2 x)))\n  (define (newton f df guess)\n    (define (close-enough? v1 v2)\n      (< (abs (- v1 v2)) 0.001))\n    (define (try guess)\n      (let ((next (newton-transform guess)))\n        (if (close-enough? guess next)\n            next\n            (try next))))\n    (define (newton-transform x)\n      (- x (/ (f x) (df x))))\n    (try guess))\n  (newton f df 0))\n",
    "  (define (x)\n    (/ (- b) (* 2 a)))\n  (define (y)\n    (- (/ b (* 2 a)) (sqrt (- (sqr b) (* 4 a c)))))\n  (cons x y))\n",
    "  (let ((x (- (/ b (* 2 a)))))\n    (if (positive? a)\n        (- (/ c (+ (* a (sqr x)) (* b x) c)))\n        (+ (/ c (+ (* a (sqr x)) (* b x) c))))))\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (g x)\n    (- (f x) (* b x)))\n  (define (h x)\n    (- (g x) (* a x)))\n  (define (i x)\n    (- (h x) c))\n  (define (j x)\n    (/ (i x) (* -2 b)))\n  (j 0))\n",
    "  (let ((x-intercept (/ (- b) (* 2 a))))\n    (define (directrix x)\n      (- (/ c) (* a x)))\n    (directrix x-intercept)))\n",
    "  (let ([x (- (/ b (* 2 a)))]\n        [y (- (/ c b))])\n    (list x y)))\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (g x)\n    (- (/ c x) b))\n  (define (h x)\n    (- (/ c x) a))\n  (define (i x)\n    (- (/ c x) (* a x)))\n  (define (j x)\n    (- (/ c x) (* b x)))\n  (define (k x)\n    (- (/ c x) (* a x x)))\n  (define (l x)\n    (- (/ c x) (* b x x)))\n  (define (m x)\n    (- (/ c x) (* a x x x)))\n  (define (n x)\n    (- (/ c x) (* b x x x)))\n  (define (o x)\n    (- (/ c x) (* a x x x x)))\n  (define (p x)\n    (- (/ c x) (* b x x x x)))\n  (define (q x)\n    (- (/ c x) (* a x x x x x)))\n  (define (r x)\n    (- (/ c x) (* b x x x x x)))\n  (define (s x)\n    (- (/ c x) (* a x x x x x x)))\n  (define (t x)\n    (- (/ c x) (* b x x x x x x)))\n  (define (u x)\n    (- (/ c x) (* a x x x x x x x)))\n  (define (v x)\n    (- (/ c x) (* b x x x x x x x)))\n  (define (w x)\n    (- (/ c x) (* a x x x x x x x x)))\n  (define (x1 x)\n    (- (/ c x) (* b x x x x x x x x)))\n  (define (y x)\n    (- (/ c x) (* a x x x x x x x x x)))\n  (define (z x)\n    (- (/ c x) (* b x x x x x x x x x)))\n  (define (aa x)\n    (- (/ c x) (* a x x x x x x x x x x)))\n  (define (bb x)\n    (- (/ c",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (df x)\n    (+ (* (* 2 a) x) b))\n  (define (newton f df x)\n    (define (newton-iter f df x)\n      (if (close-enough? x (f x))\n          x\n          (newton-iter f df (f x))))\n    (newton-iter f df x))\n  (define (close-enough? x y)\n    (< (abs (- x y)) 0.001))\n  (define (f-of-x x)\n    (define (f x)\n      (+ (* a x) (* b x x) c))\n    (define (df x)\n      (+ (* (* 2 a) x) b))\n    (define (newton f df x)\n      (define (newton-iter f df x)\n        (if (close-enough? x (f x))\n            x\n            (newton-iter f df (f x))))\n      (newton-iter f df x))\n    (define (close-enough? x y)\n      (< (abs (- x y)) 0.001))\n    (newton f df x))\n  (define (x-of-y y)\n    (f-of-x (/ (- y c) b)))\n  (define (y-of-x x)\n    (f x))\n  (define (y-of-x-plus-h x h)\n    (f (+ x h)))\n  (define (slope-of-line x1 x2 y1 y2)\n    (/ (- y2 y1) (- x2 x1)))\n  (define (slope-of-tangent x)\n    (slope-of-line x (+ x 0.001) (y-of-x x) (y-of-x-plus-h x 0.001)))\n  (define (slope-of-normal x)\n    (- (/ 1 (slope-of-tangent x))))\n  (define (slope-of-directrix x)\n    (- (/ 1 (slope-of-normal x))))\n  (define (y-intercept-of",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (/ (- c (* b b)) (* 2 a)))\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (g x)\n    (- (* a x) (* b x x) c))\n  (define (h x)\n    (- (* a x) (* b x x) c))\n  (define (i x)\n    (+ (* a x) (* b x x) c))\n  (define (j x)\n    (- (* a x) (* b x x) c))\n  (define (k x)\n    (+ (* a x) (* b x x) c))\n  (define (l x)\n    (- (* a x) (* b x x) c))\n  (define (m x)\n    (+ (* a x) (* b x x) c))\n  (define (n x)\n    (- (* a x) (* b x x) c))\n  (define (o x)\n    (+ (* a x) (* b x x) c))\n  (define (p x)\n    (- (* a x) (* b x x) c))\n  (define (q x)\n    (+ (* a x) (* b x x) c))\n  (define (r x)\n    (- (* a x) (* b x x) c))\n  (define (s x)\n    (+ (* a x) (* b x x) c))\n  (define (t x)\n    (- (* a x) (* b x x) c))\n  (define (u x)\n    (+ (* a x) (* b x x) c))\n  (define (v x)\n    (- (* a x) (* b x x) c))\n  (define (w x)\n    (+ (* a x) (* b x x) c))\n  (define (x x)\n    (- (* a x) (* b x x) c))\n  (define (y x)\n    (+ (* a x) (* b x x) c))\n  (define (z x)\n    (- (* a x) (* b x x) c))\n  (define (aa x)\n    (+ (* a x) (* b x x) c))\n  (define (bb x)\n    (- (* a x) (* b x x) c))\n  (define (cc",
    "  (define (directrix x)\n    (+ (/ b (* 2 a))\n       (* (/ (- (* b b) (* 4 a c)) (* 4 a)) x)))\n  directrix)\n",
    "  (let ([x (- (/ b (* 2 a)) (/ (sqrt (- (* b b) (* 4 a c))) (* 2 a)))])\n    (if (and (number? x) (not (complex? x)))\n        x\n        (error \"No directrix\"))))\n",
    "  (- (/ b (* 2 a))))\n",
    "  (let* ([x-vertex (/ (- b) (* 2 a))]\n         [y-vertex (- (+ (* a (expt x-vertex 2)) (* b x-vertex) c))])\n    (let ([slope (/ (- y-vertex) (- x-vertex))])\n      (let ([y-intercept (- y-vertex (* slope x-vertex))])\n        (list slope y-intercept)))))\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (g x)\n    (- (/ 1 (* 2 a)) x))\n  (define (h x)\n    (- (/ b (* 2 a)) x))\n  (define (i x)\n    (- (/ c (* 2 a)) x))\n  (define (j x)\n    (- (/ 1 (* 2 b)) x))\n  (define (k x)\n    (- (/ a (* 2 b)) x))\n  (define (l x)\n    (- (/ c (* 2 b)) x))\n  (define (m x)\n    (- (/ 1 (* 2 c)) x))\n  (define (n x)\n    (- (/ a (* 2 c)) x))\n  (define (o x)\n    (- (/ b (* 2 c)) x))\n  (cond ((= a 0) (g (f 0)))\n        ((= b 0) (j (f 0)))\n        ((= c 0) (m (f 0)))\n        (else (h (f 0)))))\n",
    "  (define (directrix x)\n    (sqrt (- (sqr (- x a)) (/ b 2))))\n  directrix)\n",
    "  (define (directrix x)\n    (sqrt (- (sqr (- x a)) (/ (- (sqr b) (* 4 a c)) (* 4 a)))))\n  directrix)\n",
    "  (define (directrix x)\n    (sqrt (- (* a x) c)))\n  directrix)\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (df x)\n    (+ (* 2 a) (* 4 b x)))\n  (define (newton x)\n    (newton-help x (f x) (df x)))\n  (define (newton-help x f df)\n    (if (close-enough? f 0)\n        x\n        (newton-help (- x (/ f df)) (f x) (df x))))\n  (define (close-enough? x y)\n    (< (abs (- x y)) 0.001))\n  (newton 0))\n",
    "  (- (/ b 2) a))\n",
    "  (define (directrix x)\n    (+ (/ b (* 2 a))\n       (sqrt (- (sqr (- x (/ b (* 2 a))))\n                (/ c a)))))\n  directrix)\n",
    "  (/ (- b) (* 2 a)))\n",
    "  (define (directrix x)\n    (+ (/ b (* 2 a))\n       (sqrt (- (sqr (- x (/ b (* 2 a))))\n                (/ c a)))))\n  directrix)\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (deriv x)\n    (+ (* b x) b))\n  (define (newton x)\n    (newton-help f deriv x))\n  (define (newton-help f fprime guess)\n    (define (close-enough? v1 v2)\n      (< (abs (- v1 v2)) 0.001))\n    (define (improve guess)\n      (newton-help f fprime\n                   (- guess (/ (f guess) (fprime guess)))))\n    (if (close-enough? (f guess) 0)\n        guess\n        (improve guess)))\n  (newton (/ -b 2)))\n",
    "  (define (x)\n    (sqrt (/ (- b) (* 2 a))))\n  (define (y)\n    (- (/ c (* 2 a))))\n  (define (d)\n    (sqrt (+ (sqr x) (sqr y))))\n  (define (theta)\n    (acos (/ x d)))\n  (define (phi)\n    (acos (/ y d)))\n  (define (delta)\n    (- theta phi))\n  (define (delta-deg)\n    (* 180 (/ delta pi)))\n  (define (delta-rad)\n    (* pi (/ delta 180)))\n  (define (directrix)\n    (- y (* d (sin delta-rad))))\n  (list (list x y) (list d theta phi delta delta-deg delta-rad) directrix))\n",
    "  (let ((d (/ (- b) (* 2 a))))\n    (if (zero? a)\n        (error \"a cannot be zero\")\n        (if (positive? a)\n            (- d)\n            (+ d)))))\n",
    "  (+ (* -1 (/ b (* 2 a))) (/ c (* 2 a))))\n",
    "  (let ([x (- (/ b (* 2 a)))]\n        [y (- (/ c b))])\n    (list x y)))\n",
    "  (define (x)\n    (sqrt (/ (- b) (* 2 a))))\n  (define (y)\n    (- (/ c (* 2 a))))\n  (define (d)\n    (- y (* x x)))\n  (list x y d))\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (df x)\n    (+ (* 2 a) (* 4 b x)))\n  (define (newton x)\n    (newton-help f df x))\n  (define (newton-help f df guess)\n    (let ((next (newton-transform f df guess)))\n      (if (good-enough? guess next)\n          next\n          (newton-help f df next))))\n  (define (newton-transform f df guess)\n    (- guess (/ (f guess) (df guess))))\n  (define (good-enough? guess next)\n    (< (abs (- guess next)) 0.001))\n  (newton 0))\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a)) (/ (+ (* x x) (* b x) c) (* 2 a))))\n  directrix)\n",
    "  (let ((d (sqrt (- (* b b) (* 4 a c)))))\n    (/ (- -b d) (* 2 a))))\n",
    "  (define (directrix x)\n    (+ (/ b (* 2 a)) (sqrt (- (sqr (- x (/ b (* 2 a)))) (/ c a)))))\n  directrix)\n",
    "  (let ((d (sqrt (- (* b b) (* 4 a c)))))\n    (/ (- b d) (* 2 a))))\n",
    "  (define (directrix x)\n    (+ (/ b (* 2 a))\n       (sqrt (- (sqr b) (* 4 a c)))))\n  (directrix 0))\n",
    "  (define (directrix x)\n    (+ (/ b (* 2 a))\n       (sqrt (- (sqr (- x (/ b (* 2 a))))\n                (* 4 (/ c a))))))\n  (directrix (/ b (* 2 a))))\n",
    "  (let ([x (- (/ b (* 2 a)) (/ (sqrt (- (* b b) (* 4 a c))) (* 2 a)))])\n    (if (and (number? x) (not (complex? x)))\n        (list x)\n        '())))\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a))\n       (sqrt (- (sqr (- (/ b (* 2 a)) x))\n                (/ c a)))))\n  directrix)\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a))\n       (sqrt (- (sqr (- (/ b (* 2 a))))\n                (/ c a)))))\n  (directrix 0))\n",
    "  (define (directrix x)\n    (+ (/ b (* 2 a))\n       (sqrt (- (sqr (- x (/ b (* 2 a))))\n                (/ c a)))))\n  directrix)\n",
    "  (define (parabola_directrix_helper x)\n    (define (parabola_directrix_helper_helper y)\n      (define (parabola_directrix_helper_helper_helper z)\n        (define (parabola_directrix_helper_helper_helper_helper w)\n          (define (parabola_directrix_helper_helper_helper_helper_helper u)\n            (define (parabola_directrix_helper_helper_helper_helper_helper_helper v)\n              (define (parabola_directrix_helper_helper_helper_helper_helper_helper_helper t)\n                (define (parabola_directrix_helper_helper_helper_helper_helper_helper_helper_helper s)\n                  (define (parabola_directrix_helper_helper_helper_helper_helper_helper_helper_helper_helper r)\n                    (define (parabola_directrix_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper q)\n                      (define (parabola_directrix_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper p)\n                        (define (parabola_directrix_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper o)\n                          (define (parabola_directrix_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper n)\n                            (define (parabola_directrix_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper m)\n                              (define (parabola_directrix_",
    "  (define (directrix x)\n    (- (/ b (* 2 a))\n       (/ (sqrt (+ (* b b) (* 4 a c) (* 4 a x))) (* 2 a))))\n  directrix)\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (df x)\n    (+ (* b x) b))\n  (define (newton x)\n    (newton-help x (df x) 0.00001))\n  (define (newton-help guess df dx)\n    (if (&lt; (abs (- guess (/ (f guess) df))) dx)\n        guess\n        (newton-help (- guess (/ (f guess) df)) df dx)))\n  (newton 0))\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a))\n       (/ (+ (* a (sqr x)) (* b x) c)\n          (* 2 a))))\n  directrix)\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a))\n       (/ (sqrt (+ (* b b) (* 4 a c) (* 4 a x)))\n          (* 2 a))))\n  directrix)\n",
    "  (define (x)\n    (/ (- b) (* 2 a)))\n  (define (y)\n    (- (/ b (* 2 a)) (sqrt (- (sqr b) (* 4 a c)))))\n  (cons x y))\n",
    "  (cond [(= a 0) (error \"Not a parabola\")]\n        [else (- (/ b (* 2 a)))]))\n",
    "  (define (x)\n    (/ (- b) (* 2 a)))\n  (define (y)\n    (- (/ c a)))\n  (cons x y))\n",
    "  (define (x)\n    (/ (- b) (* 2 a)))\n  (define (y)\n    (- (/ c a) (* a (x) (x))))\n  (list (x) (y)))\n",
    "  (let ([x (- (/ b (* 2 a)) (/ (sqrt (- (* b b) (* 4 a c))) (* 2 a)))])\n    (if (and (number? x) (not (nan? x)))\n        x\n        (error \"No real solution\"))))\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a))\n       (/ (sqrt (+ (* b b) (* 4 a c) (* 4 a x))) (* 2 a))))\n  directrix)\n",
    "  (let ([x (- (/ b (* 2 a)))]\n        [y (- (/ c b))])\n    (list x y)))\n",
    "  (let ((d (/ (+ (* -1 a) (* -1 b)) (* 2 c))))\n    (if (= d 0)\n        (error \"The parabola is vertical\")\n        d)))\n",
    "  (define (directrix x)\n    (define (y x)\n      (+ (* a x) (* b x x) c))\n    (define (derivative x)\n      (+ (* a 1) (* b 2 x)))\n    (define (newton-raphson x)\n      (if (&lt; (abs (- (y x) 0)) 0.00001)\n          x\n          (newton-raphson (- x (/ (y x) (derivative x))))))\n    (newton-raphson x))\n  (directrix 0))\n",
    "  (let ((discriminant (- (* b b) (* 4 a c))))\n    (cond ((> discriminant 0)\n           (let ((x1 (/ (+ (- b) (sqrt discriminant)) (* 2 a)))\n                 (x2 (/ (- (- b) (sqrt discriminant)) (* 2 a))))\n             (cond ((> x1 x2) x1)\n                   (else x2))))\n          ((= discriminant 0)\n           (/ (- b) (* 2 a)))\n          (else\n           (error \"No directrix exists.\")))))\n",
    "  (let ([x (- (/ b (* 2 a)))]\n        [y (- (/ c b))])\n    (list x y)))\n",
    "  (let ((x (- (/ b (* 2 a)))))\n    (if (positive? a)\n        (- (/ c (+ (* a (sqr x)) (* b x) c)))\n        (- (/ c (+ (* a (sqr x)) (* b x) c))))))\n",
    "  (let ([x (/ (- b) (* 2 a))])\n    (- (/ c a) (* x x))))\n",
    "  (define (directrix x)\n    (sqrt (- (sqr (- x a)) (/ b 2))))\n  directrix)\n",
    "  (let ([x (- (/ b (* 2 a)))]\n        [y (- (/ c b))])\n    (list x y)))\n",
    "  (let* ([d (- (* b b) (* 4 a c))]\n         [x1 (/ (+ b (sqrt d)) (* 2 a))]\n         [x2 (/ (- b (sqrt d)) (* 2 a))])\n    (if (and (number? x1) (number? x2))\n        (if (&lt; x1 x2) x1 x2)\n        (error \"No real solution.\"))))\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a)) x))\n  directrix)\n",
    "  (let* ([x1 (/ (- b) (* 2 a))]\n         [y1 (+ (* a (sqr x1)) (* b x1) c)])\n    (line-through x1 y1 (sqr x1) (- y1 (sqr x1)))))\n",
    "  (let ([x-intercept (parabola_x-intercept a b c)])\n    (- (/ b (* 2 a)) x-intercept)))\n",
    "  (let ([x (/ (- b) (* 2 a))])\n    (if (positive? a)\n        (- (/ c (+ (* a (sqr x)) (* b x) c)))\n        (+ (/ c (+ (* a (sqr x)) (* b x) c)))))\n  )\n",
    "  (define (x) (/ (* -1 b) (* 2 a)))\n  (define (y) (/ (* -1 c) (* 2 a)))\n  (list x y))\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a))\n       (sqrt (- (sqr (- (/ b (* 2 a))))\n                (* 4 (/ c a))))))\n  directrix)\n",
    "  (let ((x (- b (/ (sqrt (* b b (- 4 (* 4 a c)))) (* 2 a)))))\n    (if (and (number? x) (not (complex? x)))\n        x\n        (error \"No real solution\"))))\n",
    "  (let ((x (- b (/ (sqrt (* b b (- 4 (* 4 a c)))) (* 2 a)))))\n    (let ((y (+ (/ b (* 2 a)) (* a x x))))\n      (list x y))))\n",
    "  (let ([x (/ (- b) (* 2 a))])\n    (- (/ c a) (* x x))))\n",
    "  (let ((d (/ (- b) (* 2 a))))\n    (- (/ c b) d)))\n",
    "  (define (directrix x)\n    (+ (/ (- b) (* 2 a))\n       (* x x (/ c a))))\n  directrix)\n",
    "  (define (directrix x)\n    (+ (/ b 2) (* a x) (* x x)))\n  (directrix (- (/ b 2) (/ (sqrt (- (* b b) (* 4 a c))) (* 2 a)))))\n",
    "  (if (zero? a)\n      (error \"Not a parabola\")\n      (let ((d (/ b (* 2 a))))\n        (- (/ c (* 2 a)) (* d d)))))\n",
    "  (let ((x-axis-intercept (/ (- b) (* 2 a))))\n    (define (directrix-y-value x)\n      (- (/ (+ (* a (sqr x-axis-intercept)) (* b x-axis-intercept) c)\n            a)\n         (sqr x-axis-intercept)))\n    directrix-y-value))\n",
    "  (* -1 (/ b (* 2 a))))\n",
    "  (let ([x (- b (/ (* 4 a) 3))])\n    (list x (- (/ (* a x x) 4) (/ b 2) c))))\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a))\n       (sqrt (- (sqr b) (* 4 a c)))))\n  directrix)\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a))\n       (sqrt (- (sqr b) (* 4 a c)))))\n  directrix)\n",
    "  (define (directrix x)\n    (+ (/ b (* 2 a))\n       (sqrt (- (sqr b) (* 4 a c)))))\n  directrix)\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a))\n       (sqrt (- (sqr b) (* 4 a c)))))\n  directrix)\n",
    "  (let ((x1 (/ (- b) (* 2 a)))\n        (x2 (/ (+ b) (* 2 a))))\n    (if (and (number? x1) (number? x2))\n        (if (< x1 x2)\n            x1\n            x2)\n        #f)))\n",
    "  (- (/ b (* 2 a))))\n",
    "  (define (parabola_directrix_helper a b c x)\n    (- (/ b 2) (* a x)))\n  (define (parabola_directrix_helper_helper a b c x)\n    (- (/ b 2) (* a x)))\n  (define (parabola_directrix_helper_helper_helper a b c x)\n    (- (/ b 2) (* a x)))\n  (define (parabola_directrix_helper_helper_helper_helper a b c x)\n    (- (/ b 2) (* a x)))\n  (define (parabola_directrix_helper_helper_helper_helper_helper a b c x)\n    (- (/ b 2) (* a x)))\n  (define (parabola_directrix_helper_helper_helper_helper_helper_helper a b c x)\n    (- (/ b 2) (* a x)))\n  (define (parabola_directrix_helper_helper_helper_helper_helper_helper_helper a b c x)\n    (- (/ b 2) (* a x)))\n  (define (parabola_directrix_helper_helper_helper_helper_helper_helper_helper_helper a b c x)\n    (- (/ b 2) (* a x)))\n  (define (parabola_directrix_helper_helper_helper_helper_helper_helper_helper_helper_helper a b c x)\n    (- (/ b 2) (* a x)))\n  (define (parabola_directrix_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper a b c x)\n    (- (/ b 2) (* a x)))\n  (define (parabola_directrix_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper_helper a b c x)\n    (- (/ b 2) (* a x)))\n  (define (parabola_directrix_helper_helper",
    "  (let ((x (- (/ b (* 2 a)))))\n    (sqrt (+ (* a x x) (* b x) c))))\n",
    "  (define (directrix x)\n    (+ (/ b 2)\n       (sqrt (- (sqr b)\n                (* 4 a c)))))\n  directrix)\n",
    "  (let ([x (- (/ b (* 2 a)))]\n        [y (- (/ c b))])\n    (list x y)))\n",
    "  (sqrt (- (sqr b) (* 4 a c))))\n",
    "  (define (directrix x)\n    (define (parabola y)\n      (+ (* a y) (* b y) c))\n    (define (deriv y)\n      (+ (* a 2) b))\n    (define (newton-transform g)\n      (lambda (x)\n        (- x (/ (g x) (deriv x)))))\n    (define (try guess)\n      (let ((next (newton-transform parabola guess)))\n        (if (good-enough? guess (next guess))\n            guess\n            (try (next guess)))))\n    (define (good-enough? guess next)\n      (< (abs (- guess next)) 0.0001))\n    (try x))\n  directrix)\n",
    "  (define (directrix x)\n    (+ (/ b (* 2 a))\n       (sqrt (- (sqr b) (* 4 a c)))))\n  directrix)\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (df x)\n    (+ (* b x) b))\n  (define (newton-transform g)\n    (lambda (x)\n      (- x (/ (g x) (df x)))))\n  (define (fixed-point f x)\n    (if (close-enough? (f x) x)\n        x\n        (fixed-point f (f x))))\n  (define (close-enough? v1 v2)\n    (< (abs (- v1 v2)) 0.00001))\n  (define (find-zero f)\n    (fixed-point (newton-transform f) 1.0))\n  (define (directrix f)\n    (define (y x)\n      (- (f x) x))\n    (define (dy x)\n      (- (df x) 1))\n    (define (newton-transform g)\n      (lambda (x)\n        (- x (/ (g x) (dy x)))))\n    (define (fixed-point f x)\n      (if (close-enough? (f x) x)\n          x\n          (fixed-point f (f x))))\n    (define (close-enough? v1 v2)\n      (< (abs (- v1 v2)) 0.00001))\n    (define (find-zero f)\n      (fixed-point (newton-transform f) 1.0))\n    (find-zero y))\n  (directrix f))\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a))\n       (/ (+ (* x x) (* b x) c) (* 2 a))))\n  directrix)\n",
    "  (let ([x-intercept (parabola_x-intercept a b c)])\n    (- (/ b (* 2 a)) x-intercept)))\n",
    "  (let ([x (- (/ b (* 2 a)) (/ (sqrt (- (* b b) (* 4 a c))) (* 2 a)))])\n    (if (and (number? x) (not (complex? x)))\n        x\n        (error \"No real solution\"))))\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a)) x))\n  directrix)\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (df x)\n    (+ (* b x) b))\n  (define (x-intercept x)\n    (- (/ c x) (/ b x x)))\n  (define (y-intercept x)\n    (- (/ c x) (/ b x x)))\n  (define (x-intercept-of-tangent x)\n    (x-intercept (/ (- (* b x) c) a)))\n  (define (y-intercept-of-tangent x)\n    (y-intercept (/ (- (* b x) c) a)))\n  (define (x-intercept-of-tangent-of-tangent x)\n    (x-intercept (/ (- (* b x) c) a)))\n  (define (y-intercept-of-tangent-of-tangent x)\n    (y-intercept (/ (- (* b x) c) a)))\n  (define (x-intercept-of-tangent-of-tangent-of-tangent x)\n    (x-intercept (/ (- (* b x) c) a)))\n  (define (y-intercept-of-tangent-of-tangent-of-tangent x)\n    (y-intercept (/ (- (* b x) c) a)))\n  (define (x-intercept-of-tangent-of-tangent-of-tangent-of-tangent x)\n    (x-intercept (/ (- (* b x) c) a)))\n  (define (y-intercept-of-tangent-of-tangent-of-tangent-of-tangent x)\n    (y-intercept (/ (- (* b x) c) a)))\n  (define (x-intercept-of-tangent-of-tangent-of-tangent-of-tangent-of-tangent x)\n    (x-intercept (/ (- (* b x) c) a)))\n  (define (y-intercept-of-tangent-of-tangent-of-t",
    "  (let ([x (/ (- b) (* 2 a))])\n    (- (/ c a) (* x x))))\n",
    "  (let ((x (- b (/ (sqrt (* (- (* b b) (* 4 a c)) (* 4 a)))))\n        (y (+ c (* a x x))))\n    (list x y)))\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (df x)\n    (+ (* 2 a) (* 4 b x)))\n  (define (newton x)\n    (newton-help x (df x)))\n  (define (newton-help x dx)\n    (if (close-enough? x (newton-update x dx))\n        x\n        (newton-help (newton-update x dx) dx)))\n  (define (newton-update x dx)\n    (- x (/ (f x) dx)))\n  (define (close-enough? x y)\n    (< (abs (- x y)) 0.001))\n  (newton 0))\n",
    "  (define (x)\n    (/ (+ (* -1 b) (* -1 (sqrt (- (* b b) (* 4 a c)))) ) (* 2 a)))\n  (define (y)\n    (/ (+ (* -1 b) (* (sqrt (- (* b b) (* 4 a c)))) ) (* 2 a)))\n  (list x y))\n",
    "  (- (/ b (* 2 a))))\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a)) (* x x (/ b (* 2 a)))))\n  directrix)\n",
    "  (define (directrix x)\n    (+ (* a x) b))\n  (directrix (/ (* -1 c) (* 2 a))))\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (g x)\n    (- (* a x) (* b x x) c))\n  (define (h x)\n    (/ (- c (* a x)) b))\n  (define (i x)\n    (/ (+ c (* a x)) b))\n  (define (j x)\n    (/ (- c (* b x x)) a))\n  (define (k x)\n    (/ (+ c (* b x x)) a))\n  (define (l x)\n    (/ (- c (* b x x)) (* a x)))\n  (define (m x)\n    (/ (+ c (* b x x)) (* a x)))\n  (define (n x)\n    (/ (- c (* a x)) (* b x x)))\n  (define (o x)\n    (/ (+ c (* a x)) (* b x x)))\n  (cond ((and (not (zero? a)) (not (zero? b))) (h 0))\n        ((and (not (zero? a)) (not (zero? c))) (i 0))\n        ((and (not (zero? b)) (not (zero? c))) (j 0))\n        ((and (not (zero? a)) (not (zero? b)) (not (zero? c))) (k 0))\n        ((and (not (zero? a)) (not (zero? b)) (not (zero? c))) (l 0))\n        ((and (not (zero? a)) (not (zero? b)) (not (zero? c))) (m 0))\n        ((and (not (zero? a)) (not (zero? b)) (not (zero? c))) (n 0))\n        ((and (not (zero? a)) (not (zero? b)) (not (zero? c))) (o 0))\n        (else (error \"Invalid input\"))))\n",
    "  (- (/ b 2) a))\n",
    "  (let ([x (/ (* -1 b) (* 2 a))])\n    (let ([y (+ (/ (* b b) (* 4 a)) c)])\n      (let ([m (/ (- y c) (- x 0))])\n        (let ([b (- y (* m x))])\n          (let ([d (- (/ b m) x)])\n            (let ([e (+ (* m d) b)])\n              (list d e)))))))))\n",
    "  (let* ([x1 (- (/ b 2) (sqrt (- (* b b) (* 4 a c))))]\n         [x2 (- (/ b 2) (sqrt (- (* b b) (* 4 a c))))])\n    (if (and (number? x1) (number? x2))\n        (if (< x1 x2) x1 x2)\n        (error \"No real roots\"))))\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (df x)\n    (+ (* 2 a) (* 4 b x)))\n  (define (newton x)\n    (newton-help x 0.00001))\n  (define (newton-help x epsilon)\n    (if (&lt; (abs (- x (newton-step x))) epsilon)\n        x\n        (newton-help (newton-step x) epsilon)))\n  (define (newton-step x)\n    (- x (/ (f x) (df x))))\n  (newton 0))\n</code>\n",
    "  (- (/ b (* 2 a))))\n",
    "  (let ((d (- (* 4 a c) (sqr b))))\n    (if (&lt; d 0)\n        (error \"No real solution\")\n        (let ((x (/ (+ (* -1 b) (sqrt d)) (* 2 a))))\n          (if (&lt; x 0)\n              (error \"No real solution\")\n              (sqrt x))))))\n",
    "  (define (directrix x)\n    (+ (/ b (* 2 a)) (sqrt (- (sqr b) (* 4 a c)))))\n  (directrix 0))\n",
    "  (let ([x-intercept (parabola_x-intercept a b c)])\n    (- (/ b (* 2 a)) x-intercept)))\n",
    "  (- (/ b (* 2 a))))\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a))\n       (/ (+ (* x x) (* b x) c) (* 2 a))))\n  directrix)\n",
    "  (let ((d (/ (* -1 b) (* 2 a))))\n    (if (zero? a)\n        (error \"Not a parabola\")\n        (cons d (parabola_y a b c d)))))\n",
    "  (define (directrix x)\n    (sqrt (+ (sqr (- a x)) (sqr b))))\n  (directrix (- (/ c a) (/ (sqr b) (sqr a)))))\n",
    "  (- (/ b (* 2 a))))\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (g x)\n    (- (/ c x) (/ b x)))\n  (define (h x)\n    (- (/ c x) (/ b x)))\n  (define (i x)\n    (- (/ c x) (/ b x)))\n  (define (j x)\n    (- (/ c x) (/ b x)))\n  (define (k x)\n    (- (/ c x) (/ b x)))\n  (define (l x)\n    (- (/ c x) (/ b x)))\n  (define (m x)\n    (- (/ c x) (/ b x)))\n  (define (n x)\n    (- (/ c x) (/ b x)))\n  (define (o x)\n    (- (/ c x) (/ b x)))\n  (define (p x)\n    (- (/ c x) (/ b x)))\n  (define (q x)\n    (- (/ c x) (/ b x)))\n  (define (r x)\n    (- (/ c x) (/ b x)))\n  (define (s x)\n    (- (/ c x) (/ b x)))\n  (define (t x)\n    (- (/ c x) (/ b x)))\n  (define (u x)\n    (- (/ c x) (/ b x)))\n  (define (v x)\n    (- (/ c x) (/ b x)))\n  (define (w x)\n    (- (/ c x) (/ b x)))\n  (define (x x)\n    (- (/ c x) (/ b x)))\n  (define (y x)\n    (- (/ c x) (/ b x)))\n  (define (z x)\n    (- (/ c x) (/ b x)))\n  (define (aa x)\n    (- (/ c x) (/ b x)))\n  (define (ab x)\n    (- (/ c x) (/ b x)))\n  (define (ac x)\n    (- (/ c x) (/ b x)))\n  (define (ad x)\n    (- (/ c x) (/ b x)))\n  (define (ae x)\n    (- (/ c x) (/ b x)))\n  (define (af x)\n    (- (/ c x)",
    "  (define (directrix x)\n    (sqrt (- (sqr (- x a)) (/ b 2))))\n  directrix)\n",
    "  (- (/ b (* 2 a))))\n",
    "  (let ((x (sqrt (- (sqr b) (* 4 a c)))))\n    (if (negative? x)\n        (error \"No real solution\")\n        (let ((x1 (/ (+ b x) (* 2 a)))\n              (x2 (/ (- b x) (* 2 a))))\n          (if (positive? a)\n              (if (positive? x1)\n                  x1\n                  x2)\n              (if (positive? x1)\n                  x2\n                  x1))))))\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (df x)\n    (+ (* 2 a) (* 4 b x)))\n  (define (newton x)\n    (newton-help x (f x) (df x)))\n  (define (newton-help x fx dfx)\n    (if (close-enough? x (- fx (/ (fx) (dfx))))\n        x\n        (newton-help (- x (/ (fx) (dfx))) (f x) (df x))))\n  (define (close-enough? v1 v2)\n    (< (abs (- v1 v2)) 0.001))\n  (newton 0))\n",
    "  (define (directrix x)\n    (sqrt (+ (sqr (- x a)) (sqr c))))\n  (directrix b))\n",
    "  (define (directrix x)\n    (+ (/ (- b) (* 2 a))\n       (* x x (/ c a))))\n  directrix)\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a)) (* a x)))\n  directrix)\n",
    "  (let ([x (- (/ b (* 2 a)) (/ (sqrt (- (* b b) (* 4 a c))) (* 2 a)))])\n    (if (and (number? x) (not (nan? x)))\n        x\n        (error \"No directrix\"))))\n",
    "  (define (x)\n    (/ (- b) (* 2 a)))\n  (define (y)\n    (- (/ b (* 2 a)) (sqrt (- (sqr b) (* 4 a c)))))\n  (list x y))\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (df x)\n    (+ (* b x) b))\n  (define (newton x)\n    (newton-help f df x))\n  (define (newton-help f df guess)\n    (let ((next (newton-transform f df guess)))\n      (if (good-enough? guess next)\n          next\n          (newton-help f df next))))\n  (define (newton-transform f df guess)\n    (- guess (/ (f guess) (df guess))))\n  (define (good-enough? guess next)\n    (< (abs (- guess next)) 0.001))\n  (newton 0))\n",
    "  (- (/ b 2) a))\n",
    "  (define (directrix x)\n    (+ (/ b (* 2 a))\n       (sqrt (- (sqr b) (* 4 a c)))))\n  directrix)\n",
    "  (let ([x-intercept (parabola_x-intercept a b c)])\n    (if (zero? a)\n        (error \"Not a parabola\")\n        (let ([slope (/ b (* 2 a))])\n          (let ([y-intercept (+ c (* slope x-intercept))])\n            (let ([y-directrix (- y-intercept (* slope slope))])\n              y-directrix)))))\n  )\n",
    "  (define (x)\n    (/ (- b) (* 2 a)))\n  (define (y)\n    (/ (+ (* a (x)) (sqr (x)) b) (* -2 a)))\n  (define (slope)\n    (/ (* -1 a) b))\n  (define (y-intercept)\n    (- (y) (* (slope) (x))))\n  (define (directrix)\n    (cons (x) (y-intercept)))\n  directrix)\n",
    "  (let ((x-squared (/ (* -1 a) b)))\n    (if (positive? b)\n        (- (/ c b))\n        (+ x-squared (/ c b)))))\n",
    "  (let ([x (- (/ b (* 2 a)))]\n        [y (- (/ c b))])\n    (list x y)))\n",
    "  (- (/ b (* 2 a))))\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a))\n       (sqrt (- (sqr b) (* 4 a c)))))\n  directrix)\n",
    "  (let ((x (- (/ b (* 2 a)))))\n    (let ((y (- (/ (+ (* a (sqr x)) (* b x) c) (* a))))))\n    (list x y)))\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (g x)\n    (- (/ b (* 2 a)) x))\n  (define (h x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (i x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (j x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (k x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (l x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (m x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (n x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (o x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (p x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (q x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (r x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (s x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (t x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (u x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (v x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (w x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (x x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (y x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (z x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (aa x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (ab x)\n    (-",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (df x)\n    (+ (* b x) b))\n  (define (newton x)\n    (newton-help f df x))\n  (define (newton-help f df guess)\n    (let ((next (newton-transform f df guess)))\n      (if (good-enough? guess next)\n          next\n          (newton-help f df next))))\n  (define (newton-transform f df guess)\n    (- guess (/ (f guess) (df guess))))\n  (define (good-enough? guess next)\n    (< (abs (- guess next)) 0.001))\n  (newton 0))\n",
    "  (define x (- (/ b (* 2 a)) (/ (sqrt (- (* b b) (* 4 a c))) (* 2 a))))\n  (define y (- (/ c (* 2 a)) (* a x x)))\n  (define m (/ (- y 0) (- x 0)))\n  (define b (- 0 (* m 0)))\n  (define m2 (/ (- 0 1) (- m 0)))\n  (define b2 (- y (* m2 x)))\n  (define x2 (/ (+ b2 b) (- m2 m)))\n  (define y2 (- (* m2 x2) b2))\n  (define m3 (/ (- y2 0) (- x2 0)))\n  (define b3 (- 0 (* m3 0)))\n  (define x3 (/ (+ b3 b2) (- m3 m2)))\n  (define y3 (- (* m3 x3) b3)))\n</code>\nI'm not sure if this is the best way to do it, but it works.\n\n\nA:\n\nYou can use the <code>solve</code> function from the <code>math/root</code> library to solve the quadratic equation.\n<code>#lang racket\n",
    "  (let* ([x1 (/ (+ (* -1 b) (sqrt (- (* b b) (* 4 a c)))) (* 2 a))]\n         [x2 (/ (- (* -1 b) (sqrt (- (* b b) (* 4 a c)))) (* 2 a))]\n         [y1 (* a (expt x1 2)) (+ (* b x1) c)]\n         [y2 (* a (expt x2 2)) (+ (* b x2) c)])\n    (if (< y1 y2)\n        y1\n        y2)))\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a)) x))\n  directrix)\n",
    "  (let ((d (- (* b b) (* 4 a c))))\n    (if (negative? d)\n        (error \"The parabola does not have a directrix.\")\n        (let ((x1 (/ (+ b) (* -2 a)))\n              (x2 (/ (- b) (* -2 a))))\n          (if (positive? a)\n              (list x1 x2)\n              (list x2 x1))))))\n",
    "  (define (directrix x)\n    (sqrt (- (sqr (- x a)) (* b b))))\n  (directrix c))\n",
    "  (let* ([x-axis-intercept (- (/ b (* 2 a))))\n         [y-axis-intercept (- c (* a (sqr x-axis-intercept)))])\n    (list x-axis-intercept y-axis-intercept)))\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a)) (* x x (/ b (* 2 a)))))\n  directrix)\n",
    "  (define (x)\n    (sqrt (/ (- b) (* 2 a))))\n  (define (y)\n    (- (/ c) (* a (x) (x))))\n  (list (x) (y)))\n",
    "  (let ((d (- (* 4 a c) (sqr b))))\n    (if (negative? d)\n        (error \"No directrix exists.\")\n        (let ((y (/ (+ (* -1 b) (sqrt d)) (* 2 a))))\n          (if (negative? a)\n              (- y)\n              y)))))\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a))\n       (sqrt (- (sqr b) (* 4 a c)))))\n  (directrix 0))\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (g x)\n    (- (/ b (* 2 a)) x))\n  (define (h x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (i x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (j x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (k x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (l x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (m x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (n x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (o x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (p x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (q x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (r x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (s x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (t x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (u x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (v x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (w x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (x x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (y x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (z x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (aa x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (ab x)\n    (-",
    "  (let ((x (- (/ b (* 2 a)))))\n    (if (positive? a)\n        (list x (parabola_y a b c x))\n        (list (parabola_y a b c x) x))))\n",
    "  (define (x) (/ (- b) (* 2 a)))\n  (define (y) (- (/ b (* 2 a)) (sqrt (- (sqr b) (* 4 a c)))))\n  (cons x y))\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a)) (sqrt (- (sqr b) (* 4 a c)))))\n  directrix)\n",
    "  (define (x) (/ (- b) (* 2 a)))\n  (define (y) (- (/ b (* 2 a)) (sqrt (- (sqr b) (* 4 a c)))))\n  (list x y))\n",
    "  (let ([x (/ (* -1 b) (* 2 a))])\n    (let ([y (+ (* a (sqr x)) (* b x) c)])\n      (let ([d (- y (/ b (* 2 a)))])\n        d))))\n",
    "  (define (directrix x)\n    (+ (/ b (* 2 a))\n       (sqrt (- (sqr (- x (/ b (* 2 a))))\n                (/ c a)))))\n  directrix)\n",
    "  (let ([x (- (/ b (* 2 a)) (/ (sqrt (- (* b b) (* 4 a c))) (* 2 a)))])\n    (if (and (number? x) (not (nan? x)))\n        x\n        (error \"No real solution\"))))\n",
    "  (/ (- b) (* 2 a)))\n",
    "  (define (directrix x)\n    (+ (* a x) b))\n  directrix)\n",
    "  (/ (- b) (* 2 a)))\n",
    "  (define (directrix x)\n    (+ (/ b (* -2 a))\n       (sqrt (- (sqr b) (* 4 a c)))))\n  directrix)\n",
    "  (let ([x (/ (- b) (* 2 a))])\n    (let ([y (- (/ b (* 2 a)) (* a (sqr x)) (+ c))])\n      (list x y))))\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (df x)\n    (+ (* b x) b))\n  (define (x0 x)\n    (- x (/ (f x) (df x))))\n  (define (find-root a b)\n    (define (close-enough? v1 v2)\n      (< (abs (- v1 v2)) 0.00001))\n    (define (try guess)\n      (let ((next (x0 guess)))\n        (if (close-enough? guess next)\n            next\n            (try next))))\n    (try b))\n  (define (find-root-2 a b)\n    (define (close-enough? v1 v2)\n      (< (abs (- v1 v2)) 0.00001))\n    (define (try guess)\n      (let ((next (x0 guess)))\n        (if (close-enough? guess next)\n            next\n            (try next))))\n    (try b))\n  (define (find-root-3 a b)\n    (define (close-enough? v1 v2)\n      (< (abs (- v1 v2)) 0.00001))\n    (define (try guess)\n      (let ((next (x0 guess)))\n        (if (close-enough? guess next)\n            next\n            (try next))))\n    (try b))\n  (define (find-root-4 a b)\n    (define (close-enough? v1 v2)\n      (< (abs (- v1 v2)) 0.00001))\n    (define (try guess)\n      (let ((next (x0 guess)))\n        (if (close-enough? guess next)\n            next\n            (try next))))\n    (try b))\n  (define (find-root-5 a b)\n    (define (close-enough? v1 v2)\n      (< (abs (- v1 v2)) 0.00001))\n    (define (try guess)\n      (let ((next (x0 guess)))\n        (if (close-enough? guess next)\n            next\n            (try next))))\n    (try b))\n  (define (find-root",
    "  (- (/ b (* 2 a))))\n",
    "  (let ([x (- (/ b (* 2 a)))]\n        [y (+ (* a (sqr x)) (* b x) c)])\n    (list x y)))\n",
    "  (let ((d (* -2 a)))\n    (if (positive? d)\n        (let ((x (/ (+ (* -1 b) (sqrt (- (* b b) (* 4 a c)))) d)))\n          (list x (parabola_y a b c x)))\n        (list (parabola_x a b c (/ b d)) 0))))\n",
    "  (let ((d (* -2 a)))\n    (if (zero? d)\n        (error \"The directrix is a vertical line.\")\n        (let ((e (* -1 b))\n              (f (* -1 c)))\n          (let ((x (/ (+ (* -1 e) (sqrt (- (* e e) (* 4 d f)))) (* 2 d)))\n                (y (/ (+ (* -1 e) (sqrt (- (* e e) (* 4 d f)))) (* 2 d))))\n            (list x y))))))\n",
    "  (define (directrix x)\n    (+ (/ b (* 2 a))\n       (sqrt (- (sqr b) (* 4 a c)))))\n  directrix)\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a))\n       (/ (+ (* a (sqr x)) (* b x) c)\n          (* 2 a))))\n  directrix)\n",
    "  (define (directrix x)\n    (+ (/ b (* 2 a))\n       (sqrt (- (sqr b) (* 4 a c)))))\n  directrix)\n",
    "  (let ([x (- (/ b (* 2 a)) (/ (sqrt (- (* b b) (* 4 a c))) (* 2 a)))])\n    (if (and (number? x) (not (complex? x)))\n        x\n        (error \"No real solution\"))))\n",
    "  (let ([x (/ (- b) (* 2 a))])\n    (- (/ c a) (* x x))))\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a))\n       (sqrt (- (sqr b) (* 4 a c)))))\n  directrix)\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a)) (sqrt (- (sqr b) (* 4 a c)))))\n  directrix)\n",
    "  (let ((x-axis-intercept (/ (- b) (* 2 a))))\n    (let ((y-axis-intercept (+ c (* a (sqr x-axis-intercept)) (* b x-axis-intercept))))\n      (let ((slope (/ a (- b))))\n        (let ((y-intercept (- y-axis-intercept (* slope x-axis-intercept))))\n          (let ((intercept-x-coord (/ (- y-intercept) slope)))\n            (let ((intercept-y-coord (* slope intercept-x-coord)))\n              (list intercept-x-coord intercept-y-coord))))))))\n",
    "  (let ((discriminant (- (* b b) (* 4 a c))))\n    (if (&lt; discriminant 0)\n        (error \"No real solution\")\n        (let ((x1 (/ (+ (- b) (sqrt discriminant)) (* 2 a)))\n              (x2 (/ (- (- b) (sqrt discriminant)) (* 2 a))))\n          (if (&lt; x1 x2)\n              (- (/ b 2))\n              (- (/ b 2)))))))\n",
    "  (define (f x) (+ (* a x) (* b x x) c))\n  (define (df x) (+ (* a 1) (* b 2 x)))\n  (define (newton-transform g)\n    (lambda (x)\n      (- x (/ (g x) (df x)))))\n  (define (fixed-point f x)\n    (define (close-enough? v1 v2)\n      (< (abs (- v1 v2)) 0.00001))\n    (define (try guess)\n      (let ((next (f guess)))\n        (if (close-enough? guess next)\n            next\n            (try next))))\n    (try x))\n  (define (find-zero f)\n    (fixed-point (newton-transform f) 1.0))\n  (define (find-root a b c)\n    (/ (- b) (* 2 a)))\n  (define (find-y a b c x)\n    (- (/ b (* 2 a)) (* x x)))\n  (define (find-x a b c y)\n    (sqrt (- (/ b (* 2 a)) y)))\n  (define (find-directrix a b c)\n    (define (f x) (+ (* a x) (* b x x) c))\n    (define (df x) (+ (* a 1) (* b 2 x)))\n    (define (newton-transform g)\n      (lambda (x)\n        (- x (/ (g x) (df x)))))\n    (define (fixed-point f x)\n      (define (close-enough? v1 v2)\n        (< (abs (- v1 v2)) 0.00001))\n      (define (try guess)\n        (let ((next (f guess)))\n          (if (close-enough? guess next)\n              next\n              (try next))))\n      (try x))\n    (define (find-zero f)\n      (fixed-point (newton-transform f) 1.0))\n    (define (find-root a b c)\n      (/ (- b) (* 2 a)))\n    (define (find-y a b c x)\n      (- (/ b (* 2 a)) (* x x)))\n    (define (find-x a b",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (df x)\n    (+ (* b x) b))\n  (define (newton f df x)\n    (define (iter x)\n      (let ((x1 (- x (/ (f x) (df x)))))\n        (if (close-enough? x x1)\n            x1\n            (iter x1))))\n    (iter x))\n  (newton f df 0))\n",
    "  (define (x)\n    (/ (* -1 a) (* 2 b)))\n  (define (y)\n    (- (/ c b) (* a (/ a 2))))\n  (list x y))\n",
    "  (let ((x (- (/ b (* 2 a)))))\n    (if (positive? a)\n        (list x (parabola_y a b c x))\n        (list x (parabola_y a b c x)))))\n",
    "  (let ([d (/ (* -1 b) (* 2 a))])\n    (if (positive? a)\n        (- d)\n        (+ d))))\n",
    "  (define (directrix x)\n    (+ (/ b (* 2 a))\n       (sqrt (- (sqr (- x (/ b (* 2 a))))\n                (/ c a)))))\n  directrix)\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (df x)\n    (+ (* b x) b))\n  (define (ddf x)\n    b)\n  (define (newton x)\n    (newton-help x (f x) (df x) (ddf x)))\n  (define (newton-help x f df ddf)\n    (if (close-enough? f df ddf)\n        x\n        (newton-help (improve x f df)\n                     (f (improve x f df))\n                     (df (improve x f df))\n                     (ddf (improve x f df)))))\n  (define (improve x f df)\n    (- x (/ f df)))\n  (define (close-enough? f df ddf)\n    (< (abs (/ f ddf)) 0.001))\n  (newton 0))\n",
    "  (define (directrix x)\n    (/ (- c (* a x)) b))\n  directrix)\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a)) (/ (sqr x) (* 2 a))))\n  directrix)\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a))\n       (sqrt (- (sqr b) (* 4 (* a c))))))\n  directrix)\n",
    "  (define (directrix x)\n    (+ (/ b (* 2 a))\n       (/ (- (sqrt (- (* b b) (* 4 a c))) b) (* 2 a))))\n  directrix)\n",
    "  (define (x) (/ (- b) (* 2 a)))\n  (define (y) (- (/ c a) (* a (x) (x))))\n  (list (x) (y)))\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a))\n       (sqrt (- (sqr b) (* 4 a c)))))\n  directrix)\n",
    "  (let ([x (/ (* -1 b) (* 2 a))])\n    (let ([y (+ (* a (sqr x)) (* b x) c)])\n      (let ([d (/ (* -1 y) a)])\n        (+ d (sqrt (sqr x)) (sqrt (sqr d)))))))\n",
    "  (define (parabola_directrix_helper x)\n    (+ (* a x) (* b x x) c))\n  (define (parabola_directrix_helper_derivative x)\n    (+ (* 2 b x) a))\n  (define (parabola_directrix_helper_derivative_derivative x)\n    2 b)\n  (define (newton_raphson_helper x)\n    (- x (/ (parabola_directrix_helper x)\n            (parabola_directrix_helper_derivative x))))\n  (define (newton_raphson_helper_derivative x)\n    (- 1 (/ (parabola_directrix_helper_derivative x)\n            (parabola_directrix_helper_derivative x))))\n  (define (newton_raphson_helper_derivative_derivative x)\n    (/ (parabola_directrix_helper_derivative_derivative x)\n       (parabola_directrix_helper_derivative x)))\n  (define (newton_raphson_helper_derivative_derivative_derivative x)\n    (/ (parabola_directrix_helper_derivative_derivative_derivative x)\n       (parabola_directrix_helper_derivative x)))\n  (define (newton_raphson_helper_derivative_derivative_derivative_derivative x)\n    (/ (parabola_directrix_helper_derivative_derivative_derivative_derivative x)\n       (parabola_directrix_helper_derivative x)))\n  (define (newton_raphson_helper_derivative_derivative_derivative_derivative_derivative x)\n    (/ (parabola_directrix_helper_derivative_derivative_derivative_derivative_derivative x)\n       (parabola_directrix_helper_derivative x)))\n  (define (newton_raphson_",
    "  (let ([x (/ (- b) (* 2 a))])\n    (let ([y (- (/ b (* 2 a)) (* a (sqr x)) (+ c))])\n      (list x y))))\n"
  ]
}