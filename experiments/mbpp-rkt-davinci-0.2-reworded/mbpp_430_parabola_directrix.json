{
  "name": "mbpp_430_parabola_directrix",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to find the directrix of a parabola.\n(define (parabola_directrix a b c)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_430_parabola_directrix.py",
  "prompt_terminology": "reworded",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parabola_directrix))\n    (check-equal? (candidate 5 3 2) -198)\n    (check-equal? (candidate 9 8 4) -2336)\n    (check-equal? (candidate 2 4 6) -130)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (directrix x)\n    (define (parabola y)\n      (+ (* a y) (* b y y) (* c y y y)))\n    (define (derivative y)\n      (+ (* b 2) (* c 3 y)))\n    (define (newton-raphson y)\n      (define (close-enough? v1 v2)\n        (< (abs (- v1 v2)) 0.001))\n    (define (try guess)\n      (let ((next (newton-guess guess)))\n        (if (close-enough? guess next)\n            next\n            (try next))))\n    (define (newton-guess x)\n      (- x (/ (parabola x) (derivative x))))\n    (try x))\n  directrix)\n",
    "  (define (directrix x)\n    (+ (/ b 2) (* a x) (* b x) c))\n  directrix)\n",
    "  (let ((discriminant (- (* b b) (* 4 a c))))\n    (cond ((< discriminant 0) #f)\n          ((= discriminant 0) (/ (- b) (* 2 a)))\n          (else (/ (- b) (* 2 a))))))\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (g x)\n    (- (f x) (* 2 a x)))\n  (define (h x)\n    (- (g x) (* 2 b x)))\n  (define (i x)\n    (- (h x) (* 2 b)))\n  (define (j x)\n    (- (i x) (* 2 a)))\n  (define (k x)\n    (- (j x) (* 2 a)))\n  (define (l x)\n    (- (k x) (* 2 b)))\n  (define (m x)\n    (- (l x) (* 2 b)))\n  (define (n x)\n    (- (m x) (* 2 a)))\n  (define (o x)\n    (- (n x) (* 2 a)))\n  (define (p x)\n    (- (o x) (* 2 b)))\n  (define (q x)\n    (- (p x) (* 2 b)))\n  (define (r x)\n    (- (q x) (* 2 a)))\n  (define (s x)\n    (- (r x) (* 2 a)))\n  (define (t x)\n    (- (s x) (* 2 b)))\n  (define (u x)\n    (- (t x) (* 2 b)))\n  (define (v x)\n    (- (u x) (* 2 a)))\n  (define (w x)\n    (- (v x) (* 2 a)))\n  (define (x x)\n    (- (w x) (* 2 b)))\n  (define (y x)\n    (- (x x) (* 2 b)))\n  (define (z x)\n    (- (y x) (* 2 a)))\n  (define (aa x)\n    (- (z x) (* 2 a)))\n  (define (bb x)\n    (- (aa x) (* 2 b)))\n  (define (cc x)\n    (- (bb x) (* 2 b)))\n  (define (dd x)\n    (- (cc x) (* 2 a)))\n  (define (ee x)\n    (- (dd x) (* 2 a)))\n  (define (ff x)\n    (- (ee",
    "  (let ([x (/ (- b) (* 2 a))])\n    (if (zero? a)\n        (error \"a cannot be zero\")\n        (- (/ c) x))))\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (/ (- c) b))\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a))\n       (/ (+ (* x x) (* b x) c) (* 2 a))))\n  directrix)\n",
    "  (let ([x (/ (- b) (* 2 a))])\n    (+ c (* a (sqr x)))))\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (df x)\n    (+ (* a 1) (* b 2 x)))\n  (define (newton f df guess)\n    (define (close-enough? v1 v2)\n      (< (abs (- v1 v2)) 0.001))\n    (define (try guess)\n      (let ((next (newton-transform guess)))\n        (if (close-enough? guess next)\n            next\n            (try next))))\n    (define (newton-transform x)\n      (- x (/ (f x) (df x))))\n    (try guess))\n  (newton f df 0))\n",
    "  (define (x)\n    (/ (- b) (* 2 a)))\n  (define (y)\n    (- (/ b (* 2 a)) (sqrt (- (sqr b) (* 4 a c)))))\n  (cons x y))\n",
    "  (let ((x (- (/ b (* 2 a)))))\n    (if (positive? a)\n        (- (/ c (+ (* a (sqr x)) (* b x) c)))\n        (+ (/ c (+ (* a (sqr x)) (* b x) c))))))\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (g x)\n    (- (f x) (* b x)))\n  (define (h x)\n    (- (g x) (* a x)))\n  (define (i x)\n    (- (h x) c))\n  (define (j x)\n    (/ (i x) (* -2 b)))\n  (j 0))\n",
    "  (let ((x-intercept (/ (- b) (* 2 a))))\n    (define (directrix x)\n      (- (/ c) (* a x)))\n    (directrix x-intercept)))\n",
    "  (let ([x (- (/ b (* 2 a)))]\n        [y (- (/ c b))])\n    (list x y)))\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (g x)\n    (- (/ c x) b))\n  (define (h x)\n    (- (/ c x) a))\n  (define (i x)\n    (- (/ c x) (* a x)))\n  (define (j x)\n    (- (/ c x) (* b x)))\n  (define (k x)\n    (- (/ c x) (* a x x)))\n  (define (l x)\n    (- (/ c x) (* b x x)))\n  (define (m x)\n    (- (/ c x) (* a x x x)))\n  (define (n x)\n    (- (/ c x) (* b x x x)))\n  (define (o x)\n    (- (/ c x) (* a x x x x)))\n  (define (p x)\n    (- (/ c x) (* b x x x x)))\n  (define (q x)\n    (- (/ c x) (* a x x x x x)))\n  (define (r x)\n    (- (/ c x) (* b x x x x x)))\n  (define (s x)\n    (- (/ c x) (* a x x x x x x)))\n  (define (t x)\n    (- (/ c x) (* b x x x x x x)))\n  (define (u x)\n    (- (/ c x) (* a x x x x x x x)))\n  (define (v x)\n    (- (/ c x) (* b x x x x x x x)))\n  (define (w x)\n    (- (/ c x) (* a x x x x x x x x)))\n  (define (x1 x)\n    (- (/ c x) (* b x x x x x x x x)))\n  (define (y x)\n    (- (/ c x) (* a x x x x x x x x x)))\n  (define (z x)\n    (- (/ c x) (* b x x x x x x x x x)))\n  (define (aa x)\n    (- (/ c x) (* a x x x x x x x x x x)))\n  (define (bb x)\n    (- (/ c",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (df x)\n    (+ (* (* 2 a) x) b))\n  (define (newton f df x)\n    (define (newton-iter f df x)\n      (if (close-enough? x (f x))\n          x\n          (newton-iter f df (f x))))\n    (newton-iter f df x))\n  (define (close-enough? x y)\n    (< (abs (- x y)) 0.001))\n  (define (f-of-x x)\n    (define (f x)\n      (+ (* a x) (* b x x) c))\n    (define (df x)\n      (+ (* (* 2 a) x) b))\n    (define (newton f df x)\n      (define (newton-iter f df x)\n        (if (close-enough? x (f x))\n            x\n            (newton-iter f df (f x))))\n      (newton-iter f df x))\n    (define (close-enough? x y)\n      (< (abs (- x y)) 0.001))\n    (newton f df x))\n  (define (x-of-y y)\n    (f-of-x (/ (- y c) b)))\n  (define (y-of-x x)\n    (f x))\n  (define (y-of-x-plus-h x h)\n    (f (+ x h)))\n  (define (slope-of-line x1 x2 y1 y2)\n    (/ (- y2 y1) (- x2 x1)))\n  (define (slope-of-tangent x)\n    (slope-of-line x (+ x 0.001) (y-of-x x) (y-of-x-plus-h x 0.001)))\n  (define (slope-of-normal x)\n    (- (/ 1 (slope-of-tangent x))))\n  (define (slope-of-directrix x)\n    (- (/ 1 (slope-of-normal x))))\n  (define (y-intercept-of",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (/ (- c (* b b)) (* 2 a)))\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (g x)\n    (- (* a x) (* b x x) c))\n  (define (h x)\n    (- (* a x) (* b x x) c))\n  (define (i x)\n    (+ (* a x) (* b x x) c))\n  (define (j x)\n    (- (* a x) (* b x x) c))\n  (define (k x)\n    (+ (* a x) (* b x x) c))\n  (define (l x)\n    (- (* a x) (* b x x) c))\n  (define (m x)\n    (+ (* a x) (* b x x) c))\n  (define (n x)\n    (- (* a x) (* b x x) c))\n  (define (o x)\n    (+ (* a x) (* b x x) c))\n  (define (p x)\n    (- (* a x) (* b x x) c))\n  (define (q x)\n    (+ (* a x) (* b x x) c))\n  (define (r x)\n    (- (* a x) (* b x x) c))\n  (define (s x)\n    (+ (* a x) (* b x x) c))\n  (define (t x)\n    (- (* a x) (* b x x) c))\n  (define (u x)\n    (+ (* a x) (* b x x) c))\n  (define (v x)\n    (- (* a x) (* b x x) c))\n  (define (w x)\n    (+ (* a x) (* b x x) c))\n  (define (x x)\n    (- (* a x) (* b x x) c))\n  (define (y x)\n    (+ (* a x) (* b x x) c))\n  (define (z x)\n    (- (* a x) (* b x x) c))\n  (define (aa x)\n    (+ (* a x) (* b x x) c))\n  (define (bb x)\n    (- (* a x) (* b x x) c))\n  (define (cc",
    "  (define (directrix x)\n    (+ (/ b (* 2 a))\n       (* (/ (- (* b b) (* 4 a c)) (* 4 a)) x)))\n  directrix)\n",
    "  (let ([x (- (/ b (* 2 a)) (/ (sqrt (- (* b b) (* 4 a c))) (* 2 a)))])\n    (if (and (number? x) (not (complex? x)))\n        x\n        (error \"No directrix\"))))\n"
  ]
}