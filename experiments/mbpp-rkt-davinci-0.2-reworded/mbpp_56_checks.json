{
  "name": "mbpp_56_checks",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a rktthon function to check if a given number is one less than twice its reverse.\n(define (checks n)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_56_checks.py",
  "prompt_terminology": "reworded",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate checks))\n    (check-equal? (candidate 70) #f)\n    (check-equal? (candidate 23) #f)\n    (check-equal? (candidate 73) #t)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (if (= n (+ 1 (* 2 (reverse-number n))))\n      #t\n      #f))\n",
    "  (let* ([r (string->number (string-reverse (number->string n)))]\n         [d (- (* 2 r) n)])\n    (if (= d 1)\n        #t\n        #f)))\n",
    "  (define (reverse n)\n    (if (= n 0)\n        0\n        (+ (* (modulo n 10) (expt 10 (- (length (number->string n)) 1))) (reverse (quotient n 10)))))\n  (= (- n (reverse n)) 1))\n",
    "  (let* ([r (reverse n)]\n         [s (string-append r r)])\n    (and (equal? (- (string->number s) n) 1)\n         (equal? (string-length s) (string-length n)))))\n",
    "  (if (= n (+ (- (* 2 (reverse n)) 1))\n      #t\n      #f))\n",
    "  (let ([r (reverse n)])\n    (and (equal? (sub1 (* 2 r)) n)\n         (not (equal? r 0)))))\n",
    "  (if (= n (- (* 2 (reverse n)) 1))\n      #t\n      #f))\n",
    "  (let ([r (reverse n)])\n    (and (= (- (* 2 r) 1) n)\n         (= (- (* 2 n) 1) r))))\n",
    "  (let* ([rev (reverse n)]\n         [rev-n (string->number rev)])\n    (= (- (* 2 rev-n) 1) n)))\n",
    "  (let ([r (reverse n)])\n    (and (= (- n 1) (* 2 r))\n         (= n (reverse r)))))\n",
    "  (if (= (- n (* 2 (reverse n))) 1)\n      #t\n      #f))\n",
    "  (define (reverse n)\n    (if (= n 0)\n        0\n        (+ (* 10 (modulo n 10)) (reverse (quotient n 10)))))\n  (= (- n (reverse n)) 1))\n",
    "  (define (reverse n)\n    (if (= n 0)\n        0\n        (+ (* 10 (modulo n 10)) (reverse (quotient n 10)))))\n  (= (- (* 2 (reverse n)) n) 1))\n",
    "  (let ([r (reverse n)])\n    (and (= (- n 1) (* 2 r))\n         (checks r))))\n",
    "  (let ([rev (reverse n)])\n    (and (= (- n 1) (* 2 rev))\n         (not (zero? (remainder n 2))))))\n",
    "  (and (= (- n (reverse n)) 1)\n       (= (modulo n 2) 1)))\n",
    "  (let ([r (reverse n)])\n    (= (- (* 2 r) 1) n)))\n",
    "  (let ([r (reverse n)])\n    (and (equal? (sub1 (* 2 r)) n)\n         (not (zero? (modulo n 2))))))\n",
    "  (let ([rev (reverse-number n)])\n    (= (- (* 2 rev) 1) n)))\n",
    "  (let ([r (reverse n)])\n    (= (- (* 2 r) 1) n)))\n"
  ]
}