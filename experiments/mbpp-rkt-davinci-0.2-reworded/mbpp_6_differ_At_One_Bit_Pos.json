{
  "name": "mbpp_6_differ_At_One_Bit_Pos",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a rktthon function to check whether the two numbers differ at one bit position only or not.\n(define (differ_At_One_Bit_Pos a b)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_6_differ_At_One_Bit_Pos.py",
  "prompt_terminology": "reworded",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate differ_At_One_Bit_Pos))\n    (check-equal? (candidate 13 9) #t)\n    (check-equal? (candidate 15 8) #f)\n    (check-equal? (candidate 2 4) #f)\n    (check-equal? (candidate 2 3) #t)\n    (check-equal? (candidate 5 1) #t)\n    (check-equal? (candidate 1 5) #t)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (let ([xor (bitwise-xor a b)])\n    (cond\n      [(zero? xor) #f]\n      [(zero? (bitwise-and xor (bitwise-not (bitwise-xor xor (bitwise-arithmetic-shift xor -1))))) #t]\n      [else #f])))\n",
    "  (let ([xor (bitwise-xor a b)])\n    (or (= xor 1) (= xor 2) (= xor 4) (= xor 8) (= xor 16) (= xor 32) (= xor 64) (= xor 128))))\n",
    "  (let ([xor (bitwise-xor a b)])\n    (cond\n      [(zero? xor) #f]\n      [(zero? (bitwise-and xor (bitwise-xor xor (sub1 xor)))) #t]\n      [else #f])))\n",
    "  (let ([xor (bitwise-xor a b)])\n    (cond [(zero? xor) #f]\n          [(zero? (bitwise-and xor (bitwise-sub1 xor))) #t]\n          [else #f])))\n",
    "  (let ([xor (bitwise-xor a b)])\n    (cond\n      [(zero? xor) #f]\n      [(zero? (bitwise-and xor (bitwise-xor xor (sub1 xor)))) #t]\n      [else #f])))\n",
    "  (define (differ_At_One_Bit_Pos_helper a b count)\n    (if (or (zero? a) (zero? b))\n        (if (= count 1)\n            #t\n            #f)\n        (if (not (= (remainder a 2) (remainder b 2)))\n            (differ_At_One_Bit_Pos_helper (quotient a 2) (quotient b 2) (+ count 1))\n            (differ_At_One_Bit_Pos_helper (quotient a 2) (quotient b 2) count))))\n  (differ_At_One_Bit_Pos_helper a b 0))\n",
    "  (if (not (= a b))\n      (if (= (bitwise-xor a b) 1)\n          #t\n          #f)\n      #f))\n",
    "  (let ([xor (bitwise-xor a b)])\n    (or (= xor 1) (= xor 2) (= xor 4) (= xor 8) (= xor 16) (= xor 32) (= xor 64) (= xor 128))))\n",
    "  (let ([xor (bitwise-xor a b)])\n    (cond [(zero? xor) #f]\n          [(zero? (bitwise-and xor (sub1 xor))) #t]\n          [else #f])))\n",
    "  (let ((xor (bitwise-xor a b)))\n    (if (zero? xor) #f\n        (let loop ((xor xor))\n          (if (zero? (bitwise-and xor 1)) (loop (bitwise-shift-right xor 1))\n              (if (zero? (bitwise-shift-right xor 1)) #t #f))))))\n",
    "  (let ([xor (bitwise-xor a b)])\n    (if (= xor 0)\n        #f\n        (let ([bit-count (bit-count xor)])\n          (if (= bit-count 1)\n              #t\n              #f)))))\n",
    "  (let ([xor (bitwise-xor a b)])\n    (cond\n      [(zero? xor) #f]\n      [(zero? (bitwise-and xor (bitwise-xor xor (sub1 xor)))) #t]\n      [else #f])))\n",
    "  (define (differ_At_One_Bit_Pos_Helper a b count)\n    (cond ((= a 0) (if (= b 0) count (differ_At_One_Bit_Pos_Helper (/ a 2) (/ b 2) (+ count 1))))\n          ((= b 0) (differ_At_One_Bit_Pos_Helper (/ a 2) (/ b 2) (+ count 1)))\n          ((= (remainder a 2) (remainder b 2)) (differ_At_One_Bit_Pos_Helper (/ a 2) (/ b 2) count))\n          (else (differ_At_One_Bit_Pos_Helper (/ a 2) (/ b 2) (+ count 1)))))\n  (if (= (differ_At_One_Bit_Pos_Helper a b 0) 1) #t #f))\n",
    "  (let ([xor (bitwise-xor a b)])\n    (cond\n      [(zero? xor) #f]\n      [(zero? (bitwise-and xor (bitwise-xor xor (sub1 xor)))) #t]\n      [else #f])))\n",
    "  (let ([xor (bitwise-xor a b)])\n    (cond [(zero? xor) #f]\n          [(zero? (bitwise-and xor (bitwise-xor xor (sub1 xor)))) #t]\n          [else #f])))\n",
    "  (let ([xor (bitwise-xor a b)])\n    (cond\n      [(zero? xor) #f]\n      [(zero? (bitwise-and xor (bitwise-xor xor (sub1 xor)))) #t]\n      [else #f])))\n",
    "  (let ([xor (bitwise-xor a b)])\n    (if (zero? xor)\n        #f\n        (let ([xor-1 (bitwise-xor xor (sub1 xor))])\n          (if (zero? xor-1)\n              #t\n              #f)))))\n",
    "  (let ([xor (bitwise-xor a b)])\n    (cond\n      [(zero? xor) #f]\n      [(zero? (bitwise-and xor (bitwise-xor xor (sub1 xor)))) #t]\n      [else #f])))\n",
    "  (let ([xor (bitwise-xor a b)])\n    (or (zero? xor)\n        (and (bitwise-and xor (bitwise-xor xor (sub1 xor)))\n             (zero? (bitwise-and xor (sub1 xor)))))))\n</code>\n",
    "  (let ([xor (bitwise-xor a b)])\n    (or (= xor 1) (= (bitwise-and xor (bitwise-xor xor 1)) 0))))\n"
  ]
}