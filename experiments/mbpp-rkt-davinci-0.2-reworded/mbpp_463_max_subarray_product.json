{
  "name": "mbpp_463_max_subarray_product",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to find the maximum product sublist of the given list.\n(define (max_subarray_product arr)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_463_max_subarray_product.py",
  "prompt_terminology": "reworded",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate max_subarray_product))\n    (check-equal? (candidate (list 1 -2 -3 0 7 -8 -2)) 112)\n    (check-equal? (candidate (list 6 -3 -10 0 2)) 180)\n    (check-equal? (candidate (list -2 -40 0 -2 -3)) 80)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (max_subarray_product_helper arr max_product max_product_start max_product_end)\n    (cond [(empty? arr) (values max_product max_product_start max_product_end)]\n          [else\n           (define (update-max-product-start-end max_product_start max_product_end)\n             (cond [(< max_product_start max_product_end) (values max_product_start max_product_end)]\n                   [else (values max_product_end max_product_start)]))\n           (define (update-max-product-start-end-helper max_product_start max_product_end)\n             (cond [(< max_product_start max_product_end) (values max_product_start max_product_end)]\n                   [else (values max_product_end max_product_start)]))\n           (define (update-max-product-start-end-helper-helper max_product_start max_product_end)\n             (cond [(< max_product_start max_product_end) (values max_product_start max_product_end)]\n                   [else (values max_product_end max_product_start)]))\n           (define (update-max-product-start-end-helper-helper-helper max_product_start max_product_end)\n             (cond [(< max_product_start max_product_end) (values max_product_start max_product_end)]\n                   [else (values max_product_end max_product_start)]))\n           (define (update-max-product-start-end-helper-helper-helper-helper max_product_start max_product_end)\n             (cond [(< max_product_start max_product_end) (values max_product_start max_product_end)]\n                   [else (values max_product_end max_product_start)]))\n           (define (update-max-product-start-end-helper-helper-helper-helper-helper max_product_start max_product_end)\n             (cond [(< max_product_start max_product_end) (values",
    "  (let loop ((arr arr)\n             (max-product (car arr))\n             (min-product (car arr))\n             (max-so-far (car arr)))\n    (if (null? arr)\n        max-so-far\n        (let ((curr-product (* (car arr) max-product))\n              (curr-min-product (* (car arr) min-product)))\n          (loop (cdr arr)\n                (max curr-product curr-min-product)\n                (min curr-product curr-min-product)\n                (max max-so-far (max curr-product curr-min-product)))))))\n",
    "  (define (max_product_helper arr max_product start_index end_index)\n    (cond\n      [(empty? arr) (values max_product start_index end_index)]\n      [(zero? (first arr))\n       (max_product_helper (rest arr) max_product start_index end_index)]\n      [else\n       (let ([product (* max_product (first arr))])\n         (if (&gt; product max_product)\n             (max_product_helper (rest arr) product start_index (+ end_index 1))\n             (max_product_helper (rest arr) max_product (+ start_index 1) (+ end_index 1))))]))\n  (max_product_helper arr 1 0 0))\n",
    "  (define (max_subarray_product_helper arr max_product min_product)\n    (cond\n      [(empty? arr) max_product]\n      [else\n       (let* ([curr (first arr)]\n              [rest (rest arr)]\n              [curr_max_product (max (max curr (* curr max_product)) (* curr min_product))]\n              [curr_min_product (min (min curr (* curr max_product)) (* curr min_product))])\n         (max_subarray_product_helper rest curr_max_product curr_min_product))]))\n  (max_subarray_product_helper arr (first arr) (first arr)))\n",
    "  (define (max_product_ending_here arr)\n    (define (helper arr max_ending_here min_ending_here)\n      (cond [(empty? arr) max_ending_here]\n            [(negative? (first arr))\n             (helper (rest arr)\n                     (max max_ending_here (min_ending_here * (first arr)))\n                     (min min_ending_here (first arr)))]\n            [else\n             (helper (rest arr)\n                     (max max_ending_here (max_ending_here * (first arr)))\n                     (min min_ending_here (min_ending_here * (first arr))))]))\n    (helper arr (first arr) (first arr)))\n  (max_product_ending_here arr))\n",
    "  (define (max_subarray_product_helper arr max_product_so_far max_product_ending_here min_product_ending_here)\n    (cond\n      [(empty? arr) max_product_so_far]\n      [else\n       (define curr_val (first arr))\n       (define max_product_ending_here_new (max (* curr_val max_product_ending_here) (* curr_val min_product_ending_here) curr_val))\n       (define min_product_ending_here_new (min (* curr_val max_product_ending_here) (* curr_val min_product_ending_here) curr_val))\n       (define max_product_so_far_new (max max_product_so_far max_product_ending_here_new))\n       (max_subarray_product_helper (rest arr) max_product_so_far_new max_product_ending_here_new min_product_ending_here_new)\n       ]\n      )\n    )\n  (max_subarray_product_helper arr -inf.0 -inf.0 inf.0)\n  )\n",
    "  (define (max_product_helper arr start end)\n    (if (= start end)\n        (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (",
    "  (define (max-product-helper arr start end)\n    (cond [(empty? arr) 1]\n          [(= start end) (first arr)]\n          [else (* (first arr) (max-product-helper (rest arr) (+ start 1) end))]))\n  (define (max-product-helper-2 arr start end)\n    (cond [(empty? arr) 1]\n          [(= start end) (first arr)]\n          [else (* (first arr) (max-product-helper-2 (rest arr) (+ start 1) end))]))\n  (define (max-product-helper-3 arr start end)\n    (cond [(empty? arr) 1]\n          [(= start end) (first arr)]\n          [else (* (first arr) (max-product-helper-3 (rest arr) (+ start 1) end))]))\n  (define (max-product-helper-4 arr start end)\n    (cond [(empty? arr) 1]\n          [(= start end) (first arr)]\n          [else (* (first arr) (max-product-helper-4 (rest arr) (+ start 1) end))]))\n  (define (max-product-helper-5 arr start end)\n    (cond [(empty? arr) 1]\n          [(= start end) (first arr)]\n          [else (* (first arr) (max-product-helper-5 (rest arr) (+ start 1) end))]))\n  (define (max-product-helper-6 arr start end)\n    (cond [(empty? arr) 1]\n          [(= start end) (first arr)]\n          [else (* (first arr) (max-product-helper-6 (rest arr) (+ start 1) end))]))\n  (define (max-product-helper-7 arr start end)\n    (cond [(empty? arr) 1]\n          [(= start end) (first arr)]\n          [else (* (first arr) (max-product-helper-7 (rest arr) (+ start 1) end))]))\n  (define (max-product-helper-8 arr start end)\n    (cond [(empty? arr) 1]\n          [(= start",
    "  (define (helper arr max_so_far max_ending_here min_ending_here)\n    (cond\n      [(null? arr) max_so_far]\n      [else\n       (let* ([curr (car arr)]\n              [max_ending_here (max curr (* curr max_ending_here) (* curr min_ending_here))]\n              [min_ending_here (min curr (* curr max_ending_here) (* curr min_ending_here))]\n              [max_so_far (max max_so_far max_ending_here)])\n         (helper (cdr arr) max_so_far max_ending_here min_ending_here))]))\n  (helper arr -1000000000 1000000000 1000000000))\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ((cur-product (apply * arr)))\n          (if (&gt; cur-product max-product)\n              (max-product-helper (cdr arr) cur-product)\n              (max-product-helper (cdr arr) max-product)))))\n  (max-product-helper arr 0))\n",
    "  (define (max_subarray_product_helper arr max_product_so_far max_product_ending_here min_product_ending_here)\n    (cond [(empty? arr) max_product_so_far]\n          [else\n           (let ([x (first arr)])\n             (cond [(zero? x)\n                    (max_subarray_product_helper (rest arr) max_product_so_far 0 0)]\n                   [else\n                    (let ([max_product_ending_here (max (* x max_product_ending_here) (* x min_product_ending_here) x)]\n                          [min_product_ending_here (min (* x max_product_ending_here) (* x min_product_ending_here) x)])\n                      (max_subarray_product_helper (rest arr)\n                                                   (max max_product_so_far max_product_ending_here)\n                                                   max_product_ending_here\n                                                   min_product_ending_here))]))]))\n  (max_subarray_product_helper arr -1/0 1/0 1/0))\n",
    "  (let loop ((arr arr)\n             (max-product (car arr))\n             (min-product (car arr))\n             (max-so-far (car arr)))\n    (if (null? (cdr arr))\n        max-so-far\n        (let ((curr-max-product (* max-product (car (cdr arr))))\n              (curr-min-product (* min-product (car (cdr arr)))))\n          (loop (cdr arr)\n                (max curr-max-product (car (cdr arr)))\n                (min curr-min-product (car (cdr arr)))\n                (max max-so-far\n                     (max curr-max-product curr-min-product)))))))\n",
    "  (define (max_product_helper arr max_product)\n    (cond\n      [(null? arr) max_product]\n      [(< (car arr) 0)\n       (max_product_helper (cdr arr)\n                           (max max_product\n                                (max_product_helper (cdr arr) (car arr))))]\n      [else\n       (max_product_helper (cdr arr)\n                           (* max_product (car arr)))]))\n  (max_product_helper arr 1))\n",
    "  (define (max_subarray_product_helper arr start end)\n    (if (= start end)\n        (list (list (list (list arr) start) end)\n              (list (list (list arr) start) end))\n        (let* ((mid (/ (+ start end) 2))\n               (left (max_subarray_product_helper arr start mid))\n               (right (max_subarray_product_helper arr (+ mid 1) end))\n               (left_max (car left))\n               (left_min (cadr left))\n               (right_max (car right))\n               (right_min (cadr right))\n               (cross_max (max_subarray_product_cross arr start mid end))\n               (cross_min (min_subarray_product_cross arr start mid end)))\n          (list (max_subarray_product_max left_max right_max cross_max)\n                (min_subarray_product_min left_min right_min cross_min)))))\n  (max_subarray_product_helper arr 0 (- (length arr) 1)))\n",
    "  (let loop ((arr arr) (max-product 1) (min-product 1) (max-so-far 1))\n    (cond ((null? arr) max-so-far)\n          ((= 0 (car arr))\n           (loop (cdr arr) 1 1 max-so-far))\n          (else\n           (let ((max-product (* max-product (car arr)))\n                 (min-product (* min-product (car arr))))\n             (if (&lt; min-product 0)\n                 (set! min-product 1))\n             (if (&lt; max-product 0)\n                 (set! max-product 1))\n             (loop (cdr arr) max-product min-product\n                   (max max-so-far max-product)))))))\n</code>\n",
    "  (let loop ((arr arr) (max-product 1) (min-product 1) (max-so-far 1))\n    (cond ((null? arr) max-so-far)\n          ((= (car arr) 0) (loop (cdr arr) 1 1 max-so-far))\n          (else\n           (let* ((product (* (car arr) max-product))\n                  (min-product (min product (* (car arr) min-product)))\n                  (max-product (max product (* (car arr) min-product))))\n             (loop (cdr arr) max-product min-product (max max-so-far max-product)))))))\n",
    "  (define (max_product_helper arr start end)\n    (if (= start end)\n        (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (if (null? arr)\n        max_product\n        (let* ([first (car arr)]\n               [new_max_product_ending_here (max (max first (* first max_product_ending_here)) (* first min_product_ending_here))]\n               [new_min_product_ending_here (min (min first (* first max_product_ending_here)) (* first min_product_ending_here))]\n               [new_max_product (max new_max_product_ending_here max_product)])\n          (max_subarray_product_helper (cdr arr) new_max_product new_max_product_ending_here new_min_product_ending_here))))\n  (max_subarray_product_helper arr (car arr) (car arr) (car arr)))\n",
    "  (let loop ((arr arr)\n             (max-product (car arr))\n             (min-product (car arr))\n             (max-so-far max-product))\n    (cond ((null? arr) max-so-far)\n          ((= (car arr) 0) (loop (cdr arr)\n                                 1\n                                 1\n                                 (max max-so-far 0)))\n          (else (let ((new-max-product (* max-product (car arr)))\n                       (new-min-product (* min-product (car arr))))\n                  (loop (cdr arr)\n                        (max new-max-product (car arr))\n                        (min new-min-product (car arr))\n                        (max max-so-far (max new-max-product new-min-product))))))))\n",
    "  (let loop ([i 0] [j 0] [max-product 1] [min-product 1] [max-so-far 1])\n    (if (= i (length arr))\n        max-so-far\n        (let ([curr-product (if (&lt; 0 (list-ref arr i))\n                                (* (list-ref arr i) max-product)\n                                (* (list-ref arr i) min-product))])\n          (let ([max-product (if (&lt; 0 (list-ref arr i))\n                                 (max curr-product (list-ref arr i))\n                                 max-product)])\n            (let ([min-product (if (&lt; 0 (list-ref arr i))\n                                   min-product\n                                   (min curr-product (list-ref arr i)))])\n              (let ([max-so-far (max max-so-far curr-product)])\n                (loop (+ i 1) j max-product min-product max-so-far)))))))))\n</code>\n",
    "  (define (max_subarray_product_helper arr max_product min_product)\n    (cond [(empty? arr) max_product]\n          [else\n           (let* ([x (first arr)]\n                  [new_max_product (max (* x max_product) (* x min_product) x)]\n                  [new_min_product (min (* x max_product) (* x min_product) x)])\n             (max_subarray_product_helper (rest arr) new_max_product new_min_product))]))\n  (max_subarray_product_helper arr 1 0))\n",
    "  (define (max_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond\n      [(null? arr) max_product]\n      [else\n       (let ([x (car arr)]\n             [max_product_ending_here_new (max x (* x max_product_ending_here) (* x min_product_ending_here))]\n             [min_product_ending_here_new (min x (* x max_product_ending_here) (* x min_product_ending_here))]\n             [max_product_new (max max_product max_product_ending_here_new)])\n         (max_product_helper (cdr arr) max_product_new max_product_ending_here_new min_product_ending_here_new))]))\n  (max_product_helper arr -1000000000 -1000000000 1000000000))\n",
    "  (let loop ((arr arr)\n             (max-product (first arr))\n             (min-product (first arr))\n             (max-so-far max-product))\n    (if (null? (cdr arr))\n        max-so-far\n        (let ((product (* (car arr) max-product))\n              (min-product-2 (* (car arr) min-product)))\n          (loop (cdr arr)\n                (max product min-product-2)\n                (min product min-product-2)\n                (max max-so-far (max product min-product-2)))))))\n",
    "  (let loop ((arr arr)\n             (max-product (car arr))\n             (min-product (car arr))\n             (max-so-far (car arr)))\n    (if (null? arr)\n        max-so-far\n        (let ((curr (car arr)))\n          (loop (cdr arr)\n                (max (* curr max-product)\n                     (* curr min-product)\n                     curr)\n                (min (* curr max-product)\n                     (* curr min-product)\n                     curr)\n                (max max-so-far (max (* curr max-product)\n                                     (* curr min-product)\n                                     curr)))))))\n",
    "  (define (max_subarray_product_helper arr max_product curr_product)\n    (cond\n      [(empty? arr) max_product]\n      [(zero? (first arr))\n       (max_subarray_product_helper (rest arr) max_product (first arr))]\n      [else\n       (let ([new_product (* curr_product (first arr))])\n         (max_subarray_product_helper (rest arr)\n                                      (max max_product new_product)\n                                      new_product))]))\n  (max_subarray_product_helper arr 0 1))\n",
    "  (let loop ((arr arr) (max-product 1) (min-product 1) (max-so-far 1))\n    (cond ((null? arr) max-so-far)\n          ((zero? (car arr))\n           (loop (cdr arr) 1 1 max-so-far))\n          (else\n           (let* ((product (* (car arr) max-product))\n                  (min-product (min (car arr) (* (car arr) min-product)))\n                  (max-product (max (car arr) product)))\n             (loop (cdr arr) max-product min-product (max max-so-far max-product)))))))\n",
    "  (define (max_subarray_product_helper arr max_product start end)\n    (cond\n      [(empty? arr) max_product]\n      [(negative? (car arr))\n       (max_subarray_product_helper (cdr arr) max_product (add1 start) (add1 end))]\n      [else\n       (let ([new_max_product (* max_product (car arr))])\n         (max_subarray_product_helper (cdr arr) new_max_product start (add1 end)))]))\n  (max_subarray_product_helper arr 1 0 0))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond\n      [(empty? arr) max_product]\n      [else\n       (define current_product (first arr))\n       (define new_max_product_ending_here\n         (cond\n           [(> current_product (* current_product max_product_ending_here)) current_product]\n           [(> current_product (* current_product min_product_ending_here)) current_product]\n           [else (* current_product max_product_ending_here)]))\n       (define new_min_product_ending_here\n         (cond\n           [(< current_product (* current_product max_product_ending_here)) current_product]\n           [(< current_product (* current_product min_product_ending_here)) current_product]\n           [else (* current_product min_product_ending_here)]))\n       (define new_max_product\n         (cond\n           [(> new_max_product_ending_here max_product) new_max_product_ending_here]\n           [else max_product]))\n       (max_subarray_product_helper (rest arr) new_max_product new_max_product_ending_here new_min_product_ending_here)]))\n  (max_subarray_product_helper arr (first arr) (first arr) (first arr)))\n",
    "  (define (max_subarray_product_helper arr max_ending_here min_ending_here max_so_far)\n    (cond [(null? arr) max_so_far]\n          [else\n           (let ([curr (car arr)])\n             (let ([max_ending_here (max curr (* max_ending_here curr) (* min_ending_here curr))])\n               (let ([min_ending_here (min curr (* max_ending_here curr) (* min_ending_here curr))])\n                 (let ([max_so_far (max max_so_far max_ending_here)])\n                   (max_subarray_product_helper (cdr arr) max_ending_here min_ending_here max_so_far))))))]))\n  (max_subarray_product_helper arr 1 1 1))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond\n      [(empty? arr) max_product]\n      [else\n       (define curr_product (first arr))\n       (define max_product_ending_here (max curr_product (* curr_product max_product_ending_here)))\n       (define min_product_ending_here (min curr_product (* curr_product min_product_ending_here)))\n       (define max_product (max max_product max_product_ending_here))\n       (max_subarray_product_helper (rest arr) max_product max_product_ending_here min_product_ending_here)]))\n  (max_subarray_product_helper arr -inf.0 -1.0 1.0))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond\n      [(empty? arr) max_product]\n      [else\n       (let ([first (first arr)])\n         (cond\n           [(zero? first)\n            (max_subarray_product_helper (rest arr) max_product 0 first)]\n           [else\n            (let ([max_product_ending_here_new (max (* first max_product_ending_here) (* first min_product_ending_here) first)]\n                  [min_product_ending_here_new (min (* first max_product_ending_here) (* first min_product_ending_here) first)]\n                  [max_product_new (max max_product max_product_ending_here_new)])\n              (max_subarray_product_helper (rest arr) max_product_new max_product_ending_here_new min_product_ending_here_new))]))]))\n  (max_subarray_product_helper arr -inf.0 -1.0 1.0))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond [(empty? arr) max_product]\n          [(zero? (car arr))\n           (max_subarray_product_helper (cdr arr)\n                                        (max max_product (car arr))\n                                        0\n                                        0)]\n          [else\n           (let ([max_product_ending_here_new (max (car arr) (* (car arr) max_product_ending_here))]\n                 [min_product_ending_here_new (min (car arr) (* (car arr) min_product_ending_here))])\n             (max_subarray_product_helper (cdr arr)\n                                          (max max_product max_product_ending_here_new)\n                                          max_product_ending_here_new\n                                          min_product_ending_here_new))]))\n  (max_subarray_product_helper arr 0 0 0))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond\n      [(empty? arr) max_product]\n      [else\n       (let ([cur_num (first arr)])\n         (let ([max_product_ending_here_new (max cur_num (* cur_num max_product_ending_here) (* cur_num min_product_ending_here))])\n           (let ([min_product_ending_here_new (min cur_num (* cur_num max_product_ending_here) (* cur_num min_product_ending_here))])\n             (let ([max_product_new (max max_product max_product_ending_here_new)])\n               (max_subarray_product_helper (rest arr) max_product_new max_product_ending_here_new min_product_ending_here_new))))))]))\n  (max_subarray_product_helper arr -inf.0 -inf.0 inf.0))\n",
    "  (define (helper arr max_product curr_product)\n    (cond\n      [(empty? arr) max_product]\n      [(negative? (first arr))\n       (helper (rest arr)\n               (max max_product curr_product)\n               (if (zero? (first arr)) 1 (first arr)))\n       ]\n      [else\n       (helper (rest arr)\n               (max max_product curr_product)\n               (* curr_product (first arr)))]))\n  (helper arr 0 1))\n",
    "  (define (helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond\n      [(empty? arr) max_product]\n      [else\n       (let ([x (first arr)])\n         (let ([max_product_ending_here_new (max (* x max_product_ending_here) (* x min_product_ending_here) x)])\n           (let ([min_product_ending_here_new (min (* x max_product_ending_here) (* x min_product_ending_here) x)])\n             (helper (rest arr) (max max_product max_product_ending_here_new) max_product_ending_here_new min_product_ending_here_new))))]))\n  (helper arr -inf.0 -inf.0 inf.0))\n",
    "  (define (max_subarray_product-iter arr max-product max-product-ending-here min-product-ending-here)\n    (if (null? arr)\n        max-product\n        (let ([curr (car arr)])\n          (let ([max-product-ending-here-new (max curr (* max-product-ending-here curr) (* min-product-ending-here curr))])\n            (let ([min-product-ending-here-new (min curr (* max-product-ending-here curr) (* min-product-ending-here curr))])\n              (max_subarray_product-iter (cdr arr) (max max-product max-product-ending-here-new) max-product-ending-here-new min-product-ending-here-new))))))\n  (max_subarray_product-iter arr -inf.0 -inf.0 inf.0))\n",
    "  (define (max_product_ending_here max_ending_here min_ending_here a)\n    (cond\n      [(= 0 a) (values max_ending_here min_ending_here)]\n      [(< 0 a)\n       (let ([max_ending_here (* max_ending_here a)]\n             [min_ending_here (* min_ending_here a)])\n         (if (< min_ending_here 0)\n             (values max_ending_here a)\n             (values max_ending_here min_ending_here)))]\n      [else\n       (let ([max_ending_here (* max_ending_here a)]\n             [min_ending_here (* min_ending_here a)])\n         (if (< max_ending_here 0)\n             (values a min_ending_here)\n             (values max_ending_here min_ending_here)))]))\n  (define (max_product_so_far max_ending_here min_ending_here a)\n    (let ([max_ending_here (max max_ending_here a)]\n          [min_ending_here (min min_ending_here a)])\n      (values max_ending_here min_ending_here)))\n  (let loop ([arr arr]\n             [max_ending_here 1]\n             [min_ending_here 1])\n    (if (null? arr)\n        max_ending_here\n        (let-values ([(max_ending_here min_ending_here)\n                      (max_product_ending_here max_ending_here min_ending_here (car arr))]\n                     [(max_ending_here min_ending_here)\n                      (max_product_so_far max_ending_here min_ending_here (car arr))])\n          (loop (cdr arr) max_ending_here min_ending_here)))))\n",
    "  (define (helper arr max_product curr_product)\n    (cond\n      [(empty? arr) max_product]\n      [(zero? (car arr))\n       (helper (cdr arr) max_product 0)]\n      [else\n       (let ([new_product (* curr_product (car arr))])\n         (helper (cdr arr) (max max_product new_product) new_product))]))\n  (helper arr 0 1))\n",
    "  (let loop ((arr arr)\n             (max-product (car arr))\n             (min-product (car arr))\n             (max-so-far max-product))\n    (cond ((null? arr) max-so-far)\n          ((= (car arr) 0) (loop (cdr arr) 1 1 max-so-far))\n          (else\n           (let* ((max-product (* max-product (car arr)))\n                  (min-product (* min-product (car arr)))\n                  (max-so-far (max max-so-far max-product))\n                  (max-product (max max-product min-product))\n                  (min-product (min max-product min-product)))\n             (loop (cdr arr) max-product min-product max-so-far))))))\n",
    "  (define (max_product_ending_here max_ending_here min_ending_here a)\n    (cond [(zero? a) max_ending_here]\n          [else\n           (let* ([max_ending_here_new (max (* max_ending_here a) (* min_ending_here a) a)]\n                  [min_ending_here_new (min (* max_ending_here a) (* min_ending_here a) a)])\n             (max_product_ending_here max_ending_here_new min_ending_here_new (rest arr)))]))\n  (max_product_ending_here (first arr) (first arr) (rest arr)))\n",
    "  (let loop ((arr arr)\n             (max-product (car arr))\n             (min-product (car arr))\n             (max-so-far (car arr)))\n    (if (null? arr)\n        max-so-far\n        (let ((curr-product (* (car arr) max-product))\n              (curr-min-product (* (car arr) min-product)))\n          (loop (cdr arr)\n                (max curr-product curr-min-product (car arr))\n                (min curr-product curr-min-product (car arr))\n                (max max-so-far (max curr-product curr-min-product (car arr))))))))\n",
    "  (define (max_product_helper arr max_product min_product)\n    (cond\n      [(empty? arr) max_product]\n      [else\n       (let ([x (first arr)])\n         (max_product_helper (rest arr)\n                             (max max_product (* x max_product))\n                             (min min_product (* x min_product))))]))\n  (max_product_helper arr (first arr) (first arr)))\n",
    "  (define (max_subarray_product_helper arr max_so_far max_ending_here min_ending_here)\n    (cond\n      [(empty? arr) max_so_far]\n      [else\n       (define curr (first arr))\n       (define max_ending_here (max (max (* curr max_ending_here) (* curr min_ending_here)) curr))\n       (define min_ending_here (min (min (* curr max_ending_here) (* curr min_ending_here)) curr))\n       (define max_so_far (max max_so_far max_ending_here))\n       (max_subarray_product_helper (rest arr) max_so_far max_ending_here min_ending_here)]))\n  (max_subarray_product_helper arr -9999999999 0 1))\n",
    "  (let loop ([arr arr] [max-product 1] [min-product 1] [max-so-far 1])\n    (cond [(null? arr) max-so-far]\n          [else\n           (let ([x (car arr)]\n                 [xs (cdr arr)])\n             (cond [(zero? x)\n                    (loop xs 1 1 max-so-far)]\n                   [else\n                    (let ([new-max-product (max (* x max-product) (* x min-product) x)]\n                          [new-min-product (min (* x max-product) (* x min-product) x)]\n                          [new-max-so-far (max new-max-product max-so-far)])\n                      (loop xs new-max-product new-min-product new-max-so-far))]))])))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond [(empty? arr) max_product]\n          [else\n           (define curr (first arr))\n           (define max_product_ending_here_new (max (* curr max_product_ending_here) (* curr min_product_ending_here) curr))\n           (define min_product_ending_here_new (min (* curr max_product_ending_here) (* curr min_product_ending_here) curr))\n           (define max_product_new (max max_product max_product_ending_here_new))\n           (max_subarray_product_helper (rest arr) max_product_new max_product_ending_here_new min_product_ending_here_new)]))\n  (max_subarray_product_helper arr -1000000000 -1000000000 1000000000))\n",
    "  (define (max_subarray_product_helper arr max_product start_index end_index)\n    (if (null? arr)\n        (list max_product start_index end_index)\n        (let* ([curr_product (apply * arr)]\n               [new_max_product (if (&gt; curr_product max_product)\n                                    curr_product\n                                    max_product)])\n          (max_subarray_product_helper (cdr arr)\n                                       new_max_product\n                                       start_index\n                                       (+ end_index 1)))))\n  (max_subarray_product_helper arr 1 0 0))\n",
    "  (let loop ((arr arr) (max-product 1) (min-product 1) (max-so-far 1))\n    (cond ((null? arr) max-so-far)\n          ((= (car arr) 0)\n           (loop (cdr arr) 1 1 (max max-so-far 0)))\n          (else\n           (let ((max-product (* max-product (car arr)))\n                 (min-product (* min-product (car arr))))\n             (loop (cdr arr)\n                   (max max-product min-product)\n                   (min max-product min-product)\n                   (max max-so-far max-product)))))))\n",
    "  (define (max_subarray_product_helper arr pos max_product)\n    (if (null? arr)\n        max_product\n        (let ([cur_product (apply * arr)])\n          (if (&gt; cur_product max_product)\n              (max_subarray_product_helper (cdr arr) (+ pos 1) cur_product)\n              (max_subarray_product_helper (cdr arr) (+ pos 1) max_product)))))\n  (max_subarray_product_helper arr 0 0))\n",
    "  (define (max_subarray_product_helper arr max_product)\n    (if (null? arr)\n        max_product\n        (let ((max_product_here (max (apply * arr) (apply * (reverse arr)))))\n          (max_subarray_product_helper (cdr arr) (max max_product max_product_here)))))\n  (max_subarray_product_helper arr (apply * arr)))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (if (null? arr)\n        max_product\n        (let* ([first (car arr)]\n               [max_product_ending_here_new (max first (* max_product_ending_here first) (* min_product_ending_here first))]\n               [min_product_ending_here_new (min first (* max_product_ending_here first) (* min_product_ending_here first))]\n               [max_product_new (max max_product max_product_ending_here_new)])\n          (max_subarray_product_helper (cdr arr) max_product_new max_product_ending_here_new min_product_ending_here_new))))\n  (max_subarray_product_helper arr -1000000000 -1000000000 1000000000))\n",
    "  (define (max_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond\n      [(empty? arr) max_product]\n      [else\n       (define curr_product (first arr))\n       (define max_product_ending_here (max curr_product (* curr_product max_product_ending_here) (* curr_product min_product_ending_here)))\n       (define min_product_ending_here (min curr_product (* curr_product max_product_ending_here) (* curr_product min_product_ending_here)))\n       (define max_product (max max_product max_product_ending_here))\n       (max_product_helper (rest arr) max_product max_product_ending_here min_product_ending_here)]))\n  (max_product_helper arr -inf.0 -inf.0 inf.0))\n",
    "  (define (max_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond\n      [(empty? arr) max_product]\n      [else\n       (let ([curr (first arr)])\n         (cond\n           [(= curr 0)\n            (max_product_helper (rest arr)\n                                (max max_product 0)\n                                0\n                                0)]\n           [else\n            (let ([max_product_ending_here_new (* max_product_ending_here curr)])\n              (let ([min_product_ending_here_new (* min_product_ending_here curr)])\n                (let ([max_product_ending_here_new_2 (max curr max_product_ending_here_new)])\n                  (let ([min_product_ending_here_new_2 (min curr min_product_ending_here_new)])\n                    (max_product_helper (rest arr)\n                                        (max max_product max_product_ending_here_new_2)\n                                        max_product_ending_here_new_2\n                                        min_product_ending_here_new_2))))))])))\n  (max_product_helper arr -1000000000 0 0))\n",
    "  (define (max_subarray_product_helper arr max_ending_here min_ending_here max_so_far)\n    (cond\n      [(empty? arr) max_so_far]\n      [else\n       (define a (first arr))\n       (define max_ending_here (max (* a max_ending_here) (* a min_ending_here) a))\n       (define min_ending_here (min (* a max_ending_here) (* a min_ending_here) a))\n       (define max_so_far (max max_ending_here max_so_far))\n       (max_subarray_product_helper (rest arr) max_ending_here min_ending_here max_so_far)]))\n  (max_subarray_product_helper arr 1 1 -1000000))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond [(empty? arr) max_product]\n          [else\n           (define curr_product (* (first arr) max_product_ending_here))\n           (define min_product (* (first arr) min_product_ending_here))\n           (define max_product_ending_here (max (first arr) (max curr_product min_product)))\n           (define min_product_ending_here (min (first arr) (min curr_product min_product)))\n           (define max_product (max max_product max_product_ending_here))\n           (max_subarray_product_helper (rest arr) max_product max_product_ending_here min_product_ending_here)]))\n  (max_subarray_product_helper arr 0 0 0))\n",
    "  (define (helper arr max_so_far max_ending_here min_ending_here)\n    (cond [(empty? arr) max_so_far]\n          [else\n           (define curr (first arr))\n           (define max_ending_here (max curr (* curr max_ending_here)))\n           (define min_ending_here (min curr (* curr min_ending_here)))\n           (define max_so_far (max max_so_far max_ending_here))\n           (helper (rest arr) max_so_far max_ending_here min_ending_here)]))\n  (helper arr -inf.0 -1.0 1.0))\n",
    "  (define (max_subarray_product_helper arr max_product_so_far max_product_ending_here min_product_ending_here)\n    (cond\n      [(empty? arr) max_product_so_far]\n      [else\n       (define curr_num (first arr))\n       (define max_product_ending_here_new (max (* curr_num max_product_ending_here) (* curr_num min_product_ending_here) curr_num))\n       (define min_product_ending_here_new (min (* curr_num max_product_ending_here) (* curr_num min_product_ending_here) curr_num))\n       (define max_product_so_far_new (max max_product_so_far max_product_ending_here_new))\n       (max_subarray_product_helper (rest arr) max_product_so_far_new max_product_ending_here_new min_product_ending_here_new)\n       ]))\n  (max_subarray_product_helper arr -inf.0 -inf.0 inf.0))\n",
    "  (define (max_subarray_product_helper arr start end)\n    (cond\n      [(= start end) 1]\n      [(= start (+ end 1)) (list-ref arr start)]\n      [else\n       (let ([mid (quotient (+ start end) 2)])\n         (let ([left-product (max_subarray_product_helper arr start mid)]\n               [right-product (max_subarray_product_helper arr (+ mid 1) end)])\n           (let ([left-max (apply max (map (lambda (i) (* left-product (list-ref arr i))) (range start mid)))])\n             (let ([right-max (apply max (map (lambda (i) (* right-product (list-ref arr i))) (range (+ mid 1) end)))])\n               (let ([mid-max (apply max (map (lambda (i) (* (list-ref arr i) (list-ref arr (+ i 1)))) (range start (- end 1))))])\n                 (apply max (list left-max right-max mid-max)))))))))\n  (max_subarray_product_helper arr 0 (- (length arr) 1)))\n",
    "  (define (max_subarray_product_helper arr max_product curr_product)\n    (cond\n      [(null? arr) max_product]\n      [(< (car arr) 0)\n       (max_subarray_product_helper (cdr arr)\n                                    (max max_product curr_product)\n                                    (car arr))]\n      [else\n       (max_subarray_product_helper (cdr arr)\n                                    (max max_product curr_product)\n                                    (* curr_product (car arr)))]))\n  (max_subarray_product_helper arr 1 1))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond\n      [(empty? arr) max_product]\n      [else\n       (let ([curr (first arr)])\n         (cond\n           [(zero? curr)\n            (max_subarray_product_helper (rest arr) max_product 0 0)]\n           [(positive? curr)\n            (max_subarray_product_helper (rest arr)\n                                         (max max_product\n                                              (* max_product_ending_here curr))\n                                         (* max_product_ending_here curr)\n                                         (min min_product_ending_here curr))]\n           [else\n            (max_subarray_product_helper (rest arr)\n                                         (max max_product\n                                              (* min_product_ending_here curr))\n                                         (max (* min_product_ending_here curr) 1)\n                                         (* min_product_ending_here curr))]))]))\n  (max_subarray_product_helper arr -1/0 1/0 1/0))\n",
    "  (define (max_product_ending_here product ending_here)\n    (if (null? arr)\n        (list product ending_here)\n        (let ((next (car arr)))\n          (if (zero? next)\n              (max_product_ending_here (max product ending_here) 0)\n              (max_product_ending_here (max product ending_here) (* next ending_here))))))\n  (max_product_ending_here 0 1))\n",
    "  (define (max_subarray_product_helper arr max_product curr_product)\n    (cond\n      [(empty? arr) max_product]\n      [(negative? (car arr))\n       (max_subarray_product_helper (cdr arr) max_product (car arr))]\n      [(positive? (car arr))\n       (max_subarray_product_helper (cdr arr)\n                                    (max max_product (* curr_product (car arr)))\n                                    (* curr_product (car arr)))]))\n  (max_subarray_product_helper arr 1 1))\n",
    "  (define (helper arr max_so_far max_ending_here min_ending_here)\n    (cond\n      [(empty? arr) max_so_far]\n      [else\n       (define curr (first arr))\n       (define max_ending_here (max (max (* curr max_ending_here) (* curr min_ending_here)) curr))\n       (define min_ending_here (min (min (* curr max_ending_here) (* curr min_ending_here)) curr))\n       (define max_so_far (max max_so_far max_ending_here))\n       (helper (rest arr) max_so_far max_ending_here min_ending_here)]))\n  (helper arr -1000000000 -1000000000 1000000000))\n",
    "  (define (max_subarray_product_helper arr max_product_so_far max_product_ending_here min_product_ending_here)\n    (if (null? arr)\n        max_product_so_far\n        (let ([x (car arr)])\n          (let ([max_product_ending_here (max x (* max_product_ending_here x) (* min_product_ending_here x))]\n                [min_product_ending_here (min x (* max_product_ending_here x) (* min_product_ending_here x))])\n            (max_subarray_product_helper (cdr arr)\n                                         (max max_product_so_far max_product_ending_here)\n                                         max_product_ending_here\n                                         min_product_ending_here)))))\n  (max_subarray_product_helper arr (car arr) (car arr) (car arr)))\n",
    "  (let loop ((arr arr)\n             (max-product (car arr))\n             (min-product (car arr))\n             (max-so-far max-product))\n    (if (null? (cdr arr))\n        max-so-far\n        (let ((curr-product (* (car arr) max-product))\n              (curr-min-product (* (car arr) min-product)))\n          (loop (cdr arr)\n                (if (&lt; curr-product curr-min-product)\n                    curr-min-product\n                    (if (&lt; curr-product max-product)\n                        max-product\n                        curr-product))\n                (if (&lt; curr-product curr-min-product)\n                    curr-product\n                    (if (&lt; curr-min-product min-product)\n                        min-product\n                        curr-min-product))\n                (if (&lt; max-so-far curr-product)\n                    curr-product\n                    max-so-far))))))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond\n      [(empty? arr) max_product]\n      [else\n       (let ([x (first arr)])\n         (cond\n           [(zero? x) (max_subarray_product_helper (rest arr) max_product 0 0)]\n           [else\n            (let ([max_product_ending_here_new (max x (* x max_product_ending_here))]\n                  [min_product_ending_here_new (min x (* x min_product_ending_here))])\n              (max_subarray_product_helper (rest arr)\n                                           (max max_product max_product_ending_here_new)\n                                           max_product_ending_here_new\n                                           min_product_ending_here_new))]))]))\n  (max_subarray_product_helper arr -inf.0 1.0 1.0))\n",
    "  (let loop ((arr arr) (max-product 1) (min-product 1) (max-so-far 1))\n    (if (null? arr)\n        max-so-far\n        (let* ((cur-num (car arr))\n               (cur-max-product (* cur-num max-product))\n               (cur-min-product (* cur-num min-product))\n               (cur-max-so-far (max cur-num\n                                    (max cur-max-product cur-min-product))))\n          (loop (cdr arr)\n                (max cur-max-product cur-min-product)\n                (min cur-max-product cur-min-product)\n                (max cur-max-so-far max-so-far))))))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond\n      [(empty? arr) max_product]\n      [else\n       (let ([x (first arr)])\n         (let ([max_product_ending_here_new (max (max x (* x max_product_ending_here)) (* x min_product_ending_here))])\n           (let ([min_product_ending_here_new (min (min x (* x max_product_ending_here)) (* x min_product_ending_here))])\n             (let ([max_product_new (max max_product max_product_ending_here_new)])\n               (max_subarray_product_helper (rest arr) max_product_new max_product_ending_here_new min_product_ending_here_new))))))]))\n  (max_subarray_product_helper arr -1000000000 -1000000000 1000000000))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond [(empty? arr) max_product]\n          [else\n           (define curr_product (* (first arr) max_product_ending_here))\n           (define new_max_product_ending_here (max (first arr) curr_product))\n           (define new_min_product_ending_here (min (first arr) curr_product))\n           (define new_max_product (max max_product new_max_product_ending_here))\n           (max_subarray_product_helper (rest arr) new_max_product new_max_product_ending_here new_min_product_ending_here)]))\n  (max_subarray_product_helper arr 0 0 0))\n",
    "  (define (max_subarray_product_helper arr max_product_so_far max_product_ending_here min_product_ending_here)\n    (if (null? arr)\n        max_product_so_far\n        (let ([curr (car arr)])\n          (let ([max_product_ending_here (max curr (* curr max_product_ending_here) (* curr min_product_ending_here))])\n            (let ([min_product_ending_here (min curr (* curr max_product_ending_here) (* curr min_product_ending_here))])\n              (let ([max_product_so_far (max max_product_so_far max_product_ending_here)])\n                (max_subarray_product_helper (cdr arr) max_product_so_far max_product_ending_here min_product_ending_here)))))))\n  (max_subarray_product_helper arr -999999999 -999999999 -999999999))\n",
    "  (let loop ((arr arr)\n             (max-product (car arr))\n             (min-product (car arr))\n             (max-so-far (car arr)))\n    (if (null? (cdr arr))\n        max-so-far\n        (let ((curr-product (* max-product (car (cdr arr))))\n              (curr-min-product (* min-product (car (cdr arr)))))\n          (loop (cdr arr)\n                (max curr-product curr-min-product (car (cdr arr)))\n                (min curr-product curr-min-product (car (cdr arr)))\n                (max max-so-far (max curr-product curr-min-product (car (cdr arr)))))))))\n</code>\n",
    "  (let loop ((i 0) (j 0) (max-product 1) (min-product 1) (max-subarray (list)))\n    (cond ((>= i (length arr)) max-subarray)\n          ((< j (length arr))\n           (let* ((a (list-ref arr i))\n                  (b (list-ref arr j))\n                  (product (* a b))\n                  (new-max-product (max product max-product))\n                  (new-min-product (min product min-product))\n                  (new-max-subarray (if (> new-max-product max-product)\n                                        (list i j)\n                                        max-subarray)))\n             (loop i (+ j 1) new-max-product new-min-product new-max-subarray)))\n          (else (loop (+ i 1) (+ i 2) max-product min-product max-subarray)))))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here)\n    (if (null? arr)\n        max_product\n        (let ([curr_product (* max_product_ending_here (car arr))])\n          (if (&lt; curr_product (car arr))\n              (max_subarray_product_helper (cdr arr)\n                                           (max max_product (car arr))\n                                           (car arr))\n              (max_subarray_product_helper (cdr arr)\n                                           (max max_product curr_product)\n                                           curr_product)))))\n  (max_subarray_product_helper arr -inf.0 -inf.0))\n",
    "  (define (max_subarray_product_helper arr max_product_so_far max_product_ending_here min_product_ending_here)\n    (if (null? arr)\n        max_product_so_far\n        (let ([curr (car arr)])\n          (let ([max_product_ending_here (max curr (* curr max_product_ending_here) (* curr min_product_ending_here))])\n            (let ([min_product_ending_here (min curr (* curr max_product_ending_here) (* curr min_product_ending_here))])\n              (let ([max_product_so_far (max max_product_so_far max_product_ending_here)])\n                (max_subarray_product_helper (cdr arr) max_product_so_far max_product_ending_here min_product_ending_here)))))))\n  (max_subarray_product_helper arr -1000000000 -1000000000 1000000000))\n",
    "  (define (max_subarray_product_helper arr max_so_far max_ending_here min_ending_here)\n    (if (null? arr)\n        max_so_far\n        (let ((curr (car arr)))\n          (let ((max_ending_here (max (* curr max_ending_here) (* curr min_ending_here) curr))\n                (min_ending_here (min (* curr max_ending_here) (* curr min_ending_here) curr)))\n            (max_subarray_product_helper (cdr arr) (max max_so_far max_ending_here) max_ending_here min_ending_here)))))\n  (max_subarray_product_helper arr -1000000000 -1000000000 1000000000))\n",
    "  (define (max_product_helper arr start end max_product)\n    (if (= start end)\n        max_product\n        (let ((product (* (list-ref arr start) (max_product_helper arr (+ start 1) end max_product))))\n          (if (&gt; product max_product)\n              product\n              max_product))))\n  (max_product_helper arr 0 (length arr) 0))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here)\n    (if (null? arr)\n        max_product\n        (let ([curr_num (car arr)])\n          (let ([max_product_ending_here (* max_product_ending_here curr_num)])\n            (if (&lt; max_product_ending_here curr_num)\n                (max_subarray_product_helper (cdr arr) max_product curr_num)\n                (max_subarray_product_helper (cdr arr) max_product max_product_ending_here))))))\n  (max_subarray_product_helper arr 0 0))\n</code>\n",
    "  (define (max_product_ending_here arr)\n    (define (max_product_ending_here_helper arr max_ending_here min_ending_here)\n      (cond\n        [(empty? arr) max_ending_here]\n        [(= (first arr) 0) (max_product_ending_here_helper (rest arr) 0 0)]\n        [(> (first arr) 0)\n         (max_product_ending_here_helper (rest arr)\n                                         (* max_ending_here (first arr))\n                                         (* min_ending_here (first arr)))]\n        [else\n         (max_product_ending_here_helper (rest arr)\n                                         (* min_ending_here (first arr))\n                                         (* max_ending_here (first arr)))]))\n    (max_product_ending_here_helper arr 1 0))\n  (max_product_ending_here arr))\n",
    "  (let loop ((arr arr)\n             (max-product (car arr))\n             (min-product (car arr))\n             (max-so-far (car arr)))\n    (cond ((null? arr) max-so-far)\n          ((< (car arr) 0)\n           (let ((temp max-product))\n             (set! max-product (min-product (car arr)))\n             (set! min-product (temp (car arr)))))\n          (else (set! max-product (max-product (car arr)))\n                (set! min-product (min-product (car arr)))))\n    (set! max-so-far (max max-so-far max-product))\n    (loop (cdr arr) max-product min-product max-so-far)))\n",
    "  (let loop ((arr arr)\n             (max-product (car arr))\n             (min-product (car arr))\n             (max-so-far (car arr)))\n    (if (null? (cdr arr))\n        max-so-far\n        (let ((curr-product (* (car arr) max-product))\n              (curr-min-product (* (car arr) min-product)))\n          (loop (cdr arr)\n                (if (&gt; curr-product curr-min-product)\n                    curr-product\n                    curr-min-product)\n                (if (&lt; curr-product curr-min-product)\n                    curr-product\n                    curr-min-product)\n                (max max-so-far (car arr)))))))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond\n      [(empty? arr) max_product]\n      [else\n       (define curr (first arr))\n       (define max_product_ending_here_new (max (* curr max_product_ending_here) (* curr min_product_ending_here) curr))\n       (define min_product_ending_here_new (min (* curr max_product_ending_here) (* curr min_product_ending_here) curr))\n       (define max_product_new (max max_product max_product_ending_here_new))\n       (max_subarray_product_helper (rest arr) max_product_new max_product_ending_here_new min_product_ending_here_new)\n       ]))\n  (max_subarray_product_helper arr -1000000000 -1000000000 1000000000))\n",
    "  (define (max_subarray_product_helper arr max_product min_product max_product_so_far)\n    (cond\n      [(null? arr) max_product_so_far]\n      [else\n       (let ([x (car arr)])\n         (cond\n           [(= x 0)\n            (max_subarray_product_helper (cdr arr) 0 0 max_product_so_far)]\n           [else\n            (let ([new_max_product (* max_product x)]\n                  [new_min_product (* min_product x)])\n              (let ([new_max_product_so_far (max max_product_so_far new_max_product)])\n                (max_subarray_product_helper (cdr arr)\n                                             (max new_max_product new_min_product)\n                                             (min new_max_product new_min_product)\n                                             new_max_product_so_far))))]))]))\n  (max_subarray_product_helper arr 1 1 1))\n",
    "  (define (product lst)\n    (if (null? lst)\n        1\n        (* (car lst) (product (cdr lst)))))\n  (define (max_product lst)\n    (if (null? lst)\n        1\n        (max (product lst) (max_product (cdr lst)))))\n  (max_product arr))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond\n      [(empty? arr) max_product]\n      [else\n       (let ([curr (first arr)])\n         (cond\n           [(> curr 0)\n            (max_subarray_product_helper (rest arr)\n                                         (max max_product (* max_product_ending_here curr))\n                                         (* max_product_ending_here curr)\n                                         (min min_product_ending_here curr))]\n           [(< curr 0)\n            (max_subarray_product_helper (rest arr)\n                                         (max max_product (* min_product_ending_here curr))\n                                         (if (zero? min_product_ending_here)\n                                             curr\n                                             (* min_product_ending_here curr))\n                                         curr)]\n           [else\n            (max_subarray_product_helper (rest arr)\n                                         (max max_product curr)\n                                         curr\n                                         curr)]))))\n    (max_subarray_product_helper arr -inf.0 1.0 -inf.0))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond [(empty? arr) max_product]\n          [else\n           (let* ([x (first arr)]\n                  [max_product_ending_here (max x (* x max_product_ending_here))]\n                  [min_product_ending_here (min x (* x min_product_ending_here))]\n                  [max_product (max max_product max_product_ending_here)])\n             (max_subarray_product_helper (rest arr) max_product max_product_ending_here min_product_ending_here))]))\n  (max_subarray_product_helper arr -inf.0 1.0 1.0))\n",
    "  (let loop ((arr arr) (max-product 1) (min-product 1) (max-so-far 1))\n    (cond ((null? arr) max-so-far)\n          (else\n           (let ((curr-product (* (car arr) (max min-product max-product))))\n             (loop (cdr arr)\n                   (max curr-product (car arr))\n                   (min curr-product (car arr))\n                   (max max-so-far curr-product)))))))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (if (null? arr)\n        max_product\n        (let ([x (car arr)])\n          (let ([max_product_ending_here_new (max x (* x max_product_ending_here) (* x min_product_ending_here))])\n            (let ([min_product_ending_here_new (min x (* x max_product_ending_here) (* x min_product_ending_here))])\n              (let ([max_product_new (max max_product max_product_ending_here_new)])\n                (max_subarray_product_helper (cdr arr) max_product_new max_product_ending_here_new min_product_ending_here_new))))))))\n  (max_subarray_product_helper arr -inf.0 -inf.0 inf.0))\n",
    "  (define (max_subarray_product-helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond\n      [(empty? arr) max_product]\n      [else\n       (define curr (first arr))\n       (define max_product_ending_here_new (max (* curr max_product_ending_here) (* curr min_product_ending_here) curr))\n       (define min_product_ending_here_new (min (* curr max_product_ending_here) (* curr min_product_ending_here) curr))\n       (define max_product_new (max max_product max_product_ending_here_new))\n       (max_subarray_product-helper (rest arr) max_product_new max_product_ending_here_new min_product_ending_here_new)]))\n  (max_subarray_product-helper arr -inf.0 -inf.0 inf.0))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond\n      [(empty? arr) max_product]\n      [else\n       (define curr (first arr))\n       (define max_product_ending_here_new (max (* curr max_product_ending_here) (* curr min_product_ending_here) curr))\n       (define min_product_ending_here_new (min (* curr max_product_ending_here) (* curr min_product_ending_here) curr))\n       (define max_product_new (max max_product max_product_ending_here_new))\n       (max_subarray_product_helper (rest arr) max_product_new max_product_ending_here_new min_product_ending_here_new)]))\n  (max_subarray_product_helper arr -inf.0 -inf.0 inf.0))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond\n      [(empty? arr) max_product]\n      [else\n       (define curr (first arr))\n       (define max_product_ending_here_new (max (* curr max_product_ending_here) (* curr min_product_ending_here) curr))\n       (define min_product_ending_here_new (min (* curr max_product_ending_here) (* curr min_product_ending_here) curr))\n       (define max_product_new (max max_product max_product_ending_here_new))\n       (max_subarray_product_helper (rest arr) max_product_new max_product_ending_here_new min_product_ending_here_new)]))\n  (max_subarray_product_helper arr -inf.0 -inf.0 inf.0))\n",
    "  (define (max_prod_helper arr max_prod max_prod_ending_here min_prod_ending_here)\n    (cond\n      [(empty? arr) max_prod]\n      [else (let ([x (first arr)])\n              (cond\n                [(< x 0)\n                 (let ([temp (max max_prod_ending_here (* x min_prod_ending_here))])\n                   (max_prod_helper (rest arr)\n                                    (max max_prod temp)\n                                    (/ max_prod_ending_here min_prod_ending_here)\n                                    (* x min_prod_ending_here)))]\n                [else (max_prod_helper (rest arr)\n                                       (max max_prod max_prod_ending_here)\n                                       (* x max_prod_ending_here)\n                                       (min 1 (* x min_prod_ending_here)))]))]))\n  (max_prod_helper arr 0 1 1))\n",
    "  (define (max_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond\n      [(empty? arr) max_product]\n      [else\n       (define curr_product (first arr))\n       (define max_product_ending_here\n         (max (max curr_product (* curr_product max_product_ending_here))\n              (* curr_product min_product_ending_here)))\n       (define min_product_ending_here\n         (min (min curr_product (* curr_product max_product_ending_here))\n              (* curr_product min_product_ending_here)))\n       (define max_product (max max_product max_product_ending_here))\n       (max_product_helper (rest arr) max_product max_product_ending_here min_product_ending_here)]))\n  (max_product_helper arr -inf.0 -inf.0 inf.0))\n",
    "  (define (max_subarray_product_helper arr max_product_so_far max_product_ending_here min_product_ending_here)\n    (cond\n      [(empty? arr) max_product_so_far]\n      [else\n       (define curr_val (first arr))\n       (define max_product_ending_here_new (max (* curr_val max_product_ending_here) (* curr_val min_product_ending_here) curr_val))\n       (define min_product_ending_here_new (min (* curr_val max_product_ending_here) (* curr_val min_product_ending_here) curr_val))\n       (define max_product_so_far_new (max max_product_so_far max_product_ending_here_new))\n       (max_subarray_product_helper (rest arr) max_product_so_far_new max_product_ending_here_new min_product_ending_here_new)\n       ]\n      )\n    )\n  (max_subarray_product_helper arr -inf.0 -inf.0 inf.0)\n  )\n",
    "  (define (max_subarray_product_helper arr max_product_so_far max_product_ending_here min_product_ending_here)\n    (cond\n      [(empty? arr) max_product_so_far]\n      [else\n       (define curr (first arr))\n       (define max_product_ending_here_new (max (* curr max_product_ending_here) (* curr min_product_ending_here) curr))\n       (define min_product_ending_here_new (min (* curr max_product_ending_here) (* curr min_product_ending_here) curr))\n       (define max_product_so_far_new (max max_product_so_far max_product_ending_here_new))\n       (max_subarray_product_helper (rest arr) max_product_so_far_new max_product_ending_here_new min_product_ending_here_new)\n       ]\n      )\n    )\n  (max_subarray_product_helper arr -inf.0 -inf.0 inf.0)\n  )\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here)\n    (cond [(empty? arr) max_product]\n          [else\n           (let ([curr_num (first arr)])\n             (let ([max_product_ending_here\n                    (if (&lt; max_product_ending_here 0)\n                        curr_num\n                        (* max_product_ending_here curr_num))])\n               (let ([max_product (max max_product max_product_ending_here)])\n                 (max_subarray_product_helper (rest arr)\n                                              max_product\n                                              max_product_ending_here))))]))\n  (max_subarray_product_helper arr -inf.0 -inf.0))\n",
    "  (let loop ((arr arr) (max-product 1) (min-product 1) (max-so-far 1))\n    (cond ((null? arr) max-so-far)\n          ((= 0 (car arr)) (loop (cdr arr) 1 1 max-so-far))\n          (else\n           (let ((max-product (* max-product (car arr)))\n                 (min-product (* min-product (car arr))))\n             (loop (cdr arr)\n                   (max max-product min-product)\n                   (min max-product min-product)\n                   (max max-so-far (max max-product min-product))))))))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond\n      [(empty? arr) max_product]\n      [else\n       (define curr_product (* (first arr) max_product_ending_here))\n       (define new_max_product_ending_here (max (first arr) curr_product))\n       (define new_min_product_ending_here (min (first arr) curr_product))\n       (define new_max_product (max max_product new_max_product_ending_here))\n       (max_subarray_product_helper (rest arr) new_max_product new_max_product_ending_here new_min_product_ending_here)\n       ]))\n  (max_subarray_product_helper arr -1000000000 -1000000000 1000000000))\n",
    "  (define (max_subarray_product_helper arr max_so_far max_ending_here min_ending_here)\n    (cond ((null? arr) max_so_far)\n          ((= (car arr) 0) (max_subarray_product_helper (cdr arr) (max max_so_far 0) 0 0))\n          ((> (car arr) 0) (max_subarray_product_helper (cdr arr) max_so_far (* max_ending_here (car arr)) (* min_ending_here (car arr))))\n          ((< (car arr) 0) (max_subarray_product_helper (cdr arr) max_so_far (* max_ending_here (car arr)) (* min_ending_here (car arr))))))\n  (max_subarray_product_helper arr 0 0 0))\n",
    "  (let loop ((arr arr) (max-product (car arr)) (min-product (car arr)) (max-so-far max-product))\n    (if (null? (cdr arr))\n        max-so-far\n        (let* ((product (* (car arr) max-product))\n               (min-product (min (car arr) (min product min-product)))\n               (max-product (max (car arr) (max product max-product))))\n          (loop (cdr arr) max-product min-product (max max-so-far max-product))))))\n",
    "  (define (helper arr max_ending_here min_ending_here max_so_far)\n    (cond\n      [(empty? arr) max_so_far]\n      [else\n       (define a (first arr))\n       (define max_ending_here_new (max (* a max_ending_here) (* a min_ending_here) a))\n       (define min_ending_here_new (min (* a max_ending_here) (* a min_ending_here) a))\n       (define max_so_far_new (max max_so_far max_ending_here_new))\n       (helper (rest arr) max_ending_here_new min_ending_here_new max_so_far_new)]))\n  (helper arr 1 1 1))\n",
    "  (define (max-product-helper arr max-product min-product)\n    (if (null? arr)\n        max-product\n        (let* ([val (car arr)]\n               [max-product (max (* val max-product) (* val min-product) val)]\n               [min-product (min (* val max-product) (* val min-product) val)])\n          (max-product-helper (cdr arr) max-product min-product))))\n  (max-product-helper arr 1 -1))\n</code>\n",
    "  (define (max_subarray_product_helper arr current-max current-min current-product)\n    (cond\n      [(empty? arr) current-product]\n      [else\n       (let ([first (first arr)])\n         (let ([new-max (max current-max first)]\n               [new-min (min current-min first)]\n               [new-product (* current-product first)])\n           (max_subarray_product_helper (rest arr) new-max new-min new-product)))]))\n  (max_subarray_product_helper arr (first arr) (first arr) (first arr)))\n",
    "  (define (max_product_ending_here arr)\n    (define (iter arr max_ending_here min_ending_here max_so_far)\n      (cond [(empty? arr) max_so_far]\n            [else\n             (let ([x (first arr)])\n               (cond [(< x 0)\n                      (iter (rest arr)\n                            (min_ending_here x)\n                            (max_ending_here x)\n                            (max max_so_far (max_ending_here x)))]\n                     [(> x 0)\n                      (iter (rest arr)\n                            (max_ending_here (* max_ending_here x))\n                            (min_ending_here (* min_ending_here x))\n                            (max max_so_far (max_ending_here x)))]\n                     [else\n                      (iter (rest arr)\n                            x\n                            x\n                            (max max_so_far x))]))]))\n    (iter arr 1 1 1))\n  (max_product_ending_here arr))\n",
    "  (define (max_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond [(null? arr) max_product]\n          [else\n           (define curr_product (* (car arr) max_product_ending_here))\n           (define new_max_product_ending_here\n             (cond [(> curr_product (car arr)) curr_product]\n                   [else (car arr)]))\n           (define new_min_product_ending_here\n             (cond [(< curr_product (car arr)) curr_product]\n                   [else (car arr)]))\n           (define new_max_product\n             (cond [(> new_max_product_ending_here max_product) new_max_product_ending_here]\n                   [else max_product]))\n           (max_product_helper (cdr arr) new_max_product new_max_product_ending_here new_min_product_ending_here)]))\n  (max_product_helper arr 0 0 0))\n",
    "  (let loop ((arr arr)\n             (max-product (car arr))\n             (min-product (car arr))\n             (max-so-far (car arr)))\n    (if (null? (cdr arr))\n        max-so-far\n        (let ((curr (car (cdr arr))))\n          (let ((max-product (max (* curr max-product)\n                                  (* curr min-product)\n                                  curr)))\n            (let ((min-product (min (* curr max-product)\n                                    (* curr min-product)\n                                    curr)))\n              (let ((max-so-far (max max-product max-so-far)))\n                (loop (cdr arr) max-product min-product max-so-far))))))))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond\n      [(null? arr) max_product]\n      [else\n       (let ([num (car arr)])\n         (let ([max_product_ending_here (max num (* num max_product_ending_here) (* num min_product_ending_here))]\n               [min_product_ending_here (min num (* num max_product_ending_here) (* num min_product_ending_here))])\n           (max_subarray_product_helper (cdr arr) (max max_product max_product_ending_here) max_product_ending_here min_product_ending_here)))]))\n  (max_subarray_product_helper arr -999999999 -999999999 999999999))\n",
    "  (define (helper arr max_ending_here min_ending_here max_so_far)\n    (cond\n      [(empty? arr) max_so_far]\n      [else\n       (let* ([a (first arr)]\n              [max_ending_here (max a (* a max_ending_here))]\n              [min_ending_here (min a (* a min_ending_here))]\n              [max_so_far (max max_so_far max_ending_here)])\n         (helper (rest arr) max_ending_here min_ending_here max_so_far))]))\n  (helper arr 1 -1 -1))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (if (null? arr)\n        max_product\n        (let ([curr (car arr)])\n          (let ([max_product_ending_here (max curr (* max_product_ending_here curr) (* min_product_ending_here curr))])\n            (let ([min_product_ending_here (min curr (* max_product_ending_here curr) (* min_product_ending_here curr))])\n              (let ([max_product (max max_product max_product_ending_here)])\n                (max_subarray_product_helper (cdr arr) max_product max_product_ending_here min_product_ending_here))))))))\n  (max_subarray_product_helper arr (car arr) (car arr) (car arr)))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond\n      [(empty? arr) max_product]\n      [else\n       (let* ([first (first arr)]\n              [rest (rest arr)]\n              [max_product_ending_here_new (max first (* first max_product_ending_here) (* first min_product_ending_here))]\n              [min_product_ending_here_new (min first (* first max_product_ending_here) (* first min_product_ending_here))]\n              [max_product_new (max max_product max_product_ending_here_new)])\n         (max_subarray_product_helper rest max_product_new max_product_ending_here_new min_product_ending_here_new))]))\n  (max_subarray_product_helper arr -inf.0 -inf.0 inf.0))\n",
    "  (let loop ((arr arr) (max-product 1) (min-product 1) (max-so-far 1))\n    (cond ((null? arr) max-so-far)\n          ((zero? (car arr))\n           (loop (cdr arr) 1 1 max-so-far))\n          (else\n           (let* ((max-product (* max-product (car arr)))\n                  (min-product (* min-product (car arr)))\n                  (max-so-far (max max-so-far max-product min-product)))\n             (loop (cdr arr)\n                   (max max-product min-product)\n                   (min max-product min-product)\n                   max-so-far))))))\n",
    "  (define (max_subarray_product_helper arr max_product_so_far min_product_so_far max_product_ending_here min_product_ending_here)\n    (cond\n      [(empty? arr) max_product_so_far]\n      [else\n       (define curr (first arr))\n       (define max_product_ending_here_new (max (* curr max_product_ending_here) (* curr min_product_ending_here) curr))\n       (define min_product_ending_here_new (min (* curr max_product_ending_here) (* curr min_product_ending_here) curr))\n       (define max_product_so_far_new (max max_product_so_far max_product_ending_here_new))\n       (define min_product_so_far_new (min min_product_so_far min_product_ending_here_new))\n       (max_subarray_product_helper (rest arr) max_product_so_far_new min_product_so_far_new max_product_ending_here_new min_product_ending_here_new)]))\n  (max_subarray_product_helper arr -1000000000 1000000000 -1000000000 1000000000))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond\n      [(null? arr) max_product]\n      [else\n       (define curr (car arr))\n       (define max_product_ending_here_new (max (* curr max_product_ending_here) (* curr min_product_ending_here) curr))\n       (define min_product_ending_here_new (min (* curr max_product_ending_here) (* curr min_product_ending_here) curr))\n       (define max_product_new (max max_product max_product_ending_here_new))\n       (max_subarray_product_helper (cdr arr) max_product_new max_product_ending_here_new min_product_ending_here_new)\n       ]\n      )\n    )\n  (max_subarray_product_helper arr -1000000000 -1000000000 1000000000)\n  )\n",
    "  (define (helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond\n      [(empty? arr) max_product]\n      [else (define curr (first arr))\n            (define max_product_ending_here_new (max (* curr max_product_ending_here)\n                                                    (* curr min_product_ending_here)\n                                                    curr))\n            (define min_product_ending_here_new (min (* curr max_product_ending_here)\n                                                    (* curr min_product_ending_here)\n                                                    curr))\n            (define max_product_new (max max_product max_product_ending_here_new))\n            (helper (rest arr) max_product_new max_product_ending_here_new min_product_ending_here_new)])\n    )\n  (helper arr -1000000000 -1000000000 1000000000)\n  )\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond [(empty? arr) max_product]\n          [else\n           (define current (first arr))\n           (define max_product_ending_here_new (max (* current max_product_ending_here) (* current min_product_ending_here) current))\n           (define min_product_ending_here_new (min (* current max_product_ending_here) (* current min_product_ending_here) current))\n           (define max_product_new (max max_product max_product_ending_here_new))\n           (max_subarray_product_helper (rest arr) max_product_new max_product_ending_here_new min_product_ending_here_new)]))\n  (max_subarray_product_helper arr -inf.0 -inf.0 inf.0))\n",
    "  (define (helper arr max-so-far max-ending-here min-ending-here)\n    (if (null? arr)\n        max-so-far\n        (let* ([cur (car arr)]\n               [max-ending-here (max cur (* cur max-ending-here) (* cur min-ending-here))]\n               [min-ending-here (min cur (* cur max-ending-here) (* cur min-ending-here))]\n               [max-so-far (max max-so-far max-ending-here)])\n          (helper (cdr arr) max-so-far max-ending-here min-ending-here))))\n  (helper arr -1000000000 1000000000 -1000000000))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (if (null? arr)\n        max_product\n        (let* ([x (car arr)]\n               [max_product_ending_here_new (cond [(> x 0) (* max_product_ending_here x)]\n                                                  [(< x 0) (* min_product_ending_here x)]\n                                                  [else 1])]\n               [min_product_ending_here_new (cond [(> x 0) (* min_product_ending_here x)]\n                                                  [(< x 0) (* max_product_ending_here x)]\n                                                  [else 1])]\n               [max_product_new (max max_product max_product_ending_here_new)])\n          (max_subarray_product_helper (cdr arr) max_product_new max_product_ending_here_new min_product_ending_here_new))))\n  (max_subarray_product_helper arr 1 1 1))\n",
    "  (define (max_subarray_product_helper arr max_product min_product)\n    (cond\n      [(empty? arr) max_product]\n      [else\n       (let* ([first (first arr)]\n              [rest (rest arr)]\n              [new_max_product (max (* first max_product) (* first min_product) first)]\n              [new_min_product (min (* first max_product) (* first min_product) first)])\n         (max_subarray_product_helper rest new_max_product new_min_product))]))\n  (max_subarray_product_helper arr 1 -1))\n",
    "  (define (max_subarray_product_helper arr max_product_so_far current_product)\n    (cond\n      [(empty? arr) max_product_so_far]\n      [else\n       (let ([current_product (* current_product (first arr))])\n         (max_subarray_product_helper (rest arr)\n                                      (max max_product_so_far current_product)\n                                      (if (&lt; current_product 0) 1 current_product)))]))\n  (max_subarray_product_helper arr 1 1))\n</code>\n",
    "  (define (max_subarray_product_helper arr max_product)\n    (cond\n      [(null? arr) max_product]\n      [(< (car arr) 0)\n       (max_subarray_product_helper (cdr arr) max_product)]\n      [else\n       (max_subarray_product_helper (cdr arr) (* max_product (car arr)))]))\n  (max_subarray_product_helper arr 1))\n",
    "  (define (max_subarray_product_helper arr max_product curr_product)\n    (cond\n      [(empty? arr) max_product]\n      [(zero? (car arr))\n       (max_subarray_product_helper (cdr arr) max_product (car arr))]\n      [else\n       (max_subarray_product_helper (cdr arr)\n                                    (max max_product curr_product)\n                                    (* curr_product (car arr)))]))\n  (max_subarray_product_helper arr (car arr) (car arr)))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_here max_product_here_neg min_product_here)\n    (cond\n      [(empty? arr) max_product]\n      [else\n       (define curr (first arr))\n       (define rest (rest arr))\n       (define max_product_here_new (max (* curr max_product_here) (* curr min_product_here) curr))\n       (define min_product_here_new (min (* curr max_product_here) (* curr min_product_here) curr))\n       (define max_product_here_neg_new (min (* curr max_product_here_neg) (* curr min_product_here) curr))\n       (define max_product_new (max max_product max_product_here_new))\n       (max_subarray_product_helper rest max_product_new max_product_here_new max_product_here_neg_new min_product_here_new)]]))\n  (max_subarray_product_helper arr (first arr) (first arr) (first arr) (first arr)))\n",
    "  (define (max-product-helper arr max-product min-product)\n    (cond\n      [(empty? arr) max-product]\n      [else\n       (let* ([head (first arr)]\n              [tail (rest arr)]\n              [max-product-head (max (* head max-product) (* head min-product))]\n              [min-product-head (min (* head max-product) (* head min-product))]\n              [max-product-tail (max-product-helper tail max-product min-product)])\n         (max max-product-head max-product-tail))]))\n  (max-product-helper arr 1 -1))\n",
    "  (define (max_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond\n      [(empty? arr) max_product]\n      [else\n       (define first (first arr))\n       (define rest (rest arr))\n       (define max_product_ending_here_new (max (* first max_product_ending_here) (* first min_product_ending_here) first))\n       (define min_product_ending_here_new (min (* first max_product_ending_here) (* first min_product_ending_here) first))\n       (define max_product_new (max max_product max_product_ending_here_new))\n       (max_product_helper rest max_product_new max_product_ending_here_new min_product_ending_here_new)\n       ]))\n  (max_product_helper arr -1000000000 -1000000000 1000000000))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond\n      [(empty? arr) max_product]\n      [else\n       (define current (first arr))\n       (define max_product_ending_here_new (max (* current max_product_ending_here) (* current min_product_ending_here) current))\n       (define min_product_ending_here_new (min (* current max_product_ending_here) (* current min_product_ending_here) current))\n       (define max_product_new (max max_product max_product_ending_here_new))\n       (max_subarray_product_helper (rest arr) max_product_new max_product_ending_here_new min_product_ending_here_new)]])\n  (max_subarray_product_helper arr -inf.0 -inf.0 inf.0))\n",
    "  (define (max_subarray_product_helper arr max_product_so_far max_product_ending_here min_product_ending_here)\n    (cond\n      [(empty? arr) max_product_so_far]\n      [else\n       (define curr (first arr))\n       (define max_product_ending_here_new\n         (cond\n           [(> curr 0)\n            (max (* curr max_product_ending_here) curr)]\n           [(< curr 0)\n            (max (* curr min_product_ending_here) curr)]\n           [else\n            (max curr 0)]))\n       (define min_product_ending_here_new\n         (cond\n           [(> curr 0)\n            (min (* curr min_product_ending_here) curr)]\n           [(< curr 0)\n            (min (* curr max_product_ending_here) curr)]\n           [else\n            (min curr 0)]))\n       (define max_product_so_far_new\n         (max max_product_so_far max_product_ending_here_new))\n       (max_subarray_product_helper (rest arr) max_product_so_far_new max_product_ending_here_new min_product_ending_here_new)]))\n  (max_subarray_product_helper arr 0 0 0))\n",
    "  (define (max_subarray_product_helper arr max_product current_product)\n    (cond ((null? arr) max_product)\n          ((zero? (car arr))\n           (max_subarray_product_helper (cdr arr) max_product 0))\n          (else\n           (let ((new_product (* current_product (car arr))))\n             (max_subarray_product_helper (cdr arr)\n                                          (max max_product new_product)\n                                          new_product)))))\n  (max_subarray_product_helper arr 0 0))\n",
    "  (let loop ((arr arr)\n             (max-product 1)\n             (min-product 1)\n             (max-so-far 1))\n    (cond ((null? arr) max-so-far)\n          ((= (car arr) 0)\n           (loop (cdr arr)\n                 1\n                 1\n                 (max max-so-far 0)))\n          ((< (car arr) 0)\n           (let ((temp min-product))\n             (loop (cdr arr)\n                   (* max-product (car arr))\n                   (* temp (car arr))\n                   (max max-so-far (* max-product (car arr))))))\n          (else\n           (loop (cdr arr)\n                 (* max-product (car arr))\n                 min-product\n                 (max max-so-far (* max-product (car arr))))))))\n",
    "  (define (max_product_ending_here arr)\n    (define (helper arr max_ending_here min_ending_here max_so_far)\n      (cond ((null? arr) max_so_far)\n            ((= (car arr) 0) (helper (cdr arr) 0 0 max_so_far))\n            ((< (car arr) 0)\n             (let ((temp (max max_ending_here (car arr))))\n               (helper (cdr arr) temp (min min_ending_here (car arr)) max_so_far)))\n            (else\n             (let ((temp (max max_ending_here (* max_ending_here (car arr)))))\n               (helper (cdr arr) temp min_ending_here max_so_far)))))\n    (helper arr 1 0 0))\n  (max_product_ending_here arr))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond\n      [(empty? arr) max_product]\n      [else\n       (let ([curr (first arr)])\n         (cond\n           [(zero? curr)\n            (max_subarray_product_helper (rest arr) max_product 0 0)]\n           [else\n            (let ([max_product_ending_here_new (max (* curr max_product_ending_here) (* curr min_product_ending_here) curr)]\n                  [min_product_ending_here_new (min (* curr max_product_ending_here) (* curr min_product_ending_here) curr)]\n                  [max_product_new (max max_product max_product_ending_here_new)])\n              (max_subarray_product_helper (rest arr) max_product_new max_product_ending_here_new min_product_ending_here_new))]))]))\n  (max_subarray_product_helper arr -(+inf.0) 1 (+inf.0)))\n",
    "  (define (max_subarray_product_helper arr max_product current_product)\n    (cond [(empty? arr) max_product]\n          [else\n           (let ([current_product (if (= 0 (car arr))\n                                     1\n                                     (* current_product (car arr)))])\n             (max_subarray_product_helper (cdr arr)\n                                          (max max_product current_product)\n                                          current_product))]))\n  (max_subarray_product_helper arr 0 1))\n",
    "  (define (max_subarray_product_helper arr max_so_far max_ending_here min_ending_here)\n    (cond [(empty? arr) max_so_far]\n          [else\n           (define curr (first arr))\n           (define max_ending_here (max curr (* max_ending_here curr) (* min_ending_here curr)))\n           (define min_ending_here (min curr (* max_ending_here curr) (* min_ending_here curr)))\n           (define max_so_far (max max_so_far max_ending_here))\n           (max_subarray_product_helper (rest arr) max_so_far max_ending_here min_ending_here)]))\n  (max_subarray_product_helper arr (first arr) (first arr) (first arr)))\n",
    "  (define (max_subarray_product_helper arr start end max_product)\n    (cond\n      [(= start end) max_product]\n      [(> (car arr) 0)\n       (max_subarray_product_helper (cdr arr) (+ start 1) end (* max_product (car arr)))]\n      [(< (car arr) 0)\n       (max_subarray_product_helper (cdr arr) (+ start 1) end (max max_product (* max_product (car arr))))]\n      [else\n       (max_subarray_product_helper (cdr arr) (+ start 1) end max_product)]))\n  (max_subarray_product_helper arr 0 (length arr) 1))\n",
    "  (define (max_product_helper arr max_product_ending_here min_product_ending_here)\n    (if (null? arr)\n        max_product_ending_here\n        (let ((curr (car arr)))\n          (if (zero? curr)\n              (max_product_helper (cdr arr) max_product_ending_here min_product_ending_here)\n              (let ((max_product_ending_here_new (* max_product_ending_here curr))\n                    (min_product_ending_here_new (* min_product_ending_here curr)))\n                (max_product_helper (cdr arr)\n                                    (max max_product_ending_here_new min_product_ending_here_new)\n                                    (min min_product_ending_here_new max_product_ending_here_new)))))))\n  (max_product_helper arr 1 1))\n",
    "  (let loop ((arr arr)\n             (max-product (first arr))\n             (min-product (first arr))\n             (max-so-far max-product))\n    (cond ((null? arr) max-so-far)\n          ((= (first arr) 0)\n           (loop (rest arr)\n                 1\n                 1\n                 (max max-so-far 0)))\n          (else\n           (let ((product (* (first arr) max-product))\n                 (min-product-2 (* (first arr) min-product)))\n             (loop (rest arr)\n                   (max product min-product-2)\n                   (min product min-product-2)\n                   (max max-so-far (max product min-product-2))))))))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond\n      [(empty? arr) max_product]\n      [else\n       (define current_product (first arr))\n       (define max_product_ending_here_new (max current_product (* max_product_ending_here current_product) (* min_product_ending_here current_product)))\n       (define min_product_ending_here_new (min current_product (* max_product_ending_here current_product) (* min_product_ending_here current_product)))\n       (define max_product_new (max max_product max_product_ending_here_new))\n       (max_subarray_product_helper (rest arr) max_product_new max_product_ending_here_new min_product_ending_here_new)\n       ]))\n  (max_subarray_product_helper arr (first arr) (first arr) (first arr)))\n",
    "  (let loop ((arr arr)\n             (max_product (car arr))\n             (min_product (car arr))\n             (max_so_far max_product))\n    (if (null? (cdr arr))\n        max_so_far\n        (let ((curr (car (cdr arr))))\n          (let ((curr_max_product (* max_product curr))\n                (curr_min_product (* min_product curr)))\n            (let ((curr_max (max curr curr_max_product curr_min_product))\n                  (curr_min (min curr curr_max_product curr_min_product)))\n              (loop (cdr arr)\n                    curr_max\n                    curr_min\n                    (max max_so_far curr_max))))))))\n",
    "  (define (max_subarray_product_aux arr max_so_far max_ending_here min_ending_here)\n    (cond\n      [(empty? arr) max_so_far]\n      [else\n       (define curr (first arr))\n       (define max_ending_here (max curr (* curr max_ending_here) (* curr min_ending_here)))\n       (define min_ending_here (min curr (* curr max_ending_here) (* curr min_ending_here)))\n       (define max_so_far (max max_so_far max_ending_here))\n       (max_subarray_product_aux (rest arr) max_so_far max_ending_here min_ending_here)]))\n  (max_subarray_product_aux arr -inf.0 1.0 1.0))\n",
    "  (define (max_subarray_product_helper arr max_ending_here min_ending_here max_so_far)\n    (cond [(empty? arr) max_so_far]\n          [else\n           (define curr_max (max (first arr) (* (first arr) max_ending_here) (* (first arr) min_ending_here)))\n           (define curr_min (min (first arr) (* (first arr) max_ending_here) (* (first arr) min_ending_here)))\n           (define curr_max_so_far (max curr_max max_so_far))\n           (max_subarray_product_helper (rest arr) curr_max curr_min curr_max_so_far)]))\n  (max_subarray_product_helper arr 1 1 1))\n",
    "  (let loop ((arr arr) (max-product 1) (min-product 1) (max-so-far 1))\n    (cond ((null? arr) max-so-far)\n          ((= (car arr) 0) (loop (cdr arr) 1 1 (max max-so-far 0)))\n          (else\n           (let ((product (* (car arr) max-product))\n                 (min-product (* (car arr) min-product)))\n             (loop (cdr arr)\n                   (if (&lt; product min-product) min-product product)\n                   (if (&lt; product min-product) product min-product)\n                   (max max-so-far product)))))))\n",
    "  (define (max-product-helper arr max-product)\n    (cond [(empty? arr) max-product]\n          [(zero? (first arr)) (max-product-helper (rest arr) max-product)]\n          [else (max-product-helper (rest arr) (* (first arr) max-product))]))\n  (define (max-product-helper-2 arr max-product)\n    (cond [(empty? arr) max-product]\n          [(zero? (first arr)) (max-product-helper-2 (rest arr) max-product)]\n          [else (max-product-helper-2 (rest arr) (* (first arr) max-product))]))\n  (define (max-product-helper-3 arr max-product)\n    (cond [(empty? arr) max-product]\n          [(zero? (first arr)) (max-product-helper-3 (rest arr) max-product)]\n          [else (max-product-helper-3 (rest arr) (* (first arr) max-product))]))\n  (define (max-product-helper-4 arr max-product)\n    (cond [(empty? arr) max-product]\n          [(zero? (first arr)) (max-product-helper-4 (rest arr) max-product)]\n          [else (max-product-helper-4 (rest arr) (* (first arr) max-product))]))\n  (define (max-product-helper-5 arr max-product)\n    (cond [(empty? arr) max-product]\n          [(zero? (first arr)) (max-product-helper-5 (rest arr) max-product)]\n          [else (max-product-helper-5 (rest arr) (* (first arr) max-product))]))\n  (define (max-product-helper-6 arr max-product)\n    (cond [(empty? arr) max-product]\n          [(zero? (first arr)) (max-product-helper-6 (rest arr) max-product)]\n          [else (max-product-helper-6 (rest arr) (* (first arr) max-product))]))\n  (define (max-product",
    "  (let loop ((arr arr) (max-product 1) (min-product 1) (max-subarray '()))\n    (cond ((null? arr) max-subarray)\n          ((= (car arr) 0) (loop (cdr arr) 1 1 '()))\n          ((< (car arr) 0)\n           (let ((temp max-product))\n             (set! max-product (max min-product (* max-product (car arr))))\n             (set! min-product (min temp (* min-product (car arr))))\n             (loop (cdr arr) max-product min-product\n                   (if (> max-product max-subarray)\n                       (cons (car arr) '())\n                       max-subarray))))\n          (else\n           (set! max-product (* max-product (car arr)))\n           (set! min-product (min min-product (* min-product (car arr))))\n           (loop (cdr arr) max-product min-product\n                 (if (> max-product max-subarray)\n                     (cons (car arr) '())\n                     max-subarray)))))))\n",
    "  (define (max_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond [(empty? arr) max_product]\n          [else\n           (define curr_product (* (first arr) max_product_ending_here))\n           (define new_max_product_ending_here (max curr_product (first arr)))\n           (define new_min_product_ending_here (min curr_product (first arr)))\n           (define new_max_product (max max_product new_max_product_ending_here))\n           (max_product_helper (rest arr) new_max_product new_max_product_ending_here new_min_product_ending_here)]))\n  (max_product_helper arr 0 0 0))\n",
    "  (let loop ((arr arr)\n             (max-product (first arr))\n             (min-product (first arr))\n             (max-so-far max-product))\n    (cond ((null? arr) max-so-far)\n          ((= (first arr) 0)\n           (loop (rest arr)\n                 1\n                 1\n                 (max max-so-far 0)))\n          (else\n           (let* ((product (* (first arr) max-product))\n                  (min-product (min (first arr) (* (first arr) min-product))))\n             (loop (rest arr)\n                   (max product min-product)\n                   (min product min-product)\n                   (max max-so-far (max product min-product))))))))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (if (null? arr)\n        max_product\n        (let ([curr (car arr)])\n          (let ([max_product_ending_here (max curr (* curr max_product_ending_here) (* curr min_product_ending_here))])\n            (let ([min_product_ending_here (min curr (* curr max_product_ending_here) (* curr min_product_ending_here))])\n              (let ([max_product (max max_product max_product_ending_here)])\n                (max_subarray_product_helper (cdr arr) max_product max_product_ending_here min_product_ending_here))))))))\n  (max_subarray_product_helper arr -inf.0 -inf.0 inf.0))\n",
    "  (let loop ((arr arr) (max-product 1) (min-product 1) (max-product-so-far 1))\n    (cond ((null? arr) max-product-so-far)\n          ((= (car arr) 0) (loop (cdr arr) 1 1 max-product-so-far))\n          (else\n           (let ((max-product (* max-product (car arr)))\n                 (min-product (* min-product (car arr))))\n             (if (&lt; min-product 0)\n                 (set! min-product (min min-product max-product)))\n             (if (&gt; max-product max-product-so-far)\n                 (set! max-product-so-far max-product))\n             (loop (cdr arr) max-product min-product max-product-so-far))))))\n",
    "  (let loop ((arr arr)\n             (max-product (first arr))\n             (min-product (first arr))\n             (max-so-far max-product))\n    (if (null? (cdr arr))\n        max-so-far\n        (let* ((product (* max-product (car (cdr arr))))\n               (min-product (min min-product product))\n               (max-product (max max-product product))\n               (max-so-far (max max-so-far max-product)))\n          (loop (cdr arr) max-product min-product max-so-far)))))\n",
    "  (define (max_product_helper arr max_product min_product)\n    (if (null? arr)\n        max_product\n        (let ([curr_num (car arr)])\n          (let ([curr_product (* curr_num (or min_product 1))])\n            (let ([curr_min_product (min curr_product (or min_product 1))])\n              (let ([curr_max_product (max curr_product (or max_product 1))])\n                (max_product_helper (cdr arr) curr_max_product curr_min_product)))))))\n  (max_product_helper arr 0 0))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (if (null? arr)\n        max_product\n        (let ([x (car arr)])\n          (let ([max_product_ending_here_new (max (* x max_product_ending_here) (* x min_product_ending_here) x)])\n            (let ([min_product_ending_here_new (min (* x max_product_ending_here) (* x min_product_ending_here) x)])\n              (let ([max_product_new (max max_product max_product_ending_here_new)])\n                (max_subarray_product_helper (cdr arr) max_product_new max_product_ending_here_new min_product_ending_here_new))))))))\n  (max_subarray_product_helper arr -1000000000 -1000000000 1000000000))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond\n      [(empty? arr) max_product]\n      [else\n       (let* ([current (first arr)]\n              [max_product_ending_here_new (max current (* max_product_ending_here current) (* min_product_ending_here current))]\n              [min_product_ending_here_new (min current (* max_product_ending_here current) (* min_product_ending_here current))]\n              [max_product_new (max max_product max_product_ending_here_new)])\n         (max_subarray_product_helper (rest arr) max_product_new max_product_ending_here_new min_product_ending_here_new))]))\n  (max_subarray_product_helper arr -inf.0 -inf.0 inf.0))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond\n      [(null? arr) max_product]\n      [else\n       (let* ([curr (car arr)]\n              [max_product_ending_here_new (max curr (* max_product_ending_here curr) (* min_product_ending_here curr))]\n              [min_product_ending_here_new (min curr (* max_product_ending_here curr) (* min_product_ending_here curr))]\n              [max_product_new (max max_product max_product_ending_here_new)])\n         (max_subarray_product_helper (cdr arr) max_product_new max_product_ending_here_new min_product_ending_here_new))]))\n  (max_subarray_product_helper arr -9999999999 0 0))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond [(empty? arr) max_product]\n          [else\n           (define curr_product (* (first arr) max_product_ending_here))\n           (define new_max_product_ending_here (max (first arr) curr_product))\n           (define new_min_product_ending_here (min (first arr) curr_product))\n           (define new_max_product (max max_product new_max_product_ending_here))\n           (max_subarray_product_helper (rest arr) new_max_product new_max_product_ending_here new_min_product_ending_here)]))\n  (max_subarray_product_helper arr 1 1 1))\n",
    "  (define (max_product_ending_at i)\n    (let loop ([i i] [max_ending_here 1] [min_ending_here 1])\n      (if (zero? i)\n          max_ending_here\n          (let ([a (list-ref arr i)])\n            (if (&lt; a 0)\n                (loop (- i 1) (min_ending_here (* min_ending_here a)) (max_ending_here (* max_ending_here a)))\n                (loop (- i 1) (max_ending_here (* max_ending_here a)) (min_ending_here (* min_ending_here a))))))))\n  (let loop ([i (sub1 (length arr))] [max_so_far (max_product_ending_at i)])\n    (if (zero? i)\n        max_so_far\n        (loop (- i 1) (max max_so_far (max_product_ending_at i))))))\n",
    "  (define (max_product_helper arr start end)\n    (if (&lt; start end)\n        (let* ([subarr (sublist arr start end)]\n               [max-product (apply * subarr)])\n          (max max-product\n               (max_product_helper arr start (- end 1))\n               (max_product_helper arr (+ start 1) end)))\n        1))\n  (max_product_helper arr 0 (- (length arr) 1)))\n</code>\nThis is the solution I came up with. It works, but it's pretty slow. I'm looking for a more efficient solution.\n\n\nA:\n\nI think this is a pretty good solution.  I don't think you can do much better than this.  Here's a version that is a little more efficient, but not much:\n<code>(define (max-subarray-product arr)\n  (define (max-product-helper arr start end)\n    (if (&lt; start end)\n        (let* ([subarr (sublist arr start end)]\n               [max-product (apply * subarr)])\n          (max max-product\n               (max-product-helper arr start (- end 1))\n               (max-product-helper arr (+ start 1) end)))\n        1))\n  (max-product-helper arr 0 (- (length arr) 1)))\n</code>\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond\n      [(null? arr) max_product]\n      [(= (car arr) 0) (max_subarray_product_helper (cdr arr) max_product 0 0)]\n      [else\n       (let* ([product_ending_here (* max_product_ending_here (car arr))]\n              [new_max_product_ending_here (max (car arr) product_ending_here)]\n              [new_min_product_ending_here (min (car arr) product_ending_here)])\n         (max_subarray_product_helper (cdr arr)\n                                      (max max_product new_max_product_ending_here)\n                                      new_max_product_ending_here\n                                      new_min_product_ending_here))]))\n  (max_subarray_product_helper arr 0 0 0))\n",
    "  (define (max_subarray_product_helper arr max_product min_product)\n    (cond\n      [(empty? arr) max_product]\n      [else\n       (let ([curr_product (first arr)])\n         (if (&lt; curr_product 0)\n             (max_subarray_product_helper (rest arr)\n                                          (max max_product curr_product)\n                                          (min min_product curr_product))\n             (max_subarray_product_helper (rest arr)\n                                          (max max_product (* curr_product max_product))\n                                          (min min_product (* curr_product min_product)))))]))\n  (max_subarray_product_helper arr (first arr) (first arr)))\n",
    "  (define (helper arr max_so_far max_ending_here min_ending_here)\n    (cond [(empty? arr) max_so_far]\n          [else\n           (define curr (first arr))\n           (define max_ending_here (max (max curr (* curr max_ending_here)) (* curr min_ending_here)))\n           (define min_ending_here (min (min curr (* curr max_ending_here)) (* curr min_ending_here)))\n           (define max_so_far (max max_so_far max_ending_here))\n           (helper (rest arr) max_so_far max_ending_here min_ending_here)]))\n  (helper arr (first arr) (first arr) (first arr)))\n",
    "  (let loop ((arr arr)\n             (max-product (car arr))\n             (product (car arr)))\n    (cond ((null? arr) max-product)\n          ((< product 0)\n           (loop (cdr arr)\n                 (max max-product product)\n                 (car arr)))\n          (else\n           (loop (cdr arr)\n                 (max max-product product)\n                 (* product (car arr)))))))\n",
    "  (define (iter arr max_so_far max_ending_here min_ending_here)\n    (cond\n      [(empty? arr) max_so_far]\n      [else\n       (let ([curr (first arr)])\n         (iter (rest arr)\n               (max max_so_far\n                    (max max_ending_here\n                         (max min_ending_here\n                              curr)))\n               (max (max curr (* curr max_ending_here))\n                    (max curr (* curr min_ending_here)))\n               (min (min curr (* curr max_ending_here))\n                    (min curr (* curr min_ending_here)))))]))\n  (iter arr -1000000000 -1000000000 1000000000))\n",
    "  (define (max_subarray_product_helper arr max_product_so_far max_product_ending_here min_product_ending_here)\n    (cond\n      [(empty? arr) max_product_so_far]\n      [else\n       (let ([x (first arr)]\n             [new_max_product_ending_here (max (max (* x max_product_ending_here) (* x min_product_ending_here)) x)]\n             [new_min_product_ending_here (min (min (* x max_product_ending_here) (* x min_product_ending_here)) x)])\n         (max_subarray_product_helper (rest arr)\n                                      (max max_product_so_far new_max_product_ending_here)\n                                      new_max_product_ending_here\n                                      new_min_product_ending_here))]))\n  (max_subarray_product_helper arr -1000000000 -1000000000 1000000000))\n",
    "  (define (max_subarray_product_helper arr max_product start_index end_index)\n    (if (null? arr)\n        (list max_product start_index end_index)\n        (let ([curr_product (apply * arr)])\n          (if (&gt; curr_product max_product)\n              (max_subarray_product_helper (cdr arr) curr_product start_index (+ end_index 1))\n              (max_subarray_product_helper (cdr arr) max_product (+ start_index 1) (+ end_index 1))))))\n  (max_subarray_product_helper arr (apply * arr) 0 0))\n",
    "  (define (max_product_helper arr max_product curr_product)\n    (cond\n      [(empty? arr) max_product]\n      [(zero? (first arr)) (max_product_helper (rest arr) max_product 0)]\n      [else\n       (let ([new_product (* curr_product (first arr))])\n         (max_product_helper (rest arr)\n                             (max max_product new_product)\n                             new_product))]))\n  (max_product_helper arr 0 1))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond\n      [(empty? arr) max_product]\n      [else\n       (let ([curr (first arr)])\n         (let ([max_product_ending_here_new (max (* curr max_product_ending_here) (* curr min_product_ending_here) curr)])\n           (let ([min_product_ending_here_new (min (* curr max_product_ending_here) (* curr min_product_ending_here) curr)])\n             (let ([max_product_new (max max_product max_product_ending_here_new)])\n               (max_subarray_product_helper (rest arr) max_product_new max_product_ending_here_new min_product_ending_here_new))))))]))\n  (max_subarray_product_helper arr -inf.0 -inf.0 inf.0))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond\n      [(empty? arr) max_product]\n      [else\n       (define first (first arr))\n       (define rest (rest arr))\n       (define max_product_ending_here_new\n         (max (* first max_product_ending_here)\n              (* first min_product_ending_here)\n              first))\n       (define min_product_ending_here_new\n         (min (* first max_product_ending_here)\n              (* first min_product_ending_here)\n              first))\n       (define max_product_new\n         (max max_product_ending_here_new\n              max_product))\n       (max_subarray_product_helper rest max_product_new max_product_ending_here_new min_product_ending_here_new)])\n    )\n  (max_subarray_product_helper arr -inf.0 -inf.0 inf.0))\n",
    "  (let loop ((arr arr) (max-product 1) (min-product 1))\n    (cond\n      [(null? arr) max-product]\n      [(< (car arr) 0)\n       (let* ([max-product-so-far (max max-product min-product)]\n              [min-product-so-far (min max-product min-product)])\n         (loop (cdr arr) max-product-so-far min-product-so-far))]\n      [else\n       (let* ([max-product-so-far (* max-product (car arr))]\n              [min-product-so-far (* min-product (car arr))])\n         (loop (cdr arr) max-product-so-far min-product-so-far))])))\n",
    "  (define (max_subarray_product_helper arr max_so_far max_ending_here min_ending_here)\n    (cond\n      [(empty? arr) max_so_far]\n      [else\n       (define curr (first arr))\n       (define max_ending_here (max curr (* max_ending_here curr) (* min_ending_here curr)))\n       (define min_ending_here (min curr (* max_ending_here curr) (* min_ending_here curr)))\n       (define max_so_far (max max_so_far max_ending_here))\n       (max_subarray_product_helper (rest arr) max_so_far max_ending_here min_ending_here)]))\n  (max_subarray_product_helper arr -1000000000 -1000000000 1000000000))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (if (null? arr)\n        max_product\n        (let ([curr (car arr)])\n          (let ([max_product_ending_here_new (max (* curr max_product_ending_here) (* curr min_product_ending_here) curr)])\n            (let ([min_product_ending_here_new (min (* curr max_product_ending_here) (* curr min_product_ending_here) curr)])\n              (let ([max_product_new (max max_product max_product_ending_here_new)])\n                (max_subarray_product_helper (cdr arr) max_product_new max_product_ending_here_new min_product_ending_here_new))))))))\n  (max_subarray_product_helper arr -1000000000 -1000000000 1000000000))\n",
    "  (define (max-product-helper arr max-product)\n    (cond\n      [(empty? arr) max-product]\n      [(negative? (first arr))\n       (max-product-helper (rest arr) max-product)]\n      [else\n       (max-product-helper (rest arr) (* max-product (first arr)))]))\n  (max-product-helper arr 1))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond\n      [(null? arr) max_product]\n      [else\n       (define curr_product (* (car arr) max_product_ending_here))\n       (define new_max_product_ending_here (max (car arr) curr_product))\n       (define new_min_product_ending_here (min (car arr) curr_product))\n       (define new_max_product (max new_max_product_ending_here max_product))\n       (max_subarray_product_helper (cdr arr) new_max_product new_max_product_ending_here new_min_product_ending_here)\n       ]))\n  (max_subarray_product_helper arr 1 1 1))\n",
    "  (define (max_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond\n      [(empty? arr) max_product]\n      [else\n       (define current_product (first arr))\n       (define max_product_ending_here (max current_product (* current_product max_product_ending_here)))\n       (define min_product_ending_here (min current_product (* current_product min_product_ending_here)))\n       (define max_product (max max_product max_product_ending_here))\n       (max_product_helper (rest arr) max_product max_product_ending_here min_product_ending_here)]))\n  (max_product_helper arr 1 1 1))\n",
    "  (define (helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond [(empty? arr) max_product]\n          [else\n           (define curr_product (* (first arr) max_product_ending_here))\n           (define new_max_product_ending_here (max (first arr) curr_product))\n           (define new_min_product_ending_here (min (first arr) curr_product))\n           (define new_max_product (max max_product new_max_product_ending_here))\n           (helper (rest arr) new_max_product new_max_product_ending_here new_min_product_ending_here)]))\n  (helper arr 1 1 1))\n",
    "  (define (max_product_helper arr start end)\n    (if (= start end)\n        (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (",
    "  (define (max_product_helper arr max-product max-product-ending-here min-product-ending-here)\n    (if (null? arr)\n        max-product\n        (let* ([x (car arr)]\n               [max-product-ending-here (if (zero? x)\n                                            (max (max-product-ending-here (/ min-product-ending-here)) 1)\n                                            (max (* x max-product-ending-here) x))]\n               [min-product-ending-here (if (zero? x)\n                                            (min (min-product-ending-here (/ max-product-ending-here)) 1)\n                                            (min (* x min-product-ending-here) x))]\n               [max-product (max max-product max-product-ending-here)])\n          (max_product_helper (cdr arr) max-product max-product-ending-here min-product-ending-here))))\n  (max_product_helper arr -1000000000 -1000000000 1000000000))\n",
    "  (define (max_product arr)\n    (cond [(empty? arr) 1]\n          [(negative? (first arr)) (max (max_product (rest arr))\n                                        (* (first arr) (max_product (rest arr))))]\n          [else (max (max_product (rest arr))\n                     (* (first arr) (max_product (rest arr))))]))\n  (max_product arr))\n",
    "  (let loop ([arr arr] [max-product 1] [min-product 1] [max-so-far 1])\n    (cond [(empty? arr) max-so-far]\n          [else\n           (let ([curr-product (first arr)])\n             (loop (rest arr)\n                   (max (max-product * curr-product) curr-product)\n                   (min (min-product * curr-product) curr-product)\n                   (max (max max-so-far max-product) min-product)))])))\n",
    "  (define (max_product_helper arr max_product_so_far max_product_ending_here min_product_ending_here)\n    (cond\n      [(null? arr) max_product_so_far]\n      [else\n       (define curr_num (car arr))\n       (define max_product_ending_here_new (max (* curr_num max_product_ending_here) (* curr_num min_product_ending_here) curr_num))\n       (define min_product_ending_here_new (min (* curr_num max_product_ending_here) (* curr_num min_product_ending_here) curr_num))\n       (define max_product_so_far_new (max max_product_so_far max_product_ending_here_new))\n       (max_product_helper (cdr arr) max_product_so_far_new max_product_ending_here_new min_product_ending_here_new)\n       ]))\n  (max_product_helper arr -9999999999 0 0))\n",
    "  (let loop ((arr arr)\n             (max-product (car arr))\n             (max-product-start 0)\n             (max-product-end 0)\n             (current-product (car arr))\n             (current-product-start 0)\n             (current-product-end 0))\n    (cond ((null? arr) (values max-product max-product-start max-product-end))\n          ((= (car arr) 0)\n           (loop (cdr arr)\n                 (max max-product 0)\n                 (if (&gt; max-product 0) max-product-start (add1 current-product-end))\n                 (add1 current-product-end)\n                 0\n                 (add1 current-product-end)\n                 (add1 current-product-end)))\n          ((&lt; (car arr) 0)\n           (let ((new-product (* current-product (car arr))))\n             (if (&lt; new-product 0)\n                 (loop (cdr arr)\n                       (max max-product current-product)\n                       (if (&gt; max-product current-product) max-product-start current-product-start)\n                       (add1 current-product-end)\n                       new-product\n                       (add1 current-product-end)\n                       (add1 current-product-end))\n                 (loop (cdr arr)\n                       (max max-product new-product)\n                       (if (&gt; max-product new-product) max-product-start current-product-start)\n                       (add1 current-product-end)\n                       new-product\n                       current-product-start\n                       (add1 current-product-end)))))\n          (else\n           (loop (cdr arr)\n                 (max max-product (* current-product (car arr)))\n                 (if (&gt; max-product (* current-product (car arr))) max-product-start current-product-start)\n                 (add1 current-product-end)\n                 (* current-product (car arr))\n                 current-product-start\n                 (add1 current-product-end))))))\n</code>\n",
    "  (define (max_subarray_product_helper arr start end)\n    (if (= start end)\n        (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list (list",
    "  (define (max_product_helper arr i j max_product)\n    (cond\n      [(>= i (length arr)) max_product]\n      [(>= j (length arr)) (max_product_helper arr (+ i 1) (+ i 2) max_product)]\n      [else\n       (let ([product (* (list-ref arr i) (list-ref arr j))])\n         (max_product_helper arr i (+ j 1) (if (> product max_product) product max_product)))]))\n  (max_product_helper arr 0 1 0))\n",
    "  (define (max-product-helper arr max-product min-product)\n    (cond [(empty? arr) max-product]\n          [else\n           (let ([curr-num (first arr)])\n             (let ([curr-product (* curr-num (or min-product 1))])\n               (let ([curr-max-product (max curr-product max-product)])\n                 (let ([curr-min-product (min curr-product min-product)])\n                   (max-product-helper (rest arr) curr-max-product curr-min-product))))))]))\n  (max-product-helper arr -1000000000 1000000000))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond\n      [(null? arr) max_product]\n      [else\n       (define curr_product (* (car arr) max_product_ending_here))\n       (define curr_min_product (* (car arr) min_product_ending_here))\n       (define curr_max_product (car arr))\n       (define new_max_product_ending_here (max curr_product curr_min_product curr_max_product))\n       (define new_min_product_ending_here (min curr_product curr_min_product curr_max_product))\n       (define new_max_product (max new_max_product_ending_here max_product))\n       (max_subarray_product_helper (cdr arr) new_max_product new_max_product_ending_here new_min_product_ending_here)\n       ]\n      )\n    )\n  (max_subarray_product_helper arr -999999999 -999999999 -999999999)\n  )\n",
    "  (define (helper arr max_product curr_product)\n    (cond\n      [(empty? arr) max_product]\n      [(zero? (car arr))\n       (helper (cdr arr) max_product 0)]\n      [else\n       (let ([curr_product (if (zero? curr_product)\n                              (car arr)\n                              (* curr_product (car arr)))])\n         (helper (cdr arr) (max max_product curr_product) curr_product))]))\n  (helper arr 0 0))\n",
    "  (define (max_subarray_product_helper arr max_product_so_far max_product_ending_here min_product_ending_here)\n    (cond\n      [(null? arr) max_product_so_far]\n      [else\n       (let ([curr_val (car arr)])\n         (let ([max_product_ending_here (max curr_val (* curr_val max_product_ending_here) (* curr_val min_product_ending_here))])\n           (let ([min_product_ending_here (min curr_val (* curr_val max_product_ending_here) (* curr_val min_product_ending_here))])\n             (let ([max_product_so_far (max max_product_so_far max_product_ending_here)])\n               (max_subarray_product_helper (cdr arr) max_product_so_far max_product_ending_here min_product_ending_here))))))]))\n  (max_subarray_product_helper arr -inf.0 -inf.0 inf.0))\n",
    "  (let loop ((arr arr) (max-product 1) (min-product 1) (max-so-far 1))\n    (cond ((null? arr) max-so-far)\n          ((< (car arr) 0)\n           (let ((temp (max-product)))\n             (loop (cdr arr) (* min-product (car arr)) (* temp (car arr))\n                   (max (max-so-far) (* min-product (car arr))))))\n          ((> (car arr) 0)\n           (loop (cdr arr) (* max-product (car arr)) (* min-product (car arr))\n                 (max max-so-far max-product)))\n          (else (loop (cdr arr) 1 1 (max max-so-far 1))))))\n",
    "  (define (max_subarray_product_helper arr max_product start_index end_index)\n    (if (null? arr)\n        (list max_product start_index end_index)\n        (let* ([curr_product (apply * arr)]\n               [new_max_product (if (&gt; curr_product max_product)\n                                    curr_product\n                                    max_product)])\n          (max_subarray_product_helper (cdr arr) new_max_product start_index (+ end_index 1)))))\n  (max_subarray_product_helper arr 1 0 0))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond\n      [(empty? arr) max_product]\n      [else\n       (let* ([first (first arr)]\n              [rest (rest arr)]\n              [max_product_ending_here_next (max first (* first max_product_ending_here))]\n              [min_product_ending_here_next (min first (* first min_product_ending_here))]\n              [max_product_next (max max_product max_product_ending_here_next)])\n         (max_subarray_product_helper rest max_product_next max_product_ending_here_next min_product_ending_here_next))]))\n  (max_subarray_product_helper arr (first arr) (first arr) (first arr)))\n",
    "  (let loop ((arr arr)\n             (max-product (car arr))\n             (min-product (car arr))\n             (max-so-far (car arr)))\n    (if (null? (cdr arr))\n        max-so-far\n        (let ((next (cadr arr)))\n          (loop (cdr arr)\n                (max (max-product (* max-product next))\n                     (min-product (* min-product next))\n                     next)\n                (min (min-product (* max-product next))\n                     (min-product (* min-product next))\n                     next)\n                (max max-so-far (max (max-product (* max-product next))\n                                     (min-product (* min-product next))\n                                     next)))))))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond\n      [(empty? arr) max_product]\n      [else\n       (let* ([first (first arr)]\n              [rest (rest arr)]\n              [max_product_ending_here_new (max first (* first max_product_ending_here) (* first min_product_ending_here))]\n              [min_product_ending_here_new (min first (* first max_product_ending_here) (* first min_product_ending_here))]\n              [max_product_new (max max_product max_product_ending_here_new)])\n         (max_subarray_product_helper rest max_product_new max_product_ending_here_new min_product_ending_here_new))]))\n  (max_subarray_product_helper arr -inf.0 -inf.0 inf.0))\n",
    "  (define (max_product_ending_at i)\n    (define (max_product_ending_at_i_helper i max_ending_here min_ending_here)\n      (if (= i (length arr))\n          max_ending_here\n          (let ((a (list-ref arr i))\n                (max_ending_here_next (if (&gt; a 0)\n                                          (max (* max_ending_here a) a)\n                                          max_ending_here))\n                (min_ending_here_next (if (&lt; a 0)\n                                          (min (* min_ending_here a) a)\n                                          min_ending_here)))\n            (max_product_ending_at_i_helper (+ i 1) max_ending_here_next min_ending_here_next))))\n    (max_product_ending_at_i_helper i 1 1))\n  (define (max_product_starting_at i)\n    (define (max_product_starting_at_i_helper i max_starting_here min_starting_here)\n      (if (= i 0)\n          max_starting_here\n          (let ((a (list-ref arr (- i 1)))\n                (max_starting_here_next (if (&gt; a 0)\n                                            (max (* max_starting_here a) a)\n                                            max_starting_here))\n                (min_starting_here_next (if (&lt; a 0)\n                                            (min (* min_starting_here a) a)\n                                            min_starting_here)))\n            (max_product_starting_at_i_helper (- i 1) max_starting_here_next min_starting_here_next))))\n    (max_product_starting_at_i_helper i 1 1))\n  (define (max_product_between_i_j i j)\n    (if (&lt; i j)\n        (* (max_product_ending_at i) (max_product_starting_at j))\n        (max_product_ending_at i)))\n  (define (max_product_between_i_j_helper i j max_product",
    "  (define (max_subarray_product_helper arr max_product start_index end_index)\n    (if (null? arr)\n        (list max_product start_index end_index)\n        (let* ([current_product (apply * (take arr (add1 end_index))))\n               [max_product (if (&gt; current_product max_product)\n                                current_product\n                                max_product)])\n          (if (&lt;= current_product 0)\n              (max_subarray_product_helper (cdr arr) max_product (add1 start_index) (add1 end_index))\n              (max_subarray_product_helper (cdr arr) max_product start_index (add1 end_index))))))\n  (max_subarray_product_helper arr -1000000000 0 0))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (if (null? arr)\n        max_product\n        (let ([curr (car arr)])\n          (let ([max_product_ending_here_new (max (max curr (* curr max_product_ending_here)) (* curr min_product_ending_here))])\n            (let ([min_product_ending_here_new (min (min curr (* curr max_product_ending_here)) (* curr min_product_ending_here))])\n              (let ([max_product_new (max max_product max_product_ending_here_new)])\n                (max_subarray_product_helper (cdr arr) max_product_new max_product_ending_here_new min_product_ending_here_new))))))))\n  (max_subarray_product_helper arr -inf.0 -inf.0 inf.0))\n",
    "  (define (helper arr max_product)\n    (if (null? arr)\n        max_product\n        (let* ([first (car arr)]\n               [rest (cdr arr)]\n               [new_max_product (if (zero? first)\n                                    (helper rest max_product)\n                                    (let* ([new_max_product (if (zero? max_product)\n                                                                first\n                                                                (* max_product first))]\n                                           [new_max_product (if (zero? new_max_product)\n                                                                (helper rest new_max_product)\n                                                                new_max_product)])\n                                      (helper rest new_max_product)))])\n          new_max_product)))\n  (helper arr 0))\n",
    "  (define (max_subarray_product_helper arr max_product min_product)\n    (if (null? arr)\n        max_product\n        (let* ([curr (car arr)]\n               [max_product (if (and (positive? curr) (positive? max_product))\n                                (* curr max_product)\n                                (if (and (negative? curr) (negative? min_product))\n                                    (* curr min_product)\n                                    curr))]\n               [min_product (if (and (positive? curr) (negative? min_product))\n                                (* curr min_product)\n                                (if (and (negative? curr) (positive? max_product))\n                                    (* curr max_product)\n                                    curr))])\n          (max_subarray_product_helper (cdr arr) max_product min_product))))\n  (max_subarray_product_helper arr 1 -1))\n",
    "  (define (prod lst)\n    (if (null? lst)\n        1\n        (* (car lst) (prod (cdr lst)))))\n  (define (max_prod lst)\n    (if (null? lst)\n        0\n        (max (prod lst) (max_prod (cdr lst)))))\n  (max_prod arr))\n",
    "  (let loop ((arr arr)\n             (max-product (car arr))\n             (min-product (car arr))\n             (max-so-far max-product))\n    (if (null? (cdr arr))\n        max-so-far\n        (let* ((next (cadr arr))\n               (max-product (max (* max-product next)\n                                 (* min-product next)\n                                 next))\n               (min-product (min (* max-product next)\n                                 (* min-product next)\n                                 next))\n               (max-so-far (max max-so-far max-product)))\n          (loop (cdr arr)\n                max-product\n                min-product\n                max-so-far)))))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond\n      [(empty? arr) max_product]\n      [else\n       (define current_product (first arr))\n       (define max_product_ending_here_new (max current_product (* current_product max_product_ending_here)))\n       (define min_product_ending_here_new (min current_product (* current_product min_product_ending_here)))\n       (define max_product_new (max max_product_ending_here_new max_product_ending_here))\n       (max_subarray_product_helper (rest arr) max_product_new max_product_ending_here_new min_product_ending_here_new)]))\n  (max_subarray_product_helper arr -inf.0 -inf.0 inf.0))\n",
    "  (let loop ((arr arr)\n             (max-product (first arr))\n             (min-product (first arr))\n             (max-so-far max-product))\n    (cond ((null? arr) max-so-far)\n          ((= (first arr) 0)\n           (loop (rest arr)\n                 1\n                 1\n                 (max max-so-far 0)))\n          (else\n           (let ((product (* max-product (first arr))))\n             (loop (rest arr)\n                   (max product (first arr))\n                   (min product (first arr))\n                   (max max-so-far product)))))))\n",
    "  (define (max_subarray_product-iter arr max-product max-product-ending-here min-product-ending-here)\n    (cond\n      [(null? arr) max-product]\n      [else\n       (let* ([x (car arr)]\n              [max-product-ending-here (max x (* x max-product-ending-here))]\n              [min-product-ending-here (min x (* x min-product-ending-here))]\n              [max-product (max max-product max-product-ending-here)])\n         (max_subarray_product-iter (cdr arr) max-product max-product-ending-here min-product-ending-here))]))\n  (max_subarray_product-iter arr 0 1 0))\n",
    "  (define (helper arr max-so-far max-ending-here min-ending-here)\n    (cond\n      [(null? arr) max-so-far]\n      [else\n       (define cur (car arr))\n       (define max-ending-here (max (max cur (* cur max-ending-here)) (* cur min-ending-here)))\n       (define min-ending-here (min (min cur (* cur max-ending-here)) (* cur min-ending-here)))\n       (define max-so-far (max max-so-far max-ending-here))\n       (helper (cdr arr) max-so-far max-ending-here min-ending-here)]))\n  (helper arr -1000000000 -1000000000 1000000000))\n",
    "  (define (max_product_helper arr start end max)\n    (if (= start end)\n        max\n        (let ((product (apply * (sublist arr start end))))\n          (if (&gt; product max)\n              (max_product_helper arr start (+ end 1) product)\n              (max_product_helper arr start (+ end 1) max)))))\n  (max_product_helper arr 0 (length arr) 0))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (if (null? arr)\n        max_product\n        (let* ([curr (car arr)]\n               [max_product_ending_here_next (max curr (* max_product_ending_here curr) (* min_product_ending_here curr))]\n               [min_product_ending_here_next (min curr (* max_product_ending_here curr) (* min_product_ending_here curr))]\n               [max_product_next (max max_product max_product_ending_here_next)])\n          (max_subarray_product_helper (cdr arr) max_product_next max_product_ending_here_next min_product_ending_here_next))))\n  (max_subarray_product_helper arr -999999999 -999999999 -999999999))\n",
    "  (define (helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond\n      [(empty? arr) max_product]\n      [else\n       (let ([curr (first arr)])\n         (cond\n           [(> curr 0)\n            (helper (rest arr)\n                    (max max_product (* curr max_product_ending_here))\n                    (* curr max_product_ending_here)\n                    (min min_product_ending_here curr))]\n           [(< curr 0)\n            (helper (rest arr)\n                    (max max_product (* curr min_product_ending_here))\n                    (min min_product_ending_here curr)\n                    (* curr min_product_ending_here))]\n           [else\n            (helper (rest arr)\n                    (max max_product curr)\n                    curr\n                    curr)]))]))\n  (helper arr -1/0 1/0 1/0))\n"
  ]
}