{
  "name": "mbpp_558_digit_distance_nums",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a rktthon function to find the sum of the per-digit difference between two integers.\n(define (digit_distance_nums n1 n2)\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_558_digit_distance_nums.py",
  "prompt_terminology": "reworded",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate digit_distance_nums))\n    (check-equal? (candidate 1 2) 1)\n    (check-equal? (candidate 23 56) 6)\n    (check-equal? (candidate 123 256) 7)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (digit_distance_helper n1 n2 acc)\n    (if (or (zero? n1) (zero? n2))\n        acc\n        (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (and (zero? n1) (zero? n2))\n        0\n        (+ (abs (- (remainder n1 10) (remainder n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (define (digit_distance_helper n1 n2 sum)\n    (cond\n      [(zero? n1) sum]\n      [(zero? n2) sum]\n      [else (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ sum (abs (- (remainder n1 10) (remainder n2 10)))))]))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_nums_helper n1 n2 sum)\n    (cond\n      [(= n1 0) sum]\n      [(= n2 0) sum]\n      [else\n       (digit_distance_nums_helper (quotient n1 10) (quotient n2 10) (+ sum (abs (- (remainder n1 10) (remainder n2 10)))))]))\n  (digit_distance_nums_helper n1 n2 0))\n",
    "  (let ([n1-digits (string->list (number->string n1))]\n        [n2-digits (string->list (number->string n2))])\n    (if (or (empty? n1-digits) (empty? n2-digits))\n        0\n        (+ (abs (- (string->number (list->string (car n1-digits)))\n                   (string->number (list->string (car n2-digits)))))\n           (digit_distance_nums (string->number (list->string (cdr n1-digits)))\n                                (string->number (list->string (cdr n2-digits))))))))\n",
    "  (define (digit_distance_nums_helper n1 n2 acc)\n    (if (zero? n1)\n        acc\n        (digit_distance_nums_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_nums_helper n1 n2 0))\n",
    "  (let ([d1 (number->string n1)]\n        [d2 (number->string n2)])\n    (if (or (empty? d1) (empty? d2))\n        0\n        (+ (abs (- (string-&gt;number (substring d1 0 1))\n                   (string-&gt;number (substring d2 0 1))))\n           (digit_distance_nums (string-&gt;number (substring d1 1 (string-length d1)))\n                                (string-&gt;number (substring d2 1 (string-length d2))))))))\n",
    "  (let ([d1 (number->string n1)]\n        [d2 (number->string n2)])\n    (let loop ([i 0] [sum 0])\n      (if (= i (string-length d1))\n          sum\n          (let ([d1-i (string-ref d1 i)]\n                [d2-i (string-ref d2 i)])\n            (loop (+ i 1)\n                  (+ sum (abs (- (string->number (string d1-i))\n                                 (string->number (string d2-i)))))))))))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (zero? n1)\n        0\n        (+ (abs (- (modulo n1 10) (modulo n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (let ([n1 (number->string n1)]\n        [n2 (number->string n2)])\n    (if (or (empty? n1) (empty? n2))\n        0\n        (+ (abs (- (string->number (first n1)) (string->number (first n2))))\n           (digit_distance_nums (rest n1) (rest n2))))))\n",
    "  (define (digit_distance_helper n1 n2 sum)\n    (if (zero? n1)\n        sum\n        (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ sum (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2 sum)\n    (cond [(= n1 0) sum]\n          [(= n2 0) sum]\n          [else (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ sum (abs (- (remainder n1 10) (remainder n2 10)))))]))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (if (and (zero? n1) (zero? n2))\n        acc\n        (let ([d1 (remainder n1 10)])\n          (let ([d2 (remainder n2 10)])\n            (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- d1 d2))))))))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2 sum)\n    (cond ((or (zero? n1) (zero? n2)) sum)\n          (else (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ sum (abs (- (remainder n1 10) (remainder n2 10))))))))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (if (zero? n1)\n        acc\n        (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ (abs (- (remainder n1 10) (remainder n2 10))) acc))))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_nums_helper n1 n2 acc)\n    (cond\n      [(zero? n1) acc]\n      [(zero? n2) acc]\n      [else (digit_distance_nums_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))]))\n  (digit_distance_nums_helper n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (cond\n      [(zero? n1) acc]\n      [(zero? n2) acc]\n      [else (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))]))\n  (digit_distance_helper n1 n2 0))\n",
    "  (if (or (zero? n1) (zero? n2))\n      0\n      (+ (abs (- (remainder n1 10) (remainder n2 10)))\n         (digit_distance_nums (quotient n1 10) (quotient n2 10)))))\n",
    "  (let ([d1 (digits n1)]\n        [d2 (digits n2)])\n    (cond [(empty? d1) 0]\n          [(empty? d2) 0]\n          [else (+ (abs (- (first d1) (first d2)))\n                   (digit_distance_nums (rest d1) (rest d2)))])))\n",
    "  (let ([d1 (number->string n1)]\n        [d2 (number->string n2)])\n    (if (or (empty? d1) (empty? d2))\n        0\n        (+ (abs (- (string-&gt;number (first d1)) (string-&gt;number (first d2))))\n           (digit_distance_nums (rest d1) (rest d2))))))\n"
  ]
}