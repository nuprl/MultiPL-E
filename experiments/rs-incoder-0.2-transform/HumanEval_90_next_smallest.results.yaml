language: rs
name: HumanEval_90_next_smallest
results:
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n\n\
    \    let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|x| x == smallest).unwrap();\n\n    if smallest_index\
    \ == lst.len() - 1 {\n        smallest_index = 0;\n    }\n\n    Some(smallest)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpro2dixna.rs:24:10\n   |\n\
    24 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n24 |     Some(*smallest)\n\
    \   |          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    for\
    \ x in lst {\n        if *x < smallest[0] {\n            smallest[0] = x;\n  \
    \      }\n        if *x > smallest[1] {\n            smallest[1] = x;\n      \
    \  }\n    }\n    if smallest[0] == smallest[1] {\n        None\n    } else {\n\
    \        Some(smallest[1])\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp05xvtj72.rs:15:12\n\
    \   |\n15 |         if *x < smallest[0] {\n   |            ^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp05xvtj72.rs:16:27\n   |\n16 |             smallest[0]\
    \ = x;\n   |             -----------   ^ expected `i32`, found `isize`\n   | \
    \            |\n   |             expected due to the type of this binding\n\n\
    error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp05xvtj72.rs:18:12\n\
    \   |\n18 |         if *x > smallest[1] {\n   |            ^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp05xvtj72.rs:19:27\n   |\n19 |             smallest[1]\
    \ = x;\n   |             -----------   ^ expected `i32`, found `isize`\n   | \
    \            |\n   |             expected due to the type of this binding\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp05xvtj72.rs:25:14\n   |\n25 |  \
    \       Some(smallest[1])\n   |              ^^^^^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n25 |         Some(smallest[1].try_into().unwrap())\n\
    \   |                         ++++++++++++++++++++\n\nerror: aborting due to 5\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0614.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n\n\
    \    let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = 0;\n    let mut smallest_value = lst.iter().min().unwrap();\n\n    for &i\
    \ in lst {\n        if *i < smallest {\n            smallest_value = i;\n    \
    \        smallest_index = i;\n        }\n    }\n\n    Some(smallest_value)\n}\n\
    \nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1l8u5s_n.rs:21:9\n   |\n\
    21 |     for &i in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1l8u5s_n.rs:28:10\n   |\n28 |     Some(smallest_value)\n   |  \
    \        ^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n28 |     Some(*smallest_value)\n   |       \
    \   +\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min();\n    let mut smallest_index\
    \ = lst.iter().position(|&x| x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() {\n        return None;\n    }\n    smallest = lst.iter().nth(smallest_index).unwrap();\n\
    \    smallest_index += 1;\n    if smallest_index == lst.len() {\n        return\
    \ None;\n    }\n    smallest = lst.iter().nth(smallest_index).unwrap();\n    Some(smallest)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6enp2xnj.rs:14:60\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp6enp2xnj.rs:18:16\n   |\n13 |     let mut smallest = lst.iter().min();\n\
    \   |                        ---------------- expected due to this value\n...\n\
    18 |     smallest = lst.iter().nth(smallest_index).unwrap();\n   |           \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`, found `&isize`\n\
    \   |\n   = note:   expected enum `Option<&isize>`\n           found reference\
    \ `&isize`\nhelp: try wrapping the expression in `Some`\n   |\n18 |     smallest\
    \ = Some(lst.iter().nth(smallest_index).unwrap());\n   |                +++++\
    \                                       +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp6enp2xnj.rs:23:16\n   |\n13 |     let mut smallest = lst.iter().min();\n\
    \   |                        ---------------- expected due to this value\n...\n\
    23 |     smallest = lst.iter().nth(smallest_index).unwrap();\n   |           \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`, found `&isize`\n\
    \   |\n   = note:   expected enum `Option<&isize>`\n           found reference\
    \ `&isize`\nhelp: try wrapping the expression in `Some`\n   |\n23 |     smallest\
    \ = Some(lst.iter().nth(smallest_index).unwrap());\n   |                +++++\
    \                                       +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp6enp2xnj.rs:24:10\n   |\n24 |     Some(smallest)\n   |        \
    \  ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected type\
    \ `isize`\n              found enum `Option<&isize>`\n\nerror: aborting due to\
    \ 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    for\
    \ x in lst {\n        if x < smallest[0] {\n            smallest[0] = x;\n   \
    \     }\n        if x < smallest[1] {\n            smallest[1] = x;\n        }\n\
    \    }\n    if smallest[1] == std::i32::MAX {\n        None\n    } else {\n  \
    \      Some(smallest[1])\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpafczotra.rs:15:16\n   |\n\
    15 |         if x < smallest[0] {\n   |                ^^^^^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n15 |         if x < smallest[0].try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpafczotra.rs:16:27\n   |\n16 |             smallest[0] =\
    \ x;\n   |             -----------   ^ expected `i32`, found `isize`\n   |   \
    \          |\n   |             expected due to the type of this binding\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpafczotra.rs:18:16\n   |\n18 |         if x <\
    \ smallest[1] {\n   |                ^^^^^^^^^^^ expected `isize`, found `i32`\n\
    \   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n18 |         if x < smallest[1].try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpafczotra.rs:19:27\n   |\n19 |             smallest[1] =\
    \ x;\n   |             -----------   ^ expected `i32`, found `isize`\n   |   \
    \          |\n   |             expected due to the type of this binding\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpafczotra.rs:25:14\n   |\n25 |         Some(smallest[1])\n\
    \   |              ^^^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you\
    \ can convert an `i32` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n25 |         Some(smallest[1].try_into().unwrap())\n   |        \
    \                 ++++++++++++++++++++\n\nerror: aborting due to 5 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().cloned().enumerate().find(|(_, i)| i.1 <\
    \ i.2).map(|(_, i)| i.1)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `1` on type `&isize`\n  --> /tmp/tmpwgroeoi5.rs:13:53\n\
    \   |\n13 |     lst.iter().cloned().enumerate().find(|(_, i)| i.1 < i.2).map(|(_,\
    \ i)| i.1)\n   |                                                     ^\n\nerror[E0609]:\
    \ no field `2` on type `&isize`\n  --> /tmp/tmpwgroeoi5.rs:13:59\n   |\n13 | \
    \    lst.iter().cloned().enumerate().find(|(_, i)| i.1 < i.2).map(|(_, i)| i.1)\n\
    \   |                                                           ^\n\nerror[E0610]:\
    \ `isize` is a primitive type and therefore doesn't have fields\n  --> /tmp/tmpwgroeoi5.rs:13:77\n\
    \   |\n13 |     lst.iter().cloned().enumerate().find(|(_, i)| i.1 < i.2).map(|(_,\
    \ i)| i.1)\n   |                                                             \
    \                ^\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0609, E0610.\nFor more information about an error,\
    \ try `rustc --explain E0609`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![lst[0]];\n    let mut smallest_idx\
    \ = 1;\n    for &x in lst {\n        if x < smallest[smallest_idx] {\n       \
    \     smallest[smallest_idx] = x;\n            smallest_idx += 1;\n        }\n\
    \    }\n    if smallest_idx == lst.len() {\n        return None;\n    }\n    Some(smallest[smallest_idx])\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp796mlzjl.rs:15:9\n   |\n\
    15 |     for &x in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n\n\
    \    let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|x| x == smallest).unwrap();\n\n    if smallest_index\
    \ == lst.len() - 1 {\n        return Some(smallest);\n    }\n\n    let mut smallest_index\
    \ = smallest_index + 1;\n    let mut smallest_value = lst.iter().nth(smallest_index).unwrap();\n\
    \n    while smallest_index != lst.len() - 1 {\n        if smallest_value < lst.iter().nth(smallest_index).unwrap()\
    \ {\n            smallest_value = lst.iter().nth(smallest_index).unwrap();\n \
    \           smallest_index = smallest_index + 1;\n        }\n        smallest_index\
    \ = smallest_index + 1;\n    }\n\n    Some(smallest_value)\n}\n\nfn main() {\n\
    \    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4,\
    \ 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7k9lpqi6.rs:21:21\n   |\n\
    21 |         return Some(smallest);\n   |                     ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    21 |         return Some(*smallest);\n   |                     +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7k9lpqi6.rs:35:10\n   |\n35 |     Some(smallest_value)\n\
    \   |          ^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n35 |     Some(*smallest_value)\n   |       \
    \   +\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    smallest[0]\
    \ = std::i32::MAX;\n    smallest[1] = std::i32::MAX;\n\n    for elt in lst {\n\
    \        if smallest[0] < elt {\n            smallest[0] = elt;\n        }\n \
    \       if smallest[1] < elt {\n            smallest[1] = elt;\n        }\n  \
    \  }\n\n    if smallest[0] == std::i32::MAX {\n        None\n    } else {\n  \
    \      Some(smallest[1])\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl7aoqf3v.rs:18:26\n   |\n\
    18 |         if smallest[0] < elt {\n   |                          ^^^ expected\
    \ `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an `i32` and\
    \ panic if the converted value doesn't fit\n   |\n18 |         if smallest[0]\
    \ < elt.try_into().unwrap() {\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpl7aoqf3v.rs:19:27\n   |\n19 |\
    \             smallest[0] = elt;\n   |             -----------   ^^^ expected\
    \ `i32`, found `isize`\n   |             |\n   |             expected due to the\
    \ type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl7aoqf3v.rs:21:26\n\
    \   |\n21 |         if smallest[1] < elt {\n   |                          ^^^\
    \ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n21 |         if smallest[1]\
    \ < elt.try_into().unwrap() {\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpl7aoqf3v.rs:22:27\n   |\n22 |\
    \             smallest[1] = elt;\n   |             -----------   ^^^ expected\
    \ `i32`, found `isize`\n   |             |\n   |             expected due to the\
    \ type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl7aoqf3v.rs:29:14\n\
    \   |\n29 |         Some(smallest[1])\n   |              ^^^^^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n29 |         Some(smallest[1].try_into().unwrap())\n\
    \   |                         ++++++++++++++++++++\n\nerror: aborting due to 5\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n   \
    \ if smallest_index == lst.len() {\n        return None;\n    }\n    smallest\
    \ = lst.iter().skip(smallest_index).min().unwrap();\n    smallest_index = lst.iter().position(|x|\
    \ *x == smallest).unwrap();\n    if smallest_index == lst.len() {\n        return\
    \ None;\n    }\n    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn0pet1nj.rs:14:60\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|x| *x == *smallest).unwrap();\n\
    \   |                                                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpn0pet1nj.rs:19:52\n   |\n19 |     smallest_index\
    \ = lst.iter().position(|x| *x == smallest).unwrap();\n   |                  \
    \                                  ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n19 |     smallest_index\
    \ = lst.iter().position(|x| *x == *smallest).unwrap();\n   |                 \
    \                                   +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpn0pet1nj.rs:23:10\n   |\n23 |     Some(smallest)\n   |          ^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n23 |     Some(*smallest)\n   |          +\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![0; lst.len()];\n    let mut\
    \ smallest_idx = vec![0; lst.len()];\n    for &x in lst {\n        if smallest[x]\
    \ < smallest[smallest_idx[x]] {\n            smallest[x] = smallest_idx[x];\n\
    \        }\n        smallest_idx[x] += 1;\n    }\n    if smallest_idx.iter().any(|&x|\
    \ x < lst.len()) {\n        smallest_idx[lst.len()] = lst.len();\n    }\n    smallest_idx.iter().map(|&x|\
    \ lst[x]).find(|&x| x < lst.len())\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplfp6cwyz.rs:15:9\n   |\n\
    15 |     for &x in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmplfp6cwyz.rs:24:56\n   |\n24 |     smallest_idx.iter().map(|&x|\
    \ lst[x]).find(|&x| x < lst.len())\n   |                                     \
    \                   ^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you\
    \ can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n24 |     smallest_idx.iter().map(|&x| lst[x]).find(|&x| x < lst.len().try_into().unwrap())\n\
    \   |                                                                 ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|&x| x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        smallest_index = 0;\n    }\n    Some(smallest)\n}\n\
    \nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz9ejcwk6.rs:17:60\n   |\n\
    17 |     let mut smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    17 |     let mut smallest_index = lst.iter().position(|&x| x == *smallest).unwrap();\n\
    \   |                                                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpz9ejcwk6.rs:21:10\n   |\n21 |     Some(smallest)\n\
    \   |          ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n21 |     Some(*smallest)\n   |          +\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min();\n    let mut smallest_index\
    \ = lst.iter().position(|x| *x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() {\n        return None;\n    }\n    let mut smallest_value = lst.iter().nth(smallest_index).unwrap();\n\
    \    let mut smallest_index = smallest_index + 1;\n    while smallest_index <\
    \ lst.len() {\n        if lst.iter().nth(smallest_index).unwrap() < smallest_value\
    \ {\n            smallest_value = lst.iter().nth(smallest_index).unwrap();\n \
    \           smallest_index = smallest_index + 1;\n        }\n        smallest_index\
    \ = smallest_index + 1;\n    }\n    Some(smallest_value)\n}\n\nfn main() {\n \
    \   let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4,\
    \ 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpla0u8x5q.rs:14:60\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpla0u8x5q.rs:27:10\n   |\n27 |     Some(smallest_value)\n   |       \
    \   ^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n27 |     Some(*smallest_value)\n   |          +\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    for\
    \ elt in lst {\n        if smallest[0] < elt {\n            smallest[0] = elt;\n\
    \        }\n        if smallest[1] < elt {\n            smallest[1] = elt;\n \
    \       }\n    }\n    if smallest[0] == std::i32::MAX {\n        None\n    } else\
    \ {\n        Some(smallest[1])\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm76sdb4z.rs:15:26\n   |\n\
    15 |         if smallest[0] < elt {\n   |                          ^^^ expected\
    \ `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an `i32` and\
    \ panic if the converted value doesn't fit\n   |\n15 |         if smallest[0]\
    \ < elt.try_into().unwrap() {\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpm76sdb4z.rs:16:27\n   |\n16 |\
    \             smallest[0] = elt;\n   |             -----------   ^^^ expected\
    \ `i32`, found `isize`\n   |             |\n   |             expected due to the\
    \ type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm76sdb4z.rs:18:26\n\
    \   |\n18 |         if smallest[1] < elt {\n   |                          ^^^\
    \ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n18 |         if smallest[1]\
    \ < elt.try_into().unwrap() {\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpm76sdb4z.rs:19:27\n   |\n19 |\
    \             smallest[1] = elt;\n   |             -----------   ^^^ expected\
    \ `i32`, found `isize`\n   |             |\n   |             expected due to the\
    \ type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm76sdb4z.rs:25:14\n\
    \   |\n25 |         Some(smallest[1])\n   |              ^^^^^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n25 |         Some(smallest[1].try_into().unwrap())\n\
    \   |                         ++++++++++++++++++++\n\nerror: aborting due to 5\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![lst[0]];\n    let mut smallest_idx\
    \ = 1;\n    for &i in lst {\n        if *i < smallest[smallest_idx] {\n      \
    \      smallest[smallest_idx] = *i;\n            smallest_idx += 1;\n        }\n\
    \    }\n    if smallest_idx == lst.len() {\n        return None;\n    }\n    Some(smallest[smallest_idx])\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiurcwzbw.rs:15:9\n   |\n\
    15 |     for &i in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![lst[0]; 2];\n    let mut smallest_idx\
    \ = 1;\n    for &x in lst {\n        if x < smallest[smallest_idx] {\n       \
    \     smallest[smallest_idx] = x;\n            smallest_idx += 1;\n        }\n\
    \    }\n    if smallest_idx == 2 {\n        Some(smallest[1])\n    } else {\n\
    \        None\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppa7j9mi3.rs:15:9\n   |\n\
    15 |     for &x in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min();\n    let mut smallest_index\
    \ = lst.iter().position(|x| x < smallest);\n    if smallest_index == lst.len()\
    \ {\n        return None;\n    }\n    smallest = lst.iter().nth(smallest_index\
    \ + 1);\n    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgpsr3dkx.rs:14:58\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|x| x < smallest);\n   |\
    \                                                          ^^^^^^^^ expected `&isize`,\
    \ found enum `Option`\n   |\n   = note: expected reference `&isize`\n        \
    \           found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpgpsr3dkx.rs:15:26\n   |\n15 |     if smallest_index == lst.len() {\n\
    \   |                          ^^^^^^^^^ expected enum `Option`, found `usize`\n\
    \   |\n   = note: expected enum `Option<usize>`\n              found type `usize`\n\
    help: try wrapping the expression in `Some`\n   |\n15 |     if smallest_index\
    \ == Some(lst.len()) {\n   |                          +++++         +\n\nerror[E0369]:\
    \ cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmpgpsr3dkx.rs:18:46\n\
    \   |\n18 |     smallest = lst.iter().nth(smallest_index + 1);\n   |         \
    \                      -------------- ^ - {integer}\n   |                    \
    \           |\n   |                               Option<usize>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgpsr3dkx.rs:19:10\n   |\n19 |     Some(smallest)\n\
    \   |          ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note:\
    \ expected type `isize`\n              found enum `Option<&isize>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0369.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    let\
    \ mut smallest_idx = 0;\n    for el in lst {\n        if el < smallest[smallest_idx]\
    \ {\n            smallest[smallest_idx] = el;\n            smallest_idx += 1;\n\
    \        }\n    }\n    if smallest_idx == 1 {\n        None\n    } else {\n  \
    \      Some(smallest[smallest_idx - 1])\n    }\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmperxkb6gn.rs:16:17\n   |\n\
    16 |         if el < smallest[smallest_idx] {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n16 |         if el < smallest[smallest_idx].try_into().unwrap()\
    \ {\n   |                                       ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmperxkb6gn.rs:17:38\n   |\n17 |             smallest[smallest_idx]\
    \ = el;\n   |             ----------------------   ^^ expected `i32`, found `isize`\n\
    \   |             |\n   |             expected due to the type of this binding\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmperxkb6gn.rs:24:14\n   |\n24 |\
    \         Some(smallest[smallest_idx - 1])\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n24 |         Some(smallest[smallest_idx\
    \ - 1].try_into().unwrap())\n   |                                        ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min();\n    let mut smallest_index\
    \ = lst.iter().position(|x| x < smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        return None;\n    }\n    let mut smallest_value = lst.iter().nth(smallest_index).unwrap();\n\
    \    let mut second_smallest = lst.iter().skip(smallest_index).min();\n    let\
    \ mut second_smallest_index = lst.iter().position(|x| x < second_smallest).unwrap();\n\
    \    if second_smallest_index == lst.len() - 1 {\n        return None;\n    }\n\
    \    let mut second_smallest_value = lst.iter().nth(second_smallest_index).unwrap();\n\
    \    if second_smallest_value < smallest_value {\n        smallest = second_smallest;\n\
    \        smallest_index = second_smallest_index;\n    }\n    Some(smallest)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpco1d0re8.rs:14:58\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|x| x < smallest).unwrap();\n\
    \   |                                                          ^^^^^^^^ expected\
    \ `&isize`, found enum `Option`\n   |\n   = note: expected reference `&isize`\n\
    \                   found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpco1d0re8.rs:20:65\n   |\n20 |     let mut second_smallest_index\
    \ = lst.iter().position(|x| x < second_smallest).unwrap();\n   |             \
    \                                                    ^^^^^^^^^^^^^^^ expected\
    \ `&isize`, found enum `Option`\n   |\n   = note: expected reference `&isize`\n\
    \                   found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpco1d0re8.rs:29:10\n   |\n29 |     Some(smallest)\n   |        \
    \  ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected type\
    \ `isize`\n              found enum `Option<&isize>`\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min();\n    let mut smallest_index\
    \ = 0;\n    for &i in lst {\n        if *i < smallest {\n            smallest\
    \ = i;\n            smallest_index = i;\n        }\n    }\n    Some(smallest)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptg5ui_fn.rs:15:9\n   |\n\
    15 |     for &i in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptg5ui_fn.rs:21:10\n   |\n21 |     Some(smallest)\n   |        \
    \  ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected type\
    \ `isize`\n              found enum `Option<&isize>`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min();\n    let mut smallest_index\
    \ = lst.iter().position(|&x| x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() {\n        return None;\n    }\n    smallest = lst.iter().nth(smallest_index).unwrap();\n\
    \    smallest_index += 1;\n    if smallest_index >= lst.len() {\n        smallest_index\
    \ = 0;\n    }\n    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcfvi1vhu.rs:14:60\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpcfvi1vhu.rs:18:16\n   |\n13 |     let mut smallest = lst.iter().min();\n\
    \   |                        ---------------- expected due to this value\n...\n\
    18 |     smallest = lst.iter().nth(smallest_index).unwrap();\n   |           \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`, found `&isize`\n\
    \   |\n   = note:   expected enum `Option<&isize>`\n           found reference\
    \ `&isize`\nhelp: try wrapping the expression in `Some`\n   |\n18 |     smallest\
    \ = Some(lst.iter().nth(smallest_index).unwrap());\n   |                +++++\
    \                                       +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpcfvi1vhu.rs:23:10\n   |\n23 |     Some(smallest)\n   |        \
    \  ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected type\
    \ `isize`\n              found enum `Option<&isize>`\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min();\n    let mut smallest_idx\
    \ = lst.iter().position(|&x| x == smallest).unwrap();\n    if smallest_idx ==\
    \ lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_idx).min();\n\
    \    smallest_idx = lst.iter().position(|&x| x == smallest).unwrap();\n    if\
    \ smallest_idx == lst.len() {\n        return None;\n    }\n    Some(smallest)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_4i5q33c.rs:14:58\n   |\n\
    14 |     let mut smallest_idx = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                          ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp_4i5q33c.rs:19:50\n   |\n19 |     smallest_idx = lst.iter().position(|&x|\
    \ x == smallest).unwrap();\n   |                                             \
    \     ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected\
    \ type `isize`\n              found enum `Option<&isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_4i5q33c.rs:23:10\n   |\n23 |     Some(smallest)\n   |\
    \          ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected\
    \ type `isize`\n              found enum `Option<&isize>`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n    if\
    \ smallest_index == lst.len() {\n        return None;\n    }\n    let mut smallest_value\
    \ = lst.iter().nth(smallest_index).unwrap();\n    if smallest_value == smallest\
    \ {\n        smallest_index += 1;\n    }\n    Some(smallest_value)\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4ckrlsii.rs:22:10\n   |\n\
    22 |     Some(smallest_value)\n   |          ^^^^^^^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n22 |  \
    \   Some(*smallest_value)\n   |          +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n \
    \   let mut smallest = vec![lst[0]];\n    let mut smallest_idx = 1;\n    for &i\
    \ in lst {\n        if i < smallest[smallest_idx] {\n            smallest[smallest_idx]\
    \ = i;\n            smallest_idx += 1;\n        }\n    }\n    smallest[smallest_idx..]\n\
    \        .iter()\n        .next()\n        .cloned()\n        .ok_or(Error::NoSuchElement)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Error`\n  -->\
    \ /tmp/tmpxsd8ihis.rs:28:16\n   |\n28 |         .ok_or(Error::NoSuchElement)\n\
    \   |                ^^^^^ use of undeclared type `Error`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxsd8ihis.rs:18:9\n   |\n18 |     for &i in lst {\n   |\
    \         ^^    --- this expression has type `Option<isize>`\n   |         |\n\
    \   |         expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxsd8ihis.rs:24:5\n\
    \   |\n12 |   fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |     \
    \                                   ------------- expected `Option<isize>` because\
    \ of return type\n...\n24 | /     smallest[smallest_idx..]\n25 | |         .iter()\n\
    26 | |         .next()\n27 | |         .cloned()\n28 | |         .ok_or(Error::NoSuchElement)\n\
    \   | |____________________________________^ expected enum `Option`, found enum\
    \ `Result`\n   |\n   = note: expected enum `Option<isize>`\n              found\
    \ enum `Result<isize, _>`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0433.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = 0;\n    for index in lst.iter().rev() {\n        if index\
    \ == smallest {\n            break;\n        }\n        if index == smallest_index\
    \ {\n            break;\n        }\n        smallest_index += 1;\n        smallest\
    \ = index;\n    }\n    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpzij5laoy.rs:19:18\n\
    \   |\n19 |         if index == smallest_index {\n   |                  ^^ no\
    \ implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpzij5laoy.rs:25:10\n   |\n25 |     Some(smallest)\n   |          ^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n25 |     Some(*smallest)\n   |          +\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().cloned().enumerate().find(|(_, i)| i < lst.len()\
    \ - 2).map(|(_, i)| lst[i + 1])\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_0dr2sq5.rs:13:55\n   |\n\
    13 |     lst.iter().cloned().enumerate().find(|(_, i)| i < lst.len() - 2).map(|(_,\
    \ i)| lst[i + 1])\n   |                                                      \
    \ ^^^^^^^^^^^^^ expected `&isize`, found `usize`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp_0dr2sq5.rs:13:83\n   |\n13 |  \
    \   lst.iter().cloned().enumerate().find(|(_, i)| i < lst.len() - 2).map(|(_,\
    \ i)| lst[i + 1])\n   |                                                      \
    \                             ^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        smallest_index = 0;\n    }\n    Some(smallest)\n}\n\
    \nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdip3dbce.rs:21:10\n   |\n\
    21 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n21 |     Some(*smallest)\n\
    \   |          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n   \
    \ if smallest_index == lst.len() {\n        return None;\n    }\n    smallest\
    \ = lst.iter().skip(smallest_index).min().unwrap();\n    smallest_index = lst.iter().position(|x|\
    \ *x == smallest).unwrap();\n    if smallest_index == lst.len() {\n        return\
    \ None;\n    }\n    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn0pet1nj.rs:14:60\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|x| *x == *smallest).unwrap();\n\
    \   |                                                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpn0pet1nj.rs:19:52\n   |\n19 |     smallest_index\
    \ = lst.iter().position(|x| *x == smallest).unwrap();\n   |                  \
    \                                  ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n19 |     smallest_index\
    \ = lst.iter().position(|x| *x == *smallest).unwrap();\n   |                 \
    \                                   +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpn0pet1nj.rs:23:10\n   |\n23 |     Some(smallest)\n   |          ^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n23 |     Some(*smallest)\n   |          +\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n   \
    \ if smallest_index == lst.len() {\n        return None;\n    }\n    smallest\
    \ = lst.iter().nth(smallest_index).unwrap();\n    Some(smallest)\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmtw_idze.rs:14:60\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|x| *x == *smallest).unwrap();\n\
    \   |                                                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmtw_idze.rs:19:10\n   |\n19 |     Some(smallest)\n\
    \   |          ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n19 |     Some(*smallest)\n   |          +\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    for\
    \ elt in lst {\n        if smallest[0] < elt {\n            smallest[0] = elt;\n\
    \        }\n        if smallest[1] < elt {\n            smallest[1] = elt;\n \
    \       }\n    }\n    if smallest[0] == std::i32::MAX {\n        None\n    } else\
    \ {\n        Some(smallest[1])\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm76sdb4z.rs:15:26\n   |\n\
    15 |         if smallest[0] < elt {\n   |                          ^^^ expected\
    \ `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an `i32` and\
    \ panic if the converted value doesn't fit\n   |\n15 |         if smallest[0]\
    \ < elt.try_into().unwrap() {\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpm76sdb4z.rs:16:27\n   |\n16 |\
    \             smallest[0] = elt;\n   |             -----------   ^^^ expected\
    \ `i32`, found `isize`\n   |             |\n   |             expected due to the\
    \ type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm76sdb4z.rs:18:26\n\
    \   |\n18 |         if smallest[1] < elt {\n   |                          ^^^\
    \ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n18 |         if smallest[1]\
    \ < elt.try_into().unwrap() {\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpm76sdb4z.rs:19:27\n   |\n19 |\
    \             smallest[1] = elt;\n   |             -----------   ^^^ expected\
    \ `i32`, found `isize`\n   |             |\n   |             expected due to the\
    \ type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm76sdb4z.rs:25:14\n\
    \   |\n25 |         Some(smallest[1])\n   |              ^^^^^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n25 |         Some(smallest[1].try_into().unwrap())\n\
    \   |                         ++++++++++++++++++++\n\nerror: aborting due to 5\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    for\
    \ &x in lst {\n        if *x < smallest[0] {\n            smallest[0] = x;\n \
    \       }\n        if *x > smallest[1] {\n            smallest[1] = x;\n     \
    \   }\n    }\n    smallest.iter().cloned().next()\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp059sunof.rs:14:9\n   |\n\
    14 |     for &x in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp059sunof.rs:22:5\n   |\n12 | fn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n   |                                      -------------\
    \ expected `Option<isize>` because of return type\n...\n22 |     smallest.iter().cloned().next()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `i32`\n   |\n\
    \   = note: expected enum `Option<isize>`\n              found enum `Option<i32>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![0; lst.len()];\n    let mut\
    \ smallest_idx = -1;\n    for idx in lst.iter().rev() {\n        if smallest[idx]\
    \ < smallest[smallest_idx] {\n            smallest_idx = idx;\n        }\n   \
    \     smallest[idx] += 1;\n    }\n    if smallest_idx == -1 { None } else { Some(smallest[smallest_idx])\
    \ }\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[{integer}]` cannot be indexed by `&isize`\n  -->\
    \ /tmp/tmpha7oazzb.rs:16:12\n   |\n16 |         if smallest[idx] < smallest[smallest_idx]\
    \ {\n   |            ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<{integer}>`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpha7oazzb.rs:14:28\n   |\n14 |     let mut smallest_idx = -1;\n\
    \   |                            ^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n        \
    \     &i32\n             &i64\n             &i8\n             &isize\n       \
    \    and 8 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpha7oazzb.rs:17:28\n\
    \   |\n14 |     let mut smallest_idx = -1;\n   |                            --\
    \ expected due to this value\n...\n17 |             smallest_idx = idx;\n   |\
    \                            ^^^ expected `usize`, found `&isize`\n\nerror[E0277]:\
    \ the type `[{integer}]` cannot be indexed by `&isize`\n  --> /tmp/tmpha7oazzb.rs:19:9\n\
    \   |\n19 |         smallest[idx] += 1;\n   |         ^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<{integer}>`\n\nerror[E0600]: cannot apply unary operator\
    \ `-` to type `usize`\n  --> /tmp/tmpha7oazzb.rs:21:24\n   |\n21 |     if smallest_idx\
    \ == -1 { None } else { Some(smallest[smallest_idx]) }\n   |                 \
    \       ^^\n   |                        |\n   |                        cannot\
    \ apply unary operator `-`\n   |                        help: you may have meant\
    \ the"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        smallest_index = 0;\n    }\n    Some(smallest)\n}\n\
    \nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdip3dbce.rs:21:10\n   |\n\
    21 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n21 |     Some(*smallest)\n\
    \   |          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min();\n    let mut smallest_index\
    \ = 0;\n    for index in lst.iter().rev() {\n        if index == smallest {\n\
    \            smallest_index += 1;\n        }\n        if index > smallest {\n\
    \            break;\n        }\n    }\n    Some(smallest_index)\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `Option<&isize>`\n  --> /tmp/tmpgc7egmn9.rs:16:18\n\
    \   |\n16 |         if index == smallest {\n   |                  ^^ no implementation\
    \ for `&isize == Option<&isize>`\n   |\n   = help: the trait `PartialEq<Option<&isize>>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpgc7egmn9.rs:19:20\n   |\n19 |         if index > smallest {\n   |  \
    \                  ^^^^^^^^ expected `&isize`, found enum `Option`\n   |\n   =\
    \ note: expected reference `&isize`\n                   found enum `Option<&isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min();\n    let mut smallest_idx\
    \ = lst.iter().enumerate().find(|&(i, _)| i == smallest).unwrap();\n    if smallest_idx.next().is_some()\
    \ {\n        smallest_idx\n    } else {\n        None\n    }\n}\n\nfn main() {\n\
    \    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4,\
    \ 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe426iyms.rs:14:71\n   |\n\
    14 |     let mut smallest_idx = lst.iter().enumerate().find(|&(i, _)| i == smallest).unwrap();\n\
    \   |                                                                       ^^^^^^^^\
    \ expected `usize`, found enum `Option`\n   |\n   = note: expected type `usize`\n\
    \              found enum `Option<&isize>`\n\nerror[E0599]: no method named `next`\
    \ found for tuple `(usize, &isize)` in the current scope\n  --> /tmp/tmpe426iyms.rs:15:21\n\
    \   |\n15 |     if smallest_idx.next().is_some() {\n   |                     ^^^^\
    \ method not found in `(usize, &isize)`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpe426iyms.rs:16:9\n   |\n12 | fn next_smallest(lst: Vec<isize>) -> Option<isize>\
    \ {\n   |                                      ------------- expected `Option<isize>`\
    \ because of return type\n...\n16 |         smallest_idx\n   |         ^^^^^^^^^^^^\
    \ expected enum `Option`, found tuple\n   |\n   = note: expected enum `Option<isize>`\n\
    \             found tuple `(usize, &isize)`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().enumerate().find(|(_, i)| i < lst.len() -\
    \ 1).map(|(_, i)| lst[i + 1])\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp96zvlbxk.rs:13:46\n   |\n\
    13 |     lst.iter().enumerate().find(|(_, i)| i < lst.len() - 1).map(|(_, i)|\
    \ lst[i + 1])\n   |                                              ^^^^^^^^^^^^^\
    \ expected `&&isize`, found `usize`\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmp96zvlbxk.rs:13:74\n   |\n13 |     lst.iter().enumerate().find(|(_,\
    \ i)| i < lst.len() - 1).map(|(_, i)| lst[i + 1])\n   |                      \
    \                                                    ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 101
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().cloned().enumerate().find(|(_, elem)| elem\
    \ < lst.iter().skip(1).next().unwrap()).map(|(_, elem)| elem)\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(2)`', /tmp/tmpz511mqrq.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n\n\
    \    let mut smallest = lst.iter().min().unwrap();\n    let mut second_smallest\
    \ = lst.iter().skip(1).min().unwrap();\n\n    if smallest == second_smallest {\n\
    \        return None;\n    }\n\n    Some(second_smallest)\n}\n\nfn main() {\n\
    \    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4,\
    \ 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu4a4u95p.rs:24:10\n   |\n\
    24 |     Some(second_smallest)\n   |          ^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n24 |  \
    \   Some(*second_smallest)\n   |          +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min();\n    if smallest.is_none()\
    \ {\n        return None;\n    }\n    let mut smallest_index = lst.iter().position(|x|\
    \ x == smallest).unwrap();\n    if smallest_index == lst.len() - 1 {\n       \
    \ smallest_index = 0;\n    }\n    Some(smallest[smallest_index + 1])\n}\n\nfn\
    \ main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `Option<&isize>`\n  --> /tmp/tmpidg32rvs.rs:17:56\n\
    \   |\n17 |     let mut smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n\
    \   |                                                        ^^ no implementation\
    \ for `&isize == Option<&isize>`\n   |\n   = help: the trait `PartialEq<Option<&isize>>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0608]: cannot index into a value\
    \ of type `Option<&isize>`\n  --> /tmp/tmpidg32rvs.rs:21:10\n   |\n21 |     Some(smallest[smallest_index\
    \ + 1])\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0608.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().cloned().enumerate().find(|(_, i)| {\n  \
    \      i < lst.len() - 2 && lst[i] < lst[i + 1]\n    }).map(|(_, i)| lst[i + 1])\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgjqbi5wh.rs:14:13\n   |\n\
    14 |         i < lst.len() - 2 && lst[i] < lst[i + 1]\n   |             ^^^^^^^^^^^^^\
    \ expected `&isize`, found `usize`\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `&isize`\n  --> /tmp/tmpgjqbi5wh.rs:14:30\n   |\n14 |        \
    \ i < lst.len() - 2 && lst[i] < lst[i + 1]\n   |                             \
    \ ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help:\
    \ the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpgjqbi5wh.rs:14:39\n\
    \   |\n14 |         i < lst.len() - 2 && lst[i] < lst[i + 1]\n   |           \
    \                            ^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpgjqbi5wh.rs:15:21\n   |\n15 |     }).map(|(_, i)| lst[i + 1])\n\
    \   |                     ^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![lst[0]];\n    let mut smallest_idx\
    \ = 1;\n    for &x in lst {\n        if x < smallest[smallest_idx] {\n       \
    \     smallest[smallest_idx] = x;\n            smallest_idx += 1;\n        }\n\
    \    }\n    if smallest_idx == lst.len() {\n        return None;\n    }\n    Some(smallest[smallest_idx\
    \ - 1])\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgkwjrt2a.rs:15:9\n   |\n\
    15 |     for &x in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_idx =\
    \ lst.iter().position(|&x| x == smallest).unwrap();\n    if smallest_idx == lst.len()\
    \ - 1 {\n        smallest_idx = 0;\n    }\n    Some(smallest)\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxe3qj73r.rs:17:58\n   |\n\
    17 |     let mut smallest_idx = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                          ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    17 |     let mut smallest_idx = lst.iter().position(|&x| x == *smallest).unwrap();\n\
    \   |                                                          +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxe3qj73r.rs:21:10\n   |\n21 |     Some(smallest)\n\
    \   |          ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n21 |     Some(*smallest)\n   |          +\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    for\
    \ elt in lst {\n        if smallest[0] < elt {\n            smallest[0] = elt;\n\
    \        }\n        if smallest[1] < elt {\n            smallest[1] = elt;\n \
    \       }\n    }\n    if smallest[0] == std::i32::MAX {\n        None\n    } else\
    \ {\n        Some(smallest[1])\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm76sdb4z.rs:15:26\n   |\n\
    15 |         if smallest[0] < elt {\n   |                          ^^^ expected\
    \ `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an `i32` and\
    \ panic if the converted value doesn't fit\n   |\n15 |         if smallest[0]\
    \ < elt.try_into().unwrap() {\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpm76sdb4z.rs:16:27\n   |\n16 |\
    \             smallest[0] = elt;\n   |             -----------   ^^^ expected\
    \ `i32`, found `isize`\n   |             |\n   |             expected due to the\
    \ type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm76sdb4z.rs:18:26\n\
    \   |\n18 |         if smallest[1] < elt {\n   |                          ^^^\
    \ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n18 |         if smallest[1]\
    \ < elt.try_into().unwrap() {\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpm76sdb4z.rs:19:27\n   |\n19 |\
    \             smallest[1] = elt;\n   |             -----------   ^^^ expected\
    \ `i32`, found `isize`\n   |             |\n   |             expected due to the\
    \ type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm76sdb4z.rs:25:14\n\
    \   |\n25 |         Some(smallest[1])\n   |              ^^^^^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n25 |         Some(smallest[1].try_into().unwrap())\n\
    \   |                         ++++++++++++++++++++\n\nerror: aborting due to 5\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![0; lst.len()];\n    let mut\
    \ smallest_idx = vec![0; lst.len()];\n    for &x in lst {\n        smallest[smallest_idx[x]]\
    \ = x;\n        smallest_idx[x] += 1;\n    }\n    smallest.iter().enumerate().find(|&(i,\
    \ x)| smallest[i] < x).map(|&(i, x)| smallest[i])\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvsc7sb61.rs:15:9\n   |\n\
    15 |     for &x in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: can't compare\
    \ `{integer}` with `&{integer}`\n  --> /tmp/tmpvsc7sb61.rs:19:60\n   |\n19 | \
    \    smallest.iter().enumerate().find(|&(i, x)| smallest[i] < x).map(|&(i, x)|\
    \ smallest[i])\n   |                                                         \
    \   ^ no implementation for `{integer} < &{integer}` and `{integer} > &{integer}`\n\
    \   |\n   = help: the trait `PartialOrd<&{integer}>` is not implemented for `{integer}`\n\
    \   = help: the following other types implement trait `PartialOrd<Rhs>`:\n   \
    \          f32\n             f64\n             i128\n             i16\n      \
    \       i32\n             i64\n             i8\n             isize\n         \
    \  and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvsc7sb61.rs:19:70\n\
    \   |\n19 |     smallest.iter().enumerate().find(|&(i, x)| smallest[i] < x).map(|&(i,\
    \ x)| smallest[i])\n   |                                                     \
    \                 ^^^^^^-\n   |                                              \
    \                        |     |\n   |                                       \
    \                               |     expected due to this\n   |             \
    \                                                         expected tuple, found\
    \ reference\n   |\n   = note:  expected tuple `(usize, &{integer})`\n        \
    \   found reference `&_`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    for\
    \ x in lst {\n        if x < smallest[0] {\n            smallest[0] = x;\n   \
    \     }\n        if x > smallest[1] {\n            smallest[1] = x;\n        }\n\
    \    }\n    smallest.iter().next()\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8s19p46_.rs:15:16\n   |\n\
    15 |         if x < smallest[0] {\n   |                ^^^^^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n15 |         if x < smallest[0].try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8s19p46_.rs:16:27\n   |\n16 |             smallest[0] =\
    \ x;\n   |             -----------   ^ expected `i32`, found `isize`\n   |   \
    \          |\n   |             expected due to the type of this binding\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8s19p46_.rs:18:16\n   |\n18 |         if x >\
    \ smallest[1] {\n   |                ^^^^^^^^^^^ expected `isize`, found `i32`\n\
    \   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n18 |         if x > smallest[1].try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8s19p46_.rs:19:27\n   |\n19 |             smallest[1] =\
    \ x;\n   |             -----------   ^ expected `i32`, found `isize`\n   |   \
    \          |\n   |             expected due to the type of this binding\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8s19p46_.rs:22:5\n   |\n12 | fn next_smallest(lst:\
    \ Vec<isize>) -> Option<isize> {\n   |                                      -------------\
    \ expected `Option<isize>` because of return type\n...\n22 |     smallest.iter().next()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&i32`\n   |\n   = note:\
    \ expected enum `Option<isize>`\n              found enum `Option<&i32>`\n\nerror:\
    \ aborting due to 5 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    for\
    \ x in lst {\n        if x < smallest[0] {\n            smallest[0] = x;\n   \
    \     }\n        if x > smallest[1] {\n            smallest[1] = x;\n        }\n\
    \    }\n    if smallest[0] == smallest[1] {\n        None\n    } else {\n    \
    \    Some(smallest[1])\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2rg34bzy.rs:15:16\n   |\n\
    15 |         if x < smallest[0] {\n   |                ^^^^^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n15 |         if x < smallest[0].try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2rg34bzy.rs:16:27\n   |\n16 |             smallest[0] =\
    \ x;\n   |             -----------   ^ expected `i32`, found `isize`\n   |   \
    \          |\n   |             expected due to the type of this binding\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2rg34bzy.rs:18:16\n   |\n18 |         if x >\
    \ smallest[1] {\n   |                ^^^^^^^^^^^ expected `isize`, found `i32`\n\
    \   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n18 |         if x > smallest[1].try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2rg34bzy.rs:19:27\n   |\n19 |             smallest[1] =\
    \ x;\n   |             -----------   ^ expected `i32`, found `isize`\n   |   \
    \          |\n   |             expected due to the type of this binding\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2rg34bzy.rs:25:14\n   |\n25 |         Some(smallest[1])\n\
    \   |              ^^^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you\
    \ can convert an `i32` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n25 |         Some(smallest[1].try_into().unwrap())\n   |        \
    \                 ++++++++++++++++++++\n\nerror: aborting due to 5 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().enumerate().find(|(_, elem)| elem < lst.iter().skip(1).next().unwrap()).map(|(_,\
    \ elem)| elem)\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwo3houis.rs:13:52\n   |\n\
    13 |     lst.iter().enumerate().find(|(_, elem)| elem < lst.iter().skip(1).next().unwrap()).map(|(_,\
    \ elem)| elem)\n   |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `isize`\n   |\n   = note: expected reference `&&isize`\n\
    \              found reference `&isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpwo3houis.rs:13:5\n   |\n12 | fn next_smallest(lst: Vec<isize>) -> Option<isize>\
    \ {\n   |                                      ------------- expected `Option<isize>`\
    \ because of return type\n13 |     lst.iter().enumerate().find(|(_, elem)| elem\
    \ < lst.iter().skip(1).next().unwrap()).map(|(_, elem)| elem)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found enum `Option<&isize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n    if\
    \ smallest_index == lst.len() {\n        return None;\n    }\n    let mut smallest_value\
    \ = lst.iter().nth(smallest_index).unwrap();\n    smallest_index += 1;\n    if\
    \ smallest_index == lst.len() {\n        smallest_index = 0;\n    }\n    Some(smallest_value)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp44sy4w6p.rs:23:10\n   |\n\
    23 |     Some(smallest_value)\n   |          ^^^^^^^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n23 |  \
    \   Some(*smallest_value)\n   |          +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = 0;\n    for &i in lst {\n        if *i < smallest {\n \
    \           smallest = i;\n            smallest_index = i;\n        }\n    }\n\
    \    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n  \
    \  assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpypb7_sx8.rs:15:9\n   |\n\
    15 |     for &i in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpypb7_sx8.rs:21:10\n   |\n21 |     Some(smallest)\n   |        \
    \  ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n21 |     Some(*smallest)\n   |          +\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().cloned().enumerate().find(|(_, i)| i.1 <\
    \ i.2).map(|(_, i)| i.1).unwrap_or(None)\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `1` on type `&isize`\n  --> /tmp/tmp_foehh8f.rs:13:53\n\
    \   |\n13 |     lst.iter().cloned().enumerate().find(|(_, i)| i.1 < i.2).map(|(_,\
    \ i)| i.1).unwrap_or(None)\n   |                                             \
    \        ^\n\nerror[E0609]: no field `2` on type `&isize`\n  --> /tmp/tmp_foehh8f.rs:13:59\n\
    \   |\n13 |     lst.iter().cloned().enumerate().find(|(_, i)| i.1 < i.2).map(|(_,\
    \ i)| i.1).unwrap_or(None)\n   |                                             \
    \              ^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't\
    \ have fields\n  --> /tmp/tmp_foehh8f.rs:13:77\n   |\n13 |     lst.iter().cloned().enumerate().find(|(_,\
    \ i)| i.1 < i.2).map(|(_, i)| i.1).unwrap_or(None)\n   |                     \
    \                                                        ^\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0609, E0610.\n\
    For more information about an error, try `rustc --explain E0609`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    for\
    \ x in lst {\n        if smallest[0] < x {\n            smallest[0] = x;\n   \
    \     }\n        if smallest[1] < x {\n            smallest[1] = x;\n        }\n\
    \    }\n    if smallest[0] == std::i32::MAX {\n        None\n    } else {\n  \
    \      Some(smallest[1])\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphstkm6vb.rs:15:26\n   |\n\
    15 |         if smallest[0] < x {\n   |                          ^ expected `i32`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to an `i32` and panic\
    \ if the converted value doesn't fit\n   |\n15 |         if smallest[0] < x.try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphstkm6vb.rs:16:27\n   |\n16 |             smallest[0] =\
    \ x;\n   |             -----------   ^ expected `i32`, found `isize`\n   |   \
    \          |\n   |             expected due to the type of this binding\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphstkm6vb.rs:18:26\n   |\n18 |         if smallest[1]\
    \ < x {\n   |                          ^ expected `i32`, found `isize`\n   |\n\
    help: you can convert an `isize` to an `i32` and panic if the converted value\
    \ doesn't fit\n   |\n18 |         if smallest[1] < x.try_into().unwrap() {\n \
    \  |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphstkm6vb.rs:19:27\n   |\n19 |             smallest[1] =\
    \ x;\n   |             -----------   ^ expected `i32`, found `isize`\n   |   \
    \          |\n   |             expected due to the type of this binding\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphstkm6vb.rs:25:14\n   |\n25 |         Some(smallest[1])\n\
    \   |              ^^^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you\
    \ can convert an `i32` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n25 |         Some(smallest[1].try_into().unwrap())\n   |        \
    \                 ++++++++++++++++++++\n\nerror: aborting due to 5 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![0; lst.len()];\n    let mut\
    \ smallest_idx = lst.len();\n    let mut smallest_val = lst.len();\n    for &x\
    \ in lst {\n        if x < smallest_val {\n            smallest_val = x;\n   \
    \         smallest_idx = lst.iter().position(|&x| x == smallest_val);\n      \
    \  }\n        smallest[smallest_idx] = x;\n    }\n    smallest.iter().position(|&x|\
    \ x == smallest_val).map(|i| smallest[i])\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmhp9v90n.rs:16:9\n   |\n\
    16 |     for &x in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmhp9v90n.rs:19:58\n   |\n19 |             smallest_idx = lst.iter().position(|&x|\
    \ x == smallest_val);\n   |                                                  \
    \        ^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    19 |             smallest_idx = lst.iter().position(|&x| x == smallest_val.try_into().unwrap());\n\
    \   |                                                                      ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpmhp9v90n.rs:19:28\n   |\n14 |\
    \     let mut smallest_idx = lst.len();\n   |                            ---------\
    \ expected due to this value\n...\n19 |             smallest_idx = lst.iter().position(|&x|\
    \ x == smallest_val);\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found enum `Option`\n   |\n   = note: expected type `usize`\n\
    \              found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmhp9v90n.rs:23:5\n   |\n12 | fn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n   |                                      -------------\
    \ expected `Option<isize>` because of return type\n...\n23 |     smallest.iter().position(|&x|\
    \ x == smallest_val).map(|i| smallest[i])\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found enum `Option<usize>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_idx = lst.iter().position(|x| x == smallest).unwrap();\n    if\
    \ smallest_idx == lst.len() {\n        return None;\n    }\n    let mut smallest_val\
    \ = lst.iter().nth(smallest_idx).unwrap();\n    if smallest_val < smallest {\n\
    \        smallest = smallest_val;\n        smallest_idx = smallest_idx;\n    }\n\
    \    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n  \
    \  assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgw_7c90n.rs:23:10\n   |\n\
    23 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n23 |     Some(*smallest)\n\
    \   |          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    let\
    \ mut smallest_idx = 1;\n    for &x in lst {\n        if x < smallest[smallest_idx]\
    \ {\n            smallest[smallest_idx] = x;\n            smallest_idx += 1;\n\
    \        }\n    }\n    if smallest_idx == 2 {\n        Some(smallest[1])\n   \
    \ } else {\n        None\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjy442w7k.rs:15:9\n   |\n\
    15 |     for &x in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjy442w7k.rs:22:14\n   |\n22 |         Some(smallest[1])\n   | \
    \             ^^^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    22 |         Some(smallest[1].try_into().unwrap())\n   |                     \
    \    ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min();\n    let mut smallest_index = lst.iter().position(|x|\
    \ x == smallest);\n    if smallest_index == lst.len() {\n        return None;\n\
    \    }\n    let mut second_smallest = lst.iter().skip(smallest_index + 1).min();\n\
    \    if second_smallest == smallest {\n        return None;\n    }\n    Some(second_smallest)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `Option<&isize>`\n  --> /tmp/tmpqw8xl1r5.rs:17:56\n\
    \   |\n17 |     let mut smallest_index = lst.iter().position(|x| x == smallest);\n\
    \   |                                                        ^^ no implementation\
    \ for `&isize == Option<&isize>`\n   |\n   = help: the trait `PartialEq<Option<&isize>>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpqw8xl1r5.rs:18:26\n   |\n18 |     if smallest_index == lst.len() {\n\
    \   |                          ^^^^^^^^^ expected enum `Option`, found `usize`\n\
    \   |\n   = note: expected enum `Option<usize>`\n              found type `usize`\n\
    help: try wrapping the expression in `Some`\n   |\n18 |     if smallest_index\
    \ == Some(lst.len()) {\n   |                          +++++         +\n\nerror[E0369]:\
    \ cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmpqw8xl1r5.rs:21:62\n\
    \   |\n21 |     let mut second_smallest = lst.iter().skip(smallest_index + 1).min();\n\
    \   |                                               -------------- ^ - {integer}\n\
    \   |                                               |\n   |                  \
    \                             Option<usize>\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqw8xl1r5.rs:25:10\n   |\n25 |     Some(second_smallest)\n   | \
    \         ^^^^^^^^^^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note:\
    \ expected type `isize`\n              found enum `Option<&isize>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0369.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min_by_key(|x| x).unwrap();\n\
    \    if smallest.is_none() {\n        return None;\n    }\n    let mut smallest_index\
    \ = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        smallest_index = 0;\n    }\n    Some(smallest[smallest_index\
    \ + 1])\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_none` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmpxv9s9g6b.rs:14:17\n   |\n14 |     if smallest.is_none()\
    \ {\n   |                 ^^^^^^^ method not found in `&isize`\n\nerror[E0608]:\
    \ cannot index into a value of type `&isize`\n  --> /tmp/tmpxv9s9g6b.rs:21:10\n\
    \   |\n21 |     Some(smallest[smallest_index + 1])\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0608.\nFor more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    for\
    \ elt in lst {\n        if elt < smallest[0] {\n            smallest[0] = elt;\n\
    \        }\n        if elt < smallest[1] {\n            smallest[1] = elt;\n \
    \       }\n    }\n    smallest.iter().next().map(|elt| elt)\n}\n\nfn main() {\n\
    \    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4,\
    \ 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjaeogtdn.rs:15:18\n   |\n\
    15 |         if elt < smallest[0] {\n   |                  ^^^^^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n15 |         if elt < smallest[0].try_into().unwrap()\
    \ {\n   |                             ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjaeogtdn.rs:16:27\n   |\n16 |             smallest[0] =\
    \ elt;\n   |             -----------   ^^^ expected `i32`, found `isize`\n   |\
    \             |\n   |             expected due to the type of this binding\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpjaeogtdn.rs:18:18\n   |\n18 |  \
    \       if elt < smallest[1] {\n   |                  ^^^^^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n18 |         if elt < smallest[1].try_into().unwrap()\
    \ {\n   |                             ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjaeogtdn.rs:19:27\n   |\n19 |             smallest[1] =\
    \ elt;\n   |             -----------   ^^^ expected `i32`, found `isize`\n   |\
    \             |\n   |             expected due to the type of this binding\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpjaeogtdn.rs:22:5\n   |\n12 | fn\
    \ next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |                    \
    \                  ------------- expected `Option<isize>` because of return type\n\
    ...\n22 |     smallest.iter().next().map(|elt| elt)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&i32`\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found enum `Option<&i32>`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n    if\
    \ smallest_index == lst.len() {\n        return None;\n    }\n    let mut second_smallest\
    \ = lst.iter().skip(smallest_index + 1).min().unwrap();\n    let mut second_smallest_index\
    \ = lst.iter().position(|x| x == second_smallest).unwrap();\n    if second_smallest_index\
    \ == lst.len() {\n        return None;\n    }\n    Some(second_smallest)\n}\n\n\
    fn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_rq09_xt.rs:23:10\n   |\n\
    23 |     Some(second_smallest)\n   |          ^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n23 |  \
    \   Some(*second_smallest)\n   |          +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![0; lst.len()];\n    let mut\
    \ smallest_idx = vec![0; lst.len()];\n    let mut smallest_val = vec![0; lst.len()];\n\
    \    for &i in lst {\n        smallest[i] += i;\n        smallest_idx[i] += 1;\n\
    \        smallest_val[i] = i;\n    }\n    for i in 0..lst.len() {\n        if\
    \ smallest[i] < smallest_val[smallest_idx[i]] {\n            smallest_idx[i] =\
    \ 0;\n            smallest_val[i] = smallest[i];\n        }\n    }\n    smallest_idx[lst.len()-1]\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbo4w6r60.rs:16:9\n   |\n\
    16 |     for &i in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbo4w6r60.rs:27:5\n   |\n12 | fn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n   |                                      -------------\
    \ expected `Option<isize>` because of return type\n...\n27 |     smallest_idx[lst.len()-1]\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`, found `usize`\n  \
    \ |\n   = note: expected enum `Option<isize>`\n              found type `usize`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    let\
    \ mut smallest_idx = 0;\n    for &i in lst {\n        if *i < smallest[smallest_idx]\
    \ {\n            smallest[smallest_idx] = *i;\n            smallest_idx += 1;\n\
    \        }\n    }\n    if smallest_idx == 0 {\n        None\n    } else {\n  \
    \      Some(smallest[smallest_idx - 1])\n    }\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwz75dsfm.rs:15:9\n   |\n\
    15 |     for &i in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwz75dsfm.rs:24:14\n   |\n24 |         Some(smallest[smallest_idx\
    \ - 1])\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n24 |         Some(smallest[smallest_idx - 1].try_into().unwrap())\n\
    \   |                                        ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min();\n    if smallest.is_none()\
    \ {\n        return None;\n    }\n    let mut smallest_idx = lst.iter().position(|&x|\
    \ x == smallest).unwrap();\n    if smallest_idx == lst.len() - 1 {\n        return\
    \ Some(smallest);\n    }\n    let mut smallest_next = lst.iter().skip(smallest_idx\
    \ + 1).min();\n    if smallest_next.is_none() {\n        return Some(smallest);\n\
    \    }\n    if smallest == smallest_next {\n        smallest_idx += 1;\n    }\n\
    \    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n  \
    \  assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp95c26iru.rs:17:58\n   |\n\
    17 |     let mut smallest_idx = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                          ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp95c26iru.rs:19:21\n   |\n19 |         return Some(smallest);\n   | \
    \                    ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n  \
    \ = note: expected type `isize`\n              found enum `Option<&isize>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp95c26iru.rs:23:21\n   |\n23 |  \
    \       return Some(smallest);\n   |                     ^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp95c26iru.rs:28:10\n\
    \   |\n28 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<&isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n   \
    \ if smallest_index == lst.len() {\n        return None;\n    }\n    let mut second_smallest\
    \ = lst.iter().skip(smallest_index).min().unwrap();\n    let mut second_smallest_index\
    \ = lst.iter().position(|x| *x == second_smallest).unwrap();\n    if second_smallest_index\
    \ == lst.len() {\n        return None;\n    }\n    Some(second_smallest)\n}\n\n\
    fn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf96dkj7e.rs:14:60\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|x| *x == *smallest).unwrap();\n\
    \   |                                                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf96dkj7e.rs:19:67\n   |\n19 |     let mut second_smallest_index\
    \ = lst.iter().position(|x| *x == second_smallest).unwrap();\n   |           \
    \                                                        ^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    19 |     let mut second_smallest_index = lst.iter().position(|x| *x == *second_smallest).unwrap();\n\
    \   |                                                                   +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpf96dkj7e.rs:23:10\n   |\n23 |  \
    \   Some(second_smallest)\n   |          ^^^^^^^^^^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n23 |     Some(*second_smallest)\n\
    \   |          +\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = 0;\n    for &x in lst {\n        if x < smallest {\n  \
    \          smallest = x;\n            smallest_index = lst.iter().position(|&x|\
    \ x == smallest).unwrap();\n        }\n    }\n    Some(smallest)\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkit71k9x.rs:15:9\n   |\n\
    15 |     for &x in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkit71k9x.rs:18:60\n   |\n18 |             smallest_index = lst.iter().position(|&x|\
    \ x == smallest).unwrap();\n   |                                             \
    \               ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n18 |             smallest_index = lst.iter().position(|&x|\
    \ x == *smallest).unwrap();\n   |                                            \
    \                +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkit71k9x.rs:21:10\n\
    \   |\n21 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n21 |     Some(*smallest)\n\
    \   |          +\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min();\n    if smallest\
    \ == lst.len() {\n        return None;\n    }\n    let mut smallest_index = smallest;\n\
    \    let mut smallest_value = lst.iter().nth(smallest).unwrap();\n    for index\
    \ in lst.iter().skip(smallest + 1) {\n        if lst.iter().nth(index).unwrap()\
    \ < smallest_value {\n            smallest_value = lst.iter().nth(index).unwrap();\n\
    \            smallest_index = index;\n        }\n    }\n    Some(smallest_index)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3udt8c8v.rs:14:20\n   |\n\
    14 |     if smallest == lst.len() {\n   |                    ^^^^^^^^^ expected\
    \ enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<&isize>`\n\
    \              found type `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3udt8c8v.rs:18:45\n\
    \   |\n18 |     let mut smallest_value = lst.iter().nth(smallest).unwrap();\n\
    \   |                                             ^^^^^^^^ expected `usize`, found\
    \ enum `Option`\n   |\n   = note: expected type `usize`\n              found enum\
    \ `Option<&isize>`\n\nerror[E0369]: cannot add `{integer}` to `Option<&isize>`\n\
    \  --> /tmp/tmp3udt8c8v.rs:19:43\n   |\n19 |     for index in lst.iter().skip(smallest\
    \ + 1) {\n   |                                  -------- ^ - {integer}\n   | \
    \                                 |\n   |                                  Option<&isize>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3udt8c8v.rs:20:27\n   |\n20 |\
    \         if lst.iter().nth(index).unwrap() < smallest_value {\n   |         \
    \                  ^^^^^ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3udt8c8v.rs:21:45\n   |\n21 |             smallest_value\
    \ = lst.iter().nth(index).unwrap();\n   |                                    \
    \         ^^^^^ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3udt8c8v.rs:22:30\n   |\n17 |     let mut smallest_index = smallest;\n\
    \   |                              -------- expected due to this value\n...\n\
    22 |             smallest_index = index;\n   |                              ^^^^^\
    \ expected enum `Option`, found `&isize`\n   |\n   = note:   expected enum `Option<&isize>`\n\
    \           found reference `&isize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n22 |             smallest_index = Some(index);\n   |                  \
    \            +++++     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3udt8c8v.rs:25:10\n\
    \   |\n25 |     Some(smallest_index)\n   |          ^^^^^^^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n         "
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_idx = lst.iter().position(|x| x == smallest).unwrap();\n    if\
    \ smallest_idx == lst.len() {\n        return None;\n    }\n    let mut second_smallest\
    \ = lst.iter().skip(smallest_idx + 1).min().unwrap();\n    if second_smallest\
    \ == smallest {\n        return None;\n    }\n    Some(second_smallest)\n}\n\n\
    fn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp17gnlqd4.rs:22:10\n   |\n\
    22 |     Some(second_smallest)\n   |          ^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n22 |  \
    \   Some(*second_smallest)\n   |          +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    let\
    \ mut smallest_idx = 1;\n    for &i in lst {\n        if *i < smallest[smallest_idx]\
    \ {\n            smallest[smallest_idx] = *i;\n            smallest_idx += 1;\n\
    \        }\n    }\n    if smallest_idx == 2 {\n        Some(smallest[1])\n   \
    \ } else {\n        None\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8b08e2rf.rs:15:9\n   |\n\
    15 |     for &i in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8b08e2rf.rs:22:14\n   |\n22 |         Some(smallest[1])\n   | \
    \             ^^^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    22 |         Some(smallest[1].try_into().unwrap())\n   |                     \
    \    ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min();\n    if smallest.is_none()\
    \ {\n        return None;\n    }\n    let mut smallest_index = lst.iter().position(|&x|\
    \ x == smallest).unwrap();\n    if smallest_index == lst.len() - 1 {\n       \
    \ smallest_index = 0;\n    }\n    Some(smallest[smallest_index + 1])\n}\n\nfn\
    \ main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsvf_sz_4.rs:17:60\n   |\n\
    17 |     let mut smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<&isize>`\n\nerror[E0608]: cannot index into a value\
    \ of type `Option<&isize>`\n  --> /tmp/tmpsvf_sz_4.rs:21:10\n   |\n21 |     Some(smallest[smallest_index\
    \ + 1])\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0308, E0608.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n\n\
    \    let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        smallest_index = 0;\n    }\n\n    Some(smallest)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1bfk9vra.rs:23:10\n   |\n\
    23 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n23 |     Some(*smallest)\n\
    \   |          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    for\
    \ x in lst {\n        if *x < smallest[0] {\n            smallest[0] = x;\n  \
    \      }\n        if *x > smallest[1] {\n            smallest[1] = x;\n      \
    \  }\n    }\n    smallest.iter().next().map(|x| x).ok()\n}\n\nfn main() {\n  \
    \  let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]),\
    \ Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp46hh28tj.rs:15:12\n\
    \   |\n15 |         if *x < smallest[0] {\n   |            ^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp46hh28tj.rs:16:27\n   |\n16 |             smallest[0]\
    \ = x;\n   |             -----------   ^ expected `i32`, found `isize`\n   | \
    \            |\n   |             expected due to the type of this binding\n\n\
    error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp46hh28tj.rs:18:12\n\
    \   |\n18 |         if *x > smallest[1] {\n   |            ^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp46hh28tj.rs:19:27\n   |\n19 |             smallest[1]\
    \ = x;\n   |             -----------   ^ expected `i32`, found `isize`\n   | \
    \            |\n   |             expected due to the type of this binding\n\n\
    error[E0599]: no method named `ok` found for enum `Option` in the current scope\n\
    \  --> /tmp/tmp46hh28tj.rs:22:39\n   |\n22 |     smallest.iter().next().map(|x|\
    \ x).ok()\n   |                                       ^^ help: there is an associated\
    \ function with a similar name: `or`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().cloned().enumerate().find(|(i, e)| {\n  \
    \      e < lst.len() && e != i\n    }).map(|(i, e)| lst.iter().skip(i).next().unwrap())\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphqdykfou.rs:14:13\n   |\n\
    14 |         e < lst.len() && e != i\n   |             ^^^^^^^^^ expected `&isize`,\
    \ found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphqdykfou.rs:14:31\n\
    \   |\n14 |         e < lst.len() && e != i\n   |                            \
    \   ^ expected `isize`, found `usize`\n\nerror[E0277]: can't compare `isize` with\
    \ `usize`\n  --> /tmp/tmphqdykfou.rs:14:28\n   |\n14 |         e < lst.len() &&\
    \ e != i\n   |                            ^^ no implementation for `isize == usize`\n\
    \   |\n   = help: the trait `PartialEq<usize>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n   = note: required because of the requirements on the impl of\
    \ `PartialEq<&usize>` for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphqdykfou.rs:13:5\n\
    \   |\n12 |   fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |     \
    \                                   ------------- expected `Option<isize>` because\
    \ of return type\n13 | /     lst.iter().cloned().enumerate().find(|(i, e)| {\n\
    14 | |         e < lst.len() && e != i\n15 | |     }).map(|(i, e)| lst.iter().skip(i).next().unwrap())\n\
    \   | |_______________________________________________________^ expected `isize`,\
    \ found `&isize`\n   |\n   = note: expected enum `Option<isize>`\n           \
    \   found enum `Option<&isize>`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    let\
    \ mut smallest_idx = 1;\n    for elt in lst {\n        if smallest[smallest_idx]\
    \ < elt {\n            smallest[smallest_idx] = elt;\n            smallest_idx\
    \ += 1;\n        }\n    }\n    if smallest_idx == 2 {\n        Some(smallest[1])\n\
    \    } else {\n        None\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphn6brf1b.rs:16:37\n   |\n\
    16 |         if smallest[smallest_idx] < elt {\n   |                         \
    \            ^^^ expected `i32`, found `isize`\n   |\nhelp: you can convert an\
    \ `isize` to an `i32` and panic if the converted value doesn't fit\n   |\n16 |\
    \         if smallest[smallest_idx] < elt.try_into().unwrap() {\n   |        \
    \                                ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphn6brf1b.rs:17:38\n   |\n17 |             smallest[smallest_idx]\
    \ = elt;\n   |             ----------------------   ^^^ expected `i32`, found\
    \ `isize`\n   |             |\n   |             expected due to the type of this\
    \ binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphn6brf1b.rs:22:14\n\
    \   |\n22 |         Some(smallest[1])\n   |              ^^^^^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n22 |         Some(smallest[1].try_into().unwrap())\n\
    \   |                         ++++++++++++++++++++\n\nerror: aborting due to 3\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n    if\
    \ smallest_index == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().nth(smallest_index).unwrap();\n\
    \    smallest_index += 1;\n    Some(smallest)\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6jdvao_t.rs:20:10\n   |\n\
    20 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n20 |     Some(*smallest)\n\
    \   |          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min();\n    if smallest.is_none()\
    \ {\n        return None;\n    }\n    let mut smallest_idx = lst.iter().position(|&x|\
    \ x == smallest).unwrap();\n    if smallest_idx == lst.len() - 1 {\n        return\
    \ Some(smallest);\n    }\n    let mut smallest_next = lst.iter().skip(smallest_idx\
    \ + 1).min();\n    if smallest_next.is_none() {\n        return Some(smallest);\n\
    \    }\n    if smallest == smallest_next {\n        return Some(smallest);\n \
    \   }\n    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwhpmruwr.rs:17:58\n   |\n\
    17 |     let mut smallest_idx = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                          ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpwhpmruwr.rs:19:21\n   |\n19 |         return Some(smallest);\n   | \
    \                    ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n  \
    \ = note: expected type `isize`\n              found enum `Option<&isize>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpwhpmruwr.rs:23:21\n   |\n23 |  \
    \       return Some(smallest);\n   |                     ^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwhpmruwr.rs:26:21\n\
    \   |\n26 |         return Some(smallest);\n   |                     ^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwhpmruwr.rs:28:10\n   |\n28 |     Some(smallest)\n   |        \
    \  ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected type\
    \ `isize`\n              found enum `Option<&isize>`\n\nerror: aborting due to\
    \ 5 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n   \
    \ if smallest_index == lst.len() {\n        return None;\n    }\n    let mut smallest_value\
    \ = lst.iter().nth(smallest_index).unwrap();\n    let mut smallest_index2 = lst.iter().position(|x|\
    \ *x == smallest_value).unwrap();\n    if smallest_index2 == lst.len() {\n   \
    \     return None;\n    }\n    let mut smallest_value2 = lst.iter().nth(smallest_index2).unwrap();\n\
    \    if smallest_value2 < smallest {\n        smallest = smallest_value2;\n  \
    \      smallest_index = smallest_index2;\n    }\n    Some(smallest)\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmucyjxbc.rs:14:60\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|x| *x == *smallest).unwrap();\n\
    \   |                                                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmucyjxbc.rs:19:61\n   |\n19 |     let mut smallest_index2\
    \ = lst.iter().position(|x| *x == smallest_value).unwrap();\n   |            \
    \                                                 ^^^^^^^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n19 |  \
    \   let mut smallest_index2 = lst.iter().position(|x| *x == *smallest_value).unwrap();\n\
    \   |                                                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmucyjxbc.rs:28:10\n   |\n28 |     Some(smallest)\n\
    \   |          ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n28 |     Some(*smallest)\n   |          +\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        smallest_index = 0;\n    }\n    Some(smallest * smallest_index\
    \ + 1)\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvds3m0_g.rs:21:21\n   |\n\
    21 |     Some(smallest * smallest_index + 1)\n   |                     ^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n\nerror[E0277]: cannot multiply `&isize` by\
    \ `usize`\n  --> /tmp/tmpvds3m0_g.rs:21:19\n   |\n21 |     Some(smallest * smallest_index\
    \ + 1)\n   |                   ^ no implementation for `&isize * usize`\n   |\n\
    \   = help: the trait `Mul<usize>` is not implemented for `&isize`\n   = help:\
    \ the following other types implement trait `Mul<Rhs>`:\n             <&'a f32\
    \ as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n             <&'a i128 as\
    \ Mul<i128>>\n             <&'a i16 as Mul<i16>>\n             <&'a i32 as Mul<i32>>\n\
    \             <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n      \
    \       <&'a isize as Mul<isize>>\n           and 49 others\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    let\
    \ mut smallest_idx = 1;\n    for &i in lst {\n        if *i < smallest[smallest_idx]\
    \ {\n            smallest[smallest_idx] = *i;\n            smallest_idx += 1;\n\
    \        }\n    }\n    if smallest_idx == 2 {\n        Some(smallest[1])\n   \
    \ } else {\n        None\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8b08e2rf.rs:15:9\n   |\n\
    15 |     for &i in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8b08e2rf.rs:22:14\n   |\n22 |         Some(smallest[1])\n   | \
    \             ^^^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    22 |         Some(smallest[1].try_into().unwrap())\n   |                     \
    \    ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min();\n    if smallest\
    \ == lst.len() {\n        return None;\n    }\n    let mut smallest_index = lst.iter().position(|&x|\
    \ x == smallest).unwrap();\n    if smallest_index == 0 {\n        return None;\n\
    \    }\n    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph_jrn15c.rs:14:20\n   |\n\
    14 |     if smallest == lst.len() {\n   |                    ^^^^^^^^^ expected\
    \ enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<&isize>`\n\
    \              found type `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph_jrn15c.rs:17:60\n\
    \   |\n17 |     let mut smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmph_jrn15c.rs:21:10\n   |\n21 |     Some(smallest)\n   |          ^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<&isize>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min();\n    let mut smallest_index\
    \ = lst.iter().position(|x| *x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() {\n        return None;\n    }\n    let mut second_smallest = lst.iter().skip(smallest_index).min();\n\
    \    if second_smallest == smallest {\n        return None;\n    }\n    Some(second_smallest)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3qhyx741.rs:14:60\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp3qhyx741.rs:22:10\n   |\n22 |     Some(second_smallest)\n   |      \
    \    ^^^^^^^^^^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected\
    \ type `isize`\n              found enum `Option<&isize>`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    for\
    \ x in lst {\n        if *x < smallest[0] {\n            smallest[0] = x;\n  \
    \      }\n        if *x > smallest[1] {\n            smallest[1] = x;\n      \
    \  }\n    }\n    if smallest[1] == std::i32::MAX {\n        None\n    } else {\n\
    \        Some(smallest[1])\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp_v659akq.rs:15:12\n\
    \   |\n15 |         if *x < smallest[0] {\n   |            ^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_v659akq.rs:16:27\n   |\n16 |             smallest[0]\
    \ = x;\n   |             -----------   ^ expected `i32`, found `isize`\n   | \
    \            |\n   |             expected due to the type of this binding\n\n\
    error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmp_v659akq.rs:18:12\n\
    \   |\n18 |         if *x > smallest[1] {\n   |            ^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_v659akq.rs:19:27\n   |\n19 |             smallest[1]\
    \ = x;\n   |             -----------   ^ expected `i32`, found `isize`\n   | \
    \            |\n   |             expected due to the type of this binding\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp_v659akq.rs:25:14\n   |\n25 |  \
    \       Some(smallest[1])\n   |              ^^^^^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n25 |         Some(smallest[1].try_into().unwrap())\n\
    \   |                         ++++++++++++++++++++\n\nerror: aborting due to 5\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0614.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    let\
    \ mut smallest_idx = 1;\n    for &x in lst {\n        if x < smallest[smallest_idx]\
    \ {\n            smallest[smallest_idx] = x;\n            smallest_idx += 1;\n\
    \        }\n    }\n    if smallest_idx == 2 {\n        Some(smallest[1])\n   \
    \ } else {\n        None\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjy442w7k.rs:15:9\n   |\n\
    15 |     for &x in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjy442w7k.rs:22:14\n   |\n22 |         Some(smallest[1])\n   | \
    \             ^^^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    22 |         Some(smallest[1].try_into().unwrap())\n   |                     \
    \    ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().enumerate().find(|(_, i)| i < lst.len() -\
    \ 2).map(|(_, i)| lst[i + 1])\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk6i36_pg.rs:13:46\n   |\n\
    13 |     lst.iter().enumerate().find(|(_, i)| i < lst.len() - 2).map(|(_, i)|\
    \ lst[i + 1])\n   |                                              ^^^^^^^^^^^^^\
    \ expected `&&isize`, found `usize`\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpk6i36_pg.rs:13:74\n   |\n13 |     lst.iter().enumerate().find(|(_,\
    \ i)| i < lst.len() - 2).map(|(_, i)| lst[i + 1])\n   |                      \
    \                                                    ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    let\
    \ mut smallest_idx = 1;\n    for elt in lst {\n        if smallest[smallest_idx]\
    \ < elt {\n            smallest[smallest_idx] = elt;\n            smallest_idx\
    \ += 1;\n        }\n    }\n    if smallest_idx == 2 {\n        Some(smallest[1])\n\
    \    } else {\n        None\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphn6brf1b.rs:16:37\n   |\n\
    16 |         if smallest[smallest_idx] < elt {\n   |                         \
    \            ^^^ expected `i32`, found `isize`\n   |\nhelp: you can convert an\
    \ `isize` to an `i32` and panic if the converted value doesn't fit\n   |\n16 |\
    \         if smallest[smallest_idx] < elt.try_into().unwrap() {\n   |        \
    \                                ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphn6brf1b.rs:17:38\n   |\n17 |             smallest[smallest_idx]\
    \ = elt;\n   |             ----------------------   ^^^ expected `i32`, found\
    \ `isize`\n   |             |\n   |             expected due to the type of this\
    \ binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphn6brf1b.rs:22:14\n\
    \   |\n22 |         Some(smallest[1])\n   |              ^^^^^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n22 |         Some(smallest[1].try_into().unwrap())\n\
    \   |                         ++++++++++++++++++++\n\nerror: aborting due to 3\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().enumerate().find(|(_, elem)| elem < lst.iter().skip(1).next().unwrap()).map(|(_,\
    \ elem)| elem)\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwo3houis.rs:13:52\n   |\n\
    13 |     lst.iter().enumerate().find(|(_, elem)| elem < lst.iter().skip(1).next().unwrap()).map(|(_,\
    \ elem)| elem)\n   |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `isize`\n   |\n   = note: expected reference `&&isize`\n\
    \              found reference `&isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpwo3houis.rs:13:5\n   |\n12 | fn next_smallest(lst: Vec<isize>) -> Option<isize>\
    \ {\n   |                                      ------------- expected `Option<isize>`\
    \ because of return type\n13 |     lst.iter().enumerate().find(|(_, elem)| elem\
    \ < lst.iter().skip(1).next().unwrap()).map(|(_, elem)| elem)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found enum `Option<&isize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min();\n    if smallest.is_none()\
    \ {\n        return None;\n    }\n    let mut smallest_index = lst.iter().position(|&x|\
    \ x == smallest).unwrap();\n    if smallest_index == lst.len() {\n        return\
    \ None;\n    }\n    smallest_index += 1;\n    Some(smallest[smallest_index])\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkhrk5s10.rs:17:60\n   |\n\
    17 |     let mut smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<&isize>`\n\nerror[E0608]: cannot index into a value\
    \ of type `Option<&isize>`\n  --> /tmp/tmpkhrk5s10.rs:22:10\n   |\n22 |     Some(smallest[smallest_index])\n\
    \   |          ^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n    if\
    \ smallest_index == lst.len() - 1 {\n        None\n    } else {\n        Some(smallest)\n\
    \    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphfhrnqht.rs:18:14\n   |\n\
    18 |         Some(smallest)\n   |              ^^^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |        \
    \ Some(*smallest)\n   |              +\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = 0;\n    for &x in lst {\n        if x < smallest {\n            smallest =\
    \ x;\n            smallest_index += 1;\n        }\n    }\n    Some(smallest[smallest_index..])\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8_tszmot.rs:18:9\n   |\n\
    18 |     for &x in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0608]: cannot index\
    \ into a value of type `&isize`\n  --> /tmp/tmp8_tszmot.rs:24:10\n   |\n24 | \
    \    Some(smallest[smallest_index..])\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0608.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![0; lst.len()];\n    let mut\
    \ smallest_idx = 0;\n    for idx in lst.iter().rev() {\n        if smallest[idx]\
    \ < smallest[smallest_idx] {\n            smallest[idx] = smallest[smallest_idx];\n\
    \            smallest_idx = idx;\n        }\n    }\n    if smallest_idx == lst.len()\
    \ {\n        return None;\n    }\n    Some(smallest[smallest_idx + 1])\n}\n\n\
    fn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[{integer}]` cannot be indexed by `&isize`\n  -->\
    \ /tmp/tmp7i3fbc4l.rs:16:12\n   |\n16 |         if smallest[idx] < smallest[smallest_idx]\
    \ {\n   |            ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]` cannot be indexed\
    \ by `&isize`\n  --> /tmp/tmp7i3fbc4l.rs:17:13\n   |\n17 |             smallest[idx]\
    \ = smallest[smallest_idx];\n   |             ^^^^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<{integer}>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp7i3fbc4l.rs:18:28\n   |\n14 |     let mut smallest_idx = 0;\n   |  \
    \                          - expected due to this value\n...\n18 |           \
    \  smallest_idx = idx;\n   |                            ^^^ expected `usize`,\
    \ found `&isize`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    let\
    \ mut smallest_idx = 1;\n    for &i in lst {\n        if smallest[smallest_idx]\
    \ < i {\n            smallest[smallest_idx] = i;\n            smallest_idx +=\
    \ 1;\n        }\n    }\n    if smallest_idx == 2 {\n        Some(smallest[1])\n\
    \    } else {\n        None\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_4i11okm.rs:15:9\n   |\n\
    15 |     for &i in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_4i11okm.rs:22:14\n   |\n22 |         Some(smallest[1])\n   | \
    \             ^^^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    22 |         Some(smallest[1].try_into().unwrap())\n   |                     \
    \    ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().cloned().enumerate().find(|(i, &x)| x.0 >\
    \ lst.len() - 2).map(|(_, x)| x.1).unwrap_or(None)\n}\n\nfn main() {\n    let\
    \ candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4p3n_yo_.rs:13:47\n   |\n\
    13 |     lst.iter().cloned().enumerate().find(|(i, &x)| x.0 > lst.len() - 2).map(|(_,\
    \ x)| x.1).unwrap_or(None)\n   |                                             \
    \  ^^- expected due to this\n   |                                            \
    \   |\n   |                                               expected `isize`, found\
    \ reference\n   |                                               help: you can\
    \ probably remove the explicit borrow: `x`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror[E0610]: `isize` is a primitive type\
    \ and therefore doesn't have fields\n  --> /tmp/tmp4p3n_yo_.rs:13:88\n   |\n13\
    \ |     lst.iter().cloned().enumerate().find(|(i, &x)| x.0 > lst.len() - 2).map(|(_,\
    \ x)| x.1).unwrap_or(None)\n   |                                             \
    \                                           ^\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0610.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 101
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().cloned().skip(1).next()\n}\n\nfn main() {\n\
    \    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4,\
    \ 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(2)`', /tmp/tmpqs73gexb.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n\n\
    \    let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = 0;\n    for &i in lst {\n        if i < smallest {\n            smallest =\
    \ i;\n            smallest_index = i;\n        }\n    }\n\n    Some(smallest)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmak5h072.rs:19:9\n   |\n\
    19 |     for &i in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmak5h072.rs:22:30\n   |\n18 |     let mut smallest_index = 0;\n\
    \   |                              - expected due to this value\n...\n22 |   \
    \          smallest_index = i;\n   |                              ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n22 |  \
    \           smallest_index = *i;\n   |                              +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmak5h072.rs:26:10\n   |\n26 |     Some(smallest)\n\
    \   |          ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n26 |     Some(*smallest)\n   |          +\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![0; lst.len()];\n    let mut\
    \ smallest_idx = -1;\n    let mut smallest_val = vec![0; lst.len()];\n\n    for\
    \ &i in lst {\n        if smallest_idx == -1 || i < smallest_val[smallest_idx]\
    \ {\n            smallest_idx = 0;\n            smallest_val[smallest_idx] = i;\n\
    \        }\n\n        smallest_idx += 1;\n        if smallest_idx == lst.len()\
    \ {\n            smallest_idx = -1;\n        }\n    }\n\n    if smallest_idx ==\
    \ -1 {\n        return None;\n    }\n\n    Some(smallest_val[smallest_idx])\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzowizwyr.rs:17:9\n   |\n\
    17 |     for &i in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmpzowizwyr.rs:14:28\n   |\n14 | \
    \    let mut smallest_idx = -1;\n   |                            ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmpzowizwyr.rs:18:28\n   |\n18 | \
    \        if smallest_idx == -1 || i < smallest_val[smallest_idx] {\n   |     \
    \                       ^^ the trait `Neg` is not implemented for `usize`\n  \
    \ |\n   = help: the following other types implement trait `Neg`:\n           \
    \  &f32\n             &f64\n             &i128\n             &i16\n          \
    \   &i32\n             &i64\n             &i8\n             &isize\n         \
    \  and 8 others\n\nerror[E0600]: cannot apply unary operator `-` to type `usize`\n\
    \  --> /tmp/tmpzowizwyr.rs:25:28\n   |\n25 |             smallest_idx = -1;\n\
    \   |                            ^^\n   |                            |\n   | \
    \                           cannot apply unary operator `-`\n   |            \
    \                help: you may have meant the maximum value of `usize`: `usize::MAX`\n\
    \   |\n   = note: unsigned values cannot be negated\n\nerror[E0600]: cannot apply\
    \ unary operator `-` to type `usize`\n  --> /tmp/tmpzowizwyr.rs:29:24\n   |\n\
    29 |     if smallest_idx == -1 {\n   |                        ^^\n   |       \
    \                 |\n   |                        cannot apply unary operator `-`\n\
    \   |                        help: you may have meant the maximum value of `usize"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().cloned().enumerate().find(|(_, x)| x < lst.len()\
    \ - 2).map(|(_, x)| x).ok()\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpada8p4vy.rs:13:55\n   |\n\
    13 |     lst.iter().cloned().enumerate().find(|(_, x)| x < lst.len() - 2).map(|(_,\
    \ x)| x).ok()\n   |                                                       ^^^^^^^^^^^^^\
    \ expected `&isize`, found `usize`\n\nerror[E0599]: no method named `ok` found\
    \ for enum `Option` in the current scope\n  --> /tmp/tmpada8p4vy.rs:13:86\n  \
    \ |\n13 |     lst.iter().cloned().enumerate().find(|(_, x)| x < lst.len() - 2).map(|(_,\
    \ x)| x).ok()\n   |                                                          \
    \                            ^^ help: there is an associated function with a similar\
    \ name: `or`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min();\n    if smallest.is_none()\
    \ {\n        return None;\n    }\n    let mut smallest_index = lst.iter().position(|&x|\
    \ x == smallest).unwrap();\n    if smallest_index == lst.len() - 1 {\n       \
    \ smallest_index = 0;\n    }\n    Some(smallest[smallest_index + 1])\n}\n\nfn\
    \ main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsvf_sz_4.rs:17:60\n   |\n\
    17 |     let mut smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<&isize>`\n\nerror[E0608]: cannot index into a value\
    \ of type `Option<&isize>`\n  --> /tmp/tmpsvf_sz_4.rs:21:10\n   |\n21 |     Some(smallest[smallest_index\
    \ + 1])\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0308, E0608.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n   \
    \ if smallest_index == lst.len() {\n        return None;\n    }\n    let mut smallest_value\
    \ = lst.iter().nth(smallest_index).unwrap();\n    let mut smallest_value_index\
    \ = lst.iter().position(|x| *x == smallest_value).unwrap();\n    if smallest_value_index\
    \ == lst.len() {\n        return None;\n    }\n    Some(smallest_value)\n}\n\n\
    fn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_jqvi9is.rs:14:60\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|x| *x == *smallest).unwrap();\n\
    \   |                                                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_jqvi9is.rs:19:66\n   |\n19 |     let mut smallest_value_index\
    \ = lst.iter().position(|x| *x == smallest_value).unwrap();\n   |            \
    \                                                      ^^^^^^^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    19 |     let mut smallest_value_index = lst.iter().position(|x| *x == *smallest_value).unwrap();\n\
    \   |                                                                  +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_jqvi9is.rs:23:10\n   |\n23 |     Some(smallest_value)\n\
    \   |          ^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n23 |     Some(*smallest_value)\n   |       \
    \   +\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min();\n    let mut smallest_index\
    \ = lst.iter().position(|&x| x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_index).min().unwrap();\n\
    \    smallest_index += 1;\n    if smallest_index == lst.len() {\n        return\
    \ None;\n    }\n    smallest = lst.iter().skip(smallest_index).min().unwrap();\n\
    \    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n  \
    \  assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt98jhm2h.rs:14:60\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpt98jhm2h.rs:18:16\n   |\n13 |     let mut smallest = lst.iter().min();\n\
    \   |                        ---------------- expected due to this value\n...\n\
    18 |     smallest = lst.iter().skip(smallest_index).min().unwrap();\n   |    \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`,\
    \ found `&isize`\n   |\n   = note:   expected enum `Option<&isize>`\n        \
    \   found reference `&isize`\nhelp: try wrapping the expression in `Some`\n  \
    \ |\n18 |     smallest = Some(lst.iter().skip(smallest_index).min().unwrap());\n\
    \   |                +++++                                              +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpt98jhm2h.rs:23:16\n   |\n13 |  \
    \   let mut smallest = lst.iter().min();\n   |                        ----------------\
    \ expected due to this value\n...\n23 |     smallest = lst.iter().skip(smallest_index).min().unwrap();\n\
    \   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum\
    \ `Option`, found `&isize`\n   |\n   = note:   expected enum `Option<&isize>`\n\
    \           found reference `&isize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n23 |     smallest = Some(lst.iter().skip(smallest_index).min().unwrap());\n\
    \   |                +++++                                              +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpt98jhm2h.rs:24:10\n   |\n24 |  \
    \   Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<&isize>`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = 0;\n    for &i in lst {\n        if *i < smallest {\n \
    \           smallest = i;\n            smallest_index = i;\n        }\n    }\n\
    \    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n  \
    \  assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpypb7_sx8.rs:15:9\n   |\n\
    15 |     for &i in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpypb7_sx8.rs:21:10\n   |\n21 |     Some(smallest)\n   |        \
    \  ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n21 |     Some(*smallest)\n   |          +\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    for\
    \ x in lst {\n        if x < smallest[0] {\n            smallest[0] = x;\n   \
    \     }\n        if x > smallest[1] {\n            smallest[1] = x;\n        }\n\
    \    }\n    if smallest[0] == std::i32::MAX {\n        None\n    } else {\n  \
    \      Some(smallest[1])\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsrojpyl1.rs:15:16\n   |\n\
    15 |         if x < smallest[0] {\n   |                ^^^^^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n15 |         if x < smallest[0].try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsrojpyl1.rs:16:27\n   |\n16 |             smallest[0] =\
    \ x;\n   |             -----------   ^ expected `i32`, found `isize`\n   |   \
    \          |\n   |             expected due to the type of this binding\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsrojpyl1.rs:18:16\n   |\n18 |         if x >\
    \ smallest[1] {\n   |                ^^^^^^^^^^^ expected `isize`, found `i32`\n\
    \   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n18 |         if x > smallest[1].try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsrojpyl1.rs:19:27\n   |\n19 |             smallest[1] =\
    \ x;\n   |             -----------   ^ expected `i32`, found `isize`\n   |   \
    \          |\n   |             expected due to the type of this binding\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsrojpyl1.rs:25:14\n   |\n25 |         Some(smallest[1])\n\
    \   |              ^^^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you\
    \ can convert an `i32` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n25 |         Some(smallest[1].try_into().unwrap())\n   |        \
    \                 ++++++++++++++++++++\n\nerror: aborting due to 5 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_idx = lst.iter().position(|&x| x == smallest).unwrap();\n    if\
    \ smallest_idx == lst.len() - 1 {\n        return None;\n    }\n    smallest =\
    \ lst.iter().skip(smallest_idx + 1).min().unwrap();\n    smallest_idx = lst.iter().position(|&x|\
    \ x == smallest).unwrap();\n    if smallest_idx == lst.len() - 1 {\n        return\
    \ None;\n    }\n    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppmd9pikd.rs:14:58\n   |\n\
    14 |     let mut smallest_idx = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                          ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    14 |     let mut smallest_idx = lst.iter().position(|&x| x == *smallest).unwrap();\n\
    \   |                                                          +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmppmd9pikd.rs:19:50\n   |\n19 |     smallest_idx\
    \ = lst.iter().position(|&x| x == smallest).unwrap();\n   |                  \
    \                                ^^^^^^^^ expected `isize`, found `&isize`\n \
    \  |\nhelp: consider dereferencing the borrow\n   |\n19 |     smallest_idx = lst.iter().position(|&x|\
    \ x == *smallest).unwrap();\n   |                                            \
    \      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppmd9pikd.rs:23:10\n\
    \   |\n23 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n23 |     Some(*smallest)\n\
    \   |          +\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().cloned().enumerate().find(|(_, i)| i < lst.len()\
    \ - 1).map(|(_, j)| lst[j + 1])\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi8zxic_k.rs:13:55\n   |\n\
    13 |     lst.iter().cloned().enumerate().find(|(_, i)| i < lst.len() - 1).map(|(_,\
    \ j)| lst[j + 1])\n   |                                                      \
    \ ^^^^^^^^^^^^^ expected `&isize`, found `usize`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpi8zxic_k.rs:13:83\n   |\n13 |  \
    \   lst.iter().cloned().enumerate().find(|(_, i)| i < lst.len() - 1).map(|(_,\
    \ j)| lst[j + 1])\n   |                                                      \
    \                             ^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![lst[0]; 2];\n    let mut smallest_idx\
    \ = 1;\n    for &x in lst {\n        if x < smallest[smallest_idx] {\n       \
    \     smallest[smallest_idx] = x;\n            smallest_idx += 1;\n        }\n\
    \    }\n    if smallest_idx == 2 {\n        Some(smallest[1])\n    } else {\n\
    \        None\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppa7j9mi3.rs:15:9\n   |\n\
    15 |     for &x in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().cloned().enumerate().find(|(_, i)| i < lst.len()\
    \ - 2)\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd8rici4q.rs:13:55\n   |\n\
    13 |     lst.iter().cloned().enumerate().find(|(_, i)| i < lst.len() - 2)\n  \
    \ |                                                       ^^^^^^^^^^^^^ expected\
    \ `&isize`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd8rici4q.rs:13:5\n\
    \   |\n12 | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |       \
    \                               ------------- expected `Option<isize>` because\
    \ of return type\n13 |     lst.iter().cloned().enumerate().find(|(_, i)| i < lst.len()\
    \ - 2)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found tuple\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found enum `Option<(usize, isize)>`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n\n\
    \    let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|x| x == smallest).unwrap();\n\n    if smallest_index\
    \ == lst.len() - 1 {\n        smallest_index = 0;\n    }\n\n    Some(smallest)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxomnstzu.rs:24:10\n   |\n\
    24 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n24 |     Some(*smallest)\n\
    \   |          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    let\
    \ mut smallest_idx = 1;\n    for el in lst {\n        if el < smallest[smallest_idx]\
    \ {\n            smallest[smallest_idx] = el;\n            smallest_idx += 1;\n\
    \        }\n    }\n    if smallest_idx == 2 {\n        Some(smallest[1])\n   \
    \ } else {\n        None\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx70o82hx.rs:16:17\n   |\n\
    16 |         if el < smallest[smallest_idx] {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n16 |         if el < smallest[smallest_idx].try_into().unwrap()\
    \ {\n   |                                       ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpx70o82hx.rs:17:38\n   |\n17 |             smallest[smallest_idx]\
    \ = el;\n   |             ----------------------   ^^ expected `i32`, found `isize`\n\
    \   |             |\n   |             expected due to the type of this binding\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpx70o82hx.rs:22:14\n   |\n22 |\
    \         Some(smallest[1])\n   |              ^^^^^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n22 |         Some(smallest[1].try_into().unwrap())\n\
    \   |                         ++++++++++++++++++++\n\nerror: aborting due to 3\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    for\
    \ elt in lst {\n        if elt < smallest[0] {\n            smallest[0] = elt;\n\
    \        }\n        if elt < smallest[1] {\n            smallest[1] = elt;\n \
    \       }\n    }\n    if smallest[1] == std::i32::MAX {\n        None\n    } else\
    \ {\n        Some(smallest[1])\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp__snla4b.rs:15:18\n   |\n\
    15 |         if elt < smallest[0] {\n   |                  ^^^^^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n15 |         if elt < smallest[0].try_into().unwrap()\
    \ {\n   |                             ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp__snla4b.rs:16:27\n   |\n16 |             smallest[0] =\
    \ elt;\n   |             -----------   ^^^ expected `i32`, found `isize`\n   |\
    \             |\n   |             expected due to the type of this binding\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp__snla4b.rs:18:18\n   |\n18 |  \
    \       if elt < smallest[1] {\n   |                  ^^^^^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n18 |         if elt < smallest[1].try_into().unwrap()\
    \ {\n   |                             ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp__snla4b.rs:19:27\n   |\n19 |             smallest[1] =\
    \ elt;\n   |             -----------   ^^^ expected `i32`, found `isize`\n   |\
    \             |\n   |             expected due to the type of this binding\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp__snla4b.rs:25:14\n   |\n25 |  \
    \       Some(smallest[1])\n   |              ^^^^^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n25 |         Some(smallest[1].try_into().unwrap())\n\
    \   |                         ++++++++++++++++++++\n\nerror: aborting due to 5\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        smallest_index = 0;\n    }\n    Some(smallest)\n}\n\
    \nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdip3dbce.rs:21:10\n   |\n\
    21 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n21 |     Some(*smallest)\n\
    \   |          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min();\n    if smallest.is_none()\
    \ {\n        return None;\n    }\n    let mut smallest_index = lst.iter().position(|x|\
    \ x == smallest).unwrap();\n    if smallest_index == lst.len() - 1 {\n       \
    \ return Some(smallest);\n    }\n    let mut smallest_value = lst.iter().nth(smallest_index).unwrap();\n\
    \    if smallest_index == 0 {\n        smallest_value = lst.iter().nth(1).unwrap();\n\
    \    }\n    smallest_index += 1;\n    Some(smallest_value)\n}\n\nfn main() {\n\
    \    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4,\
    \ 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `Option<&isize>`\n  --> /tmp/tmp_kopv26t.rs:17:56\n\
    \   |\n17 |     let mut smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n\
    \   |                                                        ^^ no implementation\
    \ for `&isize == Option<&isize>`\n   |\n   = help: the trait `PartialEq<Option<&isize>>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp_kopv26t.rs:19:21\n   |\n19 |         return Some(smallest);\n   | \
    \                    ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n  \
    \ = note: expected type `isize`\n              found enum `Option<&isize>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp_kopv26t.rs:26:10\n   |\n26 |  \
    \   Some(smallest_value)\n   |          ^^^^^^^^^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n26 |     Some(*smallest_value)\n\
    \   |          +\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min();\n    if smallest.is_none()\
    \ {\n        return None;\n    }\n    let mut smallest_index = lst.iter().position(|&x|\
    \ x == smallest).unwrap();\n    if smallest_index == lst.len() - 1 {\n       \
    \ return Some(smallest);\n    }\n    let mut next_smallest = lst.iter().skip(smallest_index\
    \ + 1).min();\n    if next_smallest == smallest {\n        return Some(smallest);\n\
    \    }\n    Some(next_smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpttvfdj2x.rs:17:60\n   |\n\
    17 |     let mut smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpttvfdj2x.rs:19:21\n   |\n19 |         return Some(smallest);\n   | \
    \                    ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n  \
    \ = note: expected type `isize`\n              found enum `Option<&isize>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpttvfdj2x.rs:23:21\n   |\n23 |  \
    \       return Some(smallest);\n   |                     ^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpttvfdj2x.rs:25:10\n\
    \   |\n25 |     Some(next_smallest)\n   |          ^^^^^^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<&isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![lst[0]];\n    let mut smallest_idx\
    \ = 1;\n    for &i in lst.iter().rev() {\n        if *i < smallest[smallest_idx]\
    \ {\n            smallest[smallest_idx] = *i;\n            smallest_idx += 1;\n\
    \        }\n    }\n    if smallest_idx == lst.len() {\n        return None;\n\
    \    }\n    Some(smallest[smallest_idx])\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpi15rf9vj.rs:16:12\n\
    \   |\n16 |         if *i < smallest[smallest_idx] {\n   |            ^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpi15rf9vj.rs:17:38\n   |\n\
    17 |             smallest[smallest_idx] = *i;\n   |                          \
    \            ^^\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![0; lst.len()];\n    let mut\
    \ smallest_idx = vec![0; lst.len()];\n    for &x in lst {\n        if smallest[x]\
    \ < smallest[smallest_idx[x]] {\n            smallest[x] = smallest_idx[x];\n\
    \        }\n        smallest_idx[x] += 1;\n    }\n    if smallest_idx[lst.len()]\
    \ == lst.len() {\n        None\n    } else {\n        Some(smallest[smallest_idx[lst.len()]])\n\
    \    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphd9fk6_v.rs:15:9\n   |\n\
    15 |     for &x in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    let\
    \ mut smallest_idx = 1;\n    for el in lst {\n        if el < smallest[smallest_idx]\
    \ {\n            smallest[smallest_idx] = el;\n            smallest_idx += 1;\n\
    \        }\n    }\n    if smallest_idx == 2 {\n        Some(smallest[1])\n   \
    \ } else {\n        None\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx70o82hx.rs:16:17\n   |\n\
    16 |         if el < smallest[smallest_idx] {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n16 |         if el < smallest[smallest_idx].try_into().unwrap()\
    \ {\n   |                                       ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpx70o82hx.rs:17:38\n   |\n17 |             smallest[smallest_idx]\
    \ = el;\n   |             ----------------------   ^^ expected `i32`, found `isize`\n\
    \   |             |\n   |             expected due to the type of this binding\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpx70o82hx.rs:22:14\n   |\n22 |\
    \         Some(smallest[1])\n   |              ^^^^^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n22 |         Some(smallest[1].try_into().unwrap())\n\
    \   |                         ++++++++++++++++++++\n\nerror: aborting due to 3\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min();\n    let mut smallest_index = lst.iter().position(|x|\
    \ *x == smallest);\n    if smallest_index == lst.len() {\n        return None;\n\
    \    }\n    let mut second_smallest = lst.iter().skip(smallest_index).min();\n\
    \    if second_smallest == smallest {\n        return None;\n    }\n    Some(second_smallest)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9pb7jsf8.rs:17:60\n   |\n\
    17 |     let mut smallest_index = lst.iter().position(|x| *x == smallest);\n \
    \  |                                                            ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp9pb7jsf8.rs:18:26\n   |\n18 |     if smallest_index == lst.len() {\n\
    \   |                          ^^^^^^^^^ expected enum `Option`, found `usize`\n\
    \   |\n   = note: expected enum `Option<usize>`\n              found type `usize`\n\
    help: try wrapping the expression in `Some`\n   |\n18 |     if smallest_index\
    \ == Some(lst.len()) {\n   |                          +++++         +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9pb7jsf8.rs:21:47\n   |\n21 |     let mut second_smallest\
    \ = lst.iter().skip(smallest_index).min();\n   |                             \
    \                  ^^^^^^^^^^^^^^ expected `usize`, found enum `Option`\n   |\n\
    \   = note: expected type `usize`\n              found enum `Option<usize>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp9pb7jsf8.rs:25:10\n   |\n25 |  \
    \   Some(second_smallest)\n   |          ^^^^^^^^^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<&isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_idx = lst.iter().position(|&x| x == smallest).unwrap();\n    if\
    \ smallest_idx == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().nth(smallest_idx\
    \ + 1).unwrap();\n    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq0j0qgmo.rs:14:58\n   |\n\
    14 |     let mut smallest_idx = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                          ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    14 |     let mut smallest_idx = lst.iter().position(|&x| x == *smallest).unwrap();\n\
    \   |                                                          +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpq0j0qgmo.rs:19:10\n   |\n19 |     Some(smallest)\n\
    \   |          ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n19 |     Some(*smallest)\n   |          +\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    for\
    \ elt in lst {\n        if elt < smallest[0] {\n            smallest[0] = elt;\n\
    \        }\n        if elt < smallest[1] {\n            smallest[1] = elt;\n \
    \       }\n    }\n    if smallest[1] == std::i32::MAX {\n        None\n    } else\
    \ {\n        Some(smallest[1])\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp__snla4b.rs:15:18\n   |\n\
    15 |         if elt < smallest[0] {\n   |                  ^^^^^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n15 |         if elt < smallest[0].try_into().unwrap()\
    \ {\n   |                             ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp__snla4b.rs:16:27\n   |\n16 |             smallest[0] =\
    \ elt;\n   |             -----------   ^^^ expected `i32`, found `isize`\n   |\
    \             |\n   |             expected due to the type of this binding\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp__snla4b.rs:18:18\n   |\n18 |  \
    \       if elt < smallest[1] {\n   |                  ^^^^^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n18 |         if elt < smallest[1].try_into().unwrap()\
    \ {\n   |                             ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp__snla4b.rs:19:27\n   |\n19 |             smallest[1] =\
    \ elt;\n   |             -----------   ^^^ expected `i32`, found `isize`\n   |\
    \             |\n   |             expected due to the type of this binding\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp__snla4b.rs:25:14\n   |\n25 |  \
    \       Some(smallest[1])\n   |              ^^^^^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n25 |         Some(smallest[1].try_into().unwrap())\n\
    \   |                         ++++++++++++++++++++\n\nerror: aborting due to 5\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|x| *x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        smallest_index = 0;\n    }\n    Some(smallest)\n}\n\
    \nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6m6b7ruv.rs:17:60\n   |\n\
    17 |     let mut smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    17 |     let mut smallest_index = lst.iter().position(|x| *x == *smallest).unwrap();\n\
    \   |                                                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6m6b7ruv.rs:21:10\n   |\n21 |     Some(smallest)\n\
    \   |          ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n21 |     Some(*smallest)\n   |          +\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    let\
    \ mut smallest_idx = 1;\n    for &x in lst {\n        if x < smallest[smallest_idx]\
    \ {\n            smallest[smallest_idx] = x;\n            smallest_idx += 1;\n\
    \        }\n    }\n    if smallest_idx == 2 {\n        Some(smallest[1])\n   \
    \ } else {\n        None\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjy442w7k.rs:15:9\n   |\n\
    15 |     for &x in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjy442w7k.rs:22:14\n   |\n22 |         Some(smallest[1])\n   | \
    \             ^^^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    22 |         Some(smallest[1].try_into().unwrap())\n   |                     \
    \    ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        smallest_index = 0;\n    }\n    Some(smallest)\n}\n\
    \nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdip3dbce.rs:21:10\n   |\n\
    21 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n21 |     Some(*smallest)\n\
    \   |          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_idx =\
    \ 1;\n    for &i in lst {\n        if i < smallest {\n            smallest = i;\n\
    \            smallest_idx = i;\n        }\n    }\n    Some(smallest_idx)\n}\n\n\
    fn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2ar5u42s.rs:18:9\n   |\n\
    18 |     for &i in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2ar5u42s.rs:21:28\n   |\n17 |     let mut smallest_idx = 1;\n \
    \  |                            - expected due to this value\n...\n21 |      \
    \       smallest_idx = i;\n   |                            ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n21 |  \
    \           smallest_idx = *i;\n   |                            +\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() <= 1 {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|x| *x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        smallest_index = 0;\n    }\n    Some(smallest[smallest_index\
    \ + 1])\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3ln68v4i.rs:17:60\n   |\n\
    17 |     let mut smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    17 |     let mut smallest_index = lst.iter().position(|x| *x == *smallest).unwrap();\n\
    \   |                                                            +\n\nerror[E0608]:\
    \ cannot index into a value of type `&isize`\n  --> /tmp/tmp3ln68v4i.rs:21:10\n\
    \   |\n21 |     Some(smallest[smallest_index + 1])\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0608.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        smallest_index = 0;\n    }\n    Some(smallest)\n}\n\
    \nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpptd4mppg.rs:21:10\n   |\n\
    21 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n21 |     Some(*smallest)\n\
    \   |          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst[0];\n    let mut smallest_idx\
    \ = 1;\n    for &i in lst {\n        if i < smallest {\n            smallest =\
    \ i;\n            smallest_idx = 1;\n        } else {\n            smallest_idx\
    \ += 1;\n        }\n    }\n    Some(smallest)\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8jx_2b7m.rs:15:9\n   |\n\
    15 |     for &i in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    for\
    \ elt in lst {\n        if smallest[0] < elt {\n            smallest[0] = elt;\n\
    \        }\n        if smallest[1] < elt {\n            smallest[1] = elt;\n \
    \       }\n    }\n    if smallest[0] == std::i32::MAX {\n        return None;\n\
    \    }\n    Some(smallest[1])\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoyng7t3i.rs:15:26\n   |\n\
    15 |         if smallest[0] < elt {\n   |                          ^^^ expected\
    \ `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an `i32` and\
    \ panic if the converted value doesn't fit\n   |\n15 |         if smallest[0]\
    \ < elt.try_into().unwrap() {\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpoyng7t3i.rs:16:27\n   |\n16 |\
    \             smallest[0] = elt;\n   |             -----------   ^^^ expected\
    \ `i32`, found `isize`\n   |             |\n   |             expected due to the\
    \ type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoyng7t3i.rs:18:26\n\
    \   |\n18 |         if smallest[1] < elt {\n   |                          ^^^\
    \ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n18 |         if smallest[1]\
    \ < elt.try_into().unwrap() {\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpoyng7t3i.rs:19:27\n   |\n19 |\
    \             smallest[1] = elt;\n   |             -----------   ^^^ expected\
    \ `i32`, found `isize`\n   |             |\n   |             expected due to the\
    \ type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoyng7t3i.rs:25:10\n\
    \   |\n25 |     Some(smallest[1])\n   |          ^^^^^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n25 |     Some(smallest[1].try_into().unwrap())\n\
    \   |                     ++++++++++++++++++++\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n \
    \   let mut smallest = lst[0];\n    let mut smallest_idx = 1;\n    for &i in lst\
    \ {\n        if i < smallest {\n            smallest = i;\n            smallest_idx\
    \ = i;\n        }\n    }\n    Some(smallest_idx)\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo473x389.rs:18:9\n   |\n\
    18 |     for &i in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![lst[0]; 2];\n    let mut smallest_idx\
    \ = 1;\n    for &i in lst {\n        if *i < smallest[smallest_idx] {\n      \
    \      smallest[smallest_idx] = *i;\n            smallest_idx += 1;\n        }\n\
    \    }\n    if smallest_idx == 2 {\n        Some(smallest[1])\n    } else {\n\
    \        None\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw6ijkfu3.rs:15:9\n   |\n\
    15 |     for &i in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min();\n    if smallest.is_none()\
    \ {\n        return None;\n    }\n    let mut smallest_index = lst.iter().position(|&x|\
    \ x == smallest).unwrap();\n    if smallest_index == lst.len() - 1 {\n       \
    \ smallest_index = 0;\n    }\n    Some(lst[smallest_index + 1])\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplxuzdjix.rs:17:60\n   |\n\
    17 |     let mut smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<&isize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    for\
    \ elt in lst {\n        if elt < smallest[0] {\n            smallest[0] = elt;\n\
    \        }\n        if elt < smallest[1] {\n            smallest[1] = elt;\n \
    \       }\n    }\n    if smallest[1] == std::i32::MAX {\n        None\n    } else\
    \ {\n        Some(smallest[1])\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp__snla4b.rs:15:18\n   |\n\
    15 |         if elt < smallest[0] {\n   |                  ^^^^^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n15 |         if elt < smallest[0].try_into().unwrap()\
    \ {\n   |                             ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp__snla4b.rs:16:27\n   |\n16 |             smallest[0] =\
    \ elt;\n   |             -----------   ^^^ expected `i32`, found `isize`\n   |\
    \             |\n   |             expected due to the type of this binding\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp__snla4b.rs:18:18\n   |\n18 |  \
    \       if elt < smallest[1] {\n   |                  ^^^^^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n18 |         if elt < smallest[1].try_into().unwrap()\
    \ {\n   |                             ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp__snla4b.rs:19:27\n   |\n19 |             smallest[1] =\
    \ elt;\n   |             -----------   ^^^ expected `i32`, found `isize`\n   |\
    \             |\n   |             expected due to the type of this binding\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp__snla4b.rs:25:14\n   |\n25 |  \
    \       Some(smallest[1])\n   |              ^^^^^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n25 |         Some(smallest[1].try_into().unwrap())\n\
    \   |                         ++++++++++++++++++++\n\nerror: aborting due to 5\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![0; lst.len()];\n    let mut\
    \ smallest_index = 0;\n    let mut smallest_value = lst[0];\n    for &x in lst\
    \ {\n        if x < smallest_value {\n            smallest_value = x;\n      \
    \      smallest_index = 0;\n        }\n        if x == smallest_value {\n    \
    \        smallest_index += 1;\n        }\n        smallest[smallest_index] = x;\n\
    \    }\n    smallest.iter().position(|&x| x == smallest_value).map(|&x| x).unwrap_or(0)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa66kevzm.rs:16:9\n   |\n\
    16 |     for &x in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpa66kevzm.rs:26:61\n   |\n26 |     smallest.iter().position(|&x|\
    \ x == smallest_value).map(|&x| x).unwrap_or(0)\n   |                        \
    \                                     ^--\n   |                              \
    \                               ||\n   |                                     \
    \                        |expected due to this\n   |                         \
    \                                    expected `usize`, found reference\n   | \
    \                                                            help: did you mean\
    \ `x`: `&usize`\n   |\n   = note:   expected type `usize`\n           found reference\
    \ `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa66kevzm.rs:26:78\n  \
    \ |\n26 |     smallest.iter().position(|&x| x == smallest_value).map(|&x| x).unwrap_or(0)\n\
    \   |                                                                        \
    \      ^ expected enum `Option`, found integer\n   |\n   = note: expected enum\
    \ `Option<isize>`\n              found type `{integer}`\nhelp: try wrapping the\
    \ expression in `Some`\n   |\n26 |     smallest.iter().position(|&x| x == smallest_value).map(|&x|\
    \ x).unwrap_or(Some(0))\n   |                                                \
    \                              +++++ +\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![0; lst.len()];\n    let mut\
    \ smallest_idx = vec![0; lst.len()];\n    let mut smallest_val = vec![0; lst.len()];\n\
    \    for &i in lst {\n        smallest[smallest_idx[i]] = i;\n        smallest_idx[i]\
    \ = i;\n        smallest_val[i] = i;\n    }\n    for i in 0..lst.len() {\n   \
    \     if smallest[smallest_idx[i]] > smallest[smallest_idx[i + 1]] {\n       \
    \     smallest_idx[i + 1] = smallest_idx[i];\n            smallest_val[i + 1]\
    \ = smallest_val[i];\n        }\n    }\n    if smallest_idx[lst.len() - 1] ==\
    \ lst.len() - 1 {\n        None\n    } else {\n        Some(smallest[smallest_idx[lst.len()\
    \ - 1]])\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz1kn7oci.rs:16:9\n   |\n\
    16 |     for &i in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().cloned().enumerate().find(|(i, _)| {\n  \
    \      i < (lst.len() - 1).cloned()\n    }).map(|(i, _)| {\n        lst[i + 1]\n\
    \    })\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: `usize` is not an iterator\n  --> /tmp/tmpjsg8co1e.rs:14:29\n\
    \   |\n14 |         i < (lst.len() - 1).cloned()\n   |                       \
    \      ^^^^^^ `usize` is not an iterator\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `usize: Iterator`\n           which is\
    \ required by `&mut usize: Iterator`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    for\
    \ &x in lst {\n        if x < smallest[0] {\n            smallest[0] = x;\n  \
    \      }\n        if x < smallest[1] {\n            smallest[1] = x;\n       \
    \ }\n    }\n    smallest.iter().next()\n}\n\nfn main() {\n    let candidate =\
    \ next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n \
    \   assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7wo36wov.rs:14:9\n   |\n\
    14 |     for &x in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp7wo36wov.rs:22:5\n   |\n12 | fn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n   |                                      -------------\
    \ expected `Option<isize>` because of return type\n...\n22 |     smallest.iter().next()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&i32`\n   |\n   = note:\
    \ expected enum `Option<isize>`\n              found enum `Option<&i32>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min();\n    let mut smallest_index\
    \ = lst.iter().position(|x| *x == smallest);\n    if smallest_index == lst.len()\
    \ {\n        return None;\n    }\n    smallest = lst.iter().nth(smallest_index).unwrap();\n\
    \    smallest_index += 1;\n    if smallest_index == lst.len() {\n        return\
    \ None;\n    }\n    smallest = lst.iter().nth(smallest_index).unwrap();\n    Some(smallest)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppk0a0ib8.rs:14:60\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|x| *x == smallest);\n \
    \  |                                                            ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmppk0a0ib8.rs:15:26\n   |\n15 |     if smallest_index == lst.len() {\n\
    \   |                          ^^^^^^^^^ expected enum `Option`, found `usize`\n\
    \   |\n   = note: expected enum `Option<usize>`\n              found type `usize`\n\
    help: try wrapping the expression in `Some`\n   |\n15 |     if smallest_index\
    \ == Some(lst.len()) {\n   |                          +++++         +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmppk0a0ib8.rs:18:31\n   |\n18 |     smallest =\
    \ lst.iter().nth(smallest_index).unwrap();\n   |                             \
    \  ^^^^^^^^^^^^^^ expected `usize`, found enum `Option`\n   |\n   = note: expected\
    \ type `usize`\n              found enum `Option<usize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmppk0a0ib8.rs:18:16\n   |\n13 |     let mut smallest = lst.iter().min();\n\
    \   |                        ---------------- expected due to this value\n...\n\
    18 |     smallest = lst.iter().nth(smallest_index).unwrap();\n   |           \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`, found `&isize`\n\
    \   |\n   = note:   expected enum `Option<&isize>`\n           found reference\
    \ `&isize`\nhelp: try wrapping the expression in `Some`\n   |\n18 |     smallest\
    \ = Some(lst.iter().nth(smallest_index).unwrap());\n   |                +++++\
    \                                       +\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `Option<usize>`\n  --> /tmp/tmppk0a0ib8.rs:19:5\n\
    \   |\n19 |     smallest_index += 1;\n   |     --------------^^^^^\n   |     |\n\
    \   |     cannot use `+=` on type `Option<usize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmppk0a0ib8.rs:20:26\n   |\n20 |     if smallest_index ==\
    \ lst.len() {\n   |                          ^^"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    let\
    \ mut smallest_idx = 1;\n    for &x in lst {\n        if x < smallest[smallest_idx]\
    \ {\n            smallest[smallest_idx] = x;\n            smallest_idx += 1;\n\
    \        }\n    }\n    if smallest_idx == 2 {\n        Some(smallest[1])\n   \
    \ } else {\n        None\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjy442w7k.rs:15:9\n   |\n\
    15 |     for &x in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjy442w7k.rs:22:14\n   |\n22 |         Some(smallest[1])\n   | \
    \             ^^^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    22 |         Some(smallest[1].try_into().unwrap())\n   |                     \
    \    ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    let\
    \ mut smallest_idx = 1;\n    for &i in lst {\n        if *i < smallest[smallest_idx]\
    \ {\n            smallest[smallest_idx] = *i;\n            smallest_idx += 1;\n\
    \        }\n    }\n    if smallest_idx == 2 {\n        Some(smallest[1])\n   \
    \ } else {\n        None\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8b08e2rf.rs:15:9\n   |\n\
    15 |     for &i in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8b08e2rf.rs:22:14\n   |\n22 |         Some(smallest[1])\n   | \
    \             ^^^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    22 |         Some(smallest[1].try_into().unwrap())\n   |                     \
    \    ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n \
    \   let mut smallest = vec![0; lst.len()];\n    let mut smallest_idx = lst.len();\n\
    \    let mut smallest_val = lst.len();\n    for i in lst.iter().rev() {\n    \
    \    if smallest[smallest_idx] < i {\n            smallest[smallest_idx] = i;\n\
    \            smallest_idx = i;\n        }\n    }\n    if smallest_idx == 0 {\n\
    \        return None;\n    }\n    Some(smallest[smallest_idx - 1])\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpat5pv5qp.rs:20:35\n\
    \   |\n20 |         if smallest[smallest_idx] < i {\n   |                    \
    \               ^ no implementation for `isize < &isize` and `isize > &isize`\n\
    \   |\n   = help: the trait `PartialOrd<&isize>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `PartialOrd<Rhs>`:\n   \
    \          f32\n             f64\n             i128\n             i16\n      \
    \       i32\n             i64\n             i8\n             isize\n         \
    \  and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpat5pv5qp.rs:21:38\n\
    \   |\n21 |             smallest[smallest_idx] = i;\n   |             ----------------------\
    \   ^ expected `isize`, found `&isize`\n   |             |\n   |             expected\
    \ due to the type of this binding\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n21 |             smallest[smallest_idx] = *i;\n   |                   \
    \                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpat5pv5qp.rs:22:28\n\
    \   |\n17 |     let mut smallest_idx = lst.len();\n   |                      \
    \      --------- expected due to this value\n...\n22 |             smallest_idx\
    \ = i;\n   |                            ^ expected `usize`, found `&isize`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    let\
    \ mut smallest_idx = 1;\n    for &i in lst {\n        if *i < smallest[smallest_idx]\
    \ {\n            smallest[smallest_idx] = *i;\n            smallest_idx += 1;\n\
    \        }\n    }\n    if smallest_idx == 2 {\n        Some(smallest[1])\n   \
    \ } else {\n        None\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8b08e2rf.rs:15:9\n   |\n\
    15 |     for &i in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8b08e2rf.rs:22:14\n   |\n22 |         Some(smallest[1])\n   | \
    \             ^^^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    22 |         Some(smallest[1].try_into().unwrap())\n   |                     \
    \    ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_idx = lst.iter().position(|x| *x == smallest).unwrap();\n    if\
    \ smallest_idx == lst.len() - 1 {\n        return None;\n    }\n    smallest =\
    \ lst.iter().nth(smallest_idx + 1).unwrap();\n    Some(smallest)\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuymjc4m6.rs:14:58\n   |\n\
    14 |     let mut smallest_idx = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                          ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    14 |     let mut smallest_idx = lst.iter().position(|x| *x == *smallest).unwrap();\n\
    \   |                                                          +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpuymjc4m6.rs:19:10\n   |\n19 |     Some(smallest)\n\
    \   |          ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n19 |     Some(*smallest)\n   |          +\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![lst[0]];\n    let mut smallest_idx\
    \ = 1;\n    for &x in lst {\n        if x < smallest[smallest_idx] {\n       \
    \     smallest[smallest_idx] = x;\n            smallest_idx += 1;\n        }\n\
    \    }\n    if smallest_idx == lst.len() {\n        None\n    } else {\n     \
    \   Some(smallest[smallest_idx])\n    }\n}\n\nfn main() {\n    let candidate =\
    \ next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n \
    \   assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf0u7p_at.rs:15:9\n   |\n\
    15 |     for &x in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n\n\
    \    let mut smallest = lst.iter().min();\n    let mut smallest_index = lst.iter().position(|x|\
    \ x == smallest).unwrap();\n\n    if smallest_index == lst.len() - 1 {\n     \
    \   return Some(smallest);\n    }\n\n    let mut second_smallest = lst.iter().skip(smallest_index\
    \ + 1).min();\n    let mut second_smallest_index = lst.iter().position(|x| x ==\
    \ second_smallest).unwrap();\n\n    if second_smallest_index == lst.len() - 1\
    \ {\n        return Some(second_smallest);\n    }\n\n    if smallest_index ==\
    \ second_smallest_index {\n        return Some(smallest);\n    }\n\n    if smallest\
    \ > second_smallest {\n        return Some(second_smallest);\n    }\n\n    Some(smallest)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `Option<&isize>`\n  --> /tmp/tmp2st7g77i.rs:18:56\n\
    \   |\n18 |     let mut smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n\
    \   |                                                        ^^ no implementation\
    \ for `&isize == Option<&isize>`\n   |\n   = help: the trait `PartialEq<Option<&isize>>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp2st7g77i.rs:21:21\n   |\n21 |         return Some(smallest);\n   | \
    \                    ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n  \
    \ = note: expected type `isize`\n              found enum `Option<&isize>`\n\n\
    error[E0277]: can't compare `&isize` with `Option<&isize>`\n  --> /tmp/tmp2st7g77i.rs:25:63\n\
    \   |\n25 |     let mut second_smallest_index = lst.iter().position(|x| x == second_smallest).unwrap();\n\
    \   |                                                               ^^ no implementation\
    \ for `&isize == Option<&isize>`\n   |\n   = help: the trait `PartialEq<Option<&isize>>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp2st7g77i.rs:28:21\n   |\n28 |         return Some(second_smallest);\n\
    \   |                     ^^^^^^^^^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<&isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2st7g77i.rs:32:21\n   |\n32 |\
    \         return Some(smallest);\n   |                     ^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<&isize>`\n\nerror[E0308]: mismat"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut second_smallest\
    \ = lst.iter().skip(1).min().unwrap();\n    if smallest == second_smallest {\n\
    \        return None;\n    }\n    Some(second_smallest)\n}\n\nfn main() {\n  \
    \  let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]),\
    \ Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppbu4lclk.rs:21:10\n   |\n\
    21 |     Some(second_smallest)\n   |          ^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n21 |  \
    \   Some(*second_smallest)\n   |          +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    for\
    \ x in lst {\n        if x < smallest[0] {\n            smallest[0] = x;\n   \
    \     }\n        if x > smallest[1] {\n            smallest[1] = x;\n        }\n\
    \    }\n    smallest.iter().next().map(|x| x).ok()\n}\n\nfn main() {\n    let\
    \ candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0345mwpa.rs:15:16\n   |\n\
    15 |         if x < smallest[0] {\n   |                ^^^^^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n15 |         if x < smallest[0].try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0345mwpa.rs:16:27\n   |\n16 |             smallest[0] =\
    \ x;\n   |             -----------   ^ expected `i32`, found `isize`\n   |   \
    \          |\n   |             expected due to the type of this binding\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0345mwpa.rs:18:16\n   |\n18 |         if x >\
    \ smallest[1] {\n   |                ^^^^^^^^^^^ expected `isize`, found `i32`\n\
    \   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n18 |         if x > smallest[1].try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0345mwpa.rs:19:27\n   |\n19 |             smallest[1] =\
    \ x;\n   |             -----------   ^ expected `i32`, found `isize`\n   |   \
    \          |\n   |             expected due to the type of this binding\n\nerror[E0599]:\
    \ no method named `ok` found for enum `Option` in the current scope\n  --> /tmp/tmp0345mwpa.rs:22:39\n\
    \   |\n22 |     smallest.iter().next().map(|x| x).ok()\n   |                 \
    \                      ^^ help: there is an associated function with a similar\
    \ name: `or`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![0; lst.len()];\n    let mut\
    \ smallest_idx = 0;\n    let mut smallest_val = lst.iter().min().unwrap();\n\n\
    \    for &x in lst {\n        if x < smallest_val {\n            smallest_val\
    \ = x;\n            smallest_idx = lst.iter().position(|&x| x == smallest_val).unwrap();\n\
    \        }\n    }\n\n    Some(smallest_val)\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa915ca3y.rs:17:9\n   |\n\
    17 |     for &x in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpa915ca3y.rs:20:58\n   |\n20 |             smallest_idx = lst.iter().position(|&x|\
    \ x == smallest_val).unwrap();\n   |                                         \
    \                 ^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n20 |             smallest_idx = lst.iter().position(|&x|\
    \ x == *smallest_val).unwrap();\n   |                                        \
    \                  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa915ca3y.rs:24:10\n\
    \   |\n24 |     Some(smallest_val)\n   |          ^^^^^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n24 |  \
    \   Some(*smallest_val)\n   |          +\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_idx = lst.iter().position(|&x| x == smallest).unwrap();\n    if\
    \ smallest_idx == lst.len() {\n        return None;\n    }\n    let mut smallest_val\
    \ = lst.iter().nth(smallest_idx).unwrap();\n    if smallest_val == smallest {\n\
    \        smallest_idx += 1;\n    }\n    Some(smallest)\n}\n\nfn main() {\n   \
    \ let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]),\
    \ Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmkcqknw2.rs:14:58\n   |\n\
    14 |     let mut smallest_idx = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                          ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    14 |     let mut smallest_idx = lst.iter().position(|&x| x == *smallest).unwrap();\n\
    \   |                                                          +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmkcqknw2.rs:22:10\n   |\n22 |     Some(smallest)\n\
    \   |          ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n22 |     Some(*smallest)\n   |          +\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        smallest_index = 0;\n    }\n    Some(smallest[smallest_index\
    \ + 1])\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `&isize`\n  --> /tmp/tmp3lznu16p.rs:21:10\n\
    \   |\n21 |     Some(smallest[smallest_index + 1])\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0608`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n\n\
    \    let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|x| x == smallest).unwrap();\n\n    if smallest_index\
    \ == lst.len() - 1 {\n        smallest_index = 0;\n    }\n\n    Some(smallest)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpro2dixna.rs:24:10\n   |\n\
    24 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n24 |     Some(*smallest)\n\
    \   |          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min_by_key(|x| x).unwrap();\n\
    \    if smallest.is_none() {\n        return None;\n    }\n    let mut smallest_index\
    \ = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        return Some(smallest);\n    }\n    let mut smallest_value\
    \ = lst.iter().nth(smallest_index).unwrap();\n    let mut second_smallest = lst.iter().skip(smallest_index\
    \ + 1).min_by_key(|x| x).unwrap();\n    if second_smallest == smallest {\n   \
    \     return Some(smallest);\n    }\n    if second_smallest == smallest_value\
    \ {\n        return Some(second_smallest);\n    }\n    Some(second_smallest)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_none` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmpek77xe6n.rs:14:17\n   |\n14 |     if smallest.is_none()\
    \ {\n   |                 ^^^^^^^ method not found in `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpek77xe6n.rs:19:21\n   |\n19 |         return\
    \ Some(smallest);\n   |                     ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n19 |         return Some(*smallest);\n\
    \   |                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpek77xe6n.rs:24:21\n\
    \   |\n24 |         return Some(smallest);\n   |                     ^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n24 |         return Some(*smallest);\n   |                     +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpek77xe6n.rs:27:21\n   |\n27 |         return\
    \ Some(second_smallest);\n   |                     ^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n27 |  \
    \       return Some(*second_smallest);\n   |                     +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpek77xe6n.rs:29:10\n   |\n29 |     Some(second_smallest)\n\
    \   |          ^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n29 |     Some(*second_smallest)\n   |      \
    \    +\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = 0;\n    for index in lst.iter().rev() {\n        if index\
    \ == smallest {\n            smallest_index += 1;\n        }\n        if index\
    \ == smallest + 1 {\n            return Some(smallest);\n        }\n        smallest\
    \ = index;\n    }\n    None\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp2nx5yrfq.rs:19:18\n\
    \   |\n19 |         if index == smallest + 1 {\n   |                  ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp2nx5yrfq.rs:20:25\n   |\n20 |             return Some(smallest);\n \
    \  |                         ^^^^^^^^ expected `isize`, found `&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n20 |             return Some(*smallest);\n\
    \   |                         +\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().cloned().enumerate().find(|(_, elem)| elem\
    \ < lst.iter().cloned().next().unwrap()).map(|(_, elem)| elem)\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_3hink8r.rs:13:61\n   |\n\
    13 |     lst.iter().cloned().enumerate().find(|(_, elem)| elem < lst.iter().cloned().next().unwrap()).map(|(_,\
    \ elem)| elem)\n   |                                                         \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |                               \
    \                              |\n   |                                       \
    \                      expected `&isize`, found `isize`\n   |                \
    \                                             help: consider borrowing here: `&lst.iter().cloned().next().unwrap()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n\n\
    \    let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = 0;\n    for index in lst.iter().rev() {\n        if index == smallest {\n\
    \            break;\n        }\n        smallest_index += 1;\n        smallest\
    \ = index;\n    }\n    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa478t4m3.rs:26:10\n   |\n\
    26 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n26 |     Some(*smallest)\n\
    \   |          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().enumerate().find(|(_, i)| i < lst.len() -\
    \ 2).map(|(_, j)| lst[j + 1])\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsa8my7i8.rs:13:46\n   |\n\
    13 |     lst.iter().enumerate().find(|(_, i)| i < lst.len() - 2).map(|(_, j)|\
    \ lst[j + 1])\n   |                                              ^^^^^^^^^^^^^\
    \ expected `&&isize`, found `usize`\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpsa8my7i8.rs:13:74\n   |\n13 |     lst.iter().enumerate().find(|(_,\
    \ i)| i < lst.len() - 2).map(|(_, j)| lst[j + 1])\n   |                      \
    \                                                    ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n \
    \   let mut min_val = lst[0];\n    let mut min_idx = 1;\n    for &x in lst {\n\
    \        if x < min_val {\n            min_val = x;\n            min_idx = 1;\n\
    \        } else if x == min_val {\n            min_idx += 1;\n        }\n    }\n\
    \    Some(min_val * min_idx)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_azjzfn4.rs:18:9\n   |\n\
    18 |     for &x in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n\n\
    \    let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|&x| x == smallest).unwrap();\n\n    if smallest_index\
    \ == lst.len() - 1 {\n        smallest_index = 0;\n    }\n\n    Some(smallest)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzyo5el1k.rs:18:60\n   |\n\
    18 |     let mut smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    18 |     let mut smallest_index = lst.iter().position(|&x| x == *smallest).unwrap();\n\
    \   |                                                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzyo5el1k.rs:24:10\n   |\n24 |     Some(smallest)\n\
    \   |          ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n24 |     Some(*smallest)\n   |          +\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().cloned().enumerate().find(|(_, i)| {\n  \
    \      i < lst.len() - 2 && lst[i] < lst[i + 1]\n    })\n}\n\nfn main() {\n  \
    \  let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]),\
    \ Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa9sih0pf.rs:14:13\n   |\n\
    14 |         i < lst.len() - 2 && lst[i] < lst[i + 1]\n   |             ^^^^^^^^^^^^^\
    \ expected `&isize`, found `usize`\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `&isize`\n  --> /tmp/tmpa9sih0pf.rs:14:30\n   |\n14 |        \
    \ i < lst.len() - 2 && lst[i] < lst[i + 1]\n   |                             \
    \ ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help:\
    \ the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpa9sih0pf.rs:14:39\n\
    \   |\n14 |         i < lst.len() - 2 && lst[i] < lst[i + 1]\n   |           \
    \                            ^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa9sih0pf.rs:13:5\n\
    \   |\n12 |   fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |     \
    \                                   ------------- expected `Option<isize>` because\
    \ of return type\n13 | /     lst.iter().cloned().enumerate().find(|(_, i)| {\n\
    14 | |         i < lst.len() - 2 && lst[i] < lst[i + 1]\n15 | |     })\n   | |______^\
    \ expected `isize`, found tuple\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found enum `Option<(usize, isize)>`\n\nerror: aborting due to 4\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    smallest[0]\
    \ = std::i32::MAX;\n    smallest[1] = std::i32::MAX;\n    for x in lst {\n   \
    \     if x < smallest[0] {\n            smallest[0] = x;\n        }\n        if\
    \ x < smallest[1] {\n            smallest[1] = x;\n        }\n    }\n    if smallest[0]\
    \ == std::i32::MAX {\n        return None;\n    }\n    if smallest[1] == std::i32::MAX\
    \ {\n        return None;\n    }\n    Some(smallest[1])\n}\n\nfn main() {\n  \
    \  let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]),\
    \ Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9nqxc5gr.rs:17:16\n   |\n\
    17 |         if x < smallest[0] {\n   |                ^^^^^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n17 |         if x < smallest[0].try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9nqxc5gr.rs:18:27\n   |\n18 |             smallest[0] =\
    \ x;\n   |             -----------   ^ expected `i32`, found `isize`\n   |   \
    \          |\n   |             expected due to the type of this binding\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9nqxc5gr.rs:20:16\n   |\n20 |         if x <\
    \ smallest[1] {\n   |                ^^^^^^^^^^^ expected `isize`, found `i32`\n\
    \   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |         if x < smallest[1].try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9nqxc5gr.rs:21:27\n   |\n21 |             smallest[1] =\
    \ x;\n   |             -----------   ^ expected `i32`, found `isize`\n   |   \
    \          |\n   |             expected due to the type of this binding\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9nqxc5gr.rs:30:10\n   |\n30 |     Some(smallest[1])\n\
    \   |          ^^^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n30 |     Some(smallest[1].try_into().unwrap())\n   |                  \
    \   ++++++++++++++++++++\n\nerror: aborting due to 5 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n \
    \   let mut min_val = lst.iter().min().unwrap();\n    let mut min_idx = lst.iter().position(|x|\
    \ x == min_val).unwrap();\n    if min_idx < lst.len() - 1 {\n        min_val =\
    \ lst.iter().nth(min_idx + 1).unwrap();\n        min_idx = lst.iter().position(|x|\
    \ x == min_val).unwrap();\n    }\n    Some(min_val)\n}\n\nfn main() {\n    let\
    \ candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptahrosn0.rs:22:10\n   |\n\
    22 |     Some(min_val)\n   |          ^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n22 |     Some(*min_val)\n\
    \   |          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    if\
    \ smallest == lst.len() {\n        return None;\n    }\n    let mut smallest_index\
    \ = smallest;\n    let mut smallest_value = lst.iter().nth(smallest).unwrap();\n\
    \    for &i in lst {\n        if *i < smallest_value {\n            smallest_value\
    \ = i;\n            smallest_index = i;\n        }\n    }\n    Some(smallest_index)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa6zq8ekg.rs:14:20\n   |\n\
    14 |     if smallest == lst.len() {\n   |                    ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n\nerror[E0277]: can't compare `&isize` with `usize`\n\
    \  --> /tmp/tmpa6zq8ekg.rs:14:17\n   |\n14 |     if smallest == lst.len() {\n\
    \   |                 ^^ no implementation for `&isize == usize`\n   |\n   = help:\
    \ the trait `PartialEq<usize>` is not implemented for `&isize`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpa6zq8ekg.rs:18:45\n   |\n18 |\
    \     let mut smallest_value = lst.iter().nth(smallest).unwrap();\n   |      \
    \                                       ^^^^^^^^ expected `usize`, found `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpa6zq8ekg.rs:19:9\n   |\n19 | \
    \    for &i in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpa6zq8ekg.rs:25:10\n   |\n25 |     Some(smallest_index)\n   |  \
    \        ^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n25 |     Some(*smallest_index)\n   |       \
    \   +\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst[0];\n    let mut smallest_idx\
    \ = 1;\n    for &i in lst {\n        if i < smallest {\n            smallest =\
    \ i;\n            smallest_idx = i;\n        }\n    }\n    Some(smallest_idx)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6zidg3zc.rs:15:9\n   |\n\
    15 |     for &i in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n\n\
    \    let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|x| *x == smallest).unwrap();\n\n    if smallest_index\
    \ == lst.len() - 1 {\n        smallest_index = 0;\n    }\n\n    Some(smallest)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpibi7ccs_.rs:18:60\n   |\n\
    18 |     let mut smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    18 |     let mut smallest_index = lst.iter().position(|x| *x == *smallest).unwrap();\n\
    \   |                                                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpibi7ccs_.rs:24:10\n   |\n24 |     Some(smallest)\n\
    \   |          ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n24 |     Some(*smallest)\n   |          +\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![0; lst.len()];\n    let mut\
    \ smallest_idx = -1;\n    for &i in lst {\n        if smallest_idx == i {\n  \
    \          continue;\n        }\n        if smallest_idx < i {\n            smallest_idx\
    \ = i;\n        }\n        smallest[i] = i;\n    }\n    if smallest_idx == -1\
    \ {\n        return None;\n    }\n    let mut smallest_val = vec![0; lst.len()];\n\
    \    let mut smallest_val_idx = -1;\n    for &i in lst {\n        if smallest_val_idx\
    \ == i {\n            continue;\n        }\n        if smallest_val_idx < i {\n\
    \            smallest_val_idx = i;\n        }\n        smallest_val[i] = i;\n\
    \    }\n    if smallest_val_idx == -1 {\n        return None;\n    }\n    let\
    \ mut smallest_val_val = vec![0; lst.len()];\n    let mut smallest_val_val_idx\
    \ = -1;\n    for &i in lst {\n        if smallest_val_val_idx == i {\n       \
    \     continue;\n        }\n        if smallest_val_val_idx < i {\n          \
    \  smallest_val_val_idx = i;\n        }\n        smallest_val_val[i] = i;\n  \
    \  }\n    if smallest_val_val_idx == -1 {\n        return None;\n    }\n    if\
    \ smallest_val[smallest_val_idx] < smallest[smallest_idx] {\n        smallest[smallest_idx]\
    \ = smallest_val[smallest_val_idx];\n    }\n    if smallest_val[smallest_val_idx]\
    \ < smallest_val[smallest_val_idx] {\n        smallest_val[smallest_val_idx] =\
    \ smallest_val[smallest_val_idx];\n    }\n    if smallest_val[smallest_val_idx]\
    \ < smallest_val_val[smallest_val_val_idx] {\n        smallest_val_val[smallest_val_val_idx]\
    \ = smallest_val_val[smallest_val_val_idx];\n    }\n    if smallest_val_val[smallest_val_val_idx]\
    \ < smallest[smallest_idx] {\n        smallest[smallest_idx] = smallest_val_val[smallest_val_val_idx];\n\
    \    }\n    if smallest_val_val[smallest_val_val_idx] < smallest_val[smallest_val_idx]\
    \ {\n        smallest_val[smallest_val_idx] = smallest_val_val[smallest_val_val_idx];\n\
    \    }\n    if smallest_val_val[smallest_val_val_idx] < smallest_val_val[smallest_val_val_idx]\
    \ {\n        smallest_val_val[smallest_val_val_idx] = smallest_val_val[smallest_val_\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp0_6sj3xs.rs:83:3\n\
    \   |\n12 | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |       \
    \                                             - unclosed delimiter\n...\n70 |\
    \     if smallest_val_val[smallest_val_val_idx] < smallest_val_val[smallest_val_val_idx]\
    \ {\n   |                                                                    \
    \                    - this delimiter might not be properly closed...\n71 |  \
    \       smallest_val_val[smallest_val_val_idx] = smallest_val_val[smallest_val_\n\
    72 | }\n   | - ...as it matches this but it has different indentation\n...\n83\
    \ | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp0_6sj3xs.rs:71:66\n\
    \   |\n12 | fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |       \
    \                                             - closing delimiter possibly meant\
    \ for this\n...\n71 |         smallest_val_val[smallest_val_val_idx] = smallest_val_val[smallest_val_\n\
    \   |                                                                  ^ unclosed\
    \ delimiter\n72 | }\n   | ^ mismatched closing delimiter\n\nerror[E0425]: cannot\
    \ find value `smallest_val_` in this scope\n  --> /tmp/tmp0_6sj3xs.rs:71:67\n\
    \   |\n71 |         smallest_val_val[smallest_val_val_idx] = smallest_val_val[smallest_val_\n\
    \   |                                                                   ^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `smallest_val`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0_6sj3xs.rs:15:9\n   |\n15 |     for &i in lst\
    \ {\n   |         ^^    --- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0277]: the trait bound `usize:\
    \ Neg` is not satisfied\n  --> /tmp/tmp0_6sj3xs.rs:14:28\n   |\n14 |     let mut\
    \ smallest_idx = -1;\n   |                            ^^ the trait `Neg` is not\
    \ implemented for `usize`\n   |\n   = help: the following other types imp"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    smallest[0]\
    \ = std::i32::MAX;\n    smallest[1] = std::i32::MAX;\n    for x in lst {\n   \
    \     if x < smallest[0] {\n            smallest[0] = x;\n        }\n        if\
    \ x < smallest[1] {\n            smallest[1] = x;\n        }\n    }\n    if smallest[0]\
    \ == smallest[1] {\n        None\n    } else {\n        Some(smallest[1])\n  \
    \  }\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg2s0lsm3.rs:17:16\n   |\n\
    17 |         if x < smallest[0] {\n   |                ^^^^^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n17 |         if x < smallest[0].try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpg2s0lsm3.rs:18:27\n   |\n18 |             smallest[0] =\
    \ x;\n   |             -----------   ^ expected `i32`, found `isize`\n   |   \
    \          |\n   |             expected due to the type of this binding\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpg2s0lsm3.rs:20:16\n   |\n20 |         if x <\
    \ smallest[1] {\n   |                ^^^^^^^^^^^ expected `isize`, found `i32`\n\
    \   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |         if x < smallest[1].try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpg2s0lsm3.rs:21:27\n   |\n21 |             smallest[1] =\
    \ x;\n   |             -----------   ^ expected `i32`, found `isize`\n   |   \
    \          |\n   |             expected due to the type of this binding\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpg2s0lsm3.rs:27:14\n   |\n27 |         Some(smallest[1])\n\
    \   |              ^^^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you\
    \ can convert an `i32` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n27 |         Some(smallest[1].try_into().unwrap())\n   |        \
    \                 ++++++++++++++++++++\n\nerror: aborting due to 5 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    for\
    \ x in lst {\n        if x < smallest[0] {\n            smallest[0] = x;\n   \
    \     }\n        if x > smallest[1] {\n            smallest[1] = x;\n        }\n\
    \    }\n    smallest\n        .iter()\n        .next()\n        .cloned()\n  \
    \      .ok_or(std::iter::Error::custom(\"next_smallest failed\"))\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: could not find `Error` in `iter`\n  -->\
    \ /tmp/tmpbs_phkgj.rs:26:27\n   |\n26 |         .ok_or(std::iter::Error::custom(\"\
    next_smallest failed\"))\n   |                           ^^^^^ not found in `std::iter`\n\
    \   |\nhelp: consider importing one of these items\n   |\n1  | use std::error::Error;\n\
    \   |\n1  | use std::fmt::Error;\n   |\n1  | use std::io::Error;\n   |\nhelp:\
    \ if you import `Error`, refer to it directly\n   |\n26 -         .ok_or(std::iter::Error::custom(\"\
    next_smallest failed\"))\n26 +         .ok_or(Error::custom(\"next_smallest failed\"\
    ))\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbs_phkgj.rs:15:16\n\
    \   |\n15 |         if x < smallest[0] {\n   |                ^^^^^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n15 |         if x < smallest[0].try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbs_phkgj.rs:16:27\n   |\n16 |             smallest[0] =\
    \ x;\n   |             -----------   ^ expected `i32`, found `isize`\n   |   \
    \          |\n   |             expected due to the type of this binding\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbs_phkgj.rs:18:16\n   |\n18 |         if x >\
    \ smallest[1] {\n   |                ^^^^^^^^^^^ expected `isize`, found `i32`\n\
    \   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n18 |         if x > smallest[1].try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbs_phkgj.rs:19:27\n   |\n19 |             smallest[1] =\
    \ x;\n   |             -----------   ^ expected `i32`, found `isize`\n   |   \
    \          |\n   |             expected due to the type of this binding\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbs_phkgj.rs:22:5\n   |\n12 |   fn next_smallest(lst:\
    \ Vec<isize>) -> Option<isize> {\n   |                                       \
    \ ------------- expected `Option<isize>` because of return type\n...\n22 | / \
    \  "
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min_by_key(|&x| x).unwrap();\n\
    \    if smallest.is_none() {\n        return None;\n    }\n    let mut smallest_idx\
    \ = 1;\n    for &x in lst {\n        if x < smallest {\n            smallest =\
    \ x;\n            smallest_idx = 1;\n        }\n        if x == smallest {\n \
    \           smallest_idx += 1;\n        }\n    }\n    Some(smallest)\n}\n\nfn\
    \ main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_none` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmpy3nuu_ml.rs:14:17\n   |\n14 |     if smallest.is_none()\
    \ {\n   |                 ^^^^^^^ method not found in `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpy3nuu_ml.rs:18:9\n   |\n18 |     for &x in lst\
    \ {\n   |         ^^    --- this expression has type `Option<isize>`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `x`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpy3nuu_ml.rs:27:10\n   |\n27 |     Some(smallest)\n   |        \
    \  ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n27 |     Some(*smallest)\n   |          +\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    for\
    \ x in lst {\n        if x < smallest[0] {\n            smallest[0] = x;\n   \
    \     }\n        if x > smallest[1] {\n            smallest[1] = x;\n        }\n\
    \    }\n    smallest.iter().cloned().next()\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9iequ0xw.rs:15:16\n   |\n\
    15 |         if x < smallest[0] {\n   |                ^^^^^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n15 |         if x < smallest[0].try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9iequ0xw.rs:16:27\n   |\n16 |             smallest[0] =\
    \ x;\n   |             -----------   ^ expected `i32`, found `isize`\n   |   \
    \          |\n   |             expected due to the type of this binding\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9iequ0xw.rs:18:16\n   |\n18 |         if x >\
    \ smallest[1] {\n   |                ^^^^^^^^^^^ expected `isize`, found `i32`\n\
    \   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n18 |         if x > smallest[1].try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9iequ0xw.rs:19:27\n   |\n19 |             smallest[1] =\
    \ x;\n   |             -----------   ^ expected `i32`, found `isize`\n   |   \
    \          |\n   |             expected due to the type of this binding\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9iequ0xw.rs:22:5\n   |\n12 | fn next_smallest(lst:\
    \ Vec<isize>) -> Option<isize> {\n   |                                      -------------\
    \ expected `Option<isize>` because of return type\n...\n22 |     smallest.iter().cloned().next()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `i32`\n   |\n\
    \   = note: expected enum `Option<isize>`\n              found enum `Option<i32>`\n\
    \nerror: aborting due to 5 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![lst[0]];\n    let mut smallest_idx\
    \ = 1;\n    for &x in lst {\n        if x < smallest[smallest_idx] {\n       \
    \     smallest[smallest_idx] = x;\n            smallest_idx += 1;\n        }\n\
    \    }\n    if smallest_idx == lst.len() {\n        return None;\n    }\n    Some(smallest[smallest_idx])\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp796mlzjl.rs:15:9\n   |\n\
    15 |     for &x in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![0; lst.len()];\n    let mut\
    \ index = 0;\n    let mut smallest_index = 0;\n    for &x in lst {\n        if\
    \ x < smallest[smallest_index] {\n            smallest[smallest_index] = x;\n\
    \            smallest_index = index;\n        }\n        index += 1;\n    }\n\
    \    if smallest_index == 0 {\n        return None;\n    }\n    Some(smallest[smallest_index\
    \ - 1])\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_pqeatpf.rs:16:9\n   |\n\
    16 |     for &x in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n   \
    \ if smallest_index == lst.len() {\n        return None;\n    }\n    smallest\
    \ = lst.iter().nth(smallest_index).unwrap();\n    smallest_index += 1;\n    if\
    \ smallest_index == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().nth(smallest_index).unwrap();\n\
    \    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n  \
    \  assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoafpzo73.rs:14:60\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    14 |     let mut smallest_index = lst.iter().position(|x| *x == *smallest).unwrap();\n\
    \   |                                                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpoafpzo73.rs:24:10\n   |\n24 |     Some(smallest)\n\
    \   |          ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n24 |     Some(*smallest)\n   |          +\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![0; lst.len()];\n    let mut\
    \ smallest_idx = vec![0; lst.len()];\n    for &i in lst {\n        smallest[smallest_idx[i]]\
    \ = i;\n        smallest_idx[i] = i;\n    }\n    smallest_idx[lst.len()] = lst.len();\n\
    \    smallest_idx\n        .iter()\n        .cloned()\n        .enumerate()\n\
    \        .filter_map(|(i, j)| {\n            if smallest[j] < smallest[i] {\n\
    \                Some(smallest[j])\n            } else {\n                None\n\
    \            }\n        })\n        .next()\n        .unwrap()\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe38vdz1s.rs:15:9\n   |\n\
    15 |     for &i in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpe38vdz1s.rs:20:5\n   |\n12 |   fn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n   |                                        -------------\
    \ expected `Option<isize>` because of return type\n...\n20 | /     smallest_idx\n\
    21 | |         .iter()\n22 | |         .cloned()\n23 | |         .enumerate()\n\
    ...  |\n31 | |         .next()\n32 | |         .unwrap()\n   | |_________________^\
    \ expected enum `Option`, found integer\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found type `{integer}`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n20 ~     Some(smallest_idx\n21 |         .iter()\n22 |         .cloned()\n\
    23 |         .enumerate()\n24 |         .filter_map(|(i, j)| {\n25 |         \
    \    if smallest[j] < smallest[i] {\n ...\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().cloned().enumerate().find(|(_, elem)| elem\
    \ < lst.iter().cloned().next().unwrap()).map(|(_, elem)| elem)\n}\n\nfn main()\
    \ {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_3hink8r.rs:13:61\n   |\n\
    13 |     lst.iter().cloned().enumerate().find(|(_, elem)| elem < lst.iter().cloned().next().unwrap()).map(|(_,\
    \ elem)| elem)\n   |                                                         \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |                               \
    \                              |\n   |                                       \
    \                      expected `&isize`, found `isize`\n   |                \
    \                                             help: consider borrowing here: `&lst.iter().cloned().next().unwrap()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min();\n    if smallest\
    \ == lst.len() {\n        return None;\n    }\n    let mut smallest_idx = 1;\n\
    \    for &i in lst {\n        if i == smallest {\n            smallest_idx +=\
    \ 1;\n        }\n        if smallest_idx > 2 {\n            break;\n        }\n\
    \    }\n    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz121gr9e.rs:14:20\n   |\n\
    14 |     if smallest == lst.len() {\n   |                    ^^^^^^^^^ expected\
    \ enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<&isize>`\n\
    \              found type `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz121gr9e.rs:18:9\n\
    \   |\n18 |     for &i in lst {\n   |         ^^    --- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpz121gr9e.rs:26:10\n   |\n26 |     Some(smallest)\n\
    \   |          ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note:\
    \ expected type `isize`\n              found enum `Option<&isize>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() <= 1 {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|x| *x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        smallest_index = 0;\n    }\n    Some(smallest)\n}\n\
    \nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp_yyi7l5.rs:17:60\n   |\n\
    17 |     let mut smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    17 |     let mut smallest_index = lst.iter().position(|x| *x == *smallest).unwrap();\n\
    \   |                                                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpp_yyi7l5.rs:21:10\n   |\n21 |     Some(smallest)\n\
    \   |          ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n21 |     Some(*smallest)\n   |          +\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![lst[0]];\n    let mut smallest_idx\
    \ = 1;\n    for &i in &lst {\n        if *i < smallest[smallest_idx] {\n     \
    \       smallest[smallest_idx] = *i;\n            smallest_idx += 1;\n       \
    \ }\n    }\n    if smallest_idx == lst.len() {\n        return None;\n    }\n\
    \    Some(smallest[smallest_idx])\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpk2gyr9xh.rs:16:12\n\
    \   |\n16 |         if *i < smallest[smallest_idx] {\n   |            ^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpk2gyr9xh.rs:17:38\n   |\n\
    17 |             smallest[smallest_idx] = *i;\n   |                          \
    \            ^^\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    for\
    \ &x in lst {\n        if x < smallest[0] {\n            smallest[0] = x;\n  \
    \      }\n        if x > smallest[1] {\n            smallest[1] = x;\n       \
    \ }\n    }\n    smallest.iter().cloned().next()\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2262u0o0.rs:14:9\n   |\n\
    14 |     for &x in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2262u0o0.rs:22:5\n   |\n12 | fn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n   |                                      -------------\
    \ expected `Option<isize>` because of return type\n...\n22 |     smallest.iter().cloned().next()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `i32`\n   |\n\
    \   = note: expected enum `Option<isize>`\n              found enum `Option<i32>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        smallest_index = 0;\n    }\n    Some(smallest[smallest_index\
    \ + 1])\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `&isize`\n  --> /tmp/tmp3lznu16p.rs:21:10\n\
    \   |\n21 |     Some(smallest[smallest_index + 1])\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0608`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    smallest[0]\
    \ = std::i32::MAX;\n    smallest[1] = std::i32::MAX;\n    for x in lst {\n   \
    \     if x < smallest[0] {\n            smallest[0] = x;\n        }\n        if\
    \ x < smallest[1] {\n            smallest[1] = x;\n        }\n    }\n    if smallest[0]\
    \ == std::i32::MAX {\n        None\n    } else {\n        Some(smallest[1])\n\
    \    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj2x4foyx.rs:17:16\n   |\n\
    17 |         if x < smallest[0] {\n   |                ^^^^^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n17 |         if x < smallest[0].try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpj2x4foyx.rs:18:27\n   |\n18 |             smallest[0] =\
    \ x;\n   |             -----------   ^ expected `i32`, found `isize`\n   |   \
    \          |\n   |             expected due to the type of this binding\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpj2x4foyx.rs:20:16\n   |\n20 |         if x <\
    \ smallest[1] {\n   |                ^^^^^^^^^^^ expected `isize`, found `i32`\n\
    \   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |         if x < smallest[1].try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpj2x4foyx.rs:21:27\n   |\n21 |             smallest[1] =\
    \ x;\n   |             -----------   ^ expected `i32`, found `isize`\n   |   \
    \          |\n   |             expected due to the type of this binding\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpj2x4foyx.rs:27:14\n   |\n27 |         Some(smallest[1])\n\
    \   |              ^^^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you\
    \ can convert an `i32` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n27 |         Some(smallest[1].try_into().unwrap())\n   |        \
    \                 ++++++++++++++++++++\n\nerror: aborting due to 5 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![lst[0]; 2];\n    let mut smallest_idx\
    \ = 1;\n    for &x in lst {\n        if x < smallest[smallest_idx] {\n       \
    \     smallest[smallest_idx] = x;\n            smallest_idx += 1;\n        }\n\
    \    }\n    if smallest_idx == 2 {\n        Some(smallest[1])\n    } else {\n\
    \        None\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppa7j9mi3.rs:15:9\n   |\n\
    15 |     for &x in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_idx =\
    \ lst.iter().position(|x| *x == smallest).unwrap();\n    if smallest_idx == lst.len()\
    \ - 1 {\n        smallest_idx = 0;\n    }\n    Some(smallest[smallest_idx + 1])\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp51kf_iw.rs:17:58\n   |\n\
    17 |     let mut smallest_idx = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                          ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    17 |     let mut smallest_idx = lst.iter().position(|x| *x == *smallest).unwrap();\n\
    \   |                                                          +\n\nerror[E0608]:\
    \ cannot index into a value of type `&isize`\n  --> /tmp/tmpp51kf_iw.rs:21:10\n\
    \   |\n21 |     Some(smallest[smallest_idx + 1])\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0608.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![lst[0]];\n    let mut smallest_idx\
    \ = 1;\n    for &x in lst {\n        if x < smallest[smallest_idx] {\n       \
    \     smallest[smallest_idx] = x;\n            smallest_idx += 1;\n        }\n\
    \    }\n    if smallest_idx == lst.len() {\n        return None;\n    }\n    Some(smallest[smallest_idx])\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp796mlzjl.rs:15:9\n   |\n\
    15 |     for &x in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min();\n    let mut smallest_idx\
    \ = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_idx == lst.len()\
    \ - 1 {\n        return None;\n    }\n    smallest = lst.iter().nth(smallest_idx\
    \ + 1).unwrap();\n    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `Option<&isize>`\n  --> /tmp/tmpnqew2f0f.rs:14:54\n\
    \   |\n14 |     let mut smallest_idx = lst.iter().position(|x| x == smallest).unwrap();\n\
    \   |                                                      ^^ no implementation\
    \ for `&isize == Option<&isize>`\n   |\n   = help: the trait `PartialEq<Option<&isize>>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpnqew2f0f.rs:18:16\n   |\n13 |     let mut smallest = lst.iter().min();\n\
    \   |                        ---------------- expected due to this value\n...\n\
    18 |     smallest = lst.iter().nth(smallest_idx + 1).unwrap();\n   |         \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`, found\
    \ `&isize`\n   |\n   = note:   expected enum `Option<&isize>`\n           found\
    \ reference `&isize`\nhelp: try wrapping the expression in `Some`\n   |\n18 |\
    \     smallest = Some(lst.iter().nth(smallest_idx + 1).unwrap());\n   |      \
    \          +++++                                         +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnqew2f0f.rs:19:10\n   |\n19 |     Some(smallest)\n   |\
    \          ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected\
    \ type `isize`\n              found enum `Option<&isize>`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    for\
    \ elt in lst {\n        if elt < smallest[0] {\n            smallest[0] = elt;\n\
    \        }\n        if elt < smallest[1] {\n            smallest[1] = elt;\n \
    \       }\n    }\n    smallest\n        .iter()\n        .next()\n        .map(|elt|\
    \ elt)\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoy6xga1o.rs:15:18\n   |\n\
    15 |         if elt < smallest[0] {\n   |                  ^^^^^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n15 |         if elt < smallest[0].try_into().unwrap()\
    \ {\n   |                             ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpoy6xga1o.rs:16:27\n   |\n16 |             smallest[0] =\
    \ elt;\n   |             -----------   ^^^ expected `i32`, found `isize`\n   |\
    \             |\n   |             expected due to the type of this binding\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpoy6xga1o.rs:18:18\n   |\n18 |  \
    \       if elt < smallest[1] {\n   |                  ^^^^^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n18 |         if elt < smallest[1].try_into().unwrap()\
    \ {\n   |                             ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpoy6xga1o.rs:19:27\n   |\n19 |             smallest[1] =\
    \ elt;\n   |             -----------   ^^^ expected `i32`, found `isize`\n   |\
    \             |\n   |             expected due to the type of this binding\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpoy6xga1o.rs:22:5\n   |\n12 |   fn\
    \ next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |                    \
    \                    ------------- expected `Option<isize>` because of return\
    \ type\n...\n22 | /     smallest\n23 | |         .iter()\n24 | |         .next()\n\
    25 | |         .map(|elt| elt)\n   | |_______________________^ expected `isize`,\
    \ found `&i32`\n   |\n   = note: expected enum `Option<isize>`\n             \
    \ found enum `Option<&i32>`\n\nerror: aborting due to 5 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    for\
    \ elt in lst {\n        if smallest[0] < elt {\n            smallest[0] = elt;\n\
    \        }\n        if smallest[1] < elt {\n            smallest[1] = elt;\n \
    \       }\n    }\n    if smallest[0] == std::i32::MAX {\n        None\n    } else\
    \ {\n        Some(smallest[1])\n    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm76sdb4z.rs:15:26\n   |\n\
    15 |         if smallest[0] < elt {\n   |                          ^^^ expected\
    \ `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an `i32` and\
    \ panic if the converted value doesn't fit\n   |\n15 |         if smallest[0]\
    \ < elt.try_into().unwrap() {\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpm76sdb4z.rs:16:27\n   |\n16 |\
    \             smallest[0] = elt;\n   |             -----------   ^^^ expected\
    \ `i32`, found `isize`\n   |             |\n   |             expected due to the\
    \ type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm76sdb4z.rs:18:26\n\
    \   |\n18 |         if smallest[1] < elt {\n   |                          ^^^\
    \ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n18 |         if smallest[1]\
    \ < elt.try_into().unwrap() {\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpm76sdb4z.rs:19:27\n   |\n19 |\
    \             smallest[1] = elt;\n   |             -----------   ^^^ expected\
    \ `i32`, found `isize`\n   |             |\n   |             expected due to the\
    \ type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm76sdb4z.rs:25:14\n\
    \   |\n25 |         Some(smallest[1])\n   |              ^^^^^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n25 |         Some(smallest[1].try_into().unwrap())\n\
    \   |                         ++++++++++++++++++++\n\nerror: aborting due to 5\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![0; lst.len()];\n    let mut\
    \ smallest_idx = vec![0; lst.len()];\n    for &i in lst {\n        smallest[smallest_idx[i]]\
    \ = i;\n        smallest_idx[i] = i;\n    }\n    for i in 0..lst.len() {\n   \
    \     if smallest[smallest_idx[i]] < smallest[smallest_idx[smallest_idx[i] + 1]]\
    \ {\n            smallest_idx[smallest_idx[i] + 1] = i;\n        }\n    }\n  \
    \  smallest_idx[smallest_idx[lst.len() - 1]]\n        .map(|i| smallest[i])\n\
    \        .unwrap_or(None)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuan4ssbd.rs:15:9\n   |\n\
    15 |     for &i in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0599]: `usize` is not\
    \ an iterator\n  --> /tmp/tmpuan4ssbd.rs:25:10\n   |\n25 |         .map(|i| smallest[i])\n\
    \   |          ^^^ `usize` is not an iterator\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `usize: Iterator`\n           which\
    \ is required by `&mut usize: Iterator`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n\n\
    \    let mut smallest = vec![vec![0], vec![0]];\n    let mut smallest_idx = 1;\n\
    \    let mut smallest_val = vec![0];\n\n    for &i in lst {\n        if smallest[smallest_idx].len()\
    \ < i {\n            smallest[smallest_idx] = vec![smallest_val, i];\n       \
    \     smallest_idx += 1;\n        }\n    }\n\n    let mut smallest_idx = 0;\n\
    \    let mut smallest_val = vec![0];\n\n    for &i in lst {\n        if smallest[smallest_idx].len()\
    \ < i {\n            smallest[smallest_idx] = vec![smallest_val, i];\n       \
    \     smallest_idx += 1;\n        }\n    }\n\n    if smallest[smallest_idx].len()\
    \ == 1 {\n        Some(smallest[smallest_idx].0)\n    } else {\n        None\n\
    \    }\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjgjc9e8g.rs:21:9\n   |\n\
    21 |     for &i in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjgjc9e8g.rs:23:43\n   |\n23 |             smallest[smallest_idx]\
    \ = vec![smallest_val, i];\n   |                                           ^^^^^^^^^^^^\
    \ expected integer, found struct `Vec`\n   |\n   = note: expected type `{integer}`\n\
    \            found struct `Vec<{integer}>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjgjc9e8g.rs:31:9\n   |\n31 |     for &i in lst {\n   |        \
    \ ^^    --- this expression has type `Option<isize>`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `i`\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjgjc9e8g.rs:33:43\n\
    \   |\n33 |             smallest[smallest_idx] = vec![smallest_val, i];\n   |\
    \                                           ^^^^^^^^^^^^ expected integer, found\
    \ struct `Vec`\n   |\n   = note: expected type `{integer}`\n            found\
    \ struct `Vec<{integer}>`\n\nerror[E0609]: no field `0` on type `Vec<{integer}>`\n\
    \  --> /tmp/tmpjgjc9e8g.rs:39:37\n   |\n39 |         Some(smallest[smallest_idx].0)\n\
    \   |                                     ^ unknown field\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0609.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011046
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|x| x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        smallest_index = 0;\n    }\n    Some(smallest)\n}\n\
    \nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdip3dbce.rs:21:10\n   |\n\
    21 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n21 |     Some(*smallest)\n\
    \   |          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().cloned().enumerate().find(|(_, x)| x < lst.len()\
    \ - 2).map(|(_, x)| x).ok()\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpada8p4vy.rs:13:55\n   |\n\
    13 |     lst.iter().cloned().enumerate().find(|(_, x)| x < lst.len() - 2).map(|(_,\
    \ x)| x).ok()\n   |                                                       ^^^^^^^^^^^^^\
    \ expected `&isize`, found `usize`\n\nerror[E0599]: no method named `ok` found\
    \ for enum `Option` in the current scope\n  --> /tmp/tmpada8p4vy.rs:13:86\n  \
    \ |\n13 |     lst.iter().cloned().enumerate().find(|(_, x)| x < lst.len() - 2).map(|(_,\
    \ x)| x).ok()\n   |                                                          \
    \                            ^^ help: there is an associated function with a similar\
    \ name: `or`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = 0;\n    for &i in lst {\n        if i < smallest {\n            smallest_index\
    \ += 1;\n            smallest = i;\n        }\n    }\n    Some(smallest)\n}\n\n\
    fn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbfza5d1n.rs:18:9\n   |\n\
    18 |     for &i in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbfza5d1n.rs:24:10\n   |\n24 |     Some(smallest)\n   |        \
    \  ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n24 |     Some(*smallest)\n   |          +\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![lst[0]];\n    let mut smallest_index\
    \ = vec![0];\n    let mut smallest_value = vec![0];\n    for ele in lst {\n  \
    \      if ele < smallest[0] {\n            smallest[0] = ele;\n            smallest_index[0]\
    \ = smallest_index[0] + 1;\n            smallest_value[0] = smallest[0];\n   \
    \     } else {\n            if smallest_index[0] < smallest_value.len() {\n  \
    \              if ele < smallest_value[smallest_index[0]] {\n                \
    \    smallest[0] = ele;\n                    smallest_index[0] = smallest_index[0]\
    \ + 1;\n                    smallest_value[0] = smallest[0];\n               \
    \ }\n            }\n        }\n    }\n    smallest_index[0]\n        .checked_sub(smallest_value.len())\n\
    \        .ok_or(ErrorKind::IndexOutOfBounds)\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `ErrorKind`\n \
    \ --> /tmp/tmpv4yzw4jd.rs:33:16\n   |\n33 |         .ok_or(ErrorKind::IndexOutOfBounds)\n\
    \   |                ^^^^^^^^^ use of undeclared type `ErrorKind`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpv4yzw4jd.rs:31:5\n   |\n12 |   fn next_smallest(lst:\
    \ Vec<isize>) -> Option<isize> {\n   |                                       \
    \ ------------- expected `Option<isize>` because of return type\n...\n31 | / \
    \    smallest_index[0]\n32 | |         .checked_sub(smallest_value.len())\n33\
    \ | |         .ok_or(ErrorKind::IndexOutOfBounds)\n   | |___________________________________________^\
    \ expected enum `Option`, found enum `Result`\n   |\n   = note: expected enum\
    \ `Option<isize>`\n              found enum `Result<usize, _>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_idx =\
    \ 1;\n    for &x in lst {\n        if x < smallest {\n            smallest = x;\n\
    \            smallest_idx = 1;\n        } else if x == smallest {\n          \
    \  smallest_idx += 1;\n        }\n    }\n    Some(smallest)\n}\n\nfn main() {\n\
    \    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4,\
    \ 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3gwtkpl0.rs:18:9\n   |\n\
    18 |     for &x in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3gwtkpl0.rs:26:10\n   |\n26 |     Some(smallest)\n   |        \
    \  ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n26 |     Some(*smallest)\n   |          +\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![0; lst.len()];\n    let mut\
    \ smallest_idx = vec![0; lst.len()];\n    let mut smallest_val = vec![0; lst.len()];\n\
    \    let mut smallest_idx = vec![0; lst.len()];\n    for i in lst.iter() {\n \
    \       smallest[i] = i;\n        smallest_idx[i] = i;\n        smallest_val[i]\
    \ = i;\n    }\n    for i in lst.iter().rev() {\n        if smallest[i] == 0 {\n\
    \            continue;\n        }\n        for j in lst.iter().rev() {\n     \
    \       if smallest[j] == 0 {\n                continue;\n            }\n    \
    \        if smallest[j] < smallest[i] {\n                smallest[i] = smallest[j];\n\
    \                smallest_idx[i] = j;\n                smallest_val[i] = smallest[j];\n\
    \            }\n        }\n    }\n    if smallest[0] == 0 {\n        return None;\n\
    \    }\n    Some(smallest[smallest_idx[0]])\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[{integer}]` cannot be indexed by `&isize`\n  -->\
    \ /tmp/tmp7gggjmjv.rs:18:9\n   |\n18 |         smallest[i] = i;\n   |        \
    \ ^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n \
    \  = help: the trait `SliceIndex<[{integer}]>` is not implemented for `&isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<&isize>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `&isize`\n  --> /tmp/tmp7gggjmjv.rs:19:9\n\
    \   |\n19 |         smallest_idx[i] = i;\n   |         ^^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `&isize`\n  --> /tmp/tmp7gggjmjv.rs:20:9\n   |\n20 |  \
    \       smallest_val[i] = i;\n   |         ^^^^^^^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `&isize`\n  --> /tmp/tmp7gggjmjv.rs:23:12\n   |\n23 | \
    \        if smallest[i] == 0 {\n   |            ^^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `&isize`\n  --> /tmp/tmp7gggjmjv.rs:27:16\n   |\n27 | \
    \            if smallest[j] == 0 {\n   |                ^^^^"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n    if\
    \ smallest_index == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().skip(smallest_index).min().unwrap();\n\
    \    smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n    if\
    \ smallest_index == lst.len() {\n        return None;\n    }\n    Some(smallest)\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb3t6p2pv.rs:23:10\n   |\n\
    23 |     Some(smallest)\n   |          ^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n23 |     Some(*smallest)\n\
    \   |          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n\n\
    \    let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_idx =\
    \ lst.iter().position(|x| *x == smallest).unwrap();\n\n    if smallest_idx ==\
    \ lst.len() - 1 {\n        smallest_idx = 0;\n    }\n\n    Some(smallest)\n}\n\
    \nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb3fpnu1w.rs:18:58\n   |\n\
    18 |     let mut smallest_idx = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                          ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    18 |     let mut smallest_idx = lst.iter().position(|x| *x == *smallest).unwrap();\n\
    \   |                                                          +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpb3fpnu1w.rs:24:10\n   |\n24 |     Some(smallest)\n\
    \   |          ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n24 |     Some(*smallest)\n   |          +\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = 0;\n    for &x in lst {\n        if x < smallest {\n            smallest =\
    \ x;\n            smallest_index += 1;\n        }\n    }\n    Some(smallest as\
    \ isize)\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph6prglsh.rs:18:9\n   |\n\
    18 |     for &x in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0606]: casting `&isize`\
    \ as `isize` is invalid\n  --> /tmp/tmph6prglsh.rs:24:10\n   |\n24 |     Some(smallest\
    \ as isize)\n   |          --------^^^^^^^^^\n   |          |\n   |          cannot\
    \ cast `&isize` as `isize`\n   |          help: dereference the expression: `*smallest`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0606.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![0; lst.len()];\n    let mut\
    \ smallest_idx = 0;\n    let mut smallest_val = lst.iter().min().unwrap();\n \
    \   for &x in lst {\n        if x < smallest_val {\n            smallest_val =\
    \ x;\n            smallest_idx = lst.iter().position(|&x| x == smallest_val).unwrap();\n\
    \        }\n        smallest[smallest_idx] = x;\n    }\n    Some(smallest[smallest_idx\
    \ + 1])\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptfq7dw77.rs:16:9\n   |\n\
    16 |     for &x in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptfq7dw77.rs:19:58\n   |\n19 |             smallest_idx = lst.iter().position(|&x|\
    \ x == smallest_val).unwrap();\n   |                                         \
    \                 ^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n19 |             smallest_idx = lst.iter().position(|&x|\
    \ x == *smallest_val).unwrap();\n   |                                        \
    \                  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptfq7dw77.rs:21:34\n\
    \   |\n21 |         smallest[smallest_idx] = x;\n   |         ----------------------\
    \   ^ expected integer, found `&isize`\n   |         |\n   |         expected\
    \ due to the type of this binding\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n21 |         smallest[smallest_idx] = *x;\n   |                       \
    \           +\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.is_empty() {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|x| *x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        smallest_index = 0;\n    }\n    Some(smallest[smallest_index\
    \ + 1])\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp85mon6i0.rs:17:60\n   |\n\
    17 |     let mut smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    17 |     let mut smallest_index = lst.iter().position(|x| *x == *smallest).unwrap();\n\
    \   |                                                            +\n\nerror[E0608]:\
    \ cannot index into a value of type `&isize`\n  --> /tmp/tmp85mon6i0.rs:21:10\n\
    \   |\n21 |     Some(smallest[smallest_index + 1])\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0608.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().cloned().enumerate().find(|(_, i)| {\n  \
    \      i < lst.len() - 2 && lst[i] < lst[i + 1]\n    }).map(|(_, i)| lst[i + 1])\n\
    }\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgjqbi5wh.rs:14:13\n   |\n\
    14 |         i < lst.len() - 2 && lst[i] < lst[i + 1]\n   |             ^^^^^^^^^^^^^\
    \ expected `&isize`, found `usize`\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `&isize`\n  --> /tmp/tmpgjqbi5wh.rs:14:30\n   |\n14 |        \
    \ i < lst.len() - 2 && lst[i] < lst[i + 1]\n   |                             \
    \ ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help:\
    \ the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpgjqbi5wh.rs:14:39\n\
    \   |\n14 |         i < lst.len() - 2 && lst[i] < lst[i + 1]\n   |           \
    \                            ^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpgjqbi5wh.rs:15:21\n   |\n15 |     }).map(|(_, i)| lst[i + 1])\n\
    \   |                     ^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    if lst.len() == 0 {\n        return None;\n    }\n \
    \   let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|&x| x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        smallest_index = 0;\n    }\n    Some(smallest[smallest_index\
    \ + 1])\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphnx9ohxs.rs:17:60\n   |\n\
    17 |     let mut smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                            ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    17 |     let mut smallest_index = lst.iter().position(|&x| x == *smallest).unwrap();\n\
    \   |                                                            +\n\nerror[E0608]:\
    \ cannot index into a value of type `&isize`\n  --> /tmp/tmphnx9ohxs.rs:21:10\n\
    \   |\n21 |     Some(smallest[smallest_index + 1])\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0608.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = vec![std::i32::MAX; 2];\n    smallest[0]\
    \ = std::i32::MAX;\n    for elt in lst {\n        if elt < smallest[0] {\n   \
    \         smallest[0] = elt;\n        }\n    }\n    if smallest[0] == std::i32::MAX\
    \ {\n        return None;\n    }\n    smallest[1] = smallest[0];\n    for elt\
    \ in lst {\n        if elt < smallest[1] {\n            smallest[1] = elt;\n \
    \       }\n    }\n    Some(smallest[1])\n}\n\nfn main() {\n    let candidate =\
    \ next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n \
    \   assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1omgz9yp.rs:16:18\n   |\n\
    16 |         if elt < smallest[0] {\n   |                  ^^^^^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n16 |         if elt < smallest[0].try_into().unwrap()\
    \ {\n   |                             ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1omgz9yp.rs:17:27\n   |\n17 |             smallest[0] =\
    \ elt;\n   |             -----------   ^^^ expected `i32`, found `isize`\n   |\
    \             |\n   |             expected due to the type of this binding\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp1omgz9yp.rs:25:18\n   |\n25 |  \
    \       if elt < smallest[1] {\n   |                  ^^^^^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n25 |         if elt < smallest[1].try_into().unwrap()\
    \ {\n   |                             ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1omgz9yp.rs:26:27\n   |\n26 |             smallest[1] =\
    \ elt;\n   |             -----------   ^^^ expected `i32`, found `isize`\n   |\
    \             |\n   |             expected due to the type of this binding\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp1omgz9yp.rs:29:10\n   |\n29 |  \
    \   Some(smallest[1])\n   |          ^^^^^^^^^^^ expected `isize`, found `i32`\n\
    \   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n29 |     Some(smallest[1].try_into().unwrap())\n  \
    \ |                     ++++++++++++++++++++\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_idx = lst.iter().position(|&x| x == smallest).unwrap();\n    if\
    \ smallest_idx == lst.len() {\n        return None;\n    }\n    smallest = lst.iter().nth(smallest_idx\
    \ + 1).unwrap();\n    Some(smallest)\n}\n\nfn main() {\n    let candidate = next_smallest;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5,\
    \ 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()), None);\n\
    \    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq0j0qgmo.rs:14:58\n   |\n\
    14 |     let mut smallest_idx = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \   |                                                          ^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    14 |     let mut smallest_idx = lst.iter().position(|&x| x == *smallest).unwrap();\n\
    \   |                                                          +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpq0j0qgmo.rs:19:10\n   |\n19 |     Some(smallest)\n\
    \   |          ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n19 |     Some(*smallest)\n   |          +\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst[0];\n    let mut smallest_idx\
    \ = 1;\n    for &x in lst {\n        if x < smallest {\n            smallest =\
    \ x;\n            smallest_idx = 1;\n        } else {\n            smallest_idx\
    \ += 1;\n        }\n    }\n    Some(smallest)\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkrspmknl.rs:15:9\n   |\n\
    15 |     for &x in lst {\n   |         ^^    --- this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    let mut smallest = lst.iter().min();\n    if smallest.is_none()\
    \ {\n        return None;\n    }\n    let mut smallest_idx = lst.iter().position(|x|\
    \ *x == smallest).unwrap();\n    if smallest_idx == lst.len() - 1 {\n        return\
    \ None;\n    }\n    Some(smallest[smallest_idx + 1])\n}\n\nfn main() {\n    let\
    \ candidate = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx9dofkaq.rs:17:58\n   |\n\
    17 |     let mut smallest_idx = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \   |                                                          ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<&isize>`\n\nerror[E0608]: cannot index into a value\
    \ of type `Option<&isize>`\n  --> /tmp/tmpx9dofkaq.rs:21:10\n   |\n21 |     Some(smallest[smallest_idx\
    \ + 1])\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0608.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().enumerate().find(|(_, v)| v < lst.iter().next().unwrap()).map(|(_,\
    \ v)| v)\n}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
    \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi4saie5m.rs:13:46\n   |\n\
    13 |     lst.iter().enumerate().find(|(_, v)| v < lst.iter().next().unwrap()).map(|(_,\
    \ v)| v)\n   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `isize`\n   |\n   = note: expected reference `&&isize`\n\
    \              found reference `&isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpi4saie5m.rs:13:5\n   |\n12 | fn next_smallest(lst: Vec<isize>) -> Option<isize>\
    \ {\n   |                                      ------------- expected `Option<isize>`\
    \ because of return type\n13 |     lst.iter().enumerate().find(|(_, v)| v < lst.iter().next().unwrap()).map(|(_,\
    \ v)| v)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found enum `Option<&isize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011046
- exit_code: 1
  program: "/// You are given a list of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the list.\n/// Return None if there\
    \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n\
    /// >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
    /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
    \ -> Option<isize> {\n    lst.iter().enumerate().filter(|(_, elem)| elem < lst.len()\
    \ - 2).next()\n        .map(|(_, elem)| elem)\n}\n\nfn main() {\n    let candidate\
    \ = next_smallest;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), Some(2));\n\
    \    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1, 1]), None);\n    assert_eq!(candidate(vec![-35,\
    \ 34, 12, -45]), Some(-35));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzd7z1k8w.rs:13:54\n   |\n\
    13 |     lst.iter().enumerate().filter(|(_, elem)| elem < lst.len() - 2).next()\n\
    \   |                                                      ^^^^^^^^^^^^^ expected\
    \ `&&isize`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzd7z1k8w.rs:13:5\n\
    \   |\n12 |   fn next_smallest(lst: Vec<isize>) -> Option<isize> {\n   |     \
    \                                   ------------- expected `Option<isize>` because\
    \ of return type\n13 | /     lst.iter().enumerate().filter(|(_, elem)| elem <\
    \ lst.len() - 2).next()\n14 | |         .map(|(_, elem)| elem)\n   | |______________________________^\
    \ expected `isize`, found `&isize`\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found enum `Option<&isize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011045
