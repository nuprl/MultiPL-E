name: HumanEval_132_is_nested
language: rs
prompt: "/// Create a function that takes a string as input which contains only square\
  \ brackets.\n/// The function should return True if and only if there is a valid\
  \ subsequence of brackets \n/// where at least one bracket in the subsequence is\
  \ nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
  []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n/// false\n\
  /// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
  [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\nfn\
  \ is_nested(string: String) -> bool {\n"
tests: "}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!({left}, {right});\n\
  \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
  \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
  \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
  \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
  \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
  \ {right});\n}\n"
completions: ["    string.chars().any(|c| c == '[' || c == '{' || c == '(')", "  \
    \  string.chars().any(|c| c == '[' || c == '{' || c == '(')", "    string.chars().any(|c|\
    \ c == '[' || c == '{' || c == '(')", "    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')", "    string.chars().any(|c| c == '[' || c == '{' ||\
    \ c == '(')", "    string.chars().any(|c| c == '[' || c == '{' || c == '(')",
  "    let mut stack = Vec::new();\n    stack.push(0);\n    let mut i = 0;\n    while\
    \ i < string.len() {\n        if stack.is_empty() {\n            return false;\n\
    \        }\n        let mut j = i;\n        while j < string.len() {\n       \
    \     if string[j] == ']' {\n                stack.pop();\n            } else\
    \ {\n                stack.push(j);\n            }\n            j += 1\n     \
    \   }\n        i += 1\n    }\n    stack.is_empty()", "    string.chars().all(|c|\
    \ {\n        c != '[' && c != ']'\n    })", "    string.chars().any(|c| c == '['\
    \ || c == '{' || c == '(')", "    let mut stack = Vec::new();\n    let mut open_brackets\
    \ = 0;\n    let mut close_brackets = 0;\n    let mut i = 0;\n    while i < string.len()\
    \ {\n        if string[i] == ']' {\n            close_brackets++;\n          \
    \  if close_brackets == 1 {\n                stack.pop();\n            }\n   \
    \     } else if string[i] == '[' {\n            open_brackets++;\n           \
    \ if open_brackets == 1 {\n                stack.push(string[i]);\n          \
    \  }\n        } else {\n            stack.pop();\n            close_brackets =\
    \ 0;\n            open_brackets = 0;\n        }\n        i += 1;\n    }\n    stack.len()\
    \ == 0 && open_brackets == 0 && close_brackets == 0", "    string.chars().any(|c|\
    \ c == '[' || c == '{' || c == '(')", "    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')", "    string.chars().any(|c| c == '[' || c == '{' ||\
    \ c == '(')", "    string.chars().any(|c| c == '[' || c == '{' || c == '(')",
  "    string.chars().any(|c| c == '[' || c == '{' || c == '(')", "    string.chars().any(|c|\
    \ c == '[' || c == '{' || c == '(')", "    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')", "    let mut stack = Vec::new();\n    let mut open_brackets\
    \ = 0;\n    let mut close_brackets = 0;\n    for c in string.chars() {\n     \
    \   if c == '[' {\n            stack.push(c);\n            open_brackets += 1;\n\
    \        } else if c == '{' {\n            stack.push(c);\n        } else if c\
    \ == '}' {\n            close_brackets += 1;\n            if stack.len() == 0\
    \ {\n                return false;\n            }\n            stack.pop();\n\
    \        } else if c == ']' {\n            if stack.len() == 0 {\n           \
    \     return false;\n            }\n            close_brackets += 1;\n       \
    \     stack.pop();\n        } else {\n            if stack.len() == 0 || close_brackets\
    \ < open_brackets {\n                return false;\n            }\n        }\n\
    \    }\n    stack.len() == 0", "    string.chars().any(|c| c == '[' || c == '{'\
    \ || c == '(')", "    string.chars().any(|c| c == '[' || c == '{' || c == '(')"]
stop_tokens:
- "\n}"
