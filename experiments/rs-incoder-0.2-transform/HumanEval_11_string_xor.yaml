name: HumanEval_11_string_xor
language: rs
prompt: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
  \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
  010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
  \ b: String) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
  111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
  1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
  0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
completions: ['    String::from(a.to_owned() & b.to_owned())', "    a.iter().chain(b.iter()).filter(|&b|\
    \ b == '1').collect::<String>()", '    a.to_string().xor_eq(&b.to_string()).to_string()',
  '    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    String::from(format!("{:b}", bincode::xor(a.as_bytes(),
    b.as_bytes())))', '    String::from(a.to_owned() & b.to_owned())', "    a.iter().chain(b.iter()).filter(|&x|\
    \ x == b'0').collect::<String>()", "    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result",
  "    let mut result = String::new();\n    for i in 0..a.len() {\n        result.push(a[i]\
    \ ^ b[i]);\n    }\n    result", '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', "    let mut result = String::new();\n    for &c in &a\
    \ & &b {\n        if *c != '0' {\n            result.push(*c);\n        }\n  \
    \  }\n    result", '    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()',
  '    String::from(format!("{:b}", bincode::xor_encode(a.as_bytes(), b.as_bytes())));',
  '    a.to_string().xor_eq(&b.to_string()).to_string()', "    let mut result = String::new();\n\
    \    for i in a.chars().zip(b.chars()).map(|(a, b)| {\n        match a {\n   \
    \         b'0' => b'1',\n            b'1' => b'0',\n            _ => panic!(\"\
    Invalid input\"),\n        }\n        match b {\n            b'0' => b'1',\n \
    \           b'1' => b'0',\n            _ => panic!(\"Invalid input\"),\n     \
    \   }\n    }) {\n        (a, b) => result.push(*a ^ *b),\n    }\n    result",
  "    let mut result = String::new();\n    for &c in &a & &b {\n        match c {\n\
    \            '0' => result.push('0'),\n            '1' => result.push('1'),\n\
    \            _ => panic!(\"String contains invalid character: {}\", c),\n    \
    \    }\n    }\n    result", '    a.to_string().xor_eq(&b.to_string()).to_string()',
  '    a.to_owned() & b.to_owned()', "    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result",
  '    a.to_string().xor_eq(&b.to_string()).to_string()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    String::from(a.to_owned() ^ b.to_owned())', '    a.to_owned()
    & b.to_owned()', '    a.to_string().xor_(b).to_string()', '    a.to_owned() &
    b.to_owned()', '    String::from(a.to_owned() & b.to_owned())', '    a.to_owned()
    & b.to_owned()', '    String::from(a.to_owned() ^ b.to_owned())', '    a.to_string().xor_(b).to_string()',
  "    let mut result = String::new();\n    for i in 0..a.len() {\n        result.push_str(&a[i]\
    \ ^ b[i]);\n    }\n    result", "    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result",
  "    let mut res = String::new();\n    for &c in &a { res.push(c); }\n    for &c\
    \ in &b { res.push(c); }\n    res", "    let mut result = String::new();\n   \
    \ for &c in &a | &b {\n        if *c != 0 {\n            result.push(*c);\n  \
    \      }\n    }\n    result", '    String::from(a.to_owned() ^ b.to_owned())',
  '    a.to_owned() & b.to_owned()', '    a.iter().zip(b.iter()).map(|(a, b)| a ^
    b).collect()', "    let mut result = String::new();\n    for &c in &a { result.push(c);\
    \ }\n    for &c in &b { result.push(c); }\n    result", '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    String::from(a.to_owned() + b.to_owned())', '    a.iter().zip(b.iter()).map(|(a,
    b)| a ^ b).collect()', '    String::from(binary_xor_str(a, b))', '    String::from(a.to_owned()
    + b.to_owned())', '    a.to_owned() & b.to_owned()', '    a.chars().zip(b.chars()).map(|(a,
    b)| a ^ b).collect()', '    a.to_owned() & b.to_owned()', '    String::from(a.to_owned()
    + b.to_owned())', '    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()',
  "    let mut result = String::new();\n    for &c in &a | &b {\n        match c {\n\
    \            '0' => result.push('0'),\n            '1' => result.push('1'),\n\
    \            _ => panic!(\"String contains invalid character\"),\n        }\n\
    \    }\n    result", '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    a.to_owned() & b.to_owned()', '    a.chars().zip(b.chars()).map(|(a,
    b)| a ^ b).collect()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', "    let mut result = String::new();\n    for &c in &a\
    \ & &b {\n        if *c != 0 {\n            result.push(*c);\n        }\n    }\n\
    \    result", '    a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)|
    a ^ b).collect()', '    a.to_string().iter().zip(b.to_string().iter()).map(|(a,
    b)| a ^ b).collect::<String>()', "    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result",
  "    let mut res = String::new();\n    for i in 0..a.len() {\n        if a[i] !=\
    \ b[i] {\n            res.push_str(&format!(\"{}\", a[i] ^ b[i]));\n        }\
    \ else {\n            res.push_str(&a[i]);\n        }\n    }\n    res", "    let\
    \ mut result = String::new();\n    for &c in &a { result.push(c); }\n    for &c\
    \ in &b { result.push(c); }\n    result", '    a.to_owned() & b.to_owned()', '    a.to_owned()
    & b.to_owned()', "    let mut result = String::new();\n    for &c in &a & &b {\n\
    \        match c {\n            '0' => result.push('0'),\n            '1' => result.push('1'),\n\
    \            _ => panic!(\"String contains invalid character: {}\", c),\n    \
    \    }\n    }\n    result", '    String::from(a.to_owned() + b.to_owned())', '    String::from(a.to_owned()
    & b.to_owned())', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()',
  "    let mut result = String::new();\n    for i in 0..a.len() {\n        result.push(a[i]\
    \ ^ b[i]);\n    }\n    result", "    let mut result = String::new();\n    for\
    \ &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n    result",
  "    a.to_string().chars().zip(b.to_string().chars())\n        .map(|(a, b)| a ^\
    \ b)\n        .collect()\n        .to_string()", '    a.to_string().xor_eq(&b.to_string()).to_string()',
  '    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()', '    a.to_string().xor_eq(&b.to_string()).to_string()',
  '    a.to_string().xor_(b).to_string()', '    a.to_owned() & b.to_owned()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    String::from(format!("{:b}", bin::Xor::new(a, b).unwrap()))',
  '    a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a ^ b).collect()',
  '    String::from(a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect())', '    a.iter().zip(b.iter()).map(|(a,
    b)| a ^ b).collect()', '    a.to_owned() & b.to_owned()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', "    let mut result = String::new();\n    for &c in &a\
    \ { result.push(c); }\n    for &c in &b { result.push(c); }\n    result", "  \
    \  let mut res = String::new();\n    for &c in &a | &b {\n        if *c != 0 {\n\
    \            res.push_str(&*c as char);\n        }\n    }\n    res", "    let\
    \ mut result = String::new();\n    for &c in &a & &b {\n        if *c != 0 {\n\
    \            result.push(*c);\n        }\n    }\n    result", '    String::from(a.to_owned()
    ^ b.to_owned())', "    let mut result = String::new();\n    for &c in &a | &b\
    \ {\n        if *c != 0 {\n            result.push(*c);\n        }\n    }\n  \
    \  result", "    let mut result = String::new();\n    for &c in &a & &b {\n  \
    \      if *c != 0 {\n            result.push(*c);\n        }\n    }\n    result",
  "    let mut result = String::new();\n    for &c in &a { result.push(c); }\n   \
    \ for &c in &b { result.push(c); }\n    result", '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', "    let mut result = String::new();\n    for &c in &a\
    \ & &b {\n        if *c != '0' {\n            result.push(*c);\n        }\n  \
    \  }\n    result", "    let mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars())\
    \ {\n        *result .= if *a != *b { 1 } else { 0 };\n    }\n    result", '    a.chars().zip(b.chars()).map(|(a,
    b)| a ^ b).collect()', '    String::from(a.to_owned() & b.to_owned())', '    String::from(a.to_owned()
    & b.to_owned())', '    a.to_string().xor_(b).to_string()', '    a.to_owned() &
    b.to_owned()', "    let mut res = String::new();\n    for &c in &a & &b {\n  \
    \      if *c != 0 {\n            res.push_str(&*c as char);\n        }\n    }\n\
    \    res", '    String::from(a.to_owned() & b.to_owned())', "    a.to_string().chars().zip(b.to_string().chars())\n\
    \        .map(|(a, b)| a ^ b)\n        .collect()\n        .to_string()", "  \
    \  let mut result = String::new();\n    for &c in &a { result.push(c); }\n   \
    \ for &c in &b { result.push(c); }\n    result", "    a.to_string().xor_eq(&b.to_string())\n\
    \        .to_string()", '    a.iter().chain(b.iter()).map(|x| x ^ 1).collect()',
  "    a.to_string().xor_eq(&b.to_string())\n        .to_string()", '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    String::from(a.to_owned() + b.to_owned())', '    String::from(a.to_owned()
    & b.to_owned())', '    a.to_owned() & b.to_owned()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    a.to_owned() & b.to_owned()', '    a.to_owned() &
    b.to_owned()', '    a.to_owned() & b.to_owned()', '    a.to_owned() & b.to_owned()',
  "    let mut result = String::new();\n    for &c in &a | &b {\n        if *c !=\
    \ '0' {\n            result.push(*c);\n        }\n    }\n    result", '    String::from(format!("{:b}",
    bincode::xor_u8(a.as_bytes(), b.as_bytes())))', '    String::from(binary_xor_impl(a.to_string(),
    b.to_string()).to_string())', '    a.to_string().xor_eq(&b.to_string()).to_string()',
  "    let mut result = String::new();\n    for &c in &a & &b {\n        if *c !=\
    \ '0' {\n            result.push(*c);\n        }\n    }\n    result", "    let\
    \ mut result = String::new();\n    for &c in &a | &b {\n        if *c != 0 {\n\
    \            result.push(*c);\n        }\n    }\n    result", '    a.iter().zip(b.iter()).map(|(a,
    b)| a ^ b).collect()', '    String::from(a.to_owned() & b.to_owned())', "    a.to_string().xor_eq(&b.to_string())\n\
    \        .to_string()", '    a.to_string().xor_eq(&b.to_string()).to_string()',
  "    let mut result = String::new();\n    for &c in &a & &b {\n        if *c !=\
    \ '0' {\n            result.push(*c);\n        }\n    }\n    result", '    a.chars().zip(b.chars()).map(|(a,
    b)| a ^ b).collect()', "    let mut result = String::new();\n    for &c in &a\
    \ { result.push(c); }\n    for &c in &b { result.push(c); }\n    result", '    a.iter().zip(b.iter()).map(|(a,
    b)| a ^ b).collect()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    a.to_owned() & b.to_owned()', "    let mut result\
    \ = String::new();\n    for i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n\
    \    }\n    result", '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    String::from(a.to_owned() + b.to_owned())', '    a.to_owned()
    & b.to_owned()', "    let mut res = String::new();\n    for i in 0..a.len() {\n\
    \        res.push_str(&a[i..].iter().filter(|&b| b == '1').collect::<String>());\n\
    \    }\n    for i in 0..b.len() {\n        res.push_str(&b[i..].iter().filter(|&a|\
    \ a == '1').collect::<String>());\n    }\n    res", '    a.iter().zip(b.iter()).map(|(a,
    b)| a ^ b).collect()', '    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()',
  "    let mut res = String::new();\n    for i in a.chars() {\n        res.push_str(&format!(\"\
    {:b}\", i ^ b.chars().nth(i)));\n    }\n    res", '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', "    let mut res = String::new();\n    for i in 0..a.len()\
    \ {\n        res.push_str(&a.chars()[i ^ b.chars().nth(i).unwrap()]);\n    }\n\
    \    res", '    a.iter().chain(b.iter()).map(|x| x ^ 1).collect::<String>()',
  '    a.to_string().xor_eq(&b.to_string()).to_string()', '    a.iter().zip(b.iter()).map(|(a,
    b)| a ^ b).collect()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    a.to_string().xor_eq(&b.to_string()).to_string()',
  '    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    a.to_owned() & b.to_owned()', "    let mut result\
    \ = String::new();\n    for &c in a.chars().zip(b.chars()) {\n        result.push((*c[0])\
    \ ^ (*c[1]));\n    }\n    result", "    String::from(\n        a.chars().zip(b.chars()).fold(String::new(),\
    \ |mut acc, (mut a, mut b)| {\n            acc.push_str(&format!(\"{:b}\", a ^\
    \ b));\n            acc\n        }),\n    )", '    a.to_string().xor_(b).to_string()',
  '    a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a ^ b).collect()',
  "    let mut res = String::new();\n    for &c in &a | &b {\n        if *c != 0 {\n\
    \            res.push(*c);\n        }\n    }\n    res", '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    a.to_owned() & b.to_owned()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    a.to_owned() & b.to_owned()', "    let mut result\
    \ = String::new();\n    for &c in &a { result.push(c); }\n    for &c in &b { result.push(c);\
    \ }\n    result", '    a.to_string().xor_eq(&b.to_string()).to_string()', '    a.chars().zip(b.chars()).map(|(a,
    b)| a ^ b).collect()', '    a.to_owned() & b.to_owned()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()',
  '    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()', '    String::from(a.to_owned()
    + b.to_owned())', "    let mut result = String::new();\n    for &b in &b {\n \
    \       if *b == '1' {\n            result.push(*a);\n        }\n        *a =\
    \ *a ^ *b;\n    }\n    result", '    a.to_string().xor_(b).to_string()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    String::from(binary_xor_str(a, b))', '    String::from(binary_xor(a.as_bytes(),
    b.as_bytes()))', "    let mut result = String::new();\n    for &c in &a & &b {\n\
    \        result .= if *c != 0 {\n            *c as char\n        } else {\n  \
    \          *c as char\n        };\n    }\n    result", '    a.iter().chain(b.iter()).map(|x|
    x ^ 1).collect()', '    a.to_owned() & b.to_owned()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    String::from(a.to_owned() & b.to_owned())', '    a.iter().zip(b.iter()).map(|(a,
    b)| a ^ b).collect()', '    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()',
  '    a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a ^ b).collect()',
  '    a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a ^ b).collect()',
  "    String::from_utf8(\n        a.as_bytes().iter().zip(b.as_bytes().iter()).map(|(a,\
    \ b)| a ^ b).collect(),\n    )", "    String::from(\n        a.chars().zip(b.chars()).fold(String::new(),\
    \ |mut acc, (mut a, mut b)| {\n            *acc += *a ^ *b;\n            acc\n\
    \        }),\n    )", "    let mut result = String::new();\n    for i in 0..a.len()\
    \ {\n        if a[i] != b[i] {\n            result.push('a');\n        } else\
    \ {\n            result.push('0');\n        }\n    }\n    result", "    let mut\
    \ result = String::new();\n    for &c in &a { result.push(c); }\n    for &c in\
    \ &b { result.push(c); }\n    result", '    a.iter().zip(b.iter()).map(|(a, b)|
    a ^ b).collect()', '    a.to_string().xor_(b).to_string()', "    a.to_string().xor_eq(&b.to_string())\n\
    \        .map(|x| x.to_string())\n        .unwrap_or(String::from(\"0\"))", " \
    \   let mut result = String::new();\n    for &c in &a { result.push(c); }\n  \
    \  for &c in &b { result.push(c); }\n    result", '    String::from(a.to_owned()
    ^ b.to_owned())', '    a.to_owned() & b.to_owned()', '    String::from(a.to_owned()
    & b.to_owned())', '    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()',
  '    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()', "    let\
    \ mut result = String::new();\n    for &c in &a { result.push(c); }\n    for &c\
    \ in &b { result.push(c); }\n    result", '    a.iter().zip(b.iter()).map(|(a,
    b)| a ^ b).collect()', "    let mut result = String::new();\n    for &b in &b\
    \ {\n        if *b == 1 {\n            result.push(*a);\n        }\n        *a\
    \ = *a ^ *b;\n    }\n    result", '    String::from(a.chars().zip(b.chars()).filter(|(a,
    b)| a != b).map(|(a, b)| a ^ b).collect())', "    let mut result = String::new();\n\
    \    for &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n\
    \    result", "    let mut res = String::new();\n    for &c in &a & &b {\n   \
    \     if *c != 0 {\n            res.push_str(&*c as char);\n        }\n    }\n\
    \    res", '    String::from(a.to_owned() ^ b.to_owned())', '    a.to_string().iter().zip(b.to_string().iter()).map(|(a,
    b)| a ^ b).collect::<String>()', '    String::from(a.to_owned() ^ b.to_owned())']
stop_tokens:
- "\n}"
