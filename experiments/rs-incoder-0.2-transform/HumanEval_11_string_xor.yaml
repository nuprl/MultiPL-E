name: HumanEval_11_string_xor
language: rs
prompt: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
  \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
  010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
  \ b: String) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!({left},\
  \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
  }\n"
completions: ['    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()', "    let\
    \ mut result = String::new();\n    for &c in &a & &b {\n        if *c != 0 {\n\
    \            result.push(*c);\n        }\n    }\n    result", "    let mut result\
    \ = String::new();\n    for i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n\
    \    }\n    result", "    let mut res = String::new();\n    for &c in &a { res.push(c);\
    \ }\n    for &c in &b { res.push(c); }\n    res", '    a.iter().zip(b.iter()).map(|(a,
    b)| a ^ b).collect()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    a.to_owned() & b.to_owned()', '    a.to_owned() &
    b.to_owned()', "    let mut res = String::new();\n    for i in 0..a.len() {\n\
    \        if a[i] != b[i] {\n            res.push_str(&format!(\"{:02x}\", a[i]\
    \ ^ b[i]));\n        } else {\n            res.push(a[i]);\n        }\n    }\n\
    \    res", '    a.to_owned() & b.to_owned()', "    let mut result = String::new();\n\
    \    for &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n\
    \    result", '    String::from(format!("{:b}", a.to_u32() ^ b.to_u32()))', '    a.chars().zip(b.chars()).map(|(a,
    b)| a ^ b).collect()', '    a.to_string().xor_(b).to_string()', '    a.to_string().xor_eq(&b.to_string()).to_string()',
  "    let mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i..].iter().map(|x|\
    \ if x == b[i] { x } else { 0 }).collect::<String>());\n    }\n    res", '    a.to_owned()
    & b.to_owned()', '    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()', '    String::from(a.to_owned()
    & b.to_owned())', '    String::from(a.to_owned() & b.to_owned())', '    String::from(a.to_owned()
    & b.to_owned())', '    a.to_string().iter().zip(b.to_string().iter()).map(|(a,
    b)| a ^ b).collect()', "    let mut res = String::new();\n    for &c in &a { res.push(c);\
    \ }\n    for &c in &b { res.push(c); }\n    res", "    let mut result = String::new();\n\
    \    for i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n    }\n    result",
  "    let mut res = String::new();\n    for &c in a.chars().zip(b.chars()) {\n  \
    \      if *c != *c {\n            res.push(*c);\n        }\n    }\n    res", '    a.to_owned()
    & b.to_owned()', "    a.iter().chain(b.iter()).filter(|c| c == '1').collect::<String>()",
  "    let mut result = String::new();\n    for &c in &a | &b {\n        if *c !=\
    \ 0 {\n            result.push(*c);\n        }\n    }\n    result", "    let mut\
    \ result = String::new();\n    for &b in &b {\n        if *b == '0' {\n      \
    \      result.push(*a);\n        }\n        *a = *a ^ *b;\n        a = &a[1..];\n\
    \    }\n    result", '    a.to_string().xor_eq(&b.to_string()).to_string()', '    a.to_owned()
    & b.to_owned()', '    a.to_string().iter().zip(b.to_string().iter()).map(|(a,
    b)| a ^ b).collect()', '    a.to_string().xor_eq(&b.to_string()).to_string()',
  '    a.to_string().xor_eq(&b.to_string()).to_string()', "    let mut res = String::new();\n\
    \    for &c in &a { res += &c ^ &b[c.to_digit(10).unwrap()]; }\n    res", '    String::from(format!("{:b}",
    bincode::xor_encode(a.as_bytes(), b.as_bytes())))', '    a.to_string().xor_eq(&b.to_string()).to_string()',
  '    a.to_owned() & b.to_owned()', "    a.to_string().xor_eq(&b.to_string())\n \
    \       .to_string()", '    a.to_owned() & b.to_owned()', '    String::from(a.to_owned()
    & b.to_owned())', '    a.to_string().xor_eq(&b.to_string()).to_string()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect::<String>()',
  "    let mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars())\
    \ {\n        *result |= *a ^ *b;\n    }\n    result", '    String::from(binary_xor_str(a,
    b))', '    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()', '    a.iter().zip(b.iter()).map(|(a,
    b)| a ^ b).collect()']
stop_tokens:
- "\n}"
