name: HumanEval_11_string_xor
language: rs
prompt: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
  \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
  010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
  \ b: String) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!({left},\
  \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
  }\n"
completions: ['    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()', "    let\
    \ mut result = String::new();\n    for &c in &a & &b {\n        if *c != 0 {\n\
    \            result.push(*c);\n        }\n    }\n    result", "    let mut result\
    \ = String::new();\n    for i in 0..a.len() {\n        result.push(a[i] ^ b[i]);\n\
    \    }\n    result", "    let mut res = String::new();\n    for &c in &a { res.push(c);\
    \ }\n    for &c in &b { res.push(c); }\n    res", '    a.iter().zip(b.iter()).map(|(a,
    b)| a ^ b).collect()', '    a.to_string().chars().zip(b.to_string().chars()).map(|(a,
    b)| a ^ b).collect()', '    a.to_owned() & b.to_owned()', '    a.to_owned() &
    b.to_owned()', "    let mut res = String::new();\n    for i in 0..a.len() {\n\
    \        if a[i] != b[i] {\n            res.push_str(&format!(\"{:02x}\", a[i]\
    \ ^ b[i]));\n        } else {\n            res.push(a[i]);\n        }\n    }\n\
    \    res", '    a.to_owned() & b.to_owned()', "    let mut result = String::new();\n\
    \    for &c in &a { result.push(c); }\n    for &c in &b { result.push(c); }\n\
    \    result", '    String::from(format!("{:b}", a.to_u32() ^ b.to_u32()))', '    a.chars().zip(b.chars()).map(|(a,
    b)| a ^ b).collect()', '    a.to_string().xor_(b).to_string()', '    a.to_string().xor_eq(&b.to_string()).to_string()',
  "    let mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i..].iter().map(|x|\
    \ if x == b[i] { x } else { 0 }).collect::<String>());\n    }\n    res", '    a.to_owned()
    & b.to_owned()', '    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()', '    String::from(a.to_owned()
    & b.to_owned())', '    String::from(a.to_owned() & b.to_owned())']
stop_tokens:
- "\n}"
