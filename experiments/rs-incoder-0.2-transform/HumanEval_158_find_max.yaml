name: HumanEval_158_find_max
language: rs
prompt: "/// Write a function that accepts a list of strings.\n/// The list contains\
  \ different words. Return the word with maximum number\n/// of unique characters.\
  \ If multiple strings have maximum number of unique\n/// characters, return the\
  \ one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
  name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\"\
  )\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"\
  game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"\
  ), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\n\
  fn find_max(words: Vec<String>) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!({left}, {right});\n\
  \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
  \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
  \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
  \ {right});\n    assert_eq!({left}, {right});\n}\n"
completions: ["    let mut unique_chars = HashMap::new();\n    let mut max_chars =\
    \ String::new();\n    for word in words {\n        for c in word.chars() {\n \
    \           if !unique_chars.contains_key(&c) {\n                unique_chars.insert(c,\
    \ 1);\n            } else {\n                unique_chars.entry(c).or_insert(0)\
    \ += 1;\n            }\n        }\n        if unique_chars.len() > max_chars.len()\
    \ {\n            max_chars = word;\n        }\n    }\n    max_chars", "    let\
    \ mut counters = HashMap::new();\n    for word in words {\n        if let Some(count)\
    \ = counters.get(&word) {\n            *count += 1;\n        } else {\n      \
    \      counters.insert(word.clone(), 1);\n        }\n    }\n    let mut max_count\
    \ = counters.iter().max().unwrap();\n    let mut max_word = String::new();\n \
    \   for word in counters {\n        if *word == max_count {\n            max_word\
    \ = word;\n        }\n    }\n    max_word", "    let mut max_count = words.iter().map(|word|\
    \ word.chars().count()).max().unwrap();\n    let mut max_word = String::new();\n\
    \    let mut i = 0;\n    for word in words {\n        if word.chars().count()\
    \ > max_count {\n            max_count = word.chars().count();\n            max_word\
    \ = word;\n        }\n        if i == words.size() - 1 {\n            break;\n\
    \        }\n        i += 1;\n    }\n    max_word", "    let mut counter = HashMap::new();\n\
    \    for word in words {\n        if let Some(count) = counter.get(&word) {\n\
    \            if count > 1 {\n                counter.insert(word, 1);\n      \
    \      } else {\n                counter.insert(word, count + 1);\n          \
    \  }\n        } else {\n            counter.insert(word, 1);\n        }\n    }\n\
    \    let mut max_word = String::new();\n    let mut max_count = counter.get(&max_word);\n\
    \    for word in counter {\n        if counter.get(&word) > max_count {\n    \
    \        max_word = word;\n            max_count = counter.get(&word);\n     \
    \   }\n    }\n    max_word", "    let mut counters = HashMap::new();\n    for\
    \ word in words {\n        for c in word.chars() {\n            counters.entry(c).or_insert(0)\
    \ += 1;\n        }\n    }\n    let mut max_counters = counters.clone();\n    let\
    \ mut max_word = String::new();\n    let mut max_key = String::new();\n    for\
    \ c in max_counters.keys() {\n        if *c > max_counters.entry(c).or_insert(0)\
    \ {\n            max_counters.entry(c).or_insert(0) = *c;\n            max_key\
    \ = c;\n        }\n    }\n    max_word", "    let mut max_count = std::i32::MAX;\n\
    \    let mut max_word = String::new();\n    for word in words {\n        let mut\
    \ count = std::i32::MAX;\n        for c in word.chars() {\n            count +=\
    \ c.chars().count();\n        }\n        if count > max_count {\n            max_count\
    \ = count;\n            max_word = word;\n        }\n    }\n    max_word", " \
    \   let mut counters = HashMap::new();\n    for word in words {\n        counters.entry(word.chars().count()).or_insert(0)\
    \ += 1;\n    }\n    let mut max_counters = counters.clone();\n    let mut max_key\
    \ = String::new();\n    for (key, value) in max_counters.iter() {\n        if\
    \ value > max_counters.get(&key).unwrap() {\n            max_counters.insert(key,\
    \ value);\n            max_key = key;\n        }\n    }\n    max_key", "    let\
    \ mut counters = HashMap::new();\n    for word in words {\n        if let Some(count)\
    \ = counters.get(&word) {\n            counters.insert(word, count + 1);\n   \
    \     } else {\n            counters.insert(word, 1);\n        }\n    }\n    let\
    \ mut max_word = String::new();\n    let mut max_count = counters.iter().max().unwrap();\n\
    \    for (_, count) in counters {\n        if count == max_count {\n         \
    \   max_word = word;\n        }\n    }\n    max_word", "    let mut max_count\
    \ = std::i32::MAX;\n    let mut max_word = String::new();\n    for word in words\
    \ {\n        let mut count = std::i32::MAX;\n        for c in word.chars() {\n\
    \            if *c != ' ' {\n                count += 1;\n            }\n    \
    \    }\n        if count > max_count {\n            max_count = count;\n     \
    \       max_word = word;\n        }\n    }\n    max_word", "    let mut counters\
    \ = HashMap::new();\n    for word in words {\n        counters.entry(word.chars().count()).or_insert(0)\
    \ += 1;\n    }\n    let mut max_counter = counters.iter().max().unwrap();\n  \
    \  let mut max_word = String::new();\n    for counter in counters.iter() {\n \
    \       if *counter > max_counter {\n            max_counter = *counter;\n   \
    \         max_word = words[counters.iter().position(|&(_, count)| count == max_counter).unwrap()];\n\
    \        }\n    }\n    max_word", "    let mut counters = HashMap::new();\n  \
    \  for word in words {\n        for c in word.chars() {\n            counters.entry(c).or_insert(0)\
    \ += 1;\n        }\n    }\n    let mut max_counters = counters.clone();\n    let\
    \ mut max_word = String::new();\n    for (counter, word) in counters.iter().cloned().sort_by(|a,\
    \ b| b.cmp(&a)) {\n        if *counter > max_counters.len() {\n            max_counters\
    \ = counters;\n            max_word = word;\n        }\n    }\n    max_word",
  "    let mut counters = HashMap::new();\n    for word in words {\n        counters.insert(word.chars().count(),\
    \ 1);\n    }\n    let mut max_counters = counters.clone();\n    let mut max_word\
    \ = String::new();\n    for word in words {\n        let count = counters.get(&word.chars().count()).unwrap();\n\
    \        if count > max_counters.get(&count).unwrap() {\n            max_counters.insert(count,\
    \ 1);\n            max_word = word;\n        }\n    }\n    max_word", "    let\
    \ mut max_count = words[0].chars().count();\n    let mut max_word = words[0];\n\
    \    for word in words.iter().skip(1) {\n        let count = word.chars().count();\n\
    \        if count > max_count {\n            max_count = count;\n            max_word\
    \ = word;\n        }\n    }\n    max_word", "    let mut max_count = std::cmp::Ordering::Equal;\n\
    \    let mut max_word = String::new();\n    for word in words {\n        let mut\
    \ count = std::cmp::Ordering::Equal;\n        for c in word.chars() {\n      \
    \      if *c != c.to_ascii_lowercase() {\n                count = std::cmp::Ordering::Less;\n\
    \                break;\n            }\n        }\n        if count > max_count\
    \ {\n            max_count = count;\n            max_word = word;\n        }\n\
    \    }\n    max_word", "    let mut counters = HashMap::new();\n    for word in\
    \ words {\n        counters.entry(word.chars().count()).or_insert(0) += 1;\n \
    \   }\n    let mut max_counter = counters.iter().max().unwrap();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        if counters[word.chars().count()]\
    \ > max_counter {\n            max_counter = counters[word.chars().count()];\n\
    \            max_word = word;\n        }\n    }\n    max_word", "    let mut counters\
    \ = HashMap::new();\n    for word in words {\n        counters.insert(word.chars().count(),\
    \ 1);\n    }\n    let mut max_count = counters.iter().max().unwrap();\n    let\
    \ mut max_word = String::new();\n    for (_, count) in counters {\n        if\
    \ count == max_count {\n            max_word = word;\n            break;\n   \
    \     }\n    }\n    max_word", "    let mut max_count = words[0].chars().count();\n\
    \    let mut max_word = words[0];\n    for word in words.iter().skip(1) {\n  \
    \      if word.chars().count() > max_count {\n            max_count = word.chars().count();\n\
    \            max_word = word;\n        }\n    }\n    max_word", "    let mut counters\
    \ = HashMap::new();\n    for word in words {\n        counters.entry(word.chars().count()).or_insert(0)\
    \ += 1;\n    }\n    let mut max_counters = counters.clone();\n    let mut max_word\
    \ = String::new();\n    for (counter, word) in counters.iter().take_while(|&(_,\
    \ count)| count > max_counters.len()) {\n        max_counters = max_counters.entry(counter).or_insert(0);\n\
    \        max_word = word;\n    }\n    max_word", "    let mut max_count = words[0].chars().count();\n\
    \    let mut max_word = words[0];\n    for word in words.iter().skip(1) {\n  \
    \      let count = word.chars().count();\n        if count > max_count {\n   \
    \         max_count = count;\n            max_word = word;\n        }\n    }\n\
    \    max_word", "    let mut max_count = std::collections::HashSet::new();\n \
    \   let mut max_word = String::new();\n    for word in words {\n        let mut\
    \ count = std::collections::HashSet::new();\n        for c in word.chars() {\n\
    \            count.insert((c, 1));\n        }\n        if count.len() > max_count.len()\
    \ {\n            max_count = count;\n            max_word = word;\n        }\n\
    \    }\n    max_word"]
stop_tokens:
- "\n}"
